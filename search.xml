<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Celery 结构，组件</title>
    <url>/2019/09/26/Celery%20%E7%BB%93%E6%9E%84%EF%BC%8C%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="什么是-Celery？"><a href="#什么是-Celery？" class="headerlink" title="什么是 Celery？"></a>什么是 Celery？</h3><p>Celery是一个简单、灵活且可靠的，处理大量消息的分布式系统</p>
<p>专注于实时处理的异步任务队列</p>
<p>同时也支持任务调度</p>
<h3 id="celery-架构"><a href="#celery-架构" class="headerlink" title="celery 架构"></a>celery 架构</h3><p>Celery的架构由三部分组成，消息中间件（message broker），任务执行单元（worker）和任务执行结果存储（task result store）组成。<br><img src="https://img-blog.csdnimg.cn/20200222143757591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="~~~~~~~~~~~~~~~~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200222143757591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h4><p>Celery本身不提供消息服务，但是可以方便的和第三方提供的消息中间件集成。包括，RabbitMQ, Redis等等</p>
<h4 id="任务执行单元"><a href="#任务执行单元" class="headerlink" title="任务执行单元"></a>任务执行单元</h4><p>Worker是Celery提供的任务执行的单元，worker并发的运行在分布式的系统节点中。</p>
<h4 id="任务结果存储"><a href="#任务结果存储" class="headerlink" title="任务结果存储"></a>任务结果存储</h4><p>Task result store用来存储Worker执行的任务的结果，Celery支持以不同方式存储任务的结果，包括AMQP, redis等</p>
<h3 id="Celery-组件"><a href="#Celery-组件" class="headerlink" title="Celery 组件"></a>Celery 组件</h3><h5 id="Celery-扮演生产者和消费者的角色"><a href="#Celery-扮演生产者和消费者的角色" class="headerlink" title="Celery 扮演生产者和消费者的角色"></a>Celery 扮演生产者和消费者的角色</h5><ul>
<li><p>Producer :<br>任务生产者. 调用 Celery API , 函数或者装饰器, 而产生任务并交给任务队列处理的都是任务生产者。</p>
</li>
<li><p>Celery Beat :<br>任务调度器. Beat 进程会读取配置文件的内容, 周期性的将配置中到期需要执行的任务发送给任务队列。</p>
</li>
<li><p>Broker :<br>消息代理, 队列本身. 也称为消息中间件.。接受任务生产者发送过来的任务消息, 存进队列再按序分发给任务消费方(通常是消息队列或者数据库)。</p>
</li>
<li><p>Celery Worker :<br>执行任务的消费者, 通常会在多台服务器运行多个消费者, 提高运行效率。</p>
</li>
<li><p>Result Backend :<br>任务处理完成之后保存状态信息和结果, 以供查询。</p>
</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>异步任务：<br>发邮件、发送消息<br>自动化工单中耗时任务<br>所有需要异步处理的请求都可以</p>
</li>
<li><p>定时任务：<br>工单系统定时获取超时工单进行延时报警<br>对过期会员进行清理</p>
</li>
</ul>
<h3 id="celery应用举例"><a href="#celery应用举例" class="headerlink" title="celery应用举例"></a>celery应用举例</h3><ol>
<li><p>Celery 是一个 基于python开发的分布式异步消息任务队列，通过它可以轻松的实现任务的异步处理，如果你的业务场景中需要用到异步任务，就可以考虑使用celery</p>
</li>
<li><p>你想对100台机器执行一条批量命令，可能会花很长时间 ，但你不想让你的程序等着结果返回，而是给你返回 一个任务ID,你过一段时间只需要拿着这个任务id就可以拿到任务执行结果， 在任务执行ing进行时，你可以继续做其它的事情</p>
</li>
<li><p>Celery 在执行任务时需要通过一个消息中间件来接收和发送任务消息，以及存储任务结果， 一般使用rabbitMQ or Redis</p>
</li>
</ol>
<h3 id="Celery的优点"><a href="#Celery的优点" class="headerlink" title="Celery的优点"></a>Celery的优点</h3><ol>
<li><p>简单：一单熟悉了celery的工作流程后，配置和使用还是比较简单的</p>
</li>
<li><p>高可用：当任务执行失败或执行过程中发生连接中断，celery 会自动尝试重新执行任务</p>
</li>
<li><p>快速：一个单进程的celery每分钟可处理上百万个任务</p>
</li>
<li><p>灵活： 几乎celery的各个组件都可以被扩展及自定制</p>
</li>
</ol>
<h3 id="Celery基本工作流程图"><a href="#Celery基本工作流程图" class="headerlink" title="Celery基本工作流程图"></a>Celery基本工作流程图</h3><p>![<del>~</del>`](<a href="https://img-blog.csdnimg.cn/2020022214505926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/2020022214505926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70</a>)</p>
<p>user：用户程序，用于告知celery去执行一个任务。<br>broker: 存放任务（依赖RabbitMQ或Redis，进行存储）<br>worker：执行任务</p>
<p><img src="https://img-blog.csdnimg.cn/20200222145650451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="~~~~~~~~~~~~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200222145650451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h2 id="非常重要"><a href="#非常重要" class="headerlink" title="非常重要"></a>非常重要</h2><h3 id="版本支持情况"><a href="#版本支持情况" class="headerlink" title="版本支持情况"></a>版本支持情况</h3><pre class="highlight"><span class="line">Celery version 4.0 runs on</span><br><span class="line">        Python ❨2.7, 3.4, 3.5❩</span><br><span class="line">        PyPy ❨5.4, 5.5❩</span><br><span class="line">    This is the last version to support Python 2.7, and from the next version (Celery 5.x) Python 3.5 or newer is required.</span><br><span class="line"></span><br><span class="line">    If you’re running an older version of Python, you need to be running an older version of Celery:</span><br><span class="line"></span><br><span class="line">        Python 2.6: Celery series 3.1 or earlier.</span><br><span class="line">        Python 2.5: Celery series 3.0 or earlier.</span><br><span class="line">        Python 2.4 was Celery series 2.2 or earlier.</span><br><span class="line"></span><br><span class="line">    Celery is a project with minimal funding, so we don’t support Microsoft Windows. Please don’t open any issues related to that platform.</span><br></pre>

<p>如果使用python版本不支持 ↓</p>
<h4 id="解决版本问题："><a href="#解决版本问题：" class="headerlink" title="解决版本问题："></a>解决版本问题：</h4><p>在 celery 官方的提议下，建议将 async 文件的文件名改成 asynchronous</p>
<p>C:\Python37\Lib\site-packages\kombu\async</p>
<pre class="highlight"><span class="line">C:\Python37\Lib\site-packages\celery\utils\timer2.py</span><br><span class="line">C:\Python37\lib\site-packages\celery\concurrency\asynpool.py</span><br><span class="line">C:\Python37\lib\site-packages\celery\worker\components.py</span><br><span class="line">C:\Python37\lib\site-packages\celery\worker\autoscale.py</span><br><span class="line">C:\Python37\lib\site-packages\celery\worker\consumer.py</span><br></pre>

<p>以下的文件都有 async 的导包，我们将里面的导报都改成 asynchronous</p>
]]></content>
      <categories>
        <category>celery</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django Admin 列表页展示</title>
    <url>/2020/07/04/Django%20Admin%20%E5%88%97%E8%A1%A8%E9%A1%B5%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[<h3 id="调整列表页展示"><a href="#调整列表页展示" class="headerlink" title="调整列表页展示"></a>调整列表页展示</h3><h4 id="1-页大小"><a href="#1-页大小" class="headerlink" title="1 页大小"></a>1 页大小</h4><p>每页中显示多少条数据，默认为每页显示100条数据，属性如下：</p>
<pre class="highlight"><span class="line">list_per_page=<span class="number">100</span></span><br><span class="line"><span class="number">1</span></span><br></pre>

<ul>
<li>1）打开 <code>admin.py</code> 文件，修改 <code>AreaAdmin</code> 类如下：</li>
</ul>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_per_page = <span class="number">2</span></span><br><span class="line"><span class="number">12</span></span><br></pre>

<ul>
<li>2）在浏览器中查看区域信息的列表页面，效果如下图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200425215138294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425215138294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="2-“操作选项”的位置"><a href="#2-“操作选项”的位置" class="headerlink" title="2 “操作选项”的位置"></a>2 “操作选项”的位置</h4><p>顶部显示的属性，设置为True在顶部显示，设置为False不在顶部显示，默认为True。</p>
<pre class="highlight"><span class="line">actions_on_top=<span class="literal">True</span></span><br><span class="line"><span class="number">1</span></span><br></pre>

<p>底部显示的属性，设置为True在底部显示，设置为False不在底部显示，默认为False。</p>
<pre class="highlight"><span class="line">actions_on_bottom=<span class="literal">False</span></span><br><span class="line"><span class="number">1</span></span><br></pre>

<ul>
<li>1）打开 <code>admin.py</code> 文件，修改 <code>BookInfoAdmin</code> 类如下：</li>
</ul>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    actions_on_top = <span class="literal">True</span></span><br><span class="line">    actions_on_bottom = <span class="literal">True</span></span><br><span class="line"><span class="number">1234</span></span><br></pre>

<p>2）在浏览器中刷新效果如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200425215506626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425215506626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="3-列表中的列"><a href="#3-列表中的列" class="headerlink" title="3 列表中的列"></a>3 列表中的列</h4><p>属性如下：</p>
<pre class="highlight"><span class="line">list_display=[模型字段<span class="number">1</span>,模型字段<span class="number">2</span>,...]</span><br><span class="line"><span class="number">1</span></span><br></pre>

<ul>
<li>1）打开 <code>admin.py</code> 文件，修改 <code>BookInfoAdmin</code> 类如下：</li>
</ul>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    list_display = [<span class="string">'id'</span>,<span class="string">'name'</span>]</span><br><span class="line"><span class="number">123</span></span><br></pre>

<ul>
<li>2）在浏览器中刷新效果如下图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200425215553301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425215553301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br><strong>点击列头可以进行升序或降序排列。</strong></p>
<h4 id="4-将方法作为列"><a href="#4-将方法作为列" class="headerlink" title="4 将方法作为列"></a>4 将方法作为列</h4><p>列可以是模型字段，还可以是模型方法，要求方法有返回值。</p>
<p><strong>通过设置short_description属性，可以设置在admin站点中显示的列名。</strong></p>
<ul>
<li>1）打开 <code>models.py</code> 文件，修改 <code>BookInfo</code> 类如下：</li>
</ul>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfo</span> <span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bookname</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;&lt;'</span> + self.name + <span class="string">'&gt;&gt;'</span></span><br><span class="line"></span><br><span class="line">    bookname.short_description = <span class="string">'书名'</span>  <span class="comment"># 设置方法字段在admin中显示的标题</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre>

<ul>
<li>2）打开 <code>admin.py</code> 文件，修改 <code>BookInfoAdmin</code> 类如下：</li>
</ul>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span> <span class="params">(admin.ModelAdmin)</span> :</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">   list_display = [<span class="string">'id'</span>,<span class="string">'name'</span>,<span class="string">'bookname'</span>]</span><br><span class="line"><span class="number">1234</span></span><br></pre>

<ul>
<li>3）在浏览器中刷新效果如下图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020042521565783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/2020042521565783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>方法列是不能排序的，如果需要排序需要为方法指定排序依据。</p>
<pre class="highlight"><span class="line">admin_order_field=模型类字段</span><br><span class="line"><span class="number">1</span></span><br></pre>

<ul>
<li>1）打开 <code>models.py</code>文件，修改 <code>BookInfo</code> 类如下：</li>
</ul>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bookname</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;&lt;'</span> + self.name + <span class="string">'&gt;&gt;'</span></span><br><span class="line"></span><br><span class="line">    bookname.short_description = <span class="string">'书名'</span>  <span class="comment"># 设置方法字段在admin中显示的标题</span></span><br><span class="line">    bookname.admin_order_field = <span class="string">'name'</span></span><br><span class="line"><span class="number">123456789</span></span><br></pre>

<ul>
<li>2）在浏览器中刷新效果如下图：<br><img src="https://img-blog.csdnimg.cn/20200425215738873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425215738873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></li>
</ul>
<h4 id="5-关联对象"><a href="#5-关联对象" class="headerlink" title="5 关联对象"></a>5 关联对象</h4><p>无法直接访问关联对象的属性或方法，可以在模型类中封装方法，访问关联对象的成员。</p>
<ul>
<li>1）打开 <code>models.py</code> 文件，修改 <code>PeopleInfo</code> 类如下：</li>
</ul>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeopleInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readcount</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.book.readcount</span><br><span class="line">    readcount.short_description = <span class="string">'图书阅读量'</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre>

<p>2）打开 <code>admin.py</code> 文件，修改 <code>PeopleInfoAdmin</code> 类如下：</p>
<pre class="highlight"><span class="line"><span class="meta">@admin.register(PeopleInfo)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeopleInfoAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line"></span><br><span class="line">    list_display = [<span class="string">'id'</span>,<span class="string">'name'</span>,<span class="string">'book'</span>,<span class="string">'readcount'</span>]</span><br><span class="line"><span class="number">1234</span></span><br></pre>

<p>3）在浏览器中刷新效果如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200425215851420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425215851420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="6-右侧栏过滤器"><a href="#6-右侧栏过滤器" class="headerlink" title="6 右侧栏过滤器"></a>6 右侧栏过滤器</h4><p>属性如下，只能接收字段，会将对应字段的值列出来，用于快速过滤。一般用于有重复值的字段。</p>
<pre class="highlight"><span class="line">list_filter=[]</span><br><span class="line"><span class="number">1</span></span><br></pre>

<ul>
<li>1）打开 <code>admin.py</code> 文件，修改 <code>PeopleInfoAdmin</code> 类如下：</li>
</ul>
<pre class="highlight"><span class="line"><span class="meta">@admin.register(PeopleInfo)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeopleInfoAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line"></span><br><span class="line">    list_display = [<span class="string">'id'</span>,<span class="string">'name'</span>,<span class="string">'book'</span>,<span class="string">'readcount'</span>]</span><br><span class="line"></span><br><span class="line">    list_filter = [<span class="string">'book'</span>,<span class="string">'gender'</span>]</span><br><span class="line"><span class="number">123456</span></span><br></pre>

<ul>
<li>2）在浏览器中刷新效果如下图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200425220055236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425220055236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="7-搜索框"><a href="#7-搜索框" class="headerlink" title="7 搜索框"></a>7 搜索框</h4><p>属性如下，用于对指定字段的值进行搜索，支持模糊查询。列表类型，表示在这些字段上进行搜索。</p>
<pre class="highlight"><span class="line">search_fields=[]</span><br><span class="line"><span class="number">1</span></span><br></pre>

<ul>
<li>1）打开<code>admin.py</code>文件，修改<code>PeopleInfoAdmin</code>类如下：</li>
</ul>
<pre class="highlight"><span class="line"><span class="meta">@admin.register(PeopleInfo)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeopleInfoAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line"></span><br><span class="line">    list_display = [<span class="string">'id'</span>,<span class="string">'name'</span>,<span class="string">'book'</span>,<span class="string">'readcount'</span>]</span><br><span class="line"></span><br><span class="line">    list_filter = [<span class="string">'book'</span>,<span class="string">'gender'</span>]</span><br><span class="line"></span><br><span class="line">    search_fields = [<span class="string">'name'</span>]</span><br><span class="line"><span class="number">12345678</span></span><br></pre>

<ul>
<li>2）在浏览器中刷新效果如下图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200425220702426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425220702426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django Admin 调整站点信息（更改 Admin站点的名称信息）</title>
    <url>/2020/07/16/Django%20Admin%20%E8%B0%83%E6%95%B4%E7%AB%99%E7%82%B9%E4%BF%A1%E6%81%AF%EF%BC%88%E6%9B%B4%E6%94%B9%20Admin%E7%AB%99%E7%82%B9%E7%9A%84%E5%90%8D%E7%A7%B0%E4%BF%A1%E6%81%AF%EF%BC%89/</url>
    <content><![CDATA[<h3 id="调整站点信息"><a href="#调整站点信息" class="headerlink" title="调整站点信息"></a>调整站点信息</h3><p>Admin站点的名称信息也是可以自定义的。</p>
<p>未调整前如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200425222752410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425222752410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<ul>
<li><code>admin.site.site_header</code> 设置网站页头</li>
<li><code>admin.site.site_title</code> 设置页面标题</li>
<li><code>admin.site.index_title</code> 设置首页标语</li>
</ul>
<p>在 <code>admin.py</code> 文件中添加一下信息</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line">admin.site.site_header = <span class="string">'传智书城'</span></span><br><span class="line">admin.site.site_title = <span class="string">'传智书城MIS'</span></span><br><span class="line">admin.site.index_title = <span class="string">'欢迎使用传智书城MIS'</span></span><br><span class="line"><span class="number">12345</span></span><br></pre>

<p>刷新网站，效果如下</p>
<p><img src="https://img-blog.csdnimg.cn/20200425223005559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425223005559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django URLconf，路由命名与reverse反解析（逆向）</title>
    <url>/2020/06/01/Django%20URLconf%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%91%BD%E5%90%8D%E4%B8%8Ereverse%E5%8F%8D%E8%A7%A3%E6%9E%90%EF%BC%88%E9%80%86%E5%90%91%EF%BC%89/</url>
    <content><![CDATA[<h3 id="URLconf"><a href="#URLconf" class="headerlink" title="URLconf"></a>URLconf</h3><ul>
<li>浏览者通过在浏览器的地址栏中输入网址请求网站</li>
<li>对于Django开发的网站，由哪一个视图进行处理请求，是由url匹配找到的</li>
</ul>
<h4 id="配置URLconf"><a href="#配置URLconf" class="headerlink" title="配置URLconf"></a>配置URLconf</h4><ol>
<li><p>settings.py中</p>
<p>指定url配置</p>
<pre class="highlight"><span class="line">ROOT_URLCONF = <span class="string">'项目.urls'</span></span><br><span class="line"><span class="number">1</span></span><br></pre>
</li>
<li><p>项目中urls.py</p>
<p>匹配成功后，包含到应用的urls.py</p>
<pre class="highlight"><span class="line">url(正则, include(<span class="string">'应用.urls'</span>))</span><br><span class="line"><span class="number">1</span></span><br></pre>
</li>
<li><p>应用中urls.py</p>
<p>匹配成功后，调用views.py对应的函数</p>
<pre class="highlight"><span class="line">url(正则, views.函数名)</span><br><span class="line"><span class="number">1</span></span><br></pre>
</li>
<li><p>提示</p>
<pre class="highlight"><span class="line"><span class="number">1.</span> 正则部分推荐使用 r，表示字符串不转义，这样在正则</span><br><span class="line">表达式中使用 \ 只写一个就可以</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 不能在开始加反斜杠，推荐在结束加反斜杠</span><br><span class="line">    正确：path/</span><br><span class="line">    正确：path</span><br><span class="line">    错误：/path</span><br><span class="line">    错误：/path/</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 请求的url被看做是一个普通的python字符串，进行匹配时不包括域名、get或post参数</span><br><span class="line">    <span class="number">3.1</span> 如请求地址如下：</span><br><span class="line">        http://127.0.0.1:8000/18/?a=10</span><br><span class="line">    <span class="number">3.2</span> 去掉域名和参数部分后，只剩下如下部分与正则匹配</span><br><span class="line">        <span class="number">18</span>/</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre>

</li>
</ol>
<h3 id="路由命名与reverse反解析（逆向）"><a href="#路由命名与reverse反解析（逆向）" class="headerlink" title="路由命名与reverse反解析（逆向）"></a>路由命名与reverse反解析（逆向）</h3><h4 id="1-路由命名"><a href="#1-路由命名" class="headerlink" title="1. 路由命名"></a>1. 路由命名</h4><p>在定义路由的时候，可以为路由命名，方便查找特定视图的具体路径信息。</p>
<ul>
<li><p>在使用include函数定义路由时，可以使用namespace参数定义路由的命名空间，如</p>
<pre class="highlight"><span class="line">url(<span class="string">r'^'</span>,include(<span class="string">'book.urls'</span>,namespace=<span class="string">'book'</span>))</span><br><span class="line"><span class="number">1</span></span><br></pre>

<p>命名空间表示，凡是book.urls中定义的路由，均属于namespace指明的book名下。<code>命名空间的作用：避免不同应用中的路由使用了相同的名字发生冲突，使用命名空间区别开。</code></p>
</li>
<li><p>在定义普通路由时，可以使用name参数指明路由的名字，如</p>
<pre class="highlight"><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^$'</span>,index),</span><br><span class="line">    <span class="comment"># 匹配书籍列表信息的URL,调用对应的bookList视图</span></span><br><span class="line">    url(<span class="string">r'^booklist/$'</span>,bookList,name=<span class="string">'index'</span>),</span><br><span class="line">    url(<span class="string">r'^testproject/$'</span>,views.testproject,name=<span class="string">'test'</span>),</span><br><span class="line">]</span><br><span class="line"><span class="number">123456</span></span><br></pre>

</li>
</ul>
<h4 id="2-reverse反解析"><a href="#2-reverse反解析" class="headerlink" title="2. reverse反解析"></a>2. reverse反解析</h4><p>使用reverse函数，可以根据路由名称，返回具体的路径，如：</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.core.urlresolvers <span class="keyword">import</span> reverse</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testproject</span><span class="params">(request)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">"OK"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义视图：提供书籍列表信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bookList</span><span class="params">(request)</span>:</span></span><br><span class="line"></span><br><span class="line">    url = reverse(<span class="string">'book:test'</span>)</span><br><span class="line">    print(url)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'index'</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre>

<ul>
<li>对于未指明namespace的，reverse(路由name)</li>
<li>对于指明namespace的，reverse(命名空间namespace:路由name)</li>
</ul>
]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django Admin站点</title>
    <url>/2020/07/02/Django%20Admin%E7%AB%99%E7%82%B9/</url>
    <content><![CDATA[<h3 id="Admin站点"><a href="#Admin站点" class="headerlink" title="Admin站点"></a>Admin站点</h3><p>假设我们要设计一个新闻网站，我们需要编写展示给用户的页面，网页上展示的新闻信息是从哪里来的呢？<strong>是从数据库中查找到新闻的信息，然后把它展示在页面上。</strong> 但是我们的网站上的新闻每天都要更新，这就意味着对数据库的增、删、改、查操作，那么我们需要每天写sql语句操作数据库吗? 如果这样的话，是不是非常繁琐，所以我们可以设计一个页面，通过对这个页面的操作来实现对新闻数据库的增删改查操作。那么问题来了，老板说我们需要在建立一个新网站，是不是还要设计一个页面来实现对新网站数据库的增删改查操作，但是这样的页面具有一个很大的重复性，那有没有一种方法能够让我们很快的生成管理数据库表的页面呢？<strong>有，那就是我们接下来要给大家讲的Django的后台管理</strong>。Django能够根据定义的模型类自动地生成管理页面。</p>
<p>使用Django的管理模块，需要按照如下步骤操作：</p>
<ol>
<li>管理界面本地化</li>
<li>创建管理员</li>
<li>注册模型类</li>
<li>自定义管理页面</li>
</ol>
<h4 id="1-管理界面本地化"><a href="#1-管理界面本地化" class="headerlink" title="1 管理界面本地化"></a>1 管理界面本地化</h4><p>在settings.py中设置语言和时区</p>
<pre class="highlight"><span class="line"><span class="comment">#设置中文</span></span><br><span class="line">LANGUAGE_CODE = <span class="string">'zh-Hans'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#亚洲上海时区</span></span><br><span class="line">TIME_ZONE = <span class="string">'Asia/Shanghai'</span></span><br><span class="line"><span class="number">12345</span></span><br></pre>

<h4 id="2-创建超级管理员"><a href="#2-创建超级管理员" class="headerlink" title="2 创建超级管理员"></a>2 创建超级管理员</h4><p>创建管理员的命令如下，按提示输入用户名、邮箱、密码。</p>
<pre class="highlight"><span class="line">python manage.py createsuperuser</span><br><span class="line"><span class="number">1</span></span><br></pre>

<p><img src="https://img-blog.csdnimg.cn/20200425172151578.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425172151578.png" class="lozad post-image"></p>
<p>打开浏览器，在地址栏中输入如下地址后回车。</p>
<pre class="highlight"><span class="line">http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/admin/</span><br><span class="line"><span class="number">1</span></span><br></pre>

<p>输入前面创建的用户名、密码完成登录。</p>
<p><img src="https://img-blog.csdnimg.cn/2020042517221618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/2020042517221618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<p>登录成功后界面如下，但是并没有我们自己应用模型的入口，接下来进行第三步操作。</p>
<p><img src="https://img-blog.csdnimg.cn/20200425172234391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425172234391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h3 id="3-注册模型类"><a href="#3-注册模型类" class="headerlink" title="3 注册模型类"></a>3 注册模型类</h3><p>登录后台管理后，默认没有我们创建的应用中定义的模型类，需要在自己应用中的admin.py文件中注册，才可以在后台管理中看到，并进行增删改查操作。</p>
<p>打开booktest/admin.py文件，编写如下代码：</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="comment">#导入模型</span></span><br><span class="line"><span class="keyword">from</span> book.models <span class="keyword">import</span> BookInfo,PeopleInfo</span><br><span class="line"><span class="comment"># Register your models here.</span></span><br><span class="line"><span class="comment">#注册书籍模型</span></span><br><span class="line">admin.site.register(BookInfo)</span><br><span class="line"><span class="comment">#注册人物模型</span></span><br><span class="line">admin.site.register(PeopleInfo)</span><br><span class="line"><span class="number">12345678</span></span><br></pre>

<p>到浏览器中刷新页面，可以看到模型类BookInfo和PeopleInfo的管理了。<br><img src="https://img-blog.csdnimg.cn/20200425172305673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425172305673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>点击类名称”BookInfo”（图书）可以进入列表页，默认只有一列。<br><img src="https://img-blog.csdnimg.cn/20200425172318273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425172318273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>在列表页中点击”增加”可以进入增加页，Django会根据模型类的不同，生成不同的表单控件，按提示填写表单内容后点击”保存”，完成数据创建，创建成功后返回列表页。</p>
<p><img src="https://img-blog.csdnimg.cn/20200425172331888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425172331888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>在列表页中点击某行的第一列可以进入修改页。</p>
<p><img src="https://img-blog.csdnimg.cn/20200425172343482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425172343482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>按照提示进行内容的修改，修改成功后进入列表页。在修改页点击“删除”可以删除一项。</p>
<p><img src="https://img-blog.csdnimg.cn/20200425172357295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425172357295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>删除：在列表页勾选想要删除的复选框，可以删除多项。</p>
<p><img src="https://img-blog.csdnimg.cn/20200425172410268.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425172410268.png" class="lozad post-image"><br>点击执行后进入确认页面，删除后回来列表页面。</p>
<p><img src="https://img-blog.csdnimg.cn/20200425172421776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425172421776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h3 id="4-定义与使用Admin管理类"><a href="#4-定义与使用Admin管理类" class="headerlink" title="4 定义与使用Admin管理类"></a>4 定义与使用Admin管理类</h3><p>Django提供的Admin站点的展示效果可以通过自定义ModelAdmin类来进行控制。</p>
<p>定义管理类需要继承自admin.ModelAdmin类，如下</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="number">1234</span></span><br></pre>

<p>使用管理类有两种方式：</p>
<ul>
<li>注册参数</li>
</ul>
<pre class="highlight"><span class="line">admin.site.register(BookInfo,BookInfoAdmin</span><br><span class="line"><span class="number">1</span></span><br></pre>

<ul>
<li>装饰器</li>
</ul>
<pre class="highlight"><span class="line"><span class="meta">@admin.register(BookInfo)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre>

]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django Admin上传图片</title>
    <url>/2020/07/22/Django%20Admin%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h3 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h3><p>Django有提供文件系统支持，在Admin站点中可以轻松上传图片。</p>
<p>使用Admin站点保存图片，需要安装Python的图片操作包</p>
<pre class="highlight"><span class="line">pip install Pillow</span><br><span class="line"><span class="number">1</span></span><br></pre>

<h4 id="1-配置"><a href="#1-配置" class="headerlink" title="1 配置"></a>1 配置</h4><p>默认情况下，Django会将上传的图片保存在本地服务器上，需要配置保存的路径。</p>
<p>我们可以将上传的文件保存在静态文件目录中，如我们之前设置的static目录中在settings.py 文件中添加如下上传保存目录信息</p>
<pre class="highlight"><span class="line">MEDIA_ROOT=os.path.join(BASE_DIR,<span class="string">"static/media"</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre>

<p><img src="https://img-blog.csdnimg.cn/20200425223259996.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425223259996.png" class="lozad post-image"></p>
<h4 id="2-为模型类添加ImageField字段"><a href="#2-为模型类添加ImageField字段" class="headerlink" title="2 为模型类添加ImageField字段"></a>2 为模型类添加ImageField字段</h4><p>我们为之前的BookInfo模型类添加一个ImageFiled</p>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    image = models.ImageField(upload_to=<span class="string">'book'</span>, verbose_name=<span class="string">'图片'</span>, null=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    upload_to 选项指明该字段的图片保存在MEDIA_ROOT目录中的哪个子目录</span><br><span class="line"><span class="number">123456</span></span><br></pre>

<ul>
<li>进行数据库迁移操作</li>
</ul>
<pre class="highlight"><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br><span class="line"><span class="number">12</span></span><br></pre>

<h4 id="3-使用Admin站点上传图片"><a href="#3-使用Admin站点上传图片" class="headerlink" title="3 使用Admin站点上传图片"></a>3 使用Admin站点上传图片</h4><p>进入Admin站点的图书管理页面，选择一个图书，能发现多出来一个上传图片的字段</p>
<p><img src="https://img-blog.csdnimg.cn/20200425223441314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425223441314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<p>选择一张图片并保存后，图片会被保存在<code>static/media/book/</code>目录下。</p>
<p>在数据库中，我们能看到image字段被设置为图片的路径</p>
<p><img src="https://img-blog.csdnimg.cn/20200425223503320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425223503320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 中的 shell命令</title>
    <url>/2020/02/24/Django%20%E4%B8%AD%E7%9A%84%20shell%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="shell工具"><a href="#shell工具" class="headerlink" title="shell工具"></a>shell工具</h4><p>Django的manage工具提供了shell命令，帮助我们配置好当前工程的运行环境（如连接好数据库等），以便可以直接在终端中执行测试python语句。</p>
<p>通过如下命令进入shell</p>
<pre class="highlight"><span class="line">python manage.py shell</span><br><span class="line"><span class="number">1</span></span><br></pre>

<p><img src="https://img-blog.csdnimg.cn/20200407171230436.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200407171230436.png" class="lozad post-image"><br>导入两个模型类，以便后续使用</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> book.models <span class="keyword">import</span> BookInfo,PeopleInfo</span><br><span class="line"><span class="number">1</span></span><br></pre>

<p>此文的shell 是 manage工具的 一条命令</p>
<p>还记得之前创建的管理员嘛，用的也是 manage命令，那我们说说这个 manage</p>
<h4 id="Django的命令行工具"><a href="#Django的命令行工具" class="headerlink" title="Django的命令行工具"></a>Django的命令行工具</h4><p>django-admin.py是Django的一个用于管理任务的命令行工具，manage.py是对django-admin.py的简单包装，每个Django Project里面都会包含一个manage.py</p>
<p>语法：</p>
<pre class="highlight"><span class="line">django-admin.py &lt;subcommand&gt; [options]</span><br><span class="line">manage.py &lt;subcommand&gt; [options]</span><br><span class="line"><span class="number">12</span></span><br></pre>

<p>subcommand是子命令；options是可选的</p>
<pre class="highlight"><span class="line"><span class="comment"># 常用子命令：</span></span><br><span class="line"></span><br><span class="line">startproject:创建一个项目（*）</span><br><span class="line">startapp:创建一个app（*）</span><br><span class="line">runserver：运行开发服务器（*）</span><br><span class="line">shell：进入django shell（*）</span><br><span class="line">dbshell：进入django dbshell</span><br><span class="line">check：检查django项目完整性</span><br><span class="line">flush：清空数据库</span><br><span class="line">compilemessages：编译语言文件</span><br><span class="line">makemessages：创建语言文件</span><br><span class="line">makemigrations：生成数据库同步脚本（*）</span><br><span class="line">migrate：同步数据库（*）</span><br><span class="line">showmigrations：查看生成的数据库同步脚本（*）</span><br><span class="line">sqlflush：查看生成清空数据库的脚本（*）</span><br><span class="line">sqlmigrate：查看数据库同步的sql语句（*）</span><br><span class="line">dumpdata:导出数据</span><br><span class="line">loaddata:导入数据</span><br><span class="line">diffsettings:查看你的配置和django默认配置的不同之处</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre>

<p>manage.py 特有的一些子命令：</p>
<pre class="highlight"><span class="line">createsuperuser:创建超级管理员（*）</span><br><span class="line">changepassword:修改密码（*）</span><br><span class="line">clearsessions：清除session</span><br><span class="line"><span class="number">123</span></span><br></pre>

<p>更改开发服务器的端口：</p>
<pre class="highlight"><span class="line">python manage.py runserver <span class="number">8080</span></span><br><span class="line"><span class="number">1</span></span><br></pre>

<p>查看帮助文档：</p>
<pre class="highlight"><span class="line">python manage.py help</span><br><span class="line"><span class="number">1</span></span><br><span class="line">D:\day70class&gt;python manage.py help</span><br><span class="line"></span><br><span class="line">Type <span class="string">'manage.py help &lt;subcommand&gt;'</span> <span class="keyword">for</span> help on a specific subcommand.</span><br><span class="line"></span><br><span class="line">Available subcommands:</span><br><span class="line"></span><br><span class="line">[auth]</span><br><span class="line">    changepassword</span><br><span class="line">    createsuperuser</span><br><span class="line"></span><br><span class="line">[contenttypes]</span><br><span class="line">    remove_stale_contenttypes</span><br><span class="line"></span><br><span class="line">[django]</span><br><span class="line">    check</span><br><span class="line">    compilemessages</span><br><span class="line">    createcachetable</span><br><span class="line">    dbshell</span><br><span class="line">    diffsettings</span><br><span class="line">    dumpdata</span><br><span class="line">    flush</span><br><span class="line">    inspectdb</span><br><span class="line">    loaddata</span><br><span class="line">    makemessages</span><br><span class="line">    makemigrations</span><br><span class="line">    migrate</span><br><span class="line">    sendtestemail</span><br><span class="line">    shell</span><br><span class="line">    showmigrations</span><br><span class="line">    sqlflush</span><br><span class="line">    sqlmigrate</span><br><span class="line">    sqlsequencereset</span><br><span class="line">    squashmigrations</span><br><span class="line">    startapp</span><br><span class="line">    startproject</span><br><span class="line">    test</span><br><span class="line">    testserver</span><br><span class="line"></span><br><span class="line">[sessions]</span><br><span class="line">    clearsessions</span><br><span class="line"></span><br><span class="line">[staticfiles]</span><br><span class="line">    collectstatic</span><br><span class="line">    findstatic</span><br><span class="line">    runserver</span><br></pre>

]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django Manager管理器</title>
    <url>/2020/05/19/Django%20Manager%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h3 id="管理器Manager"><a href="#管理器Manager" class="headerlink" title="管理器Manager"></a>管理器Manager</h3><p>管理器是Django的模型进行数据库操作的接口，Django应用的每个模型类都拥有至少一个管理器。</p>
<p>我们在通过模型类的objects属性提供的方法操作数据库时，即是在使用一个管理器对象objects。当没有为模型类定义管理器时，Django会为每一个模型类生成一个名为objects的管理器，它是models.Manager类的对象。</p>
<h3 id="自定义管理器"><a href="#自定义管理器" class="headerlink" title="自定义管理器"></a>自定义管理器</h3><p>我们可以自定义管理器，并应用到我们的模型类上。</p>
<pre class="highlight"><span class="line">注意：一旦为模型类指明自定义的过滤器后，Django不再生成默认管理对象objects。</span><br></pre>

<p>自定义管理器类主要用于两种情况</p>
<ul>
<li>准备工作：把bookinfo表中的一条记录is_delete字段修改成True<br><img src="https://img-blog.csdnimg.cn/20200424133314662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200424133314662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></li>
<li>问题：逻辑删除字段为True的那条记录依然会被查询出来</li>
</ul>
<ol>
<li><p>修改原始查询集，重写all()方法。</p>
<p><strong>a、</strong> 打开book/models.py文件，定义类BookInfoManager</p>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoManager</span><span class="params">(models.Manager)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">all</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#默认查询未删除的图书信息</span></span><br><span class="line">        <span class="comment">#调用父类的成员语法为：super().方法名</span></span><br><span class="line">        <span class="keyword">return</span> super().filter(is_delete=<span class="literal">False</span>)</span><br></pre>

<p><strong>b、</strong> 在模型类BookInfo中定义管理器</p>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    books = BookInfoManager()</span><br></pre>

<p><strong>c、</strong> 使用方法</p>
<pre class="highlight"><span class="line"><span class="meta">&gt;&gt;&gt; </span>books = BookInfo.books.all()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>books</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 笑傲江湖&gt;, &lt;BookInfo: 雪山飞狐&gt;, &lt;BookInfo: python入门&gt;]&gt;</span><br></pre>

<p><strong>d、</strong> 视图方法</p>
<pre class="highlight"><span class="line"><span class="comment"># 书籍列表信息视图</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">bookList</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># 查询数据库书籍列表数据</span></span><br><span class="line">    <span class="comment"># books = BookInfo.objects.all()</span></span><br><span class="line">    books = BookInfo.books.all()</span><br><span class="line">    <span class="comment"># 构造上下文</span></span><br><span class="line">    context = &#123;<span class="string">'books'</span>:books&#125;</span><br><span class="line">    <span class="comment"># 数据交给模板处理，处理完成后通过视图响应给客户端</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'Book/booklist.html'</span>, context)</span><br></pre>
</li>
<li><p>在管理器类中补充定义新的方法</p>
<p><strong>a、</strong> 打开book/models.py文件，定义方法create。</p>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoManager</span><span class="params">(models.Manager)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_book</span><span class="params">(self,name,pub_date)</span>:</span></span><br><span class="line">        <span class="comment"># 创建模型类对象self.model可以获得模型类</span></span><br><span class="line">        book = self.model()</span><br><span class="line">        book.name = name</span><br><span class="line">        book.pub_date = pub_date</span><br><span class="line">        book.save()</span><br><span class="line">        <span class="keyword">return</span> book</span><br></pre>

<p><strong>b、</strong> 为模型类BookInfo定义管理器books语法如下</p>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">      ...</span><br><span class="line">    books = BookInfoManager()</span><br></pre>

<p><strong>c、</strong> 调用语法如下：</p>
<pre class="highlight"><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> book.models <span class="keyword">import</span> BookInfo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>book = BookInfo.books.create_book(<span class="string">'python高级'</span>,<span class="string">'2010-1-1'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>book</span><br><span class="line">&lt;BookInfo: python高级&gt;</span><br></pre>

</li>
</ol>
]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 模型类的使用，超级详细版本</title>
    <url>/2020/02/16/Django%20%E6%A8%A1%E5%9E%8B%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="定义模型类"><a href="#定义模型类" class="headerlink" title="定义模型类"></a>定义模型类</h3><ul>
<li>模型类被定义在”应用/models.py”文件中。</li>
<li>模型类必须继承自Model类，位于包django.db.models中。</li>
</ul>
<p>接下来首先以”图书-人物”管理为例进行演示。</p>
<h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h4><p>在models.py 文件中定义模型类。</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="comment"># 准备书籍列表信息的模型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># 创建字段，字段类型...</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>, verbose_name=<span class="string">'名称'</span>)</span><br><span class="line">    pub_date = models.DateField(verbose_name=<span class="string">'发布日期'</span>,null=<span class="literal">True</span>)</span><br><span class="line">    readcount = models.IntegerField(default=<span class="number">0</span>, verbose_name=<span class="string">'阅读量'</span>)</span><br><span class="line">    commentcount = models.IntegerField(default=<span class="number">0</span>, verbose_name=<span class="string">'评论量'</span>)</span><br><span class="line">    is_delete = models.BooleanField(default=<span class="literal">False</span>, verbose_name=<span class="string">'逻辑删除'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'bookinfo'</span>  <span class="comment"># 指明数据库表名</span></span><br><span class="line">        verbose_name = <span class="string">'图书'</span>  <span class="comment"># 在admin站点中显示的名称</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""定义每个数据对象的显示信息"""</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备人物列表信息的模型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeopleInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    GENDER_CHOICES = (</span><br><span class="line">        (<span class="number">0</span>, <span class="string">'male'</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="string">'female'</span>)</span><br><span class="line">    )</span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>, verbose_name=<span class="string">'名称'</span>)</span><br><span class="line">    gender = models.SmallIntegerField(choices=GENDER_CHOICES, default=<span class="number">0</span>, verbose_name=<span class="string">'性别'</span>)</span><br><span class="line">    description = models.CharField(max_length=<span class="number">200</span>, null=<span class="literal">True</span>, verbose_name=<span class="string">'描述信息'</span>)</span><br><span class="line">    book = models.ForeignKey(BookInfo, on_delete=models.CASCADE, verbose_name=<span class="string">'图书'</span>)  <span class="comment"># 外键</span></span><br><span class="line">    is_delete = models.BooleanField(default=<span class="literal">False</span>, verbose_name=<span class="string">'逻辑删除'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'peopleinfo'</span></span><br><span class="line">        verbose_name = <span class="string">'人物信息'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br></pre>

<ol>
<li><p>数据库表名</p>
<p>模型类如果未指明表名，Django默认以小写app应用名_小写模型类名为数据库表名。</p>
<p>可通过db_table指明数据库表名。</p>
</li>
<li><p>关于主键</p>
<p>django会为表创建自动增长的主键列，每个模型只能有一个主键列，如果使用选项设置某属性为主键列后django不会再创建自动增长的主键列。</p>
<p>默认创建的主键列属性为id，可以使用pk代替，pk全拼为primary key。</p>
</li>
<li><p>属性命名限制</p>
<p>不能是python的保留关键字。<br>不允许使用连续的下划线，这是由django的查询方式决定的。</p>
<p>定义属性时需要指定字段类型，通过字段类型的参数指定选项，语法如下：</p>
<pre class="highlight"><span class="line">属性=models.字段类型(选项)</span><br><span class="line"><span class="number">1</span></span><br></pre>
</li>
<li><p>字段类型</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AutoField</td>
<td>自动增长的IntegerField，通常不用指定，不指定时Django会自动创建属性名为id的自动增长属性</td>
</tr>
<tr>
<td>BooleanField</td>
<td>布尔字段，值为True或False</td>
</tr>
<tr>
<td>NullBooleanField</td>
<td>支持Null、True、False三种值</td>
</tr>
<tr>
<td>CharField</td>
<td>字符串，参数max_length表示最大字符个数</td>
</tr>
<tr>
<td>TextField</td>
<td>大文本字段，一般超过4000个字符时使用</td>
</tr>
<tr>
<td>IntegerField</td>
<td>整数</td>
</tr>
<tr>
<td>DecimalField</td>
<td>十进制浮点数， 参数max_digits表示总位数， 参数decimal_places表示小数位数</td>
</tr>
<tr>
<td>FloatField</td>
<td>浮点数</td>
</tr>
<tr>
<td>DateField</td>
<td>日期， 参数auto_now表示每次保存对象时，自动设置该字段为当前时间，用于”最后一次修改”的时间戳，它总是使用当前日期，默认为False； 参数auto_now_add表示当对象第一次被创建时自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为False; 参数auto_now_add和auto_now是相互排斥的，组合将会发生错误</td>
</tr>
<tr>
<td>TimeField</td>
<td>时间，参数同DateField</td>
</tr>
<tr>
<td>DateTimeField</td>
<td>日期时间，参数同DateField</td>
</tr>
<tr>
<td>FileField</td>
<td>上传文件字段</td>
</tr>
<tr>
<td>ImageField</td>
<td>继承于FileField，对上传的内容进行校验，确保是有效的图片</td>
</tr>
</tbody></table>
<ol>
<li>选项</li>
</ol>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>null</td>
<td>如果为True，表示允许为空，默认值是False</td>
</tr>
<tr>
<td>blank</td>
<td>如果为True，则该字段允许为空白，默认值是False</td>
</tr>
<tr>
<td>db_column</td>
<td>字段的名称，如果未指定，则使用属性的名称</td>
</tr>
<tr>
<td>db_index</td>
<td>若值为True, 则在表中会为此字段创建索引，默认值是False</td>
</tr>
<tr>
<td>default</td>
<td>默认</td>
</tr>
<tr>
<td>primary_key</td>
<td>若为True，则该字段会成为模型的主键字段，默认值是False，一般作为AutoField的选项使用</td>
</tr>
<tr>
<td>unique</td>
<td>如果为True, 这个字段在表中必须有唯一值，默认值是False</td>
</tr>
</tbody></table>
<p><strong>null是数据库范畴的概念，blank是表单验证范畴的</strong></p>
<ol>
<li><p>外键</p>
<p>在设置外键时，需要通过on_delete选项指明主表删除数据时，对于外键引用表数据如何处理，在django.db.models中包含了可选常量：</p>
</li>
</ol>
<ul>
<li>CASCADE级联，删除主表数据时连通一起删除外键表中数据</li>
<li>PROTECT保护，通过抛出ProtectedError异常，来阻止删除主表中被外键应用的数据</li>
<li>SET_NULL设置为NULL，仅在该字段null=True允许为null时可用</li>
<li>SET_DEFAULT设置为默认值，仅在该字段设置了默认值时可用</li>
<li>SET()设置为特定值或者调用特定方法</li>
<li>DO_NOTHING不做任何操作，如果数据库前置指明级联性，此选项会抛出IntegrityError异常</li>
</ul>
<h4 id="2-迁移"><a href="#2-迁移" class="headerlink" title="2 迁移"></a>2 迁移</h4><p>将模型类同步到数据库中。</p>
<ol>
<li><p>生成迁移文件</p>
<pre class="highlight"><span class="line">python manage.py makemigrations</span><br></pre>
</li>
<li><p>同步到数据库中</p>
<pre class="highlight"><span class="line">python manage.py migrate</span><br></pre>

</li>
</ol>
<h4 id="3-添加测试数据"><a href="#3-添加测试数据" class="headerlink" title="3 添加测试数据"></a>3 添加测试数据</h4><pre class="highlight"><span class="line">insert into bookinfo(name, pub_date, readcount,commentcount, is_delete) values</span><br><span class="line">(<span class="string">'射雕英雄传'</span>, <span class="string">'1980-5-1'</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="string">'天龙八部'</span>, <span class="string">'1986-7-24'</span>, <span class="number">36</span>, <span class="number">40</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="string">'笑傲江湖'</span>, <span class="string">'1995-12-24'</span>, <span class="number">20</span>, <span class="number">80</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="string">'雪山飞狐'</span>, <span class="string">'1987-11-11'</span>, <span class="number">58</span>, <span class="number">24</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">insert into peopleinfo(name, gender, book_id, description, is_delete)  values</span><br><span class="line">    (<span class="string">'郭靖'</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'降龙十八掌'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'黄蓉'</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'打狗棍法'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'黄药师'</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'弹指神通'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'欧阳锋'</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'蛤蟆功'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'梅超风'</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'九阴白骨爪'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'乔峰'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'降龙十八掌'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'段誉'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'六脉神剑'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'虚竹'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'天山六阳掌'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'王语嫣'</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="string">'神仙姐姐'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'令狐冲'</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="string">'独孤九剑'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'任盈盈'</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="string">'弹琴'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'岳不群'</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="string">'华山剑法'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'东方不败'</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="string">'葵花宝典'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'胡斐'</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="string">'胡家刀法'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'苗若兰'</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="string">'黄衣'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'程灵素'</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="string">'医术'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'袁紫衣'</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="string">'六合拳'</span>, <span class="number">0</span>);</span><br></pre>

<p>考虑到数据库 写入速度的效率，所以此时没有考虑到使用 ORM</p>
]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 中数据库的操作，多种查询方法</title>
    <url>/2020/02/28/Django%20%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%A4%9A%E7%A7%8D%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><p>增加数据有两种方法。</p>
<ol>
<li><p>save</p>
<p>通过创建模型类对象，执行对象的save()方法保存到数据库中。</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> book.models <span class="keyword">import</span> BookInfo,PeopleInfo</span><br><span class="line">book = BookInfo(</span><br><span class="line">        name=<span class="string">'python入门'</span>,</span><br><span class="line">        pub_date=<span class="string">'2010-1-1'</span></span><br><span class="line">    )</span><br><span class="line">book.save()</span><br><span class="line">book</span><br><span class="line"></span><br><span class="line">&lt;BookInfo: python入门&gt;</span><br></pre>

<p><img src="https://img-blog.csdnimg.cn/20200407173150498.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200407173150498.png" class="lozad post-image"></p>
</li>
<li><p>create</p>
<p>通过模型类.objects.create()保存。</p>
<pre class="highlight"><span class="line">PeopleInfo.objects.create(</span><br><span class="line">        name=<span class="string">'itheima'</span>,</span><br><span class="line">        book=book</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">&lt;PeopleInfo: itheima&gt;</span><br></pre>

</li>
</ol>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>修改更新有两种方法</p>
<ol>
<li><p>save</p>
<p>修改模型类对象的属性，然后执行save()方法</p>
<pre class="highlight"><span class="line">person = PeopleInfo.objects.get(name=<span class="string">'itheima'</span>)</span><br><span class="line">person.name = <span class="string">'itcast'</span></span><br><span class="line">person.save()</span><br><span class="line">person</span><br><span class="line"></span><br><span class="line">&lt;PeopleInfo: itcast&gt;</span><br></pre>
</li>
<li><p>update</p>
<p>使用模型类.objects.filter().update()，会返回受影响的行数</p>
<pre class="highlight"><span class="line">PeopleInfo.objects.filter(name=<span class="string">'itcast'</span>).update(name=<span class="string">'H_sen'</span>)</span><br></pre>

</li>
</ol>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除有两种方法</p>
<ol>
<li>模型类对象delete</li>
</ol>
<pre class="highlight"><span class="line">person = PeopleInfo.objects.get(name=<span class="string">'H_sen'</span>)</span><br><span class="line">person.delete()</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>, &#123;<span class="string">'book.PeopleInfo'</span>: <span class="number">1</span>&#125;)</span><br></pre>

<ol>
<li>模型类.objects.filter().delete()</li>
</ol>
<pre class="highlight"><span class="line">BookInfo.objects.filter(name=<span class="string">'python入门'</span>).delete()</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>, &#123;<span class="string">'book.BookInfo'</span>: <span class="number">1</span>, <span class="string">'book.PeopleInfo'</span>: <span class="number">0</span>&#125;)</span><br></pre>

<hr>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h4><ul>
<li>get 查询单一结果，如果不存在会抛出模型类.DoesNotExist异常。</li>
<li>all 查询多个结果。</li>
<li>count 查询结果数量。</li>
</ul>
<pre class="highlight"><span class="line">BookInfo.objects.get(id=<span class="number">1</span>)</span><br><span class="line">&lt;BookInfo: 射雕英雄传&gt;</span><br><span class="line"></span><br><span class="line">BookInfo.objects.get(pk=<span class="number">2</span>)</span><br><span class="line">&lt;BookInfo: 天龙八部&gt;</span><br><span class="line"></span><br><span class="line">BookInfo.objects.get(pk=<span class="number">20</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;console&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/home/python/.virtualenvs/py3_django_1.11/lib/python3.5/site-packages/django/db/models/manager.py"</span>, line <span class="number">85</span>, <span class="keyword">in</span> manager_method</span><br><span class="line">    <span class="keyword">return</span> getattr(self.get_queryset(), name)(*args, **kwargs)</span><br><span class="line">  File <span class="string">"/home/python/.virtualenvs/py3_django_1.11/lib/python3.5/site-packages/django/db/models/query.py"</span>, line <span class="number">380</span>, <span class="keyword">in</span> get</span><br><span class="line">    self.model._meta.object_name</span><br><span class="line">book.models.DoesNotExist: BookInfo matching query does <span class="keyword">not</span> exist.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BookInfo.objects.all()</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 笑傲江湖&gt;, &lt;BookInfo: 雪山飞狐&gt;]&gt;</span><br><span class="line"></span><br><span class="line">BookInfo.objects.count()</span><br></pre>

<h4 id="过滤查询"><a href="#过滤查询" class="headerlink" title="过滤查询"></a>过滤查询</h4><p>实现SQL中的where功能，包括</p>
<ul>
<li>filter过滤出多个结果</li>
<li>exclude排除掉符合条件剩下的结果</li>
<li>get过滤单一结果</li>
</ul>
<p>对于过滤条件的使用，上述三个方法相同，故仅以filter进行讲解。</p>
<p>过滤条件的表达语法如下：</p>
<pre class="highlight"><span class="line">属性名称__比较运算符=值</span><br><span class="line"></span><br><span class="line"><span class="comment"># 属性名称和比较运算符间使用两个下划线，所以属性名不能包括多个下划线</span></span><br><span class="line"></span><br><span class="line">查询编号为<span class="number">1</span>的图书</span><br><span class="line">查询书名包含<span class="string">'湖'</span>的图书</span><br><span class="line">查询书名以<span class="string">'部'</span>结尾的图书</span><br><span class="line">查询书名为空的图书</span><br><span class="line">查询编号为<span class="number">1</span>或<span class="number">3</span>或<span class="number">5</span>的图书</span><br><span class="line">查询编号大于<span class="number">3</span>的图书</span><br><span class="line">查询<span class="number">1980</span>年发表的图书</span><br><span class="line">查询<span class="number">1990</span>年<span class="number">1</span>月<span class="number">1</span>日后发表的图书</span><br></pre>

<h4 id="1-相等"><a href="#1-相等" class="headerlink" title="1. 相等"></a>1. 相等</h4><p>exact：表示判等。</p>
<p>例：查询编号为1的图书。</p>
<pre class="highlight"><span class="line">BookInfo.objects.filter(id__exact=<span class="number">1</span>)</span><br><span class="line">可简写为：</span><br><span class="line">BookInfo.objects.filter(id=<span class="number">1</span>)</span><br></pre>

<h4 id="2-模糊查询"><a href="#2-模糊查询" class="headerlink" title="2. 模糊查询"></a>2. 模糊查询</h4><p>contains：是否包含。</p>
<p>说明：如果要包含%无需转义，直接写即可。</p>
<p>例：查询书名包含’传’的图书。</p>
<pre class="highlight"><span class="line">BookInfo.objects.filter(name__contains=<span class="string">'传'</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;]&gt;</span><br></pre>

<p><strong>startswith、endswith：以指定值开头或结尾。</strong></p>
<p>例：查询书名以’部’结尾的图书</p>
<pre class="highlight"><span class="line">BookInfo.objects.filter(name__endswith=<span class="string">'部'</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 天龙八部&gt;]&gt;</span><br><span class="line"></span><br><span class="line">以上运算符都区分大小写，在这些运算符前加上i表示不区分大小写，</span><br><span class="line">如iexact、icontains、istartswith、iendswith.</span><br></pre>

<h4 id="3-空查询"><a href="#3-空查询" class="headerlink" title="3. 空查询"></a>3. 空查询</h4><p>isnull：是否为null。</p>
<p>例：查询书名为空的图书。</p>
<pre class="highlight"><span class="line">BookInfo.objects.filter(name__isnull=<span class="literal">True</span>)</span><br><span class="line">&lt;QuerySet []&gt;</span><br></pre>

<h4 id="4-范围查询"><a href="#4-范围查询" class="headerlink" title="4. 范围查询"></a>4. 范围查询</h4><p>in：是否包含在范围内。</p>
<p>例：查询编号为1或3或5的图书</p>
<pre class="highlight"><span class="line">BookInfo.objects.filter(id__in=[<span class="number">1</span>,<span class="number">3</span>，<span class="number">5</span>])</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 笑傲江湖&gt;]&gt;</span><br></pre>

<h4 id="5-比较查询"><a href="#5-比较查询" class="headerlink" title="5. 比较查询"></a>5. 比较查询</h4><ul>
<li>gt大于 (greater then)</li>
<li>gte大于等于 (greater then equal)</li>
<li>lt小于 (less then)</li>
<li>lte小于等于 (less then equal)</li>
</ul>
<p>例：查询编号大于3的图书</p>
<pre class="highlight"><span class="line">BookInfo.objects.filter(id__gt=<span class="number">3</span>)</span><br></pre>

<p><strong>不等于的运算符，使用exclude()过滤器。</strong></p>
<p>例：查询编号不等于3的图书</p>
<pre class="highlight"><span class="line">BookInfo.objects.filter(id__gt=<span class="number">3</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 雪山飞狐&gt;]&gt;</span><br></pre>

<h4 id="6-日期查询"><a href="#6-日期查询" class="headerlink" title="6. 日期查询"></a>6. 日期查询</h4><p>year、month、day、week_day、hour、minute、second：对日期时间类型的属性进行运算。</p>
<p>例：查询1980年发表的图书。</p>
<pre class="highlight"><span class="line">BookInfo.objects.filter(pub_date__year=<span class="number">1980</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;]&gt;</span><br></pre>

<p>例：查询1990年1月1日后发表的图书。</p>
<pre class="highlight"><span class="line">BookInfo.objects.filter(pub_date__gt=<span class="string">'1990-1-1'</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 笑傲江湖&gt;]&gt;</span><br></pre>

]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 模板 进阶</title>
    <url>/2020/06/29/Django%20%E6%A8%A1%E6%9D%BF%20%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h3 id="1-配置"><a href="#1-配置" class="headerlink" title="1 配置"></a>1 配置</h3><p>在工程中创建模板目录templates。</p>
<p>在settings.py配置文件中修改<strong>TEMPLATES</strong>配置项的DIRS值：</p>
<pre class="highlight"><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.template.backends.django.DjangoTemplates'</span>,</span><br><span class="line">        <span class="string">'DIRS'</span>: [os.path.join(BASE_DIR, <span class="string">'templates'</span>)],  <span class="comment"># 此处修改</span></span><br><span class="line">        <span class="string">'APP_DIRS'</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">            <span class="string">'context_processors'</span>: [</span><br><span class="line">                <span class="string">'django.template.context_processors.debug'</span>,</span><br><span class="line">                <span class="string">'django.template.context_processors.request'</span>,</span><br><span class="line">                <span class="string">'django.contrib.auth.context_processors.auth'</span>,</span><br><span class="line">                <span class="string">'django.contrib.messages.context_processors.messages'</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre>

<h3 id="2-定义模板"><a href="#2-定义模板" class="headerlink" title="2 定义模板"></a>2 定义模板</h3><p>在templates目录中新建一个模板文件，如index.html</p>
<pre class="highlight"><span class="line">html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre>

<h3 id="3-模板渲染"><a href="#3-模板渲染" class="headerlink" title="3 模板渲染"></a>3 模板渲染</h3><p>调用模板分为两步骤：</p>
<ul>
<li>找到模板 loader.get_template(模板文件在模板目录中的相对路径) -&gt; 返回模板对象</li>
<li>渲染模板 模板对象.render(context=None, request=None) -&gt; 返回渲染后的html文本字符串 context 为模板变量字典，默认值为None request 为请求对象，默认值为None</li>
</ul>
<p>例如，定义一个视图</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.template <span class="keyword">import</span> loader</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># 1.获取模板</span></span><br><span class="line">    template=loader.get_template(<span class="string">'index.html'</span>)</span><br><span class="line"></span><br><span class="line">    context=&#123;<span class="string">'city'</span>: <span class="string">'北京'</span>&#125;</span><br><span class="line">    <span class="comment"># 2.渲染模板</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(template.render(context))</span><br></pre>

<p>Django提供了一个函数render可以简写上述代码。</p>
<p>render(request对象, 模板文件路径, 模板数据字典)</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    context=&#123;<span class="string">'city'</span>: <span class="string">'北京'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'index.html'</span>,context)</span><br></pre>

<h3 id="4-模板语法"><a href="#4-模板语法" class="headerlink" title="4 模板语法"></a>4 模板语法</h3><h4 id="4-1-模板变量"><a href="#4-1-模板变量" class="headerlink" title="4.1 模板变量"></a>4.1 模板变量</h4><p>变量名必须由字母、数字、下划线（不能以下划线开头）和点组成。</p>
<p>语法如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200425123449754.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425123449754.png" class="lozad post-image"><br>模板变量可以使python的内建类型，也可以是对象。</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    context = &#123;</span><br><span class="line">        <span class="string">'city'</span>: <span class="string">'北京'</span>,</span><br><span class="line">        <span class="string">'adict'</span>: &#123;</span><br><span class="line">            <span class="string">'name'</span>: <span class="string">'西游记'</span>,</span><br><span class="line">            <span class="string">'author'</span>: <span class="string">'吴承恩'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'alist'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'index.html'</span>, context)</span><br></pre>

<p><img src="https://img-blog.csdnimg.cn/20200425123529482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425123529482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="4-2-模板语句"><a href="#4-2-模板语句" class="headerlink" title="4.2 模板语句"></a>4.2 模板语句</h4><ol>
<li><p><strong>for循环：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200425123551840.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425123551840.png" class="lozad post-image"></p>
</li>
<li><p><strong>if条件：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200425123602818.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425123602818.png" class="lozad post-image"></p>
</li>
</ol>
<p>比较运算符如下：</p>
<pre class="highlight"><span class="line">==</span><br><span class="line">!=</span><br><span class="line">&lt;</span><br><span class="line">&gt;</span><br><span class="line">&lt;=</span><br><span class="line">&gt;=</span><br></pre>

<p>布尔运算符如下：</p>
<pre class="highlight"><span class="line"><span class="keyword">and</span></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"><span class="keyword">not</span></span><br></pre>

<p><code>注意：运算符左右两侧不能紧挨变量或常量，必须有空格。</code><br><img src="https://img-blog.csdnimg.cn/20200425123741564.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425123741564.png" class="lozad post-image"></p>
<h3 id="4-3-过滤器"><a href="#4-3-过滤器" class="headerlink" title="4.3 过滤器"></a>4.3 过滤器</h3><p>语法如下:</p>
<ul>
<li>使用管道符号|来应用过滤器，用于进行计算、转换操作，可以使用在变量、标签中。</li>
<li>如果过滤器需要参数，则使用冒号:传递参数。</li>
<li>变量|过滤器:参数</li>
</ul>
<p>列举几个如下：</p>
<ul>
<li><p>safe，禁用转义，告诉模板这个变量是安全的，可以解释执行</p>
</li>
<li><p>length，长度，返回字符串包含字符的个数，或列表、元组、字典的元素个数。</p>
</li>
<li><p>default，默认值，如果变量不存在时则返回默认值。</p>
</li>
<li><pre><code class="python">data|default:<span class="string">'默认值'</span>
<span class="number">1</span>
<pre class="highlight"><span class="line"></span><br><span class="line">- date，日期，用于对日期类型的值进行字符串格式化，常用的格式化字符如下：</span><br><span class="line"></span><br><span class="line">  - Y表示年，格式为4位，y表示两位的年。</span><br><span class="line">  - m表示月，格式为01,02,12等。</span><br><span class="line">  - d表示日, 格式为01,02等。</span><br><span class="line">  - j表示日，格式为1,2等。</span><br><span class="line">  - H表示时，24进制，h表示12进制的时。</span><br><span class="line">  - i表示分，为0-59。</span><br><span class="line">  - s表示秒，为0-59。</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;python</span><br><span class="line">  value|date:&quot;Y年m月j日  H时i分s秒&quot;</span><br></pre>
</code></pre>
</li>
</ul>
<h4 id="4-4-注释"><a href="#4-4-注释" class="headerlink" title="4.4 注释"></a>4.4 注释</h4><ol>
<li><p>单行注释语法如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200425124128434.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425124128434.png" class="lozad post-image"></p>
</li>
<li><p>多行注释使用comment标签，语法如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200425124140229.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425124140229.png" class="lozad post-image"></p>
</li>
</ol>
<h4 id="4-5-模板继承"><a href="#4-5-模板继承" class="headerlink" title="4.5 模板继承"></a>4.5 模板继承</h4><p>模板继承和类的继承含义是一样的，主要是为了提高代码重用，减轻开发人员的工作量。</p>
<p><strong>父模板</strong></p>
<p>如果发现在多个模板中某些内容相同，那就应该把这段内容定义到父模板中。</p>
<p>标签block：用于在父模板中预留区域，留给子模板填充差异性的内容，名字不能相同。 为了更好的可读性，建议给endblock标签写上名字，这个名字与对应的block名字相同。父模板中也可以使用上下文中传递过来的数据。</p>
<p><strong>子模板</strong></p>
<p>标签extends：继承，写在子模板文件的第一行。</p>
<p><img src="https://img-blog.csdnimg.cn/20200425124227805.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425124227805.png" class="lozad post-image"><br>子模版不用填充父模版中的所有预留区域，如果子模版没有填充，则使用父模版定义的默认值。</p>
<p><img src="https://img-blog.csdnimg.cn/202004251242407.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/202004251242407.png" class="lozad post-image"></p>
<p>填充父模板中指定名称的预留区域。</p>
<p><img src="https://img-blog.csdnimg.cn/20200425124255595.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425124255595.png" class="lozad post-image"></p>
]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 模板，配置文件，静态资源</title>
    <url>/2020/01/30/Django%20%E6%A8%A1%E6%9D%BF%EF%BC%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%8C%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h3 id="模板-Template"><a href="#模板-Template" class="headerlink" title="模板 Template"></a>模板 Template</h3><pre class="highlight"><span class="line">思考 : 网站如何向客户端返回一个漂亮的页面呢？</span><br></pre>

<p>提示 :</p>
<pre class="highlight"><span class="line">漂亮的页面需要html、css、js.</span><br><span class="line">可以把这一堆字段串全都写到视图中, 作为HttpResponse()的参数,响应给客户端.</span><br></pre>

<p>问题 :</p>
<pre class="highlight"><span class="line">视图部分代码臃肿, 耦合度高.</span><br><span class="line">这样定义的字符串是不会出任何效果和错误的.</span><br><span class="line">效果无法及时查看.有错也不容易及时发现.</span><br></pre>

<p>设想 :</p>
<pre class="highlight"><span class="line">是否可以有一个专门定义前端页面的地方, 效果可以及时展示,错误可以及时发现,并且可以降低模块间耦合度!</span><br><span class="line">1</span><br></pre>

<p>解决问题 :模板</p>
<pre class="highlight"><span class="line">MVT设计模式中的T,Template</span><br></pre>

<p>在Django中, 将前端的内容定义在模板中, 然后再把模板交给视图调用, 各种漂亮、炫酷的效果就出现了.</p>
<h4 id="模板使用步骤"><a href="#模板使用步骤" class="headerlink" title="模板使用步骤"></a>模板使用步骤</h4><ol>
<li>创建模板</li>
<li>设置模板查找路径</li>
<li>模板接收视图传入的数据</li>
<li>模板处理数据</li>
</ol>
<h4 id="1-创建模板"><a href="#1-创建模板" class="headerlink" title="1.创建模板"></a>1.创建模板</h4><ul>
<li>在应用同级目录下创建模板文件夹templates. 文件夹名称固定写法.</li>
<li>在templates文件夹下, 创建应用同名文件夹. 例, Book</li>
<li>在应用同名文件夹下创建网页模板文件. 例 :index.html</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200407123719800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200407123719800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="2-设置模板查找路径"><a href="#2-设置模板查找路径" class="headerlink" title="2.设置模板查找路径"></a>2.设置模板查找路径</h4><p><img src="https://img-blog.csdnimg.cn/20200407123747594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200407123747594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="3-模板接收视图传入的数据"><a href="#3-模板接收视图传入的数据" class="headerlink" title="3.模板接收视图传入的数据"></a>3.模板接收视图传入的数据</h4><ul>
<li><p>视图模板加载</p>
<p><img src="https://img-blog.csdnimg.cn/20200407123821228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200407123821228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
</ul>
<h4 id="4-模板处理数据"><a href="#4-模板处理数据" class="headerlink" title="4.模板处理数据"></a>4.模板处理数据</h4><p><img src="https://img-blog.csdnimg.cn/20200407123838980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200407123838980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<ol>
<li>查看模板处理数据成果</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200407123852950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200407123852950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="总结View-Templates流程"><a href="#总结View-Templates流程" class="headerlink" title="总结View-Templates流程"></a>总结View-Templates流程</h4><p><img src="https://img-blog.csdnimg.cn/20200407124258417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200407124258417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<hr>
<h3 id="配置文件-settings-py"><a href="#配置文件-settings-py" class="headerlink" title="配置文件 settings.py"></a>配置文件 settings.py</h3><h4 id="1-BASE-DIR"><a href="#1-BASE-DIR" class="headerlink" title="1. BASE_DIR"></a>1. BASE_DIR</h4><pre class="highlight"><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line"><span class="number">1</span></span><br></pre>

<p>当前工程的根目录，Django会依此来定位工程内的相关文件，我们也可以使用该参数来构造文件路径。</p>
<h4 id="2-DEBUG-调试模式，创建工程后初始值为True，即默认工作在调试模式下。"><a href="#2-DEBUG-调试模式，创建工程后初始值为True，即默认工作在调试模式下。" class="headerlink" title="2. DEBUG 调试模式，创建工程后初始值为True，即默认工作在调试模式下。"></a>2. DEBUG 调试模式，创建工程后初始值为True，即默认工作在调试模式下。</h4><p>作用：</p>
<ul>
<li><p>修改代码文件，程序自动重启</p>
</li>
<li><p>Django程序出现异常时，向前端显示详细的错误追踪信息，例如</p>
<p><img src="https://img-blog.csdnimg.cn/20200407130311991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200407130311991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
<li><p>而非调试模式下，仅返回Server Error (500)</p>
</li>
</ul>
<pre class="highlight"><span class="line">注意：部署线上运行的Django不要运行在调式模式下，记得修改DEBUG&#x3D;False和ALLOW_HOSTS。</span><br></pre>

<h4 id="3-本地语言与时区"><a href="#3-本地语言与时区" class="headerlink" title="3. 本地语言与时区"></a>3. 本地语言与时区</h4><p>Django支持本地化处理，即显示语言与时区支持本地化。</p>
<p>本地化是将显示的语言、时间等使用本地的习惯，这里的本地化就是进行中国化，中国大陆地区使用简体中文，时区使用亚洲/上海时区，注意这里不使用北京时区表示。</p>
<p>初始化的工程默认语言和时区为英语和UTC标准时区</p>
<pre class="highlight"><span class="line"><span class="comment"># settings.py</span></span><br><span class="line"></span><br><span class="line">LANGUAGE_CODE = <span class="string">'en-us'</span>  <span class="comment"># 语言</span></span><br><span class="line">TIME_ZONE = <span class="string">'UTC'</span>  <span class="comment"># 时区# 时区</span></span><br></pre>

<p>将语言和时区修改为中国大陆信息</p>
<pre class="highlight"><span class="line">LANGUAGE_CODE = <span class="string">'zh-Hans'</span></span><br><span class="line">TIME_ZONE = <span class="string">'Asia/Shanghai'</span></span><br></pre>

<h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><p>项目中的CSS、图片、js都是静态文件。一般会将静态文件放到一个单独的目录中，以方便管理。在html页面中调用时，也需要指定静态文件的路径，Django中提供了一种解析的方式配置静态文件路径。静态文件可以放在项目根目录下，也可以放在应用的目录下，由于有些静态文件在项目中是通用的，所以推荐放在项目的根目录下，方便管理。</p>
<p>为了提供静态文件，需要配置两个参数：</p>
<ul>
<li><strong>STATICFILES_DIRS</strong>存放查找静态文件的目录</li>
<li><strong>STATIC_URL</strong>访问静态文件的<strong>URL</strong>前缀</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>1） 在项目根目录下创建static目录来保存静态文件。</p>
<p>2） 在bookmanager/settings.py中修改静态文件的两个参数为</p>
<pre class="highlight"><span class="line"><span class="comment"># settings.py</span></span><br><span class="line"></span><br><span class="line">STATIC_URL = <span class="string">'/static/'</span></span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR, <span class="string">'static'</span>),</span><br><span class="line">]</span><br></pre>

<p>3）此时在static添加的任何静态文件都可以使用网址 <strong>/static/文件在static</strong> 中的路径来访问了。</p>
<p>例如，我们向static目录中添加一个index.html文件，在浏览器中就可以使用 127.0.0.1:8000/static/index.html来访问。</p>
<p>或者我们在<strong>static</strong>目录中添加了一个子目录和文件book/detail.html，在浏览器中就可以使用127.0.0.1:8000/static/book/detail.html来访问。</p>
<h3 id="App应用配置"><a href="#App应用配置" class="headerlink" title="App应用配置"></a>App应用配置</h3><p>在每个应用目录中都包含了apps.py文件，用于保存该应用的相关信息。</p>
<p>在创建应用时，Django会向apps.py文件中写入一个该应用的配置类，如</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> AppConfig</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookConfig</span><span class="params">(AppConfig)</span>:</span></span><br><span class="line">    name = <span class="string">'book'</span></span><br></pre>

<p>我们将此类添加到工程 <strong>settings.py</strong> 中的 <strong>INSTALLED_APPS</strong> 列表中，表明注册安装具备此配置属性的应用。</p>
<ul>
<li><p>AppConfig.name属性表示这个配置类是加载到哪个应用的，每个配置类必须包含此属性，默认自动生成。</p>
</li>
<li><p>AppConfig.verbose_name属性用于设置该应用的直观可读的名字，此名字在Django提供的Admin管理站点中会显示，如</p>
<pre class="highlight"><span class="line"><span class="comment"># admin.py</span></span><br><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> AppConfig</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsersConfig</span><span class="params">(AppConfig)</span>:</span></span><br><span class="line">    name = <span class="string">'book'</span></span><br><span class="line">    verbose_name = <span class="string">'图书管理'</span></span><br></pre></li>
</ul>
]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 的 QuerySet结果集，两大特性 惰性查询，限制查询集</title>
    <url>/2020/03/19/Django%20%E7%9A%84%20QuerySet%E7%BB%93%E6%9E%9C%E9%9B%86%EF%BC%8C%E4%B8%A4%E5%A4%A7%E7%89%B9%E6%80%A7%20%E6%83%B0%E6%80%A7%E6%9F%A5%E8%AF%A2%EF%BC%8C%E9%99%90%E5%88%B6%E6%9F%A5%E8%AF%A2%E9%9B%86/</url>
    <content><![CDATA[<h3 id="查询集QuerySet"><a href="#查询集QuerySet" class="headerlink" title="查询集QuerySet"></a>查询集QuerySet</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h4><p>Django的ORM中存在查询集的概念。</p>
<p>查询集，也称查询结果集、<strong>QuerySet</strong>，表示从数据库中获取的对象集合。</p>
<p>当调用如下过滤器方法时，<strong>Django</strong> 会返回查询集（而不是简单的列表）：</p>
<ul>
<li>all()：返回所有数据。</li>
<li>filter()：返回满足条件的数据。</li>
<li>exclude()：返回满足条件之外的数据。</li>
<li>order_by()：对结果进行排序。</li>
</ul>
<p>对查询集可以再次调用过滤器进行过滤，如</p>
<pre class="highlight"><span class="line">books = BookInfo.objects.filter(readcount__gt=<span class="number">30</span>).order_by(<span class="string">'pub_date'</span>)</span><br><span class="line">books</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 雪山飞狐&gt;]&gt;</span><br><span class="line"><span class="number">1234</span></span><br></pre>

<p>也就意味着查询集可以含有零个、一个或多个过滤器。过滤器基于所给的参数限制查询的结果。</p>
<p><strong>从SQL的角度讲，查询集与select语句等价，过滤器像where、limit、order by子句。</strong></p>
<p>判断某一个查询集中是否有数据：</p>
<ul>
<li>exists()：判断查询集中是否有数据，如果有则返回True，没有则返回False。</li>
</ul>
<h4 id="2-两大特性"><a href="#2-两大特性" class="headerlink" title="2 两大特性"></a>2 两大特性</h4><h5 id="1-惰性执行"><a href="#1-惰性执行" class="headerlink" title="1. 惰性执行"></a>1. 惰性执行</h5><p>创建查询集不会访问数据库，直到调用数据时，才会访问数据库，调用数据的情况包括迭代、序列化、与if合用</p>
<p>例如，当执行如下语句时，并未进行数据库查询，只是创建了一个查询集books</p>
<pre class="highlight"><span class="line">books = BookInfo.objects.all()</span><br><span class="line"><span class="number">1</span></span><br></pre>

<p>继续执行遍历迭代操作后，才真正的进行了数据库的查询</p>
<pre class="highlight"><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> books:</span><br><span class="line">	print(book.name)</span><br><span class="line"><span class="number">12</span></span><br></pre>

<h5 id="2-缓存"><a href="#2-缓存" class="headerlink" title="2. 缓存"></a>2. 缓存</h5><p>使用同一个查询集，第一次使用时会发生数据库的查询，然后Django会把结果缓存下来，再次使用这个查询集时会使用缓存的数据，减少了数据库的查询次数。</p>
<ul>
<li><p>情况一：如下是两个查询集，无法重用缓存，每次查询都会与数据库进行一次交互，增加了数据库的负载。</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> book.models <span class="keyword">import</span> BookInfo</span><br><span class="line"></span><br><span class="line">[book.id <span class="keyword">for</span> book <span class="keyword">in</span> BookInfo.objects.all()]</span><br><span class="line"></span><br><span class="line">[book.id <span class="keyword">for</span> book <span class="keyword">in</span> BookInfo.objects.all()]</span><br><span class="line"><span class="number">12345</span></span><br></pre>

</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200409084809401.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200409084809401.png" class="lozad post-image"><br><img src="https://img-blog.csdnimg.cn/2020040908481710.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/2020040908481710.png" class="lozad post-image"></p>
<ul>
<li><p>情况二：经过存储后，可以重用查询集，第二次使用缓存中的数据。</p>
<pre class="highlight"><span class="line">books=BookInfo.objects.all()</span><br><span class="line"></span><br><span class="line">[book.id <span class="keyword">for</span> book <span class="keyword">in</span> books]</span><br><span class="line"></span><br><span class="line">[book.id <span class="keyword">for</span> book <span class="keyword">in</span> books]</span><br><span class="line"><span class="number">12345</span></span><br></pre>

</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200409084832333.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200409084832333.png" class="lozad post-image"><br><img src="https://img-blog.csdnimg.cn/20200409084838481.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200409084838481.png" class="lozad post-image"></p>
<h5 id="3-限制查询集"><a href="#3-限制查询集" class="headerlink" title="3 限制查询集"></a>3 限制查询集</h5><p>可以对查询集进行取下标或切片操作，等同于sql中的limit和offset子句。</p>
<pre class="highlight"><span class="line">注意：不支持负数索引。</span><br></pre>

<p>对查询集进行切片后返回一个新的查询集，不会立即执行查询。</p>
<p>如果获取一个对象，直接使用[0]，等同于[0:1].get()，但是如果没有数据，[0]引发IndexError异常，[0:1].get()如果没有数据引发DoesNotExist异常。</p>
<ul>
<li><p>示例：获取第1、2项，运行查看。</p>
<pre class="highlight"><span class="line">books = BookInfo.objects.all()[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">books</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 天龙八部&gt;]&gt;</span><br></pre>

</li>
</ul>
]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 状态保持 Cookie 和 Session</title>
    <url>/2020/06/12/Django%20%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8C%81%20Cookie%20%E5%92%8C%20Session/</url>
    <content><![CDATA[<h3 id="状态保持"><a href="#状态保持" class="headerlink" title="状态保持"></a>状态保持</h3><ul>
<li><p>浏览器请求服务器是无状态的。</p>
</li>
<li><p>无状态：指一次用户请求时，浏览器、服务器无法知道之前这个用户做过什么，每次请求都是一次新的请求。</p>
</li>
<li><p>无状态原因：浏览器与服务器是使用Socket套接字进行通信的，服务器将请求结果返回给浏览器之后，会关闭当前的Socket连接，而且服务器也会在处理页面完毕之后销毁页面对象。</p>
</li>
<li><p>有时需要保持下来用户浏览的状态，比如用户是否登录过，浏览过哪些商品等</p>
</li>
<li><p>实现状态保持主要有两种方式：</p>
<p>在客户端存储信息使用<code>Cookie</code><br>在服务器端存储信息使用<code>Session</code></p>
</li>
</ul>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。Cookie最早是网景公司的前雇员Lou Montulli在1993年3月的发明。Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等。服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookies最典型记住用户名。</p>
<p>Cookie是存储在浏览器中的一段纯文本信息，建议不要存储敏感信息如密码，因为电脑上的浏览器可能被其它人使用。</p>
<h4 id="Cookie的特点"><a href="#Cookie的特点" class="headerlink" title="Cookie的特点"></a>Cookie的特点</h4><ul>
<li>Cookie以键值对的格式进行信息的存储。</li>
<li>Cookie基于域名安全，不同域名的Cookie是不能互相访问的，如访问itcast.cn时向浏览器中写了Cookie信息，使用同一浏览器访问baidu.com时，无法访问到itcast.cn写的Cookie信息。</li>
<li>当浏览器请求某网站时，会将浏览器存储的跟网站相关的所有Cookie信息提交给网站服务器。</li>
</ul>
<h4 id="1-设置Cookie"><a href="#1-设置Cookie" class="headerlink" title="1 设置Cookie"></a>1 设置Cookie</h4><p>可以通过<code>HttpResponse</code>对象中的<code>set_cookie</code>方法来设置cookie。</p>
<pre class="highlight"><span class="line">HttpResponse.set_cookie(cookie名, value=cookie值, max_age=cookie有效期)</span><br><span class="line"><span class="number">1</span></span><br></pre>

<ul>
<li><code>max_age</code>单位为秒，默认为<code>None</code> 。如果是临时cookie，可将max_age设置为None。</li>
</ul>
<p>示例：</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cookie</span><span class="params">(request)</span>:</span></span><br><span class="line">    response = HttpResponse(<span class="string">'ok'</span>)</span><br><span class="line">    response.set_cookie(<span class="string">'itcast1'</span>, <span class="string">'python1'</span>)  <span class="comment"># 临时cookie</span></span><br><span class="line">    response.set_cookie(<span class="string">'itcast2'</span>, <span class="string">'python2'</span>, max_age=<span class="number">3600</span>)  <span class="comment"># 有效期一小时</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"><span class="number">12345</span></span><br></pre>

<h4 id="2-读取Cookie"><a href="#2-读取Cookie" class="headerlink" title="2 读取Cookie"></a>2 读取Cookie</h4><p>可以通过 <code>HttpResponse</code> 对象的 <code>COOKIES</code> 属性来读取本次请求携带的 <code>cookie</code> 值。<code>request.COOKIES为字典类型</code>。</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cookie</span><span class="params">(request)</span>:</span></span><br><span class="line">    cookie1 = request.COOKIES.get(<span class="string">'itcast1'</span>)</span><br><span class="line">    print(cookie1)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'OK'</span>)</span><br><span class="line"><span class="number">1234</span></span><br></pre>

<h4 id="3-删除Cookie"><a href="#3-删除Cookie" class="headerlink" title="3 删除Cookie"></a>3 删除Cookie</h4><p>可以通过 <code>HttpResponse</code> 对象中的delete_cookie方法来删除。</p>
<pre class="highlight"><span class="line">response.delete_cookie(<span class="string">'itcast2'</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre>



<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><h4 id="1-启用Session"><a href="#1-启用Session" class="headerlink" title="1 启用Session"></a>1 启用Session</h4><p>Django项目默认启用Session。</p>
<p>可以在settings.py文件中查看，如图所示</p>
<p><img src="https://img-blog.csdnimg.cn/20200424201023791.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200424201023791.png" class="lozad post-image"><br>如需禁用session，将上图中的session中间件注释掉即可。</p>
<h4 id="2-存储方式"><a href="#2-存储方式" class="headerlink" title="2 存储方式"></a>2 存储方式</h4><p>在settings.py文件中，可以设置session数据的存储方式，可以保存在数据库、本地缓存等。</p>
<h5 id="2-1-数据库"><a href="#2-1-数据库" class="headerlink" title="2.1 数据库"></a>2.1 数据库</h5><p>存储在数据库中，如下设置可以写，也可以不写，这是<strong>默认存储方式</strong>。</p>
<pre class="highlight"><span class="line">SESSION_ENGINE=<span class="string">'django.contrib.sessions.backends.db'</span></span><br><span class="line"><span class="number">1</span></span><br></pre>

<p>如果存储在数据库中，需要在项INSTALLED_APPS中安装Session应用。<br><img src="https://img-blog.csdnimg.cn/20200424201114649.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200424201114649.png" class="lozad post-image"></p>
<p>数据库中的表如图所示</p>
<p><img src="https://img-blog.csdnimg.cn/20200424201129576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200424201129576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>表结构如下<br><img src="https://img-blog.csdnimg.cn/20200424201145337.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200424201145337.png" class="lozad post-image"><br>由表结构可知，操作Session包括三个数据：键，值，过期时间。</p>
<h5 id="2-2-本地缓存"><a href="#2-2-本地缓存" class="headerlink" title="2.2 本地缓存"></a>2.2 本地缓存</h5><p>存储在本机内存中，如果丢失则不能找回，比数据库的方式读写更快。</p>
<pre class="highlight"><span class="line">SESSION_ENGINE=<span class="string">'django.contrib.sessions.backends.cache'</span></span><br><span class="line"><span class="number">1</span></span><br></pre>

<h5 id="2-3-混合存储"><a href="#2-3-混合存储" class="headerlink" title="2.3 混合存储"></a>2.3 混合存储</h5><p>优先从本机内存中存取，如果没有则从数据库中存取。</p>
<pre class="highlight"><span class="line">SESSION_ENGINE=<span class="string">'django.contrib.sessions.backends.cached_db'</span></span><br><span class="line"><span class="number">1</span></span><br></pre>

<h5 id="2-4-Redis"><a href="#2-4-Redis" class="headerlink" title="2.4 Redis"></a>2.4 Redis</h5><p>在redis中保存session，需要引入第三方扩展，我们可以使用django-redis来解决。</p>
<ul>
<li><p>1） 安装扩展</p>
<pre class="highlight"><span class="line">pip install django-redis</span><br><span class="line"><span class="number">1</span></span><br></pre>
</li>
<li><p>2）配置</p>
<p>在settings.py文件中做如下设置</p>
</li>
</ul>
<pre class="highlight"><span class="line">CACHES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django_redis.cache.RedisCache'</span>,</span><br><span class="line">        <span class="string">'LOCATION'</span>: <span class="string">'redis://127.0.0.1:6379/1'</span>,</span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">            <span class="string">'CLIENT_CLASS'</span>: <span class="string">'django_redis.client.DefaultClient'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SESSION_ENGINE = <span class="string">'django.contrib.sessions.backends.cache'</span></span><br><span class="line">SESSION_CACHE_ALIAS = <span class="string">'default'</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre>

<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>如果redis的ip地址不是本地回环127.0.0.1，而是其他地址，访问Django时，可能出现Redis连接错误，如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200424201314867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200424201314867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<p>解决方法：</p>
<p>修改redis的配置文件，添加特定ip地址。</p>
<p>打开redis的配置文件</p>
<pre class="highlight"><span class="line">sudo vim /etc/redis/redis.conf</span><br><span class="line"><span class="number">1</span></span><br></pre>

<p>在如下配置项进行修改（如要添加10.211.55.5地址）</p>
<p><img src="https://img-blog.csdnimg.cn/20200424201341157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200424201341157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<p>重新启动redis服务</p>
<pre class="highlight"><span class="line">sudo service redis-server restart</span><br><span class="line"><span class="number">1</span></span><br></pre>

<h4 id="3-Session操作"><a href="#3-Session操作" class="headerlink" title="3 Session操作"></a>3 Session操作</h4><p>通过HttpRequest对象的session属性进行会话的读写操作。</p>
<ul>
<li>1） 以键值对的格式写session。</li>
</ul>
<pre class="highlight"><span class="line">request.session[<span class="string">'键'</span>]=值</span><br><span class="line"><span class="number">1</span></span><br></pre>

<ul>
<li>2）根据键读取值。</li>
</ul>
<pre class="highlight"><span class="line">request.session.get(<span class="string">'键'</span>,默认值)</span><br><span class="line"><span class="number">1</span></span><br></pre>

<ul>
<li>3）清除所有session，在存储中删除值部分。</li>
</ul>
<pre class="highlight"><span class="line">request.session.clear()</span><br><span class="line"><span class="number">1</span></span><br></pre>

<ul>
<li>4）清除session数据，在存储中删除session的整条数据。</li>
</ul>
<pre class="highlight"><span class="line">request.session.flush()</span><br><span class="line"><span class="number">1</span></span><br></pre>

<ul>
<li>5）删除session中的指定键及值，在存储中只删除某个键及对应的值。</li>
</ul>
<pre class="highlight"><span class="line"><span class="keyword">del</span> request.session[<span class="string">'键'</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre>

<ul>
<li>6）设置session的有效期</li>
</ul>
<pre class="highlight"><span class="line">request.session.set_expiry(value)</span><br><span class="line"><span class="number">1</span></span><br></pre>

<ul>
<li>如果value是一个整数，session将在value秒没有活动后过期。</li>
<li>如果value为0，那么用户session的Cookie将在用户的浏览器关闭时过期。</li>
<li>如果value为None，那么session有效期将采用系统默认值，<code>默认为两周</code>，可以通过在settings.py中设置<code>SESSION_COOKIE_AGE</code>来设置全局默认值。</li>
</ul>
]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 视图介绍</title>
    <url>/2020/05/26/Django%20%E8%A7%86%E5%9B%BE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="视图介绍和项目准备"><a href="#视图介绍和项目准备" class="headerlink" title="视图介绍和项目准备"></a>视图介绍和项目准备</h3><p><img src="https://img-blog.csdnimg.cn/20200424131358536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200424131358536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>视图介绍</p>
<ul>
<li>视图就是应用中views.py文件中的函数</li>
<li>视图的第一个参数必须为HttpRequest对象，还可能包含下参数如<br>通过正则表达式组获取的位置参数<br>通过正则表达式组获得的关键字参数</li>
<li>视图必须返回一个HttpResponse对象或子对象作为响应<br>子对象： JsonResponse HttpResponseRedirect</li>
<li>视图负责接受Web请求HttpRequest，进行逻辑处理，返回Web响应HttpResponse给请求者<br>响应内容可以是HTML内容，404错误，重定向，json数据…</li>
<li>视图处理过程如下图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200424131510587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200424131510587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<p>使用视图时需要进行两步操作，两步操作不分先后</p>
<ul>
<li>配置URLconf</li>
<li>在应用/views.py中定义视图</li>
</ul>
<p>详细操作：<a href="https://blog.csdn.net/weixin_44685869/article/details/105353646" target="_blank" rel="noopener">视图和URL: https://blog.csdn.net/weixin_44685869/article/details/105353646</a></p>
<h3 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h3><p>项目准备整体流程：<a href="https://blog.csdn.net/weixin_44685869/article/details/105362452" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44685869/article/details/105362452</a></p>
]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 聚合函数 和 排序函数，关联查询</title>
    <url>/2020/03/13/Django%20%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%20%E5%92%8C%20%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0%EF%BC%8C%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>一下介绍的数据和字段 都在此文中进行的 创建和添加 <a href="http://localhost:4000/2020/02/16/Django%20%E6%A8%A1%E5%9E%8B%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E7%89%88%E6%9C%AC/" target="_blank" rel="noopener">http://localhost:4000/2020/02/16/Django%20%E6%A8%A1%E5%9E%8B%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E7%89%88%E6%9C%AC/</a></p>
<h3 id="1-聚合函数"><a href="#1-聚合函数" class="headerlink" title="1. 聚合函数"></a>1. 聚合函数</h3><p>使用aggregate()过滤器调用聚合函数。聚合函数包括：Avg平均，Count数量，Max最大，Min最小，Sum求和，被定义在django.db.models中。</p>
<ul>
<li><p>例：查询图书的总阅读量。</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Sum</span><br><span class="line">BookInfo.objects.aggregate(Sum(<span class="string">'readcount'</span>))</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">'readcount__sum'</span>: <span class="number">126</span>&#125;</span><br></pre>

</li>
</ul>
<pre class="highlight"><span class="line">注意aggregate的返回值是一个字典类型，格式如下：</span><br><span class="line">&#123;&#39;属性名__聚合类小写&#39;:值&#125;</span><br><span class="line">1</span><br></pre>

<p><strong>如:{‘readcount__sum’: 126}</strong></p>
<p>使用count 时一般不使用aggregate()过滤器。</p>
<ul>
<li><p>例：查询图书总数。</p>
<pre class="highlight"><span class="line">BookInfo.objects.count()</span><br></pre>

</li>
</ul>
<p>注意count函数的返回值是一个数字。</p>
<h3 id="2-排序"><a href="#2-排序" class="headerlink" title="2. 排序"></a>2. 排序</h3><p>使用order_by对结果进行排序</p>
<pre class="highlight"><span class="line"><span class="comment"># 默认升序</span></span><br><span class="line"></span><br><span class="line">BookInfo.objects.all().order_by(<span class="string">'readcount'</span>)</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 笑傲江湖&gt;, &lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 雪山飞狐&gt;]&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 降序</span></span><br><span class="line"></span><br><span class="line">BookInfo.objects.all().order_by(<span class="string">'-readcount'</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 雪山飞狐&gt;, &lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 笑傲江湖&gt;, &lt;BookInfo: 射雕英雄传&gt;]&gt;</span><br></pre>



<hr>
<h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><p>查询书籍为1的所有人物信息<br>查询人物为1的书籍信息</p>
<ul>
<li><p>由一到多的访问语法：</p>
<p>一对应的模型类对象.多对应的模型类名小写_set 例：</p>
<pre class="highlight"><span class="line">book = BookInfo.objects.get(id=<span class="number">1</span>)</span><br><span class="line">book.peopleinfo_set.all()</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&lt;PeopleInfo: 郭靖&gt;, &lt;PeopleInfo: 黄蓉&gt;, &lt;PeopleInfo: 黄药师&gt;, &lt;PeopleInfo: 欧阳锋&gt;, &lt;PeopleInfo: 梅超风&gt;]&gt;</span><br></pre>
</li>
<li><p>由多到一的访问语法:</p>
<p>多对应的模型类对象.多对应的模型类中的关系类属性名 例：</p>
<pre class="highlight"><span class="line">person = PeopleInfo.objects.get(id=<span class="number">1</span>)</span><br><span class="line">person.book</span><br><span class="line"></span><br><span class="line">&lt;BookInfo: 射雕英雄传&gt;</span><br></pre>

</li>
</ul>
<h4 id="访问一对应的模型类关联对象的id语法"><a href="#访问一对应的模型类关联对象的id语法" class="headerlink" title="访问一对应的模型类关联对象的id语法:"></a>访问一对应的模型类关联对象的id语法:</h4><p>多对应的模型类对象.关联类属性_id</p>
<ul>
<li><p>例：</p>
<pre class="highlight"><span class="line">person = PeopleInfo.objects.get(id=<span class="number">1</span>)</span><br><span class="line">person.book_id</span><br></pre>

</li>
</ul>
<h4 id="关联过滤查询"><a href="#关联过滤查询" class="headerlink" title="关联过滤查询"></a>关联过滤查询</h4><p>由多模型类条件查询一模型类数据:</p>
<p>语法如下：</p>
<p><strong>关联模型类名小写<strong>属性名</strong>条件运算符=值</strong></p>
<pre class="highlight"><span class="line">注意：如果没有&quot;__运算符&quot;部分，表示等于。</span><br></pre>

<p>查询图书，要求图书人物为”郭靖”<br>查询图书，要求图书中人物的描述包含”八”</p>
<ul>
<li><p>例：查询图书，要求图书人物为”郭靖”</p>
<pre class="highlight"><span class="line">book = BookInfo.objects.filter(peopleinfo__name=<span class="string">'郭靖'</span>)</span><br><span class="line">book</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;]&gt;</span><br></pre>
</li>
<li><p>查询图书，要求图书中人物的描述包含”八”</p>
<pre class="highlight"><span class="line">book = BookInfo.objects.filter(peopleinfo__description__contains=<span class="string">'八'</span>)</span><br><span class="line">book</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 天龙八部&gt;]&gt;</span><br></pre>

</li>
</ul>
<h5 id="由一模型类条件查询多模型类数据"><a href="#由一模型类条件查询多模型类数据" class="headerlink" title="由一模型类条件查询多模型类数据:"></a>由一模型类条件查询多模型类数据:</h5><p>语法如下：</p>
<p>一模型类关联属性名<strong>一模型类属性名</strong>条件运算符=值</p>
<pre class="highlight"><span class="line">注意：如果没有&quot;__运算符&quot;部分，表示等于。</span><br></pre>

<p>查询书名为“天龙八部”的所有人物<br>查询图书阅读量大于30的所有人物</p>
<ul>
<li><p>例：查询书名为“天龙八部”的所有人物。</p>
<pre class="highlight"><span class="line">people = PeopleInfo.objects.filter(book__name=<span class="string">'天龙八部'</span>)</span><br><span class="line">people</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&lt;PeopleInfo: 乔峰&gt;, &lt;PeopleInfo: 段誉&gt;, &lt;PeopleInfo: 虚竹&gt;, &lt;PeopleInfo: 王语嫣&gt;]&gt;</span><br></pre>
</li>
<li><p>查询图书阅读量大于30的所有人物</p>
<pre class="highlight"><span class="line">people = PeopleInfo.objects.filter(book__readcount__gt=<span class="number">30</span>)</span><br><span class="line">people</span><br><span class="line"></span><br><span class="line">&lt;QuerySet [&lt;PeopleInfo: 乔峰&gt;, &lt;PeopleInfo: 段誉&gt;, &lt;PeopleInfo: 虚竹&gt;, &lt;PeopleInfo: 王语嫣&gt;</span><br></pre>

</li>
</ul>
]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 高级查询 F Q查询</title>
    <url>/2020/03/06/Django%20%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2%20F%20Q%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h3 id="F对象"><a href="#F对象" class="headerlink" title="F对象"></a>F对象</h3><p>之前的查询都是对象的属性与常量值比较，两个属性怎么比较呢？ 答：使用F对象，被定义在django.db.models中。</p>
<p>语法如下：</p>
<pre class="highlight"><span class="line">F(属性名)</span><br><span class="line"><span class="number">1</span></span><br></pre>

<ul>
<li><p>例：查询阅读量大于等于评论量的图书。</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line"></span><br><span class="line">BookInfo.objects.filter(readcount__gt=F(<span class="string">'commentcount'</span>))</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 雪山飞狐&gt;]&gt;</span><br><span class="line"><span class="number">1234</span></span><br></pre>

</li>
</ul>
<p>可以在F对象上使用算数运算。</p>
<ul>
<li><p>例：查询阅读量大于2倍评论量的图书。</p>
<pre class="highlight"><span class="line">BookInfo.objects.filter(readcount__gt=F(<span class="string">'commentcount'</span>)*<span class="number">2</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 雪山飞狐&gt;]&gt;</span><br><span class="line"><span class="number">12</span></span><br></pre>



</li>
</ul>
<h3 id="Q对象"><a href="#Q对象" class="headerlink" title="Q对象"></a>Q对象</h3><p>多个过滤器逐个调用表示逻辑与关系，同sql语句中where部分的and关键字。</p>
<ul>
<li><p>例：查询阅读量大于20，并且编号小于3的图书。</p>
<pre class="highlight"><span class="line">BookInfo.objects.filter(readcount__gt=<span class="number">20</span>,id__lt=<span class="number">3</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 天龙八部&gt;]&gt;</span><br><span class="line"><span class="number">12</span></span><br></pre>

<p>或者</p>
<pre class="highlight"><span class="line">BookInfo.objects.filter(readcount__gt=<span class="number">20</span>).filter(id__lt=<span class="number">3</span>)</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 天龙八部&gt;]&gt;</span><br><span class="line"><span class="number">12</span></span><br></pre>

</li>
</ul>
<p>如果需要实现逻辑或or 的查询，需要使用Q()对象结合 | 运算符，Q对象被义在django.db.models中。</p>
<p>语法如下：</p>
<pre class="highlight"><span class="line">Q(属性名__运算符=值)</span><br><span class="line"><span class="number">1</span></span><br></pre>

<ul>
<li><p>例：查询阅读量大于20的图书，改写为Q对象如下。</p>
<pre class="highlight"><span class="line">BookInfo.objects.filter(Q(readcount__gt=<span class="number">20</span>))</span><br><span class="line"><span class="number">1</span></span><br></pre>

</li>
</ul>
<p>Q对象可以使用&amp;、|连接，&amp;表示逻辑与，|表示逻辑或。</p>
<ul>
<li><p>例：查询阅读量大于20，或编号小于3的图书，只能使用Q对象实现</p>
<pre class="highlight"><span class="line">BookInfo.objects.filter(Q(readcount__gt=<span class="number">20</span>)|Q(id__lt=<span class="number">3</span>))</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 雪山飞狐&gt;]&gt;</span><br><span class="line"><span class="number">12</span></span><br></pre>

</li>
</ul>
<p>Q对象前可以使用~操作符，表示非not。</p>
<ul>
<li><p>例：查询编号不等于3的图书。</p>
<pre class="highlight"><span class="line">BookInfo.objects.filter(~Q(id=<span class="number">3</span>))</span><br><span class="line">&lt;QuerySet [&lt;BookInfo: 射雕英雄传&gt;, &lt;BookInfo: 天龙八部&gt;, &lt;BookInfo: 雪山飞狐&gt;]&gt;</span><br></pre>

</li>
</ul>
]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django中间件</title>
    <url>/2018/12/04/Django%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h2><h6 id="中间件就是在目标和结果之间进行的额外处理过程，在Django中就是request和response之间进行的处理，相对来说实现起来比较简单，但是要注意它是对全局有效的，可以在全局范围内改变输入和输出结果，因此需要谨慎使用，否则不仅会造成难以定位的错误，而且可能会影响整体性能。"><a href="#中间件就是在目标和结果之间进行的额外处理过程，在Django中就是request和response之间进行的处理，相对来说实现起来比较简单，但是要注意它是对全局有效的，可以在全局范围内改变输入和输出结果，因此需要谨慎使用，否则不仅会造成难以定位的错误，而且可能会影响整体性能。" class="headerlink" title="中间件就是在目标和结果之间进行的额外处理过程，在Django中就是request和response之间进行的处理，相对来说实现起来比较简单，但是要注意它是对全局有效的，可以在全局范围内改变输入和输出结果，因此需要谨慎使用，否则不仅会造成难以定位的错误，而且可能会影响整体性能。"></a>中间件就是在目标和结果之间进行的额外处理过程，在Django中就是request和response之间进行的处理，相对来说实现起来比较简单，但是要注意它是对全局有效的，可以在全局范围内改变输入和输出结果，因此需要谨慎使用，否则不仅会造成难以定位的错误，而且可能会影响整体性能。</h6><hr>
<h2 id="中间件有什么用？"><a href="#中间件有什么用？" class="headerlink" title="中间件有什么用？"></a>中间件有什么用？</h2><h6 id="如果想要修改HttpRequest或者HttpResponse，就可以通过中间件来实现。"><a href="#如果想要修改HttpRequest或者HttpResponse，就可以通过中间件来实现。" class="headerlink" title="如果想要修改HttpRequest或者HttpResponse，就可以通过中间件来实现。"></a>如果想要修改HttpRequest或者HttpResponse，就可以通过中间件来实现。</h6><ul>
<li><p>登陆认证：在中间件中加入登陆认证，所有请求就自动拥有登陆认证，如果需要放开部分路由，只需要特殊处理就可以了。</p>
</li>
<li><p>流量统计：可以针对一些渲染页面统计访问流量。</p>
</li>
<li><p>恶意请求拦截：统计IP请求次数，可以进行频次限制或者封禁IP。</p>
</li>
</ul>
<h6 id="在Django中自定义中间件-在settings-py中找到MIDDLEWARE项，把添加的中间件配置到这里就行了。"><a href="#在Django中自定义中间件-在settings-py中找到MIDDLEWARE项，把添加的中间件配置到这里就行了。" class="headerlink" title="在Django中自定义中间件:在settings.py中找到MIDDLEWARE项，把添加的中间件配置到这里就行了。"></a>在Django中自定义中间件:在settings.py中找到MIDDLEWARE项，把添加的中间件配置到这里就行了。</h6><h6 id="例如我在myapp文件夹下-该文件夹与Django文件夹同级-有一个views-py文件，在views-py中有一个叫做MyMiddleware的中间件，那么配置的时候只要在MIDDLEWARE列表中添加一条"><a href="#例如我在myapp文件夹下-该文件夹与Django文件夹同级-有一个views-py文件，在views-py中有一个叫做MyMiddleware的中间件，那么配置的时候只要在MIDDLEWARE列表中添加一条" class="headerlink" title="例如我在myapp文件夹下(该文件夹与Django文件夹同级)有一个views.py文件，在views.py中有一个叫做MyMiddleware的中间件，那么配置的时候只要在MIDDLEWARE列表中添加一条:"></a>例如我在myapp文件夹下(该文件夹与Django文件夹同级)有一个views.py文件，在views.py中有一个叫做MyMiddleware的中间件，那么配置的时候只要在MIDDLEWARE列表中添加一条:</h6><pre class="highlight"><span class="line"><span class="string">'myapp.views.MyMiddleware'</span></span><br></pre>

<hr>
<h4 id="每个中间件可以包含五个方法"><a href="#每个中间件可以包含五个方法" class="headerlink" title="每个中间件可以包含五个方法:"></a>每个中间件可以包含五个方法:</h4><pre class="highlight"><span class="line">process_request(self,request)</span><br><span class="line">process_view(self, request, callback, callback_args, callback_kwargs)</span><br><span class="line">process_template_response(self,request,response)</span><br><span class="line">process_exception(self, request, exception)</span><br><span class="line">process_response(self, request, response)</span><br></pre>

<hr>
<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程:"></a>执行流程:</h2><ol>
<li>请求到达中间件后先依次执行每个中间件的process_request函数</li>
<li>然后再依次执行每个中间件的process_view函数，找到我们的视图函数</li>
<li>执行视图函数处理请求数据</li>
<li>如果在上面的过程中出现异常，则依次反方向执行每个中间件的process_exception函数</li>
<li>如果请求包含模板渲染，则依次反方向执行每个中间件的process_template_response函数</li>
<li>最后依次反方向执行每个中间件的process_response函数</li>
</ol>
<hr>
<h6 id="以上这些执行函数将返回None或者HttpResponse对象，如果返回None，则交给下一个中间件的对应函数处理；如果返回HttpResponse对象，则将其返回给用户。"><a href="#以上这些执行函数将返回None或者HttpResponse对象，如果返回None，则交给下一个中间件的对应函数处理；如果返回HttpResponse对象，则将其返回给用户。" class="headerlink" title="以上这些执行函数将返回None或者HttpResponse对象，如果返回None，则交给下一个中间件的对应函数处理；如果返回HttpResponse对象，则将其返回给用户。"></a>以上这些执行函数将返回None或者HttpResponse对象，如果返回None，则交给下一个中间件的对应函数处理；如果返回HttpResponse对象，则将其返回给用户。</h6><h3 id="应用"><a href="#应用" class="headerlink" title="应用:"></a>应用:</h3><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMiddleware</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        print(<span class="string">'过滤中间件'</span>)</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self, request, view_func, view_args, view_kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self, request, exception)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self, request, response)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre>

<hr>
<h2 id="每次请求时，都会打印一行”过滤中间件”"><a href="#每次请求时，都会打印一行”过滤中间件”" class="headerlink" title="每次请求时，都会打印一行”过滤中间件”"></a>每次请求时，都会打印一行”过滤中间件”</h2>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django站点管理- Admin管理员，视图和URL</title>
    <url>/2020/01/27/Django%E7%AB%99%E7%82%B9%E7%AE%A1%E7%90%86-%20Admin%E7%AE%A1%E7%90%86%E5%91%98%EF%BC%8C%E8%A7%86%E5%9B%BE%E5%92%8CURL/</url>
    <content><![CDATA[<h4 id="站点管理"><a href="#站点管理" class="headerlink" title="站点管理"></a>站点管理</h4><ul>
<li><p>站点: 分为内容发布和公共访问两部分</p>
</li>
<li><p>内容发布的部分由网站的管理员负责查看、添加、修改、删除数据</p>
</li>
<li><p>Django能够根据定义的模型类自动地生成管理模块</p>
</li>
<li><p>使用Django的管理模块, 需要按照如下步骤操作 :</p>
<p>1.管理界面本地化</p>
<p>2.创建管理员</p>
<p>3.注册模型类</p>
<p>4.发布内容到数据库</p>
</li>
</ul>
<h5 id="1-管理界面本地化"><a href="#1-管理界面本地化" class="headerlink" title="1.管理界面本地化"></a>1.管理界面本地化</h5><ul>
<li><p>本地化是将显示的语言、时间等使用本地的习惯，这里的本地化就是进行中国化.</p>
</li>
<li><p>中国大陆地区使用简体中文, 时区使用亚洲/上海时区, 注意这里不使用北京时区.</p>
</li>
<li><p>本地化前：</p>
<p><img src="https://img-blog.csdnimg.cn/20200406224641444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200406224641444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
<li><p>本地化后：</p>
<p><img src="https://img-blog.csdnimg.cn/20200406224707756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200406224707756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
</ul>
<h5 id="2-创建管理员"><a href="#2-创建管理员" class="headerlink" title="2.创建管理员"></a>2.创建管理员</h5><ul>
<li><p>创建管理员的命令 :</p>
<pre class="highlight"><span class="line">python manage.py createsuperuser</span><br><span class="line"><span class="number">1</span></span><br></pre>
</li>
<li><p>按提示输入用户名、邮箱、密码</p>
<p><img src="https://img-blog.csdnimg.cn/20200406224757508.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200406224757508.png" class="lozad post-image"></p>
</li>
<li><p>重置密码</p>
<pre class="highlight"><span class="line">python manager.py changepassword 用户名</span><br><span class="line"><span class="number">1</span></span><br></pre>
</li>
<li><p>登陆站点 :<a href="http://127.0.0.1:8000/admin" target="_blank" rel="noopener">http://127.0.0.1:8000/admin</a></p>
<p><strong>需要服务器是启动状态</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200406224914877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200406224914877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
<li><p>登陆站点成功</p>
<p>站点界面中没有书籍和人物管理入口,因为没有注册模型类</p>
<p><img src="https://img-blog.csdnimg.cn/20200406224942608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200406224942608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
</ul>
<h4 id="3-注册模型类"><a href="#3-注册模型类" class="headerlink" title="3.注册模型类"></a>3.注册模型类</h4><ul>
<li><p>在应用的admin.py文件中注册模型类</p>
<p>需要导入模型模块 :from book.models import BookInfo,PeopleInfo</p>
<p><img src="https://img-blog.csdnimg.cn/20200406225017278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200406225017278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
<li><p>注册模型后</p>
<p><img src="https://img-blog.csdnimg.cn/20200406225034809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200406225034809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
</ul>
<pre class="highlight"><span class="line">注册模型成功后, 就可以在站点管理界面方便快速的管理数据.</span><br></pre>

<h4 id="4-发布内容到数据库"><a href="#4-发布内容到数据库" class="headerlink" title="4.发布内容到数据库"></a>4.发布内容到数据库</h4><p><img src="https://img-blog.csdnimg.cn/2020040623315227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/2020040623315227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<ul>
<li><p>发布内容后，优化模型类展示</p>
</li>
<li><pre><code class="python"><span class="comment"># 准备书籍列表信息的模型类</span>
<span class="class"><span class="keyword">class</span> <span class="title">BookInfo</span><span class="params">(models.Model)</span>:</span>
    <span class="comment"># 创建字段，字段类型...</span>
    name = models.CharField(max_length=<span class="number">10</span>)

    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>
        <span class="string">"""将模型类以字符串的方式输出"""</span>
        <span class="keyword">return</span> self.name
<span class="number">12345678</span>
<pre class="highlight"><span class="line"></span><br><span class="line">![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20200406233447922.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 视图 和 URL</span><br><span class="line"></span><br><span class="line">- 站点管理页面做好了, 接下来就要做公共访问的页面了.</span><br><span class="line">- 对于Django的设计框架MVT.</span><br><span class="line"></span><br><span class="line">1. 用户在URL中请求的是视图.</span><br><span class="line">2. 视图接收请求后进行处理.</span><br><span class="line">3. 并将处理的结果返回给请求者.</span><br><span class="line"></span><br><span class="line">- 使用视图时需要进行两步操作</span><br><span class="line"></span><br><span class="line">  1.定义视图</span><br><span class="line"></span><br><span class="line">  2.配置URLconf</span><br><span class="line"></span><br><span class="line">#### 1. 定义视图</span><br><span class="line"></span><br><span class="line">- 视图就是一个Python函数，被定义在应用的views.py中.</span><br><span class="line"></span><br><span class="line">- 视图的第一个参数是HttpRequest类型的对象reqeust，包含了所有请求信息.</span><br><span class="line"></span><br><span class="line">- 视图必须返回HttpResponse对象，包含返回给请求者的响应信息.</span><br><span class="line"></span><br><span class="line">- 需要导入HttpResponse模块 :from django.http import HttpResponse</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 定义视图函数 : 响应字符串OK!给客户端 ![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20200406233824628.png?x-oss-process&#x3D;image&#x2F;watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ&#x3D;&#x3D;,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">思考 : 如何才能让请求找到视图?</span><br><span class="line">1</span><br></pre>
</code></pre>
</li>
</ul>
<h4 id="2-配置URLconf"><a href="#2-配置URLconf" class="headerlink" title="2. 配置URLconf"></a>2. 配置URLconf</h4><ul>
<li>查找视图的过程 :</li>
</ul>
<ol>
<li>请求者在浏览器地址栏中输入URL, 请求到网站.</li>
<li>网站获取URL信息.</li>
<li>然后与编写好的URLconf逐条匹配.</li>
<li>如果匹配成功则调用对应的视图.</li>
<li>如果所有的URLconf都没有匹配成功.则返回404错误.</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200406234014455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200406234014455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<ul>
<li><code>URLconf</code>入口<br><img src="https://img-blog.csdnimg.cn/20200406234041717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200406234041717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></li>
<li>需要两步完成URLconf配置</li>
</ul>
<ol>
<li>在项目中定义URLconf</li>
<li>在应用中定义URLconf</li>
</ol>
<ul>
<li><p>在项目中定义URLconf</p>
<p><img src="https://img-blog.csdnimg.cn/20200406234129220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200406234129220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
<li><p>在应用中定义URLconf</p>
<p><code>提示：一条URLconf包括URL规则、视图两部分</code></p>
<ul>
<li><p>URL规则使用正则表达式定义.</p>
</li>
<li><p>视图就是在views.py中定义的视图函数.</p>
<p><img src="https://img-blog.csdnimg.cn/20200406234252405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200406234252405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
<li><p>url匹配过程<br><img src="https://img-blog.csdnimg.cn/20200406234313545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200406234313545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
</ul>
</li>
</ul>
<h4 id="3-测试：请求访问"><a href="#3-测试：请求访问" class="headerlink" title="3. 测试：请求访问"></a>3. 测试：请求访问</h4><pre class="highlight"><span class="line">http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/</span><br><span class="line"><span class="number">1</span></span><br></pre>

<p><img src="https://img-blog.csdnimg.cn/20200406234343267.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200406234343267.png" class="lozad post-image"></p>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h4><p>视图处理过程如下图：<br><img src="https://img-blog.csdnimg.cn/20200406234434487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200406234434487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<pre class="highlight"><span class="line">使用视图时需要进行两步操作，两步操作不分先后</span><br><span class="line"></span><br><span class="line">	配置URLconf</span><br><span class="line">	</span><br><span class="line">	在应用/views.py中定义视图</span><br><span class="line"><span class="number">12345</span></span><br></pre>



<h4 id="总结View和URL匹配流程"><a href="#总结View和URL匹配流程" class="headerlink" title="总结View和URL匹配流程"></a>总结View和URL匹配流程</h4><p><img src="https://img-blog.csdnimg.cn/20200406234535649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200406234535649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch 介绍</title>
    <url>/2020/08/01/ElasticSearch%20%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200611210137425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200611210137425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="什么是ElasticSearch？"><a href="#什么是ElasticSearch？" class="headerlink" title="什么是ElasticSearch？"></a>什么是ElasticSearch？</h4><p>Elasticsearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene基础之上。 Lucene 可以说是当下最先进、高性能、全功能的搜索引擎库—无论是开源还是私有。</p>
<p>Lucece 这个 可是个很牛逼的东西，整理好资料我会在接下来的博客中 发布。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>一个分布式的实时文档存储，每个字段 可以被索引与搜索</li>
<li>一个分布式实时分析搜索引擎</li>
<li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</li>
</ul>
<p>Elasticsearch 可以横向扩展至数百（甚至数千）的服务器节点，同时可以处理PB级数据。Elasticsearch 天生就是分布式的，并且在设计时屏蔽了分布式的复杂性。</p>
<h4 id="用它来干什么"><a href="#用它来干什么" class="headerlink" title="用它来干什么?"></a>用它来干什么?</h4><p>Elasticsearch 是将所有的功能打包成一个单独的服务，这样你可以通过程序与它提供的简单的 RESTful API 进行通信， 可以使用自己喜欢的编程语言充当 web 客户端 和 命令行 去充当这个客户端。</p>
<p>Elasticsearch 在速度和可扩展性方面都表现出色，而且还能够索引多种类型的内容，这意味着其可用于多种用例：</p>
<ul>
<li>应用程序搜索</li>
<li>网站搜索</li>
<li>企业搜索</li>
<li>日志处理和分析</li>
<li>基础设施指标和容器监测</li>
<li>应用程序性能监测</li>
<li>地理空间数据分析和可视化</li>
<li>安全分析</li>
<li>业务分析</li>
</ul>
<h4 id="为何使用-Elasticsearch？"><a href="#为何使用-Elasticsearch？" class="headerlink" title="为何使用 Elasticsearch？"></a>为何使用 Elasticsearch？</h4><p>Elasticsearch 快，真男人的那种快。 由于 Elasticsearch 是在 Lucene 基础上构建而成的，所以在全文本搜索方面表现十分牛逼。Elasticsearch 同时还是一个近实时的搜索平台，这意味着从文档索引操作到文档变为可搜索状态之间的延时很短，一般只有一秒。因此，Elasticsearch 非常适用于对时间有严苛要求的用例，例如安全分析和基础设施监测。</p>
<p>Elasticsearch 具有<code>分布式</code>的本质特征。 Elasticsearch 中<code>存储的文档分布在不同的容器中</code>，这些容器称为分片，可以进行复制以提供数据冗余副本，以防发生硬件故障。Elasticsearch 的分布式特性使得它可以扩展至数百台（甚至数千台）服务器，并处理 PB 量级的数据。</p>
<p>Elasticsearch 包含一系列广泛的功能。 除了速度、可扩展性和弹性等优势以外，Elasticsearch 还有大量强大的内置功能（例如数据汇总和索引生命周期管理），可以方便用户更加高效地存储和搜索数据。</p>
<p>Elastic Stack 简化了数据采集、可视化和报告过程。 通过与 Beats 和 Logstash 进行集成，用户能够在向 Elasticsearch 中索引数据之前轻松地处理数据。同时，Kibana 不仅可针对 Elasticsearch 数据提供实时可视化，同时还提供 UI 以便用户快速访问应用程序性能监测 (APM)、日志和基础设施指标等数据。</p>
<h4 id="elastic-search-在项目中的位置"><a href="#elastic-search-在项目中的位置" class="headerlink" title="elastic search 在项目中的位置"></a>elastic search 在项目中的位置</h4><p><img src="https://img-blog.csdnimg.cn/20200612114228107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200612114228107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="Elasticsearch-的工作原理是什么？"><a href="#Elasticsearch-的工作原理是什么？" class="headerlink" title="Elasticsearch 的工作原理是什么？"></a>Elasticsearch 的工作原理是什么？</h4><p>原始数据会从多个来源（包括日志、系统指标和网络应用程序）输入到 Elasticsearch 中。数据采集指在 Elasticsearch 中进行索引之前解析、标准化并充实这些原始数据的过程。这些数据在 Elasticsearch 中索引完成之后，用户便可针对他们的数据运行复杂的查询，并使用聚合来检索自身数据的复杂汇总。在 Kibana 中，用户可以基于自己的数据创建强大的可视化，分享仪表板，并对 Elastic Stack 进行管理。</p>
<h4 id="Elasticsearch-索引是什么？"><a href="#Elasticsearch-索引是什么？" class="headerlink" title="Elasticsearch 索引是什么？"></a>Elasticsearch 索引是什么？</h4><p>Elasticsearch 索引指相互关联的文档集合。Elasticsearch 会以 JSON 文档的形式存储数据。每个文档都会在一组键（字段或属性的名称）和它们对应的值（字符串、数字、布尔值、日期、数值组、地理位置或其他类型的数据）之间建立联系。</p>
<p>Elasticsearch 使用的是一种名为 <strong>倒排索引</strong> 的数据结构，这一结构的设计可以允许十分快速地进行全文本搜索。倒排索引会列出在所有文档中出现的每个特有词汇，并且可以找到包含每个词汇的全部文档。</p>
<p>在索引过程中，Elasticsearch 会存储文档并构建倒排索引，这样用户便可以近实时地对文档数据进行搜索。索引过程是在索引 API 中启动的，通过此 API 您既可向特定索引中添加 JSON 文档，也可更改特定索引中的 JSON 文档。</p>
<pre class="highlight"><span class="line">ELK &#x3D; Elasticsearch, Logstash, Kibana 是一套实时数据收集，存储，索引，检索，统计分析及可视化的解决方案。最新版本已经改名为Elastic Stack，并新增了Beats项目。</span><br></pre>

<h4 id="Logstash-的用途是什么？"><a href="#Logstash-的用途是什么？" class="headerlink" title="Logstash 的用途是什么？"></a>Logstash 的用途是什么？</h4><p>Logstash 是 Elastic Stack 的核心产品之一，可用来对数据进行聚合和处理，并将数据发送到 Elasticsearch。Logstash 是一个开源的服务器端数据处理管道，允许您在将数据索引到 Elasticsearch 之前同时从多个来源采集数据，并对数据进行充实和转换。</p>
<h4 id="Kibana-的用途是什么？"><a href="#Kibana-的用途是什么？" class="headerlink" title="Kibana 的用途是什么？"></a>Kibana 的用途是什么？</h4><p>Kibana 是用于 Elasticsearch 的数据可视化和管理工具，实时的提供直方图、线形图、饼状图和地图。Kibana 同时还包括诸如 Canvas 和 Elastic Maps 等高级应用程序；Canvas 允许用户基于自身数据创建定制的动态信息图表，而 Elastic Maps 则可用来对地理空间数据进行可视化。</p>
]]></content>
      <categories>
        <category>ES检索</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT使用</title>
    <url>/2018/12/21/JWT%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h6 id="Json-Web-Token-JWT-是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准-JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。"><a href="#Json-Web-Token-JWT-是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准-JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。" class="headerlink" title="Json Web Token(JWT) 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准,JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。"></a>Json Web Token(JWT) 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准,JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</h6><hr>
<h2 id="什么场景使用JWTPermalink"><a href="#什么场景使用JWTPermalink" class="headerlink" title="什么场景使用JWTPermalink"></a>什么场景使用JWTPermalink</h2><h6 id="在前后端分离情况下前端的每一次请求都会携带指定url地址和参数，-从而很可能被不法分子根据指定的url来仿照前端直接请求后端，造成性能与数据的流失-，-只需更换一些参数就能获取其他用户的数据-岂不是很不安全"><a href="#在前后端分离情况下前端的每一次请求都会携带指定url地址和参数，-从而很可能被不法分子根据指定的url来仿照前端直接请求后端，造成性能与数据的流失-，-只需更换一些参数就能获取其他用户的数据-岂不是很不安全" class="headerlink" title="在前后端分离情况下前端的每一次请求都会携带指定url地址和参数， 从而很可能被不法分子根据指定的url来仿照前端直接请求后端，造成性能与数据的流失 ， 只需更换一些参数就能获取其他用户的数据 岂不是很不安全"></a>在前后端分离情况下前端的每一次请求都会携带指定url地址和参数， 从而很可能被不法分子根据指定的url来仿照前端直接请求后端，造成性能与数据的流失 ， 只需更换一些参数就能获取其他用户的数据 岂不是很不安全</h6><h6 id="我们需要在请求的时候加一些身份验证，保证后端服务器不能被第三方访问"><a href="#我们需要在请求的时候加一些身份验证，保证后端服务器不能被第三方访问" class="headerlink" title="我们需要在请求的时候加一些身份验证，保证后端服务器不能被第三方访问"></a>我们需要在请求的时候加一些身份验证，保证后端服务器不能被第三方访问</h6><p><img src="/hugoblog/jwt.jpg" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/jwt.jpg" class="lozad post-image"></p>
<h5 id="生成jwt-Permalink-amp-使用jwt模块-jwt-encode-参数-秘钥-加密方式"><a href="#生成jwt-Permalink-amp-使用jwt模块-jwt-encode-参数-秘钥-加密方式" class="headerlink" title="生成jwt:Permalink&amp;使用jwt模块 jwt.encode(参数,秘钥,加密方式)"></a>生成jwt:Permalink&amp;使用jwt模块 jwt.encode(参数,秘钥,加密方式)</h5><pre class="highlight"><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># playload 载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</span></span><br><span class="line">playload = &#123;</span><br><span class="line">    <span class="comment"># 创建一个过期时间</span></span><br><span class="line">    <span class="string">'exp'</span>: int((datetime.datetime.now() + datetime.timedelta(hours=<span class="number">4</span>)).timestamp()),</span><br><span class="line">    <span class="string">'data'</span>: &#123;<span class="string">'uid'</span>: user.id&#125;</span><br><span class="line">&#125;</span><br><span class="line">encode_jwt = jwt.encode(playload, <span class="string">'秘钥'</span>, algorithm=<span class="string">'HS256'</span>)</span><br><span class="line"><span class="comment">#加密后是二进制形式 要转码为str</span></span><br><span class="line">encode_str = str(encode_jwt, <span class="string">'utf-8'</span>)</span><br><span class="line"><span class="keyword">return</span> Response(&#123;<span class="string">"code"</span>: <span class="number">200</span>, <span class="string">"msg"</span>: <span class="string">"登录成功"</span>,<span class="string">'jwt'</span>:encode_str&#125;)</span><br></pre>
<hr>
<h5 id="这样在登录的时候就将认证的jwt传递给前端并且有过期时间-当jwt过期的时候就重新登录-如何验证jwt"><a href="#这样在登录的时候就将认证的jwt传递给前端并且有过期时间-当jwt过期的时候就重新登录-如何验证jwt" class="headerlink" title="这样在登录的时候就将认证的jwt传递给前端并且有过期时间 当jwt过期的时候就重新登录   如何验证jwt:"></a>这样在登录的时候就将认证的jwt传递给前端并且有过期时间 当jwt过期的时候就重新登录   如何验证jwt:</h5><pre class="highlight"><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator  <span class="comment"># 导入django自带的方法装饰器模块</span></span><br><span class="line"><span class="comment"># 定义权限检测装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warpper</span><span class="params">(request,*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 拦截获取参数</span></span><br><span class="line">        uid=request.GET.get(<span class="string">'uid'</span>,<span class="literal">None</span>)</span><br><span class="line">        myjwt=request.GET.get(<span class="string">'jwt'</span>,<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 对jwt进行解码  algorithms=['HS256'] 加密方式 HS256</span></span><br><span class="line">            <span class="comment"># 如果jwt过期会报错 就需要使用try</span></span><br><span class="line">            decode_jwt = jwt.decode(myjwt, <span class="string">'秘钥'</span>, algorithms=[<span class="string">'HS256'</span>])</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>: <span class="number">401</span>, <span class="string">'msg'</span>: <span class="string">'您的秘钥已失效'</span>&#125;)</span><br><span class="line">		</span><br><span class="line">        <span class="comment"># 判断jwt内的参数是否被篡改</span></span><br><span class="line">        <span class="keyword">if</span> int(uid)!= int(decode_jwt[<span class="string">'data'</span>][<span class="string">'uid'</span>]):</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>:<span class="number">401</span>,<span class="string">'msg'</span>:<span class="string">'您的秘钥无权限'</span>&#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> func(request,*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> warpper</span><br></pre>
<h3 id="创建一个装饰器-在需要验证的函数上方进行拦截验证"><a href="#创建一个装饰器-在需要验证的函数上方进行拦截验证" class="headerlink" title="创建一个装饰器 在需要验证的函数上方进行拦截验证"></a>创建一个装饰器 在需要验证的函数上方进行拦截验证</h3><pre class="highlight"><span class="line"><span class="comment"># 当使用的是类方法需要这样注册装饰器</span></span><br><span class="line"><span class="meta">@method_decorator(my_decorator)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(slef,request)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre>
]]></content>
      <categories>
        <category>jwt</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT简介</title>
    <url>/2019/08/17/JWT%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p><img src="https://v3u.cn/book/img/jwt.png" alt="~~~~~~~~~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://v3u.cn/book/img/jwt.png" class="lozad post-image"></p>
<p>JWT 特点 体积小，因而传输速度快</p>
<p>传输方式多样，可以通过URL/POST参数/HTTP头部等方式传输</p>
<p>严格的结构化。它自身（在 payload 中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且 payload 支持为你的应用而定制化。</p>
<p>支持跨域验证，可以应用于单点登录。</p>
<p>JWT是Auth0提出的通过对JSON进行加密签名来实现授权验证的方案，编码之后的JWT看起来是这样的一串字符：</p>
<pre class="highlight"><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre>

<p>由 . 分为三段，通过解码可以得到：</p>
<ol>
<li>头部（Header）<pre class="highlight"><span class="line">&#x2F;&#x2F; 包括类别（typ）、加密算法（alg）；</span><br><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre>
jwt的头部包含两部分信息：</li>
</ol>
<p>声明类型，这里是jwt</p>
<p>声明加密的算法 通常直接使用 HMAC SHA256</p>
<ol>
<li>载荷（payload）<br>载荷（payload） 载荷就是存放有效信息的地方。</li>
<li>签名（signature)<br>签名的目的：签名实际上是对头部以及载荷内容进行签名。所以，如果有人对头部以及载荷的内容解码之后进行修改，再进行编码的话，那么新的头部和载荷的签名和之前的签名就将是不一样的。而且，如果不知道服务器加密的时候用的密钥的话，得出来的签名也一定会是不一样的。 这样就能保证token不会被篡改。</li>
</ol>
<p>最后，我们将上面拼接完的字符串用HS256算法进行加密。在加密的时候，我们还需要提供一个密钥（secret）。类似盐</p>
<p>这里在第三步我们得到 JWT 之后，需要将JWT存放在 client，之后的每次需要认证的请求都要把JWT发送过来。（请求时可以放到 header 的 Authorization ）</p>
<p>一、使用JSON Web Token的好处？ </p>
<ol>
<li>性能问题。 JWT方式将用户状态分散到了客户端中，相比于session，可以明显减轻服务端的内存压力。 Session方式存储用户id的最大弊病在于Session是存储在服务器端的，所以需要占用大量服务器内存， 对于较大型应用而言可能还要保存许多的状态，一般还需借助nosql和缓存机制来实现session的存储，如果是分布式应用还需session共享。 </li>
<li>单点登录。 JWT能轻松的实现单点登录，因为用户的状态已经被传送到了客户端。 token 可保存自定义信息，如用户基本信息，web服务器用key去解析token，就获取到请求用户的信息了。 我们也可以配置它以便包含用户拥有的任何权限。这意味着每个服务不需要与授权服务交互才能授权用户。 </li>
<li>前后端分离。 以前的传统模式下，后台对应的客户端就是浏览器，就可以使用session+cookies的方式实现登录， 但是在前后分离的情况下，后端只负责通过暴露的RestApi提供数据，而页面的渲染、路由都由前端完成。因为rest是无状态的，因此也就不会有session记录到服务器端。 </li>
<li>兼容性。 支持移动设备，支持跨程序调用，Cookie 是不允许垮域访问的，而 Token 则不存在这个问题。 </li>
<li>可拓展性。 jwt是无状态的，特别适用于分布式站点的单点登录（SSO）场景。 比如有3台机器（A、B、C）组成服务器集群，若session存在机器A上，session只能保存在其中一台服务器，此时你便不能访问机器B、C，因为B、C上没有存放该Session， 而使用token就能够验证用户请求合法性，并且我再加几台机器也没事，所以可拓展性好。 </li>
<li>安全性。因为有签名，所以JWT可以防止被篡改。</li>
</ol>
<p>JWT是基于token的身份认证的方案。</p>
<p>json web token全称。可以保证安全传输的前提下传送一些基本的信息，以减轻对外部存储的依赖，减少了分布式组件的依赖，减少了硬件的资源。</p>
<p>可实现无状态、分布式的Web应用授权，jwt的安全特性保证了token的不可伪造和不可篡改。</p>
<p>本质上是一个独立的身份验证令牌，可以包含用户标识、用户角色和权限等信息，以及您可以存储任何其他信息（自包含）。任何人都可以轻松读取和解析，并使用密钥来验证真实性。</p>
<p>缺陷：<br>1). JWT在生成token的时候支持失效时间，但是支持的失效时间是固定的，比如说一天。 但是用户在等出的时候是随机触发的，那么我们jwt token来做这个失效是不可行的，因为jwt在初始化的时候已经定死在什么时候过期了。 采用其他方案，在redis中存储token，设置token的过期时间，每次鉴权的时候都会去延长时间<br>2). jwt不适合存放大量信息，信息越多token越长</p>
]]></content>
      <categories>
        <category>jwt</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>MD基本语法</title>
    <url>/2019/01/07/MD%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="md是什么"><a href="#md是什么" class="headerlink" title="md是什么"></a>md是什么</h2><h6 id="md即markdown文件的基本常用编写语法-是一种快速标记、快速排版语言"><a href="#md即markdown文件的基本常用编写语法-是一种快速标记、快速排版语言" class="headerlink" title=".md即markdown文件的基本常用编写语法,是一种快速标记、快速排版语言"></a>.md即markdown文件的基本常用编写语法,是一种快速标记、快速排版语言</h6><hr>
<h2 id="1-基本符号：-gt"><a href="#1-基本符号：-gt" class="headerlink" title="1.基本符号：* - + &gt;"></a>1.基本符号：* - + &gt;</h2><h6 id="基本上所有的markdown标记都是基于这四个符号或组合，需要注意的是，如果以基本符号开头的标记，注意基本符号后有一个用于分割标记符和内容的空格。"><a href="#基本上所有的markdown标记都是基于这四个符号或组合，需要注意的是，如果以基本符号开头的标记，注意基本符号后有一个用于分割标记符和内容的空格。" class="headerlink" title="基本上所有的markdown标记都是基于这四个符号或组合，需要注意的是，如果以基本符号开头的标记，注意基本符号后有一个用于分割标记符和内容的空格。"></a>基本上所有的markdown标记都是基于这四个符号或组合，需要注意的是，如果以基本符号开头的标记，注意基本符号后有一个用于分割标记符和内容的空格。</h6><hr>
<h2 id="2-标题"><a href="#2-标题" class="headerlink" title="2.标题"></a>2.标题</h2><h6 id="前面带-号，后面带文字，分别表示h1-h6-只到h6，而且h1下面会有一条横线-–-gt-相当于标签闭合"><a href="#前面带-号，后面带文字，分别表示h1-h6-只到h6，而且h1下面会有一条横线-–-gt-相当于标签闭合" class="headerlink" title="前面带#号，后面带文字，分别表示h1-h6,只到h6，而且h1下面会有一条横线  –&gt; 相当于标签闭合"></a>前面带#号，后面带文字，分别表示h1-h6,只到h6，而且h1下面会有一条横线  –&gt; 相当于标签闭合</h6><pre class="highlight"><span class="line"><span class="comment"># 一级标题</span></span><br><span class="line"><span class="comment">## 二级标题</span></span><br><span class="line"><span class="comment">### 三级标题</span></span><br><span class="line"><span class="comment">#### 四级标题</span></span><br><span class="line"><span class="comment">##### 五级标题</span></span><br><span class="line"><span class="comment">###### 六级标题</span></span><br></pre>

<pre class="highlight"><span class="line"><span class="comment"># 一级标题 #</span></span><br><span class="line"><span class="comment">## 二级标题 ##</span></span><br><span class="line"><span class="comment">### 三级标题 ###</span></span><br><span class="line"><span class="comment">#### 四级标题 ####</span></span><br><span class="line"><span class="comment">##### 五级标题 #####</span></span><br><span class="line"><span class="comment">###### 六级标题 #####</span></span><br></pre>
<h6 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h6><p><img src="/hugoblog/md.png" alt="md" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/md.png" class="lozad post-image"></p>
<hr>
<h2 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h2><ul>
<li>无序列表<pre class="highlight"><span class="line">//形式一</span><br><span class="line">+ a</span><br><span class="line">+ b</span><br><span class="line">+ c</span><br><span class="line"></span><br><span class="line">//形式二</span><br><span class="line">- d</span><br><span class="line">- e</span><br><span class="line">- f</span><br><span class="line"></span><br><span class="line">//形式三</span><br><span class="line">* g</span><br><span class="line">* h</span><br><span class="line">* i</span><br></pre>

</li>
</ul>
<h6 id="以上三种形式，效果其实都是一样的："><a href="#以上三种形式，效果其实都是一样的：" class="headerlink" title="以上三种形式，效果其实都是一样的："></a>以上三种形式，效果其实都是一样的：</h6><p><img src="/hugoblog/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8.png" alt="无序列表" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8.png" class="lozad post-image"></p>
<hr>
<ul>
<li>有序列表<pre class="highlight"><span class="line"></span><br><span class="line">//正常形式</span><br><span class="line"><span class="number">1.</span> abc</span><br><span class="line"><span class="number">2.</span> bcd</span><br><span class="line"><span class="number">3.</span> cde</span><br><span class="line">//错序效果</span><br><span class="line"><span class="number">2.</span> fgh</span><br><span class="line"><span class="number">3.</span> ghi</span><br><span class="line"><span class="number">5.</span> hij</span><br></pre>
<h6 id="效果图：-1"><a href="#效果图：-1" class="headerlink" title="效果图："></a>效果图：</h6><img src="/hugoblog/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8.png" alt="有序列表" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8.png" class="lozad post-image"></li>
</ul>
<hr>
<h6 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h6><pre class="highlight"><span class="line">如图,数字后面的点只能是英文的点，有序列表的序号是根据第一行列表的数字顺序来的，</span><br><span class="line">错序列表的序号本来是序号是乱的， 但是还是显示 2 3 5</span><br></pre>
<hr>
<ul>
<li>嵌套列表<pre class="highlight"><span class="line">//无序列表嵌套</span><br><span class="line">+ <span class="number">123</span></span><br><span class="line">    + abc</span><br><span class="line">    + bcd</span><br><span class="line">    + cde</span><br><span class="line">+ <span class="number">465</span></span><br><span class="line">+ <span class="number">789</span></span><br><span class="line">//有序列表嵌套</span><br><span class="line"><span class="number">1.</span> abcd</span><br><span class="line">    <span class="number">1.</span> abcde</span><br><span class="line">    <span class="number">2.</span> abcde</span><br><span class="line">    <span class="number">3.</span> abcde</span><br><span class="line"><span class="number">2.</span> bcde</span><br><span class="line"><span class="number">3.</span> cdef</span><br></pre>
<h6 id="效果图：-2"><a href="#效果图：-2" class="headerlink" title="效果图："></a>效果图：</h6><img src="/hugoblog/%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8.png" alt="嵌套列表" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8.png" class="lozad post-image"></li>
</ul>
<h6 id="列表可以嵌套，使用时在嵌套列表前按-tab-或-空格-来缩进-去控制列表的层数"><a href="#列表可以嵌套，使用时在嵌套列表前按-tab-或-空格-来缩进-去控制列表的层数" class="headerlink" title="列表可以嵌套，使用时在嵌套列表前按 tab 或 空格 来缩进,去控制列表的层数"></a>列表可以嵌套，使用时在嵌套列表前按 tab 或 空格 来缩进,去控制列表的层数</h6><hr>
<h2 id="4-引用说明区块"><a href="#4-引用说明区块" class="headerlink" title="4.引用说明区块"></a>4.引用说明区块</h2><h6 id="对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语法。"><a href="#对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语法。" class="headerlink" title="对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语法。"></a>对某个部分做的内容做一些说明或者引用某某的话等，可以用这个语法。</h6><ul>
<li>正常形式<pre class="highlight"><span class="line">&gt; 引用内容、说明内容。在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等。</span><br></pre>
<h6 id="效果图：-3"><a href="#效果图：-3" class="headerlink" title="效果图："></a>效果图：</h6><img src="/hugoblog/%E5%BC%95%E7%94%A8%E8%AF%B4%E6%98%8E.png" alt="引用说明" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E5%BC%95%E7%94%A8%E8%AF%B4%E6%98%8E.png" class="lozad post-image"></li>
</ul>
<hr>
<ul>
<li>嵌套区块<h6 id="这里我只介绍一下我常用的方法，也是个人认为比较规范的一种方法，就是给区块的下一级区块多加一个右尖括号"><a href="#这里我只介绍一下我常用的方法，也是个人认为比较规范的一种方法，就是给区块的下一级区块多加一个右尖括号" class="headerlink" title="这里我只介绍一下我常用的方法，也是个人认为比较规范的一种方法，就是给区块的下一级区块多加一个右尖括号"></a>这里我只介绍一下我常用的方法，也是个人认为比较规范的一种方法，就是给区块的下一级区块多加一个右尖括号</h6><pre class="highlight"><span class="line">&gt; 一级引用</span><br><span class="line">&gt;&gt; 二级引用</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>三级引用</span><br><span class="line">&gt;&gt;&gt;&gt; 四级引用</span><br><span class="line">&gt;&gt;&gt;&gt;&gt; 五级引用</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt; 六级引用</span><br></pre>

</li>
</ul>
<h6 id="效果图：-4"><a href="#效果图：-4" class="headerlink" title="效果图："></a>效果图：</h6><p><img src="/hugoblog/%E5%B5%8C%E5%A5%97%E5%BC%95%E7%94%A8.png" alt="嵌套引用" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E5%B5%8C%E5%A5%97%E5%BC%95%E7%94%A8.png" class="lozad post-image"></p>
<hr>
<h2 id="5-代码块"><a href="#5-代码块" class="headerlink" title="5.代码块"></a>5.代码块</h2><h6 id="在发布一些技术文章会涉及展示代码的问题，这时候代码块就显得尤为重要。"><a href="#在发布一些技术文章会涉及展示代码的问题，这时候代码块就显得尤为重要。" class="headerlink" title="在发布一些技术文章会涉及展示代码的问题，这时候代码块就显得尤为重要。"></a>在发布一些技术文章会涉及展示代码的问题，这时候代码块就显得尤为重要。</h6><hr>
<ul>
<li>少量代码，单行使用，直接用`包裹起来就行了<pre class="highlight"><span class="line">` shaoliangdaima,danhangshiyong `</span><br></pre>
<h6 id="效果图：-5"><a href="#效果图：-5" class="headerlink" title="效果图："></a>效果图：</h6><img src="/hugoblog/%E4%BB%A3%E7%A0%81%E5%8D%95%E8%A1%8C.png" alt="代码单行" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E4%BB%A3%E7%A0%81%E5%8D%95%E8%A1%8C.png" class="lozad post-image"></li>
</ul>
<hr>
<ul>
<li>大量代码，需要多行使用，用```包裹起来<pre class="highlight"><span class="line"> </span><br></pre>
<pre><code>daliangdaima,xuyaoduohangshiyong
daliangdaima,xuyaoduohangshiyong
daliangdaima,xuyaoduohangshiyong
daliangdaima,xuyaoduohangshiyong
daliangdaima,xuyaoduohangshiyong</code></pre>  <pre class="highlight"><span class="line">&#96;&#96;&#96;</span><br><span class="line">###### 效果图：</span><br><span class="line">![多行代码](&#x2F;hugoblog&#x2F;多行代码.png)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 6.链接</span><br><span class="line">- 行内式</span><br><span class="line">###### 链接的文字放在[]中，链接地址放在随后的()中，链接也可以带title属性，链接地址后面空一格，然后用引号引起来</span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">[简书](https:&#x2F;&#x2F;www.jianshu.com &quot;创作你的创作&quot;),</span><br><span class="line">是一个创作社区,任何人均可以在其上进行创作。用户在简书上面可以方便的创作自己的作品,互相交流。</span><br></pre>
</li>
</ul>
<hr>
<ul>
<li>参数式<h6 id="链接的文字放在-中，链接地址放在随后的-后，链接地址后面空一格，然后用引号引起来"><a href="#链接的文字放在-中，链接地址放在随后的-后，链接地址后面空一格，然后用引号引起来" class="headerlink" title="链接的文字放在[]中，链接地址放在随后的:后，链接地址后面空一格，然后用引号引起来"></a>链接的文字放在[]中，链接地址放在随后的:后，链接地址后面空一格，然后用引号引起来</h6></li>
</ul>
<pre class="highlight"><span class="line">[简书]: https://www.jianshu.com <span class="string">"创作你的创作"</span></span><br><span class="line">[简书]是一个创作社区,任何人均可以在其上进行创作。用户在简书上面可以方便的创作自己的作品,互相交流。</span><br><span class="line">//参数定义的其他写法</span><br><span class="line">[简书]: https://www.jianshu.com <span class="string">'创作你的创作'</span></span><br><span class="line">[简书]: https://www.jianshu.com (创作你的创作)</span><br><span class="line">[简书]: &lt;https://www.jianshu.com&gt; <span class="string">"创作你的创作"</span></span><br></pre>
<hr>
<h6 id="以上两种方式其效果图都是一样的，如下："><a href="#以上两种方式其效果图都是一样的，如下：" class="headerlink" title="以上两种方式其效果图都是一样的，如下："></a>以上两种方式其效果图都是一样的，如下：</h6><p><img src="/hugoblog/%E9%93%BE%E6%8E%A5.png" alt="链接" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E9%93%BE%E6%8E%A5.png" class="lozad post-image"></p>
<hr>
<h2 id="7-图片"><a href="#7-图片" class="headerlink" title="7.图片"></a>7.图片</h2><ul>
<li>行内式<h6 id="和链接的形式差不多，图片的名字放在-中，图片地址放在随后的-中，title属性（图片地址后面空一格，然后用引号引起来）-注意的是-前要加上"><a href="#和链接的形式差不多，图片的名字放在-中，图片地址放在随后的-中，title属性（图片地址后面空一格，然后用引号引起来）-注意的是-前要加上" class="headerlink" title="和链接的形式差不多，图片的名字放在[]中，图片地址放在随后的()中，title属性（图片地址后面空一格，然后用引号引起来）,注意的是[]前要加上!"></a>和链接的形式差不多，图片的名字放在[]中，图片地址放在随后的()中，title属性（图片地址后面空一格，然后用引号引起来）,注意的是[]前要加上!</h6></li>
</ul>
<pre class="highlight"><span class="line">![my-logo.png](https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 "my-logo")</span><br></pre>
<ul>
<li>参数式<h6 id="图片的文字放在-中，图片地址放在随后的-后，title属性（图片地址后面空一格，然后用引号引起来）-注意引用图片的时候在-前要加上"><a href="#图片的文字放在-中，图片地址放在随后的-后，title属性（图片地址后面空一格，然后用引号引起来）-注意引用图片的时候在-前要加上" class="headerlink" title="图片的文字放在[]中，图片地址放在随后的:后，title属性（图片地址后面空一格，然后用引号引起来）,注意引用图片的时候在[]前要加上!"></a>图片的文字放在[]中，图片地址放在随后的:后，title属性（图片地址后面空一格，然后用引号引起来）,注意引用图片的时候在[]前要加上!</h6></li>
</ul>
<pre class="highlight"><span class="line">[my-logo.png]: https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 "my-logo"</span><br><span class="line"></span><br><span class="line">![my-logo.png]</span><br><span class="line"></span><br><span class="line">//参数定义的其他写法</span><br><span class="line">[my-logo.png]: https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 'my-logo'</span><br><span class="line"></span><br><span class="line">[my-logo.png]: https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240 (my-logo)</span><br><span class="line"></span><br><span class="line">[my-logo.png]: &lt;https://upload-images.jianshu.io/upload_images/13623636-6d878e3d3ef63825.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&gt; "my-logo"</span><br></pre>

<h6 id="以上两种方式其效果图都是一样的，如下：-1"><a href="#以上两种方式其效果图都是一样的，如下：-1" class="headerlink" title="以上两种方式其效果图都是一样的，如下："></a>以上两种方式其效果图都是一样的，如下：</h6><p><img src="/hugoblog/%E5%8F%82%E6%95%B0%E5%BC%8F.png" alt="图片" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E5%8F%82%E6%95%B0%E5%BC%8F.png" class="lozad post-image"></p>
<hr>
<h2 id="8-分割线"><a href="#8-分割线" class="headerlink" title="8.分割线"></a>8.分割线</h2><h6 id="分割线可以由-（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以"><a href="#分割线可以由-（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以" class="headerlink" title="分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以"></a>分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以</h6><pre class="highlight"><span class="line">---</span><br><span class="line">- - -</span><br><span class="line">------</span><br><span class="line">***</span><br><span class="line">* * *</span><br><span class="line">******</span><br><span class="line">___</span><br><span class="line">_ _ _</span><br><span class="line">______</span><br></pre>
<p>效果图：</p>
<p><img src="/hugoblog/%E5%88%86%E5%89%B2%E7%BA%BF.png" alt="分割线" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E5%88%86%E5%89%B2%E7%BA%BF.png" class="lozad post-image"></p>
<hr>
<h2 id="9-其他"><a href="#9-其他" class="headerlink" title="9.其他"></a>9.其他</h2><ul>
<li>强调字体<h6 id="一个星号或者是一个下划线包起来，会转换为倾斜，如果是2个，会转换为加粗"><a href="#一个星号或者是一个下划线包起来，会转换为倾斜，如果是2个，会转换为加粗" class="headerlink" title="一个星号或者是一个下划线包起来，会转换为倾斜，如果是2个，会转换为加粗"></a>一个星号或者是一个下划线包起来，会转换为<em>倾斜，如果是2个，会转换为<strong>加粗</h6><pre class="highlight"><span class="line"></span><br><span class="line">*md*    </span><br><span class="line">**md**</span><br><span class="line">_md_   </span><br><span class="line"> __md__</span><br></pre>

</li>
</ul>
<h6 id="效果图：-6"><a href="#效果图：-6" class="headerlink" title="效果图："></a>效果图：</h6><p><img src="/hugoblog/%E5%BC%BA%E8%B0%83%E5%AD%97%E4%BD%93.png" alt="强调字体" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E5%BC%BA%E8%B0%83%E5%AD%97%E4%BD%93.png" class="lozad post-image"></p>
<hr>
<ul>
<li>转义<h6 id="基本上和js转义一样-加需要转义的字符"><a href="#基本上和js转义一样-加需要转义的字符" class="headerlink" title="基本上和js转义一样,\加需要转义的字符"></a>基本上和js转义一样,\加需要转义的字符</h6></li>
</ul>
<pre class="highlight"><span class="line">\\</span><br><span class="line">\*</span><br><span class="line">\+</span><br><span class="line">\-</span><br><span class="line">\`</span><br><span class="line">\_</span><br></pre>
<ul>
<li>删除线<h6 id="用-把需要显示删除线的字符包裹起来"><a href="#用-把需要显示删除线的字符包裹起来" class="headerlink" title="用~~把需要显示删除线的字符包裹起来"></a>用~~把需要显示删除线的字符包裹起来</h6><pre class="highlight"><span class="line"></span><br><span class="line">~~删除~~</span><br></pre>
<h6 id="效果图：-7"><a href="#效果图：-7" class="headerlink" title="效果图："></a>效果图：</h6><img src="/hugoblog/%E5%88%A0%E9%99%A4.png" alt="删除" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E5%88%A0%E9%99%A4.png" class="lozad post-image"></li>
</ul>
<hr>
<h2 id="10-表格"><a href="#10-表格" class="headerlink" title="10.表格"></a>10.表格</h2><pre class="highlight"><span class="line"></span><br><span class="line">//例子一</span><br><span class="line">|<span class="number">123</span>|<span class="number">234</span>|<span class="number">345</span>|</span><br><span class="line">|:-|:-:|-:|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">//例子二</span><br><span class="line">|<span class="number">123</span>|<span class="number">234</span>|<span class="number">345</span>|</span><br><span class="line">|:---|:---:|---:|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">|abc|bcd|cde|</span><br><span class="line">//例子三</span><br><span class="line"><span class="number">123</span>|<span class="number">234</span>|<span class="number">345</span></span><br><span class="line">:-|:-:|-:</span><br><span class="line">abc|bcd|cde</span><br><span class="line">abc|bcd|cde</span><br><span class="line">abc|bcd|cde</span><br></pre>
<h6 id="上面三个例子的效果一样，由此可得："><a href="#上面三个例子的效果一样，由此可得：" class="headerlink" title="上面三个例子的效果一样，由此可得："></a>上面三个例子的效果一样，由此可得：</h6><ol>
<li>表格的格式不一定要对的非常起，但是为了良好的变成风格，尽量对齐是最好的</li>
<li>分割线后面的冒号表示对齐方式，写在左边表示左对齐，右边为右对齐，两边都写表示居中</li>
</ol>
<h6 id="效果图：-8"><a href="#效果图：-8" class="headerlink" title="效果图："></a>效果图：</h6><p><img src="/hugoblog/%E8%A1%A8%E6%A0%BC.png" alt="表格" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E8%A1%A8%E6%A0%BC.png" class="lozad post-image"></p>
<hr>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Celery 的使用</title>
    <url>/2019/09/27/Celery%20%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>上一篇博客已经详细的介绍了 Celery 和他的工作流程 <a href="https://blog.csdn.net/weixin_44685869/article/details/104443540" target="_blank" rel="noopener">celery的介绍</a></p>
<p>接下来 要演示 Celery 的使用</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class="highlight"><span class="line">python pip install celery</span><br></pre>

<p>创建 tasks.py文件进行验证</p>
<pre class="highlight"><span class="line"># tasks.py</span><br><span class="line"></span><br><span class="line">from celery import Celery</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">app &#x3D; Celery(&#39;TASK&#39;,</span><br><span class="line">             broker&#x3D;&#39;redis:&#x2F;&#x2F;localhost&#39;,        </span><br><span class="line">             backend&#x3D;&#39;redis:&#x2F;&#x2F;localhost&#39;)</span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def add(x, y):</span><br><span class="line">	&#39;&#39;&#39;</span><br><span class="line">	进行任务的添加</span><br><span class="line">	&#39;&#39;&#39;</span><br><span class="line">    print(&quot;running..add.&quot;, x, y)</span><br><span class="line">    return x + y</span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def minus(x, y):</span><br><span class="line">	&#39;&#39;&#39;</span><br><span class="line">	任务的减少</span><br><span class="line">	&#39;&#39;&#39;</span><br><span class="line">	time.sleep(60)</span><br><span class="line">    print(&quot;running..minus.&quot;, x, y)</span><br><span class="line">    return x - y</span><br></pre>
<h3 id="启动Celery-Worker来开始监听并执行任务"><a href="#启动Celery-Worker来开始监听并执行任务" class="headerlink" title="启动Celery Worker来开始监听并执行任务"></a>启动Celery Worker来开始监听并执行任务</h3><pre class="highlight"><span class="line">celery -A tasks worker --loglevel&#x3D;info            # tasks是tasks.py文件：必须在tasks.py所在目录下执行</span><br></pre>
<h3 id="调用任务：再打开两个终端，进行命令行模式，调用任务"><a href="#调用任务：再打开两个终端，进行命令行模式，调用任务" class="headerlink" title="调用任务：再打开两个终端，进行命令行模式，调用任务"></a>调用任务：再打开两个终端，进行命令行模式，调用任务</h3><pre class="highlight"><span class="line">&gt;&gt;&gt; import tasks</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; t2 &#x3D; tasks.minus.delay(9,11)</span><br><span class="line"></span><br><span class="line"># 然后在另一个终端重复上面步骤执行</span><br><span class="line">&gt;&gt;&gt; import tasks</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; t1 &#x3D; tasks.add.delay(3,4)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; t1.get()</span><br><span class="line"># 由于t2执行sleep了3s所以t1.get()需要等待</span><br></pre>

<h3 id="celery其他命令"><a href="#celery其他命令" class="headerlink" title="celery其他命令"></a>celery其他命令</h3><pre class="highlight"><span class="line">&gt;&gt;&gt; t.ready()                  #返回true证明可以执行，不必等待</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; t.get(timeout&#x3D;1)           #如果1秒不返回结果就超时,避免一直等待</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; t.get(propagate&#x3D;False)     #如果执行的代码错误只会打印错误信息</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; t.traceback                #打印异常详细结果</span><br></pre>
<h3 id="Celery执行异步任务"><a href="#Celery执行异步任务" class="headerlink" title="Celery执行异步任务"></a>Celery执行异步任务</h3><p>创建项目celerytest</p>
<h3 id="创建py文件：celery-app-task-py"><a href="#创建py文件：celery-app-task-py" class="headerlink" title="创建py文件：celery_app_task.py"></a>创建py文件：celery_app_task.py</h3><pre class="highlight"><span class="line">import celery</span><br><span class="line">import time</span><br><span class="line"># broker&#x3D;&#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;2&#39; 不加密码</span><br><span class="line">backend&#x3D;&#39;redis:&#x2F;&#x2F;:123456@127.0.0.1:6379&#x2F;1&#39;</span><br><span class="line">broker&#x3D;&#39;redis:&#x2F;&#x2F;:123456@127.0.0.1:6379&#x2F;2&#39;</span><br><span class="line">cel&#x3D;celery.Celery(&#39;test&#39;,backend&#x3D;backend,broker&#x3D;broker)</span><br><span class="line"></span><br><span class="line">@cel.task</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">添加任务</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">def add(x,y):</span><br><span class="line">    return x+y</span><br></pre>
<h3 id="创建py文件：add-task-py-添加任务"><a href="#创建py文件：add-task-py-添加任务" class="headerlink" title="创建py文件：add_task.py,添加任务"></a>创建py文件：add_task.py,添加任务</h3><pre class="highlight"><span class="line">from celery_app_task import add</span><br><span class="line">result &#x3D; add.delay(4,5)</span><br><span class="line">print(result.id)</span><br></pre>
<h3 id="创建py文件：run-py，执行任务，或者使用命令执行：celery-worker-A-celery-app-task-l-info"><a href="#创建py文件：run-py，执行任务，或者使用命令执行：celery-worker-A-celery-app-task-l-info" class="headerlink" title="创建py文件：run.py，执行任务，或者使用命令执行：celery worker -A celery_app_task -l info"></a>创建py文件：run.py，执行任务，或者使用命令执行：celery worker -A celery_app_task -l info</h3><p>windows下：celery worker -A celery_app_task -l info -P eventlet</p>
<pre class="highlight"><span class="line">from celery_app_task import cel</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    cel.worker_main()</span><br><span class="line">    # cel.worker_main(argv&#x3D;[&#39;--loglevel&#x3D;info&#39;)</span><br></pre>

<h3 id="创建py文件：result-py，查看任务执行结果"><a href="#创建py文件：result-py，查看任务执行结果" class="headerlink" title="创建py文件：result.py，查看任务执行结果"></a>创建py文件：result.py，查看任务执行结果</h3><pre class="highlight"><span class="line">from celery.result import AsyncResult</span><br><span class="line">from celery_app_task import cel</span><br><span class="line"></span><br><span class="line">async &#x3D; AsyncResult(id&#x3D;&quot;e919d97d-2938-4d0f-9265-fd8237dc2aa3&quot;, app&#x3D;cel)</span><br><span class="line"></span><br><span class="line">if async.successful():</span><br><span class="line">    result &#x3D; async.get()</span><br><span class="line">    print(result)</span><br><span class="line">    # result.forget() # 将结果删除</span><br><span class="line">elif async.failed():</span><br><span class="line">    print(&#39;执行失败&#39;)</span><br><span class="line">elif async.status &#x3D;&#x3D; &#39;PENDING&#39;:</span><br><span class="line">    print(&#39;任务等待中被执行&#39;)</span><br><span class="line">elif async.status &#x3D;&#x3D; &#39;RETRY&#39;:</span><br><span class="line">    print(&#39;任务异常后正在重试&#39;)</span><br><span class="line">elif async.status &#x3D;&#x3D; &#39;STARTED&#39;:</span><br><span class="line">    print(&#39;任务已经开始被执行&#39;)</span><br></pre>
<p>执行 add_task.py，添加任务，并获取任务ID</p>
<p>执行 run.py ，或者执行命令：celery worker -A celery_app_task -l info</p>
<p>执行 result.py,检查任务状态并获取结果</p>
<h3 id="多任务结构"><a href="#多任务结构" class="headerlink" title="多任务结构"></a>多任务结构</h3><pre class="highlight"><span class="line">pro_cel</span><br><span class="line">    ├── celery_task      # celery相关文件夹</span><br><span class="line">    │   ├── celery.py    # celery连接和配置相关文件,必须叫这个名字</span><br><span class="line">    │   └── tasks1.py    #  所有任务函数</span><br><span class="line">    │   └── tasks2.py    #  所有任务函数</span><br><span class="line">    ├── check_result.py  # 检查结果</span><br><span class="line">    └── send_task.py     # 触发任务</span><br></pre>
<h3 id="celery-py"><a href="#celery-py" class="headerlink" title="celery.py"></a>celery.py</h3><pre class="highlight"><span class="line">from celery import Celery</span><br><span class="line"></span><br><span class="line">cel &#x3D; Celery(&#39;celery_demo&#39;,</span><br><span class="line">             broker&#x3D;&#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;1&#39;,</span><br><span class="line">             backend&#x3D;&#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;2&#39;,</span><br><span class="line">             # 包含以下两个任务文件，去相应的py文件中找任务，对多个任务做分类</span><br><span class="line">             include&#x3D;[&#39;celery_task.tasks1&#39;,</span><br><span class="line">                      &#39;celery_task.tasks2&#39;</span><br><span class="line">                      ])</span><br><span class="line"></span><br><span class="line"># 时区</span><br><span class="line">cel.conf.timezone &#x3D; &#39;Asia&#x2F;Shanghai&#39;</span><br><span class="line"># 是否使用UTC</span><br><span class="line">cel.conf.enable_utc &#x3D; False</span><br></pre>


<h3 id="tasks1-py"><a href="#tasks1-py" class="headerlink" title="tasks1.py"></a>tasks1.py</h3><pre class="highlight"><span class="line">import time</span><br><span class="line">from celery_task.celery import cel</span><br><span class="line"></span><br><span class="line">@cel.task</span><br><span class="line">def test_celery(res):</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    return &quot;test_celery任务结果:%s&quot;%res</span><br></pre>
<h3 id="tasks2-py"><a href="#tasks2-py" class="headerlink" title="tasks2.py"></a>tasks2.py</h3><pre class="highlight"><span class="line">import time</span><br><span class="line">from celery_task.celery import cel</span><br><span class="line">@cel.task</span><br><span class="line">def test_celery2(res):</span><br><span class="line">    time.sleep(5)</span><br><span class="line">    return &quot;test_celery2任务结果:%s&quot;%res</span><br></pre>

<h3 id="check-result-py"><a href="#check-result-py" class="headerlink" title="check_result.py"></a>check_result.py</h3><pre class="highlight"><span class="line">from celery.result import AsyncResult</span><br><span class="line">from celery_task.celery import cel</span><br><span class="line"></span><br><span class="line">async &#x3D; AsyncResult(id&#x3D;&quot;08eb2778-24e1-44e4-a54b-56990b3519ef&quot;, app&#x3D;cel)</span><br><span class="line"></span><br><span class="line">if async.successful():</span><br><span class="line">    result &#x3D; async.get()</span><br><span class="line">    print(result)</span><br><span class="line">    # result.forget() # 将结果删除,执行完成，结果不会自动删除</span><br><span class="line">    # async.revoke(terminate&#x3D;True)  # 无论现在是什么时候，都要终止</span><br><span class="line">    # async.revoke(terminate&#x3D;False) # 如果任务还没有开始执行呢，那么就可以终止。</span><br><span class="line">elif async.failed():</span><br><span class="line">    print(&#39;执行失败&#39;)</span><br><span class="line">elif async.status &#x3D;&#x3D; &#39;PENDING&#39;:</span><br><span class="line">    print(&#39;任务等待中被执行&#39;)</span><br><span class="line">elif async.status &#x3D;&#x3D; &#39;RETRY&#39;:</span><br><span class="line">    print(&#39;任务异常后正在重试&#39;)</span><br><span class="line">elif async.status &#x3D;&#x3D; &#39;STARTED&#39;:</span><br><span class="line">    print(&#39;任务已经开始被执行&#39;)</span><br></pre>
<h3 id="send-task-py"><a href="#send-task-py" class="headerlink" title="send_task.py"></a>send_task.py</h3><pre class="highlight"><span class="line">from celery_task.tasks1 import test_celery</span><br><span class="line">from celery_task.tasks2 import test_celery2</span><br><span class="line"></span><br><span class="line"># 立即告知celery去执行test_celery任务，并传入一个参数</span><br><span class="line">result &#x3D; test_celery.delay(&#39;第一个的执行&#39;)</span><br><span class="line">print(result.id)</span><br><span class="line">result &#x3D; test_celery2.delay(&#39;第二个的执行&#39;)</span><br><span class="line">print(result.id)</span><br></pre>

<p>添加任务（执行send_task.py），开启work：celery worker -A celery_task -l info -P eventlet，检查任务执行结果（执行check_result.py）</p>
<h2 id="Celery执行定时任务"><a href="#Celery执行定时任务" class="headerlink" title="Celery执行定时任务"></a>Celery执行定时任务</h2><h3 id="设定时间让celery执行一个任务"><a href="#设定时间让celery执行一个任务" class="headerlink" title="设定时间让celery执行一个任务"></a>设定时间让celery执行一个任务</h3><h3 id="add-task-py"><a href="#add-task-py" class="headerlink" title="add_task.py"></a>add_task.py</h3><pre class="highlight"><span class="line">from celery_app_task import add</span><br><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line"># 方式一</span><br><span class="line"># v1 &#x3D; datetime(2019, 2, 13, 18, 19, 56)</span><br><span class="line"># print(v1)</span><br><span class="line"># v2 &#x3D; datetime.utcfromtimestamp(v1.timestamp())</span><br><span class="line"># print(v2)</span><br><span class="line"># result &#x3D; add.apply_async(args&#x3D;[1, 3], eta&#x3D;v2)</span><br><span class="line"># print(result.id)</span><br><span class="line"></span><br><span class="line"># 方式二</span><br><span class="line">ctime &#x3D; datetime.now()</span><br><span class="line"># 默认用utc时间</span><br><span class="line">utc_ctime &#x3D; datetime.utcfromtimestamp(ctime.timestamp())</span><br><span class="line">from datetime import timedelta</span><br><span class="line">time_delay &#x3D; timedelta(seconds&#x3D;10)</span><br><span class="line">task_time &#x3D; utc_ctime + time_delay</span><br><span class="line"></span><br><span class="line"># 使用apply_async并设定时间</span><br><span class="line">result &#x3D; add.apply_async(args&#x3D;[4, 3], eta&#x3D;task_time)</span><br><span class="line">print(result.id)</span><br></pre>

<h3 id="类似于crontab的定时任务"><a href="#类似于crontab的定时任务" class="headerlink" title="类似于crontab的定时任务"></a>类似于crontab的定时任务</h3><h3 id="多任务结构中celery-py修改如下"><a href="#多任务结构中celery-py修改如下" class="headerlink" title="多任务结构中celery.py修改如下"></a>多任务结构中celery.py修改如下</h3><pre class="highlight"><span class="line">from datetime import timedelta</span><br><span class="line">from celery import Celery</span><br><span class="line">from celery.schedules import crontab</span><br><span class="line"></span><br><span class="line">cel &#x3D; Celery(&#39;tasks&#39;, broker&#x3D;&#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;1&#39;, backend&#x3D;&#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;2&#39;, include&#x3D;[</span><br><span class="line">    &#39;celery_task.tasks1&#39;,</span><br><span class="line">    &#39;celery_task.tasks2&#39;,</span><br><span class="line">])</span><br><span class="line">cel.conf.timezone &#x3D; &#39;Asia&#x2F;Shanghai&#39;</span><br><span class="line">cel.conf.enable_utc &#x3D; False</span><br><span class="line"></span><br><span class="line">cel.conf.beat_schedule &#x3D; &#123;</span><br><span class="line">    # 名字随意命名</span><br><span class="line">    &#39;add-every-10-seconds&#39;: &#123;</span><br><span class="line">        # 执行tasks1下的test_celery函数</span><br><span class="line">        &#39;task&#39;: &#39;celery_task.tasks1.test_celery&#39;,</span><br><span class="line">        # 每隔2秒执行一次</span><br><span class="line">        # &#39;schedule&#39;: 1.0,</span><br><span class="line">        # &#39;schedule&#39;: crontab(minute&#x3D;&quot;*&#x2F;1&quot;),</span><br><span class="line">        &#39;schedule&#39;: timedelta(seconds&#x3D;2),</span><br><span class="line">        # 传递参数</span><br><span class="line">        &#39;args&#39;: (&#39;test&#39;,)</span><br><span class="line">    &#125;,</span><br><span class="line">    # &#39;add-every-12-seconds&#39;: &#123;</span><br><span class="line">    #     &#39;task&#39;: &#39;celery_task.tasks1.test_celery&#39;,</span><br><span class="line">    #     每年4月11号，8点42分执行</span><br><span class="line">    #     &#39;schedule&#39;: crontab(minute&#x3D;42, hour&#x3D;8, day_of_month&#x3D;11, month_of_year&#x3D;4),</span><br><span class="line">    #     &#39;schedule&#39;: crontab(minute&#x3D;42, hour&#x3D;8, day_of_month&#x3D;11, month_of_year&#x3D;4),</span><br><span class="line">    #     &#39;args&#39;: (16, 16)</span><br><span class="line">    # &#125;,</span><br><span class="line">&#125;</span><br></pre>
<h3 id="启动一个beat：celery-beat-A-celery-task-l-info"><a href="#启动一个beat：celery-beat-A-celery-task-l-info" class="headerlink" title="启动一个beat：celery beat -A celery_task -l info"></a>启动一个beat：celery beat -A celery_task -l info</h3><h3 id="启动work执行：celery-worker-A-celery-task-l-info-P-eventlet"><a href="#启动work执行：celery-worker-A-celery-task-l-info-P-eventlet" class="headerlink" title="启动work执行：celery worker -A celery_task -l info -P eventlet"></a>启动work执行：celery worker -A celery_task -l info -P eventlet</h3><h2 id="Django中使用Celery"><a href="#Django中使用Celery" class="headerlink" title="Django中使用Celery"></a>Django中使用Celery</h2><h3 id="在项目目录下创建celeryconfig-py"><a href="#在项目目录下创建celeryconfig-py" class="headerlink" title="在项目目录下创建celeryconfig.py"></a>在项目目录下创建celeryconfig.py</h3><pre class="highlight"><span class="line">djcelery.setup_loader()</span><br><span class="line">CELERY_IMPORTS&#x3D;(</span><br><span class="line">    &#39;app01.tasks&#39;,</span><br><span class="line">)</span><br><span class="line">#有些情况可以防止死锁</span><br><span class="line">CELERYD_FORCE_EXECV&#x3D;True</span><br><span class="line"># 设置并发worker数量</span><br><span class="line">CELERYD_CONCURRENCY&#x3D;4</span><br><span class="line">#允许重试</span><br><span class="line">CELERY_ACKS_LATE&#x3D;True</span><br><span class="line"># 每个worker最多执行100个任务被销毁，可以防止内存泄漏</span><br><span class="line">CELERYD_MAX_TASKS_PER_CHILD&#x3D;100</span><br><span class="line"># 超时时间</span><br><span class="line">CELERYD_TASK_TIME_LIMIT&#x3D;12*30</span><br></pre>

<h3 id="在app01目录下创建tasks-py"><a href="#在app01目录下创建tasks-py" class="headerlink" title="在app01目录下创建tasks.py"></a>在app01目录下创建tasks.py</h3><pre class="highlight"><span class="line">from celery import task</span><br><span class="line">@task</span><br><span class="line">def add(a,b):</span><br><span class="line">    with open(&#39;a.text&#39;, &#39;a&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">        f.write(&#39;a&#39;)</span><br><span class="line">    print(a+b)</span><br></pre>

<h3 id="视图函数views-py"><a href="#视图函数views-py" class="headerlink" title="视图函数views.py"></a>视图函数views.py</h3><pre class="highlight"><span class="line">from django.shortcuts import render,HttpResponse</span><br><span class="line">from app01.tasks import add</span><br><span class="line">from datetime import datetime</span><br><span class="line">def test(request):</span><br><span class="line">    # result&#x3D;add.delay(2,3)</span><br><span class="line">    ctime &#x3D; datetime.now()</span><br><span class="line">    # 默认用utc时间</span><br><span class="line">    utc_ctime &#x3D; datetime.utcfromtimestamp(ctime.timestamp())</span><br><span class="line">    from datetime import timedelta</span><br><span class="line">    time_delay &#x3D; timedelta(seconds&#x3D;5)</span><br><span class="line">    task_time &#x3D; utc_ctime + time_delay</span><br><span class="line">    result &#x3D; add.apply_async(args&#x3D;[4, 3], eta&#x3D;task_time)</span><br><span class="line">    print(result.id)</span><br><span class="line">    return HttpResponse(&#39;ok&#39;)</span><br></pre>
<h3 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a>settings.py</h3><pre class="highlight"><span class="line">#INSTALLED_APPS &#x3D; [</span><br><span class="line">#    &#39;djcelery&#39;,</span><br><span class="line">#    &#39;app01&#39;</span><br><span class="line">#]</span><br><span class="line"></span><br><span class="line">from djagocele import celeryconfig</span><br><span class="line">BROKER_BACKEND&#x3D;&#39;redis&#39;</span><br><span class="line">BOOKER_URL&#x3D;&#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;1&#39;</span><br><span class="line">CELERY_RESULT_BACKEND&#x3D;&#39;redis:&#x2F;&#x2F;127.0.0.1:6379&#x2F;2&#39;</span><br></pre>

]]></content>
      <categories>
        <category>celery</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django + uWSGI + Nginx 的生产环境部署，及WSGI &amp; uwsgi &amp; uWSGI 的作用</title>
    <url>/2020/08/29/Django%20+%20uWSGI%20+%20Nginx%20%E7%9A%84%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%8F%8AWSGI%20&amp;%20uwsgi%20&amp;%20uWSGI%20%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>uWSGI的 <a href="https://blog.csdn.net/weixin_44685869/article/details/103951161" target="_blank" rel="noopener">介绍 看这里</a></p>
<h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><ol>
<li>Nginx是一个Web服务器,其中的HTTP服务器功能和uWSGI功能很类似</li>
<li>但是Nginx还可以用作更多用途，比如最常用的反向代理、负载均衡、拦截攻击等，而且性能极高</li>
</ol>
<h4 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h4><ol>
<li>Django是一个Web框架，框架的作用在于处理request和 reponse，其他的不是框架所关心的内容。</li>
<li>所以如何部署Django不是Django所需要关心的。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200304220900982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200304220900982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<pre class="highlight"><span class="line">这里举个小例子：</span><br><span class="line">我们的浏览器是 出生在海外的华侨，通过HTTP(飞机) 从 Nginx(日本) 回到  (Python 中国)</span><br><span class="line">下飞机 到了之后发现语言不通，急忙的找到了我。</span><br><span class="line">他说日语(uwsgi)“こんにちは“</span><br><span class="line">我会日语啊 我把这句话 转换成了 汉语(uWSGI)给 别人听</span><br><span class="line">这样就可以 在 中国(Python) 让日本人(浏览器) 生活了。</span><br><span class="line">但是 博主是东北人 光会转义 日语-&gt;普通话 还不行 还要和我的家人们说东北话(WSGI)</span><br><span class="line">此时 就已经非常完美的解决了语言不通的问题了。</span><br><span class="line">12345678</span><br></pre>

<ul>
<li>请求处理整体流程</li>
</ul>
<ol>
<li>nginx接收到浏览器发送过来的http请求，将包进行解析，分析url</li>
<li>静态文件请求：就直接访问用户给nginx配置的静态文件目录，直接返回用户请求的静态文件</li>
<li>动态接口请求：那么nginx就将请求转发给uWSGI，最后到达django处理</li>
</ol>
<ul>
<li>各模块作用</li>
</ul>
<ol>
<li><p>nginx：是对外的服务器，外部浏览器通过url访问nginx，nginx主要处理静态请求</p>
</li>
<li><p>uWSGI：是对内的服务器，主要用来处理动态请求</p>
</li>
<li><p>uwsgi：是一种web协议，接收到请求之后将包进行处理，处理成wsgi可以接受的格式，并发给wsgi</p>
</li>
<li><p>wsgi：是python专用的web协议，根据请求调用应用程序（django）的某个文件，某个文件的某个函数</p>
</li>
<li><p>django：是真正干活的，查询数据等资源，把处理的结果再次返回给WSGI， WSGI 将返回值进行打包，打包成uwsgi能够接收的格式</p>
</li>
<li><p>uwsgi接收wsgi发送的请求，并转发给nginx,nginx最终将返回值返回给浏览器</p>
</li>
</ol>
<h3 id="Django-uwsgi方案"><a href="#Django-uwsgi方案" class="headerlink" title="Django + uwsgi方案"></a>Django + uwsgi方案</h3><ol>
<li>没有nginx而只有uwsgi的服务器，则是Internet请求直接由uwsgi处理，并反馈到web项目中。</li>
<li>nginx可以实现安全过滤，防DDOS等保护安全的操作，并且如果配置了多台服务器，nginx可以保证服务器的负载相对均衡。</li>
<li>而uwsgi则是一个web服务器，实现了WSGI协议(Web Server Gateway Interface)，http协议等，它可以接收和处理请求，发出响应等。<br>所以只用uwsgi也是可以的。</li>
</ol>
<h3 id="nginx和uWSGI特点"><a href="#nginx和uWSGI特点" class="headerlink" title="nginx和uWSGI特点"></a>nginx和uWSGI特点</h3><ul>
<li>nginx的作用</li>
</ul>
<ol>
<li>反向代理，可以拦截一些web攻击，保护后端的web服务器</li>
<li>负载均衡，根据轮询算法，分配请求到多节点web服务器</li>
<li>缓存静态资源，加快访问速度，释放web服务器的内存占用，专项专用</li>
</ol>
<ul>
<li>uWSGI的适用</li>
</ul>
<ol>
<li><p>单节点服务器的简易部署</p>
</li>
<li><p>轻量级，好部署</p>
</li>
</ol>
<p>Django + Uwsgi + Nginx 的生产环境部署</p>
<h4 id="在centos-7中安装python3环境"><a href="#在centos-7中安装python3环境" class="headerlink" title="在centos 7中安装python3环境"></a>在centos 7中安装python3环境</h4><pre class="highlight"><span class="line"><span class="comment"># 1、yum更新yum源</span></span><br><span class="line">yum update</span><br><span class="line"><span class="comment"># 2、安装Python 3.7所需的依赖否则安装后没有pip3包</span></span><br><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make</span><br><span class="line"><span class="comment"># 3、在官网下载所需版本，这里用的是3.7.0版本</span></span><br><span class="line">wget https://www.python.org/ftp/<span class="number">3.7</span><span class="number">.0</span>/Python<span class="number">-3.7</span><span class="number">.0</span>.tgz</span><br><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="comment"># 1、yum更新yum源</span></span><br><span class="line">yum update</span><br><span class="line"><span class="comment"># 2、安装Python 3.7所需的依赖否则安装后没有pip3包</span></span><br><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make</span><br><span class="line"><span class="comment"># 3、在官网下载所需版本，这里用的是3.7.0版本</span></span><br><span class="line">wget https://www.python.org/ftp/<span class="number">3.7</span><span class="number">.0</span>/Python<span class="number">-3.7</span><span class="number">.0</span>.tgz</span><br><span class="line">　　<span class="number">2</span>、安装Python</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、解压</span></span><br><span class="line">tar -xvf Python<span class="number">-3.7</span><span class="number">.0</span>.tgz</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、配置编译</span></span><br><span class="line">cd Python<span class="number">-3.7</span><span class="number">.0</span></span><br><span class="line">./configure --prefix=/usr/local/python3  <span class="comment"># 配置编译的的路径（这里--prefix是指定编译安装的文件夹）</span></span><br><span class="line">./configure --enable-optimizations  <span class="comment"># 执行该代码后，会编译安装到 /usr/local/bin/ 下，且不用添加软连接或环境变量</span></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">ln -s /usr/local/python3/bin/python3 /usr/bin/python3  <span class="comment"># 添加软连接</span></span><br><span class="line">ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、将/usr/local/python3/bin加入PATH</span></span><br><span class="line">[root@linux-node1 testProj]<span class="comment"># vim /etc/profile</span></span><br><span class="line"><span class="comment">#然后在文件末尾添加</span></span><br><span class="line">export PATH=$PATH:/usr/local/python3/bin</span><br><span class="line"></span><br><span class="line">[root@linux-node1 testProj]<span class="comment"># source /etc/profile # 修改完后，还需要让这个环境变量在配置信息中生效，执行命令</span></span><br></pre>

<h4 id="初始化一个django项目"><a href="#初始化一个django项目" class="headerlink" title="初始化一个django项目"></a>初始化一个django项目</h4><pre class="highlight"><span class="line"><span class="comment"># 初始化一个django项目</span></span><br><span class="line"></span><br><span class="line">[root@linux-node1 /] pip3 install django==<span class="number">2.0</span><span class="number">.4</span></span><br><span class="line">[root@linux-node1 /] mkdir /code/</span><br><span class="line">[root@linux-node1 /] cd /code/</span><br><span class="line">[root@linux-node1 testProj] django-admin startproject mmcsite</span><br><span class="line">[root@linux-node1 testProj] cd /code/mmcsite</span><br><span class="line">[root@linux-node1 testProj] python3 manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span></span><br><span class="line"></span><br><span class="line">页面中访问：http://<span class="number">192.168</span><span class="number">.56</span><span class="number">.11</span>:<span class="number">8000</span>/</span><br></pre>

<h4 id="安装uwsgi-并使用uWSGI启动这个服务"><a href="#安装uwsgi-并使用uWSGI启动这个服务" class="headerlink" title="安装uwsgi 并使用uWSGI启动这个服务"></a>安装uwsgi 并使用uWSGI启动这个服务</h4><pre class="highlight"><span class="line"><span class="string">'''1. 安装uwsgi'''</span></span><br><span class="line">[root@linux-node1 /]<span class="comment"># pip3 install uwsgi</span></span><br><span class="line">[root@linux-node1 /]<span class="comment"># ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''2. 配置uwsgi.ini启动文件'''</span></span><br><span class="line">[root@linux-node1 /]<span class="comment"># vim uwsgi.ini</span></span><br><span class="line">[uwsgi]</span><br><span class="line">socket = <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">3031</span></span><br><span class="line">chdir = /code/mmcsite</span><br><span class="line">wsgi-file = /code/mmcsite/wsgi.py</span><br><span class="line">processes = <span class="number">5</span></span><br><span class="line">threads = <span class="number">30</span></span><br><span class="line">master = true</span><br><span class="line">daemonize = /code/mmcsite/uwsgi.log</span><br><span class="line">module=mmcsite.wsgi</span><br><span class="line">pidfile = /code/mmcsite/uwsgi.pid</span><br><span class="line">chmod-socket=<span class="number">666</span></span><br><span class="line">enable-threads = true</span><br><span class="line"></span><br><span class="line"><span class="string">'''3. 使用uwsgi启动django：一定要在这个项目目录中'''</span></span><br><span class="line">[root@linux-node1 /]<span class="comment"># uwsgi --http 192.168.56.11:80 --file mmcsite/wsgi.py --static-map=/static=static</span></span><br><span class="line">访问项目：http://<span class="number">192.168</span><span class="number">.56</span><span class="number">.11</span></span><br><span class="line"></span><br><span class="line">[root@linux-node2 demo2]<span class="comment"># vim /code/mmcsite/uwsgi.ini  # uwsgi.ini文件</span></span><br><span class="line">[uwsgi]</span><br><span class="line">socket = <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">3031</span>                  <span class="comment"># 指定socket监听的地址和端口</span></span><br><span class="line">chdir = /code/mmcsite                  <span class="comment"># 项目路径 </span></span><br><span class="line">wsgi-file = /code/mmcsite/wsgi.py      <span class="comment"># django的wsgi文件路径</span></span><br><span class="line">processes = <span class="number">5</span>                          <span class="comment"># 启动五个进程</span></span><br><span class="line">threads = <span class="number">30</span>                           <span class="comment"># 每个进程启动30个线程</span></span><br><span class="line">master = true</span><br><span class="line">daemonize = /code/mmcsite/uwsgi.log    <span class="comment"># 日志存放路径</span></span><br><span class="line">module=mmcsite.wsgi                    <span class="comment"># 使用mmcsite.wsgi模块</span></span><br><span class="line">pidfile = /code/mmcsite/uwsgi.pid      <span class="comment"># uwsgi启动进程id存放路径</span></span><br><span class="line">chmod-socket=<span class="number">666</span>                       <span class="comment"># socket权限</span></span><br><span class="line">enable-threads = true                  <span class="comment"># 允许用内嵌的语言启动线程，这将允许你在app程序中产生一个子线程</span></span><br></pre>

<h4 id="安装配置nginx"><a href="#安装配置nginx" class="headerlink" title="安装配置nginx"></a>安装配置nginx</h4><pre class="highlight"><span class="line"><span class="string">'''1. 配置nginx YUM源'''</span></span><br><span class="line">[root@linux-node1 /] vim /etc/yum.repos.d/nginx.repo</span><br><span class="line"><span class="number">12</span></span><br></pre>

<p>[nginx]<br>name=nginx repo</p>
<h1 id="下面这行centos根据你自己的操作系统修改比如：OS-rehel"><a href="#下面这行centos根据你自己的操作系统修改比如：OS-rehel" class="headerlink" title="下面这行centos根据你自己的操作系统修改比如：OS/rehel"></a>下面这行centos根据你自己的操作系统修改比如：OS/rehel</h1><h1 id="6是你Linux系统的版本，可以通过URL查看路径是否正确"><a href="#6是你Linux系统的版本，可以通过URL查看路径是否正确" class="headerlink" title="6是你Linux系统的版本，可以通过URL查看路径是否正确"></a>6是你Linux系统的版本，可以通过URL查看路径是否正确</h1><p>baseurl=<a href="http://nginx.org/packages/centos/7/$basearch/" target="_blank" rel="noopener">http://nginx.org/packages/centos/7/$basearch/</a><br>gpgcheck=0<br>enabled=1</p>
<pre class="highlight"><span class="line">&#39;&#39;&#39;2. 安装nginx&#39;&#39;&#39;</span><br><span class="line">[root@linux-node1 &#x2F;] yum -y install nginx</span><br><span class="line"></span><br><span class="line">安装nginx</span><br><span class="line">1234</span><br><span class="line">[root@linux-node1 &#x2F;]# vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;django.conf </span><br><span class="line">server &#123;</span><br><span class="line">    listen       8888;</span><br><span class="line">    server_name  192.168.56.11;</span><br><span class="line">    client_max_body_size 5M;</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_buffers 32 4K;#压缩在内存中缓冲32块 每块4K</span><br><span class="line">    gzip_comp_level 6 ;#压缩级别 推荐6</span><br><span class="line">    gzip_min_length 4000;#开始压缩的最小长度4bit</span><br><span class="line">        gzip_types text&#x2F;plain application&#x2F;json application&#x2F;javascript application&#x2F;x-javascript application&#x2F;css application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript application&#x2F;x-httpd-php image&#x2F;jpeg image&#x2F;gif image&#x2F;png image&#x2F;x-ms-bmp;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">              include uwsgi_params;</span><br><span class="line">              uwsgi_pass 127.0.0.1:3031;</span><br><span class="line">              uwsgi_ignore_client_abort on;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 &#x2F;404.html;</span><br><span class="line">            location &#x3D; &#x2F;40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 &#x2F;50x.html;</span><br><span class="line">            location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">配置nginx</span><br></pre>

<h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><pre class="highlight"><span class="line">[root@linux-node1 demo2]<span class="comment"># systemctl restart nginx   # 开启nginx</span></span><br><span class="line">[root@linux-node1 demo2]<span class="comment"># uwsgi --ini uwsgi.ini     # 启动uwsgi的django项目</span></span><br><span class="line"><span class="comment"># http://192.168.56.11:8888/ 访问项目</span></span><br><span class="line">[root@linux-node1 demo2]<span class="comment"># uwsgi --stop uwsgi.pid    # 关闭uwsgi</span></span><br></pre>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django HTTP Request对象 和 HTTP Response 对象</title>
    <url>/2020/06/04/Django%20HTTP%20Request%E5%AF%B9%E8%B1%A1%20%E5%92%8C%20HTTP%20Response%20%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="HttpRequest对象"><a href="#HttpRequest对象" class="headerlink" title="HttpRequest对象"></a>HttpRequest对象</h3><p>回想一下，利用HTTP协议向服务器传参有几种途径？</p>
<ul>
<li>提取URL的特定部分，如/weather/beijing/2018，可以在服务器端的路由中用正则表达式截取；</li>
<li>查询字符串（query string)，形如key1=value1&amp;key2=value2；</li>
<li>请求体（body）中发送的数据，比如表单数据、json、xml；</li>
<li>在http报文的头（header）中。</li>
</ul>
<h3 id="1-URL路径参数"><a href="#1-URL路径参数" class="headerlink" title="1 URL路径参数"></a>1 URL路径参数</h3><ul>
<li><p>如果想从URL中获取值，需要在正则表达式中使用分组，</p>
</li>
<li><p>获取值分为两种方式</p>
<ul>
<li>位置参数<br>参数的位置不能错</li>
<li>关键字参数<br>参数的位置可以变，跟关键字保持一致即可</li>
</ul>
</li>
<li><p>注意：两种参数的方式不要混合使用，在一个正则表达式中只能使用一种参数方式</p>
</li>
<li><p>分别使用以上两种获取URL值的方式提取出<code>18 188</code></p>
<pre class="highlight"><span class="line">http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/<span class="number">18</span>/<span class="number">188</span>/</span><br><span class="line"><span class="number">1</span></span><br></pre>

</li>
</ul>
<h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><ul>
<li><p>应用中urls.py</p>
<pre class="highlight"><span class="line">url(<span class="string">r'^(\d+)/(\d+)/$'</span>, views.index),</span><br><span class="line"><span class="number">1</span></span><br></pre>
</li>
<li><p>视图中函数: 参数的位置不能错</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request, value1, value2)</span>:</span></span><br><span class="line">	<span class="comment"># 构造上下文</span></span><br><span class="line">	context = &#123;<span class="string">'v1'</span>:value1, <span class="string">'v2'</span>:value2&#125;</span><br><span class="line">	<span class="keyword">return</span> render(request, <span class="string">'Book/index.html'</span>, context)</span><br><span class="line"><span class="number">1234</span></span><br></pre>

</li>
</ul>
<h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><ul>
<li><p>应用中urls.py</p>
<p>其中 <code>?P</code> 部分表示为这个参数定义的名称为value1<br>可以是其它名称，起名要做到见名知意</p>
<pre class="highlight"><span class="line">url(<span class="string">r'^(?P&lt;value1&gt;\d+)/(?P&lt;value2&gt;\d+)/$'</span>, views.index),</span><br><span class="line"><span class="number">1</span></span><br></pre>
</li>
<li><p>视图中函数: 参数的位置可以变，跟关键字保持一致即可</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request, value2, value1)</span>:</span></span><br><span class="line">       <span class="comment"># 构造上下文</span></span><br><span class="line">    context = &#123;<span class="string">'v1'</span>:value1, <span class="string">'v2'</span>:value2&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'Book/index.html'</span>, context)</span><br><span class="line"><span class="number">1234</span></span><br></pre>

</li>
</ul>
<h3 id="2-Django中的QueryDict对象"><a href="#2-Django中的QueryDict对象" class="headerlink" title="2 Django中的QueryDict对象"></a>2 Django中的QueryDict对象</h3><p>HttpRequest对象的属性GET、POST都是QueryDict类型的对象</p>
<p>与python字典不同，QueryDict类型的对象用来处理同一个键带有多个值的情况</p>
<ul>
<li><p>方法get()：根据键获取值</p>
<p>如果一个键同时拥有多个值将获取最后一个值</p>
<p>如果键不存在则返回None值，可以设置默认值进行后续处理</p>
<pre class="highlight"><span class="line">get(<span class="string">'键'</span>,默认值)</span><br><span class="line"><span class="number">1</span></span><br></pre>
</li>
<li><p>方法getlist()：根据键获取值，值以列表返回，可以获取指定键的所有值</p>
<p>如果键不存在则返回空列表[]，可以设置默认值进行后续处理</p>
<pre class="highlight"><span class="line">getlist(<span class="string">'键'</span>,默认值)</span><br><span class="line"><span class="number">1</span></span><br></pre>

</li>
</ul>
<h3 id="3-查询字符串Query-String"><a href="#3-查询字符串Query-String" class="headerlink" title="3. 查询字符串Query String"></a>3. 查询字符串Query String</h3><p>获取请求路径中的查询字符串参数（形如?k1=v1&amp;k2=v2），可以通过request.GET属性获取，返回QueryDict对象。</p>
<pre class="highlight"><span class="line"><span class="comment"># /get/?a=1&amp;b=2&amp;a=3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(request)</span>:</span></span><br><span class="line">    a = request.GET.get(<span class="string">'a'</span>)</span><br><span class="line">    b = request.GET.get(<span class="string">'b'</span>)</span><br><span class="line">    alist = request.GET.getlist(<span class="string">'a'</span>)</span><br><span class="line">    print(a)  <span class="comment"># 3</span></span><br><span class="line">    print(b)  <span class="comment"># 2</span></span><br><span class="line">    print(alist)  <span class="comment"># ['1', '3']</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'OK'</span>)</span><br><span class="line"><span class="number">12345678910</span></span><br><span class="line">重要：查询字符串不区分请求方式，即假使客户端进行POST方式的请求，依然可以通过request.GET获取请求中的查询字符串数据。</span><br></pre>

<h3 id="4-请求体"><a href="#4-请求体" class="headerlink" title="4 请求体"></a>4 请求体</h3><p>请求体数据格式不固定，可以是表单类型字符串，可以是<code>JSON</code>字符串，可以是<code>XML</code>字符串，应区别对待。</p>
<p>可以发送请求体数据的请求方式有 <code>POST、PUT、PATCH、DELETE</code>。</p>
<p><code>Django默认开启了CSRF防护</code>，会对上述请求方式进行CSRF防护验证，在测试时可以关闭CSRF防护机制，方法为在settings.py文件中注释掉CSRF中间件，如：<br><img src="https://img-blog.csdnimg.cn/20200424150124899.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200424150124899.png" class="lozad post-image"></p>
<h4 id="4-1-表单类型-Form-Data"><a href="#4-1-表单类型-Form-Data" class="headerlink" title="4.1 表单类型 Form Data"></a>4.1 表单类型 Form Data</h4><p>前端发送的表单类型的请求体数据，可以通过request.POST属性获取，返回QueryDict对象。</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(request)</span>:</span></span><br><span class="line">    a = request.POST.get(<span class="string">'a'</span>)</span><br><span class="line">    b = request.POST.get(<span class="string">'b'</span>)</span><br><span class="line">    alist = request.POST.getlist(<span class="string">'a'</span>)</span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    print(alist)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'OK'</span>)</span><br><span class="line"><span class="number">12345678</span></span><br></pre>

<h4 id="4-2-非表单类型-Non-Form-Data"><a href="#4-2-非表单类型-Non-Form-Data" class="headerlink" title="4.2 非表单类型 Non-Form Data"></a>4.2 非表单类型 Non-Form Data</h4><p>非表单类型的请求体数据，Django无法自动解析，可以通过request.body属性获取最原始的请求体数据，自己按照请求体格式（JSON、XML等）进行解析。request.body返回bytes类型。</p>
<p>例如要获取请求体中的如下JSON数据</p>
<pre class="highlight"><span class="line">&#123;<span class="string">"a"</span>: <span class="number">1</span>, <span class="string">"b"</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="number">1</span></span><br></pre>

<p>可以进行如下方法操作：</p>
<pre class="highlight"><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_json</span><span class="params">(request)</span>:</span></span><br><span class="line">    json_str = request.body</span><br><span class="line">    json_str = json_str.decode()  <span class="comment"># python3.6 无需执行此步</span></span><br><span class="line">    req_data = json.loads(json_str)</span><br><span class="line">    print(req_data[<span class="string">'a'</span>])</span><br><span class="line">    print(req_data[<span class="string">'b'</span>])</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'OK'</span>)</span><br><span class="line"><span class="number">123456789</span></span><br></pre>

<h3 id="5-请求头"><a href="#5-请求头" class="headerlink" title="5 请求头"></a>5 请求头</h3><p>可以通过request.META属性获取请求头headers中的数据，request.META为字典类型。</p>
<p>常见的请求头如：</p>
<ul>
<li>CONTENT_LENGTH– The length of the request body (as a string).</li>
<li>CONTENT_TYPE– The MIME type of the request body.</li>
<li>HTTP_ACCEPT– Acceptable content types for the response.</li>
<li>HTTP_ACCEPT_ENCODING– Acceptable encodings for the response.</li>
<li>HTTP_ACCEPT_LANGUAGE– Acceptable languages for the response.</li>
<li>HTTP_HOST– The HTTP Host header sent by the client.</li>
<li>HTTP_REFERER– The referring page, if any.</li>
<li>HTTP_USER_AGENT– The client’s user-agent string.</li>
<li>QUERY_STRING– The query string, as a single (unparsed) string.</li>
<li>REMOTE_ADDR– The IP address of the client.</li>
<li>REMOTE_HOST– The hostname of the client.</li>
<li>REMOTE_USER– The user authenticated by the Web server, if any.</li>
<li>REQUEST_METHOD– A string such as”GET”or”POST”.</li>
<li>SERVER_NAME– The hostname of the server.</li>
<li>SERVER_PORT– The port of the server (as a string).</li>
</ul>
<p>具体使用如:</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_headers</span><span class="params">(request)</span>:</span></span><br><span class="line">    print(request.META[<span class="string">'CONTENT_TYPE'</span>])</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'OK'</span>)</span><br><span class="line"><span class="number">123</span></span><br></pre>

<h3 id="6-其他常用HttpRequest对象属性"><a href="#6-其他常用HttpRequest对象属性" class="headerlink" title="6 其他常用HttpRequest对象属性"></a>6 其他常用HttpRequest对象属性</h3><ul>
<li><p>method：一个字符串，表示请求使用的HTTP方法，常用值包括：‘GET’、‘POST’。</p>
</li>
<li><p>user：请求的用户对象。</p>
</li>
<li><p>path：一个字符串，表示请求的页面的完整路径，不包含域名和参数部分。</p>
</li>
<li><p>encoding：一个字符串，表示提交的数据的编码方式。</p>
<p>如果为None则表示使用浏览器的默认设置，一般为utf-8。<br>这个属性是可写的，可以通过修改它来修改访问表单数据使用的编码，接下来对属性的任何访问将使用新的encoding值。</p>
</li>
<li><p>FILES：一个类似于字典的对象，包含所有的上传文件。</p>
</li>
</ul>
<hr>
<h3 id="HttpResponse对象"><a href="#HttpResponse对象" class="headerlink" title="HttpResponse对象"></a>HttpResponse对象</h3><p>视图在接收请求并处理后，必须返回HttpResponse对象或子对象。HttpRequest对象由Django创建，HttpResponse对象由开发人员创建。</p>
<h4 id="1-HttpResponse"><a href="#1-HttpResponse" class="headerlink" title="1 HttpResponse"></a>1 HttpResponse</h4><p>可以使用 <code>django.http.HttpResponse</code> 来构造响应对象。</p>
<pre class="highlight"><span class="line">HttpResponse(content=响应体, content_type=响应体数据类型, status=状态码)</span><br><span class="line"><span class="number">1</span></span><br></pre>

<p>也可通过HttpResponse对象属性来设置响应体、响应体数据类型、状态码：</p>
<ul>
<li>content：表示返回的内容。</li>
<li>status_code：返回的HTTP响应状态码。</li>
<li>content_type：指定返回数据的的MIME类型。</li>
</ul>
<p>响应头可以直接将HttpResponse对象当做字典进行响应头键值对的设置：</p>
<pre class="highlight"><span class="line">response = HttpResponse()</span><br><span class="line">response[<span class="string">'itcast'</span>] = <span class="string">'Python'</span>  <span class="comment"># 自定义响应头Itcast, 值为Python</span></span><br><span class="line"><span class="number">12</span></span><br></pre>

<p>示例：</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">response</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'itcast python'</span>, status=<span class="number">400</span>)</span><br><span class="line">    或者</span><br><span class="line">    response = HttpResponse(<span class="string">'itcast python'</span>)</span><br><span class="line">    response.status_code = <span class="number">400</span></span><br><span class="line">    response[<span class="string">'itcast'</span>] = <span class="string">'Python'</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"><span class="number">123456789</span></span><br></pre>

<h4 id="2-HttpResponse子类"><a href="#2-HttpResponse子类" class="headerlink" title="2 HttpResponse子类"></a>2 HttpResponse子类</h4><p>Django提供了一系列HttpResponse的子类，可以快速设置状态码</p>
<ul>
<li>HttpResponseRedirect 301</li>
<li>HttpResponsePermanentRedirect 302</li>
<li>HttpResponseNotModified 304</li>
<li>HttpResponseBadRequest 400</li>
<li>HttpResponseNotFound 404</li>
<li>HttpResponseForbidden 403</li>
<li>HttpResponseNotAllowed 405</li>
<li>HttpResponseGone 410</li>
<li>HttpResponseServerError 500</li>
</ul>
<h4 id="3-JsonResponse"><a href="#3-JsonResponse" class="headerlink" title="3 JsonResponse"></a>3 JsonResponse</h4><p>若要返回json数据，可以使用JsonResponse来构造响应对象，作用：</p>
<ul>
<li>帮助我们将数据转换为json字符串</li>
<li>设置响应头Content-Type为application/json</li>
</ul>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">response</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">'city'</span>: <span class="string">'beijing'</span>, <span class="string">'subject'</span>: <span class="string">'python'</span>&#125;)</span><br><span class="line"><span class="number">1234</span></span><br></pre>

<h4 id="4-redirect重定向"><a href="#4-redirect重定向" class="headerlink" title="4 redirect重定向"></a>4 redirect重定向</h4><pre class="highlight"><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">response</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">'/get_header'</span>)</span><br></pre>

]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 创建使用 整体流程</title>
    <url>/2020/02/10/Django%20%E5%88%9B%E5%BB%BA%E4%BD%BF%E7%94%A8%20%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>之前的几篇博客 介绍了 Django中的各个详细使用流程，我们 这命令 全部整合 起来，并且 加入数据进行测试。</p>
<p>整体流程：<code>创建项目 + 创建应用 + 安装应用 + 配置模板路径 + 本地化 + mysql数据库 + URLconf + 视图</code></p>
<h3 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h3><ol>
<li><p>创建项目</p>
<pre class="highlight"><span class="line">django-admin startproject bookmanager</span><br></pre>
</li>
<li><p>创建应用</p>
<pre class="highlight"><span class="line">python manager.py startapp book</span><br></pre>
</li>
<li><p>更换python解释器：按需选择</p>
<pre class="highlight"><span class="line"><span class="comment"># 进入指定虚拟环境</span></span><br><span class="line">which python</span><br><span class="line"></span><br><span class="line"><span class="comment"># python2</span></span><br><span class="line">/home/python/.virtualenvs/py_django/bin/python</span><br><span class="line"></span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line">/home/python/.virtualenvs/py3_django/bin/python</span><br></pre>
</li>
<li><p>安装应用</p>
<pre class="highlight"><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">    <span class="comment">#添加子应用</span></span><br><span class="line">    <span class="string">'book.apps.BookConfig'</span></span><br><span class="line">]</span><br></pre>
</li>
<li><p>本地化</p>
<pre class="highlight"><span class="line"><span class="comment">#设置中文</span></span><br><span class="line">LANGUAGE_CODE = <span class="string">'zh-Hans'</span></span><br><span class="line"><span class="comment">#亚洲上海时区</span></span><br><span class="line">TIME_ZONE = <span class="string">'Asia/Shanghai'</span></span><br></pre>
</li>
<li><p>模板路径</p>
<p><code>在应用同级目录下,创建templates 模板文件夹</code>，</p>
<p>然后创建路径</p>
<pre class="highlight"><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.template.backends.django.DjangoTemplates'</span>,</span><br><span class="line">        <span class="string">'DIRS'</span>: [os.path.join(BASE_DIR,<span class="string">'templates'</span>)],</span><br><span class="line">        <span class="string">'APP_DIRS'</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">            <span class="string">'context_processors'</span>: [</span><br><span class="line">                <span class="string">'django.template.context_processors.debug'</span>,</span><br><span class="line">                <span class="string">'django.template.context_processors.request'</span>,</span><br><span class="line">                <span class="string">'django.contrib.auth.context_processors.auth'</span>,</span><br><span class="line">                <span class="string">'django.contrib.messages.context_processors.messages'</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre>
</li>
<li><p>项目中匹配urls</p>
<p>正则 : 路径只要不是admin/就算匹配成功。并包含到应用中的urls.py</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url,include</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^admin/'</span>, admin.site.urls),</span><br><span class="line">    <span class="comment">#正则为：只要不是 admin/ 就算匹配成功</span></span><br><span class="line">    url(<span class="string">r'^'</span>,include(<span class="string">'book.urls'</span>))</span><br><span class="line">]</span><br></pre>
</li>
<li><p>应用中匹配 <strong>urls.py</strong></p>
<p>应用中创建 <strong>urls.py</strong></p>
<p>正则 : 路径中包含 <strong>booklist/</strong>，就调用视图中对应的 <strong>bookList</strong> 函数</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">from</span> book.views <span class="keyword">import</span> bookList</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 匹配书籍列表信息的URL,调用对应的bookList视图</span></span><br><span class="line">    url(<span class="string">r'^booklist/$'</span>,bookList)</span><br><span class="line">]</span><br></pre>
</li>
<li><p>准备视图</p>
<pre class="highlight"><span class="line"><span class="comment"># 定义视图：提供书籍列表信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bookList</span><span class="params">(request)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'OK!'</span>)</span><br></pre>
</li>
<li><p>开启服务器, 测试项目</p>
<pre class="highlight"><span class="line"><span class="comment"># 进入项目文件中, 开启项目对应的服务器</span></span><br><span class="line">python manage.py runserver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浏览器中输入网址</span></span><br><span class="line">http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/booklist/</span><br></pre>

</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在settings.py中保存了数据库的连接配置信息，Django默认初始配置使用sqlite数据库。</p>
<pre class="highlight"><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.sqlite3'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: os.path.join(BASE_DIR, <span class="string">'db.sqlite3'</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>

<ol>
<li><p>使用MySQL数据库首先需要安装驱动程序</p>
<pre class="highlight"><span class="line">使用MySQL数据库首先需要安装驱动程序</span><br></pre>
</li>
<li><p>在Django的工程同名子目录的<strong>init</strong>.py文件中添加如下语句</p>
<pre class="highlight"><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre>

<p>作用是让Django的ORM能以mysqldb的方式来调用PyMySQL。</p>
</li>
<li><p>修改DATABASES配置信息</p>
<pre class="highlight"><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'127.0.0.1'</span>,  <span class="comment"># 数据库主机</span></span><br><span class="line">        <span class="string">'PORT'</span>: <span class="number">3306</span>,  <span class="comment"># 数据库端口</span></span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,  <span class="comment"># 数据库用户名</span></span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'mysql'</span>,  <span class="comment"># 数据库用户密码</span></span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'book'</span>  <span class="comment"># 数据库名字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>
</li>
<li><p>在MySQL中创建数据库</p>
<pre class="highlight"><span class="line">create database book charset=utf8;</span><br><span class="line"><span class="number">1</span></span><br></pre>

</li>
</ol>
<p>然后就是 定义模型，所以创建的使用流程就OK了，如果想看 接下来的模型类，请看下一篇。</p>
<h4 id="URLConf"><a href="#URLConf" class="headerlink" title="URLConf"></a>URLConf</h4><ul>
<li>settings.py中：指定url配置</li>
</ul>
<pre class="highlight"><span class="line">ROOT_URLCONF = <span class="string">'bookmanager.urls'</span></span><br></pre>

<ul>
<li>项目中urls.py：只要不是admin/就匹配成功，包含到应用中的urls.py</li>
</ul>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url,include</span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">     url(<span class="string">r'^admin/'</span>, include(admin.site.urls)),</span><br><span class="line"></span><br><span class="line">     <span class="comment"># 只要不是‘admin/’就匹配成功，包含到应用中的urls.py</span></span><br><span class="line">     url(<span class="string">r'^'</span>, include(<span class="string">'book.urls'</span>)),</span><br><span class="line"> ]</span><br></pre>

<ul>
<li>应用中<code>urls.py：</code>匹配 <code>testproject/</code> 成功就调用 <code>views</code> 中的 <code>testproject</code> 函数，测试项目逻辑</li>
</ul>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</span><br><span class="line"><span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># 匹配`testproject/`成功就调用`views`中的`testproject`函数</span></span><br><span class="line">    url(<span class="string">r'^testproject/$'</span>, views.testproject),</span><br><span class="line">]</span><br></pre>

<ul>
<li>视图：测试项目逻辑</li>
</ul>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 测试项目逻辑</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">testproject</span><span class="params">(request)</span>:</span></span><br><span class="line">      <span class="keyword">return</span> HttpResponse(<span class="string">'测试项目逻辑'</span>)</span><br></pre>

<ul>
<li>在models.py 文件中定义模型类</li>
</ul>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="comment"># 准备书籍列表信息的模型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># 创建字段，字段类型...</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>, verbose_name=<span class="string">'名称'</span>)</span><br><span class="line">    pub_date = models.DateField(verbose_name=<span class="string">'发布日期'</span>,null=<span class="literal">True</span>)</span><br><span class="line">    readcount = models.IntegerField(default=<span class="number">0</span>, verbose_name=<span class="string">'阅读量'</span>)</span><br><span class="line">    commentcount = models.IntegerField(default=<span class="number">0</span>, verbose_name=<span class="string">'评论量'</span>)</span><br><span class="line">    is_delete = models.BooleanField(default=<span class="literal">False</span>, verbose_name=<span class="string">'逻辑删除'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'bookinfo'</span>  <span class="comment"># 指明数据库表名</span></span><br><span class="line">        verbose_name = <span class="string">'图书'</span>  <span class="comment"># 在admin站点中显示的名称</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""定义每个数据对象的显示信息"""</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备人物列表信息的模型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeopleInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    GENDER_CHOICES = (</span><br><span class="line">        (<span class="number">0</span>, <span class="string">'male'</span>),</span><br><span class="line">        (<span class="number">1</span>, <span class="string">'female'</span>)</span><br><span class="line">    )</span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>, verbose_name=<span class="string">'名称'</span>)</span><br><span class="line">    gender = models.SmallIntegerField(choices=GENDER_CHOICES, default=<span class="number">0</span>, verbose_name=<span class="string">'性别'</span>)</span><br><span class="line">    description = models.CharField(max_length=<span class="number">200</span>, null=<span class="literal">True</span>, verbose_name=<span class="string">'描述信息'</span>)</span><br><span class="line">    book = models.ForeignKey(BookInfo, on_delete=models.CASCADE, verbose_name=<span class="string">'图书'</span>)  <span class="comment"># 外键</span></span><br><span class="line">    is_delete = models.BooleanField(default=<span class="literal">False</span>, verbose_name=<span class="string">'逻辑删除'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'peopleinfo'</span></span><br><span class="line">        verbose_name = <span class="string">'人物信息'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738</span></span><br></pre>

<ol>
<li><p>生成迁移文件</p>
<pre class="highlight"><span class="line">python manage.py makemigrations</span><br></pre>
</li>
<li><p>同步到数据库中</p>
<pre class="highlight"><span class="line">python manage.py migrate</span><br></pre>
</li>
<li><p>添加测试数据</p>
<pre class="highlight"><span class="line">insert into bookinfo(name, pub_date, readcount,commentcount, is_delete) values</span><br><span class="line">(<span class="string">'射雕英雄传'</span>, <span class="string">'1980-5-1'</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="string">'天龙八部'</span>, <span class="string">'1986-7-24'</span>, <span class="number">36</span>, <span class="number">40</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="string">'笑傲江湖'</span>, <span class="string">'1995-12-24'</span>, <span class="number">20</span>, <span class="number">80</span>, <span class="number">0</span>),</span><br><span class="line">(<span class="string">'雪山飞狐'</span>, <span class="string">'1987-11-11'</span>, <span class="number">58</span>, <span class="number">24</span>, <span class="number">0</span>);</span><br></pre>

<pre class="highlight"><span class="line">insert into peopleinfo(name, gender, book_id, description, is_delete)  values</span><br><span class="line">    (<span class="string">'郭靖'</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'降龙十八掌'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'黄蓉'</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'打狗棍法'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'黄药师'</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'弹指神通'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'欧阳锋'</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'蛤蟆功'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'梅超风'</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">'九阴白骨爪'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'乔峰'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'降龙十八掌'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'段誉'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'六脉神剑'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'虚竹'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'天山六阳掌'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'王语嫣'</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="string">'神仙姐姐'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'令狐冲'</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="string">'独孤九剑'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'任盈盈'</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="string">'弹琴'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'岳不群'</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="string">'华山剑法'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'东方不败'</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="string">'葵花宝典'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'胡斐'</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="string">'胡家刀法'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'苗若兰'</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="string">'黄衣'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'程灵素'</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="string">'医术'</span>, <span class="number">0</span>),</span><br><span class="line">    (<span class="string">'袁紫衣'</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="string">'六合拳'</span>, <span class="number">0</span>);</span><br></pre>

</li>
</ol>
]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 类视图 和 中间件</title>
    <url>/2020/06/18/Django%20%E7%B1%BB%E8%A7%86%E5%9B%BE%20%E5%92%8C%20%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="类视图"><a href="#类视图" class="headerlink" title="类视图"></a>类视图</h3><p>思考：一个视图，是否可以处理两种逻辑？比如get和post请求逻辑。</p>
<h4 id="如何在一个视图中处理get和post请求"><a href="#如何在一个视图中处理get和post请求" class="headerlink" title="如何在一个视图中处理get和post请求"></a>如何在一个视图中处理get和post请求</h4><p><img src="https://img-blog.csdnimg.cn/20200424201651517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200424201651517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="注册视图处理get和post请求"><a href="#注册视图处理get和post请求" class="headerlink" title="注册视图处理get和post请求"></a>注册视图处理get和post请求</h4><p>以函数的方式定义的视图称为 <strong>函数视图</strong>，函数视图便于理解。但是遇到一个视图对应的路径提供了多种不同HTTP请求方式的支持时，便需要在一个函数中编写不同的业务逻辑，代码可读性与复用性都不佳。</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""处理注册"""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取请求方法，判断是GET/POST请求</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        <span class="comment"># 处理GET请求，返回注册页面</span></span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">'register.html'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 处理POST请求，实现注册逻辑</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'这里实现注册逻辑'</span>)</span><br><span class="line"><span class="number">12345678910</span></span><br></pre>

<h3 id="类视图使用"><a href="#类视图使用" class="headerlink" title="类视图使用"></a>类视图使用</h3><p>在Django中也可以使用类来定义一个视图，称为类视图。</p>
<p>使用类视图可以将视图对应的不同请求方式以类中的不同方法来区别定义。如下所示</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> View</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterView</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="string">"""类视图：处理注册"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""处理GET请求，返回注册页面"""</span></span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">'register.html'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""处理POST请求，实现注册逻辑"""</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'这里实现注册逻辑'</span>)</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre>

<p>类视图的好处：</p>
<ul>
<li><strong>代码可读性好</strong></li>
<li><strong>类视图相对于函数视图有更高的复用性</strong> ， 如果其他地方需要用到某个类视图的某个特定逻辑，直接继承该类视图即可</li>
</ul>
<p>定义类视图需要继承自Django提供的父类 <strong>View</strong>，可使用 <code>from django.views.generic import View</code> 或者<code>from django.views.generic.base import View</code> 导入，定义方式如上所示。</p>
<p>配置路由时，使用类视图的 <code>as_view()</code> 方法来添加。</p>
<pre class="highlight"><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># 视图函数：注册</span></span><br><span class="line">    <span class="comment"># url(r'^register/$', views.register, name='register'),</span></span><br><span class="line">    <span class="comment"># 类视图：注册</span></span><br><span class="line">    url(<span class="string">r'^register/$'</span>, views.RegisterView.as_view(), name=<span class="string">'register'</span>),</span><br><span class="line">]</span><br><span class="line"><span class="number">123456</span></span><br></pre>

<h4 id="类视图原理"><a href="#类视图原理" class="headerlink" title="类视图原理"></a>类视图原理</h4><pre class="highlight"><span class="line"><span class="meta">@classonlymethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">as_view</span><span class="params">(cls, **initkwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Main entry point for a request-response process.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ...省略代码...</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">view</span><span class="params">(request, *args, **kwargs)</span>:</span></span><br><span class="line">            self = cls(**initkwargs)</span><br><span class="line">            <span class="keyword">if</span> hasattr(self, <span class="string">'get'</span>) <span class="keyword">and</span> <span class="keyword">not</span> hasattr(self, <span class="string">'head'</span>):</span><br><span class="line">                self.head = self.get</span><br><span class="line">            self.request = request</span><br><span class="line">            self.args = args</span><br><span class="line">            self.kwargs = kwargs</span><br><span class="line">            <span class="comment"># 调用dispatch方法，按照不同请求方式调用不同请求方法</span></span><br><span class="line">            <span class="keyword">return</span> self.dispatch(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        ...省略代码...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回真正的函数视图</span></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># Try to dispatch to the right method; if a method doesn't exist,</span></span><br><span class="line">        <span class="comment"># defer to the error handler. Also defer to the error handler if the</span></span><br><span class="line">        <span class="comment"># request method isn't on the approved list.</span></span><br><span class="line">        <span class="keyword">if</span> request.method.lower() <span class="keyword">in</span> self.http_method_names:</span><br><span class="line">            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            handler = self.http_method_not_allowed</span><br><span class="line">        <span class="keyword">return</span> handler(request, *args, **kwargs)</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132</span></span><br></pre>

<h3 id="类视图使用装饰器"><a href="#类视图使用装饰器" class="headerlink" title="类视图使用装饰器"></a>类视图使用装饰器</h3><p>为类视图添加装饰器，可以使用三种方法。</p>
<p>为了理解方便，我们先来定义一个为 <strong>函数视图准备的装饰器</strong>（在设计装饰器时基本都以函数视图作为考虑的被装饰对象），及一个要被装饰的类视图。</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_require</span><span class="params">(func_view)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(request，*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">return</span> func_view(request,*args,**kwargs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">"您没有登陆"</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CenterView</span><span class="params">(View)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"OK"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"OK"</span>)</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre>

<h4 id="4-1-在URL配置中装饰"><a href="#4-1-在URL配置中装饰" class="headerlink" title="4.1 在URL配置中装饰"></a>4.1 在URL配置中装饰</h4><pre class="highlight"><span class="line"><span class="keyword">from</span> book.views <span class="keyword">import</span> login_require</span><br><span class="line">urlpatterns = [</span><br><span class="line"></span><br><span class="line">    url(<span class="string">r'^center/$'</span>,login_require(CenterView.as_view()),name=<span class="string">'center'</span>),</span><br><span class="line">]</span><br><span class="line"><span class="number">12345</span></span><br></pre>

<p>此种方式最简单，但因装饰行为被放置到了url配置中，单看视图的时候无法知道此视图还被添加了装饰器，不利于代码的完整性，不建议使用。</p>
<p><strong>此种方式会为类视图中的所有请求方法都加上装饰器行为</strong>（因为是在视图入口处，分发请求方式前）。</p>
<h4 id="4-2-在类视图中装饰"><a href="#4-2-在类视图中装饰" class="headerlink" title="4.2 在类视图中装饰"></a>4.2 在类视图中装饰</h4><p>在类视图中使用为函数视图准备的装饰器时，不能直接添加装饰器，需要使用 <code>method_decorator</code> 将其转换为适用于类视图的装饰器。</p>
<p><strong>methoddecorator装饰器还支持使用name参数指明被装饰的方法</strong>。method_decorator</p>
<pre class="highlight"><span class="line"><span class="meta">@method_decorator(login_require,name='dispatch')</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CenterView</span><span class="params">(View)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"OK"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"OK"</span>)</span><br><span class="line"><span class="number">12345678</span></span><br></pre>

<h4 id="4-3-构造Mixin扩展类"><a href="#4-3-构造Mixin扩展类" class="headerlink" title="4.3 构造Mixin扩展类"></a>4.3 构造Mixin扩展类</h4><p>使用面向对象多继承的特性。</p>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginRequireMixin</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">as_view</span><span class="params">(cls,**kwargs)</span>:</span></span><br><span class="line">        view = super().as_view(**kwargs)</span><br><span class="line">        view = login_require(view)</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CenterView</span><span class="params">(LoginRequireMixin,View)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"OK"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">"OK"</span>)</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre>

<p><strong>使用Mixin扩展类，也会为类视图的所有请求方法都添加装饰行为。</strong></p>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>Django中的中间件是一个轻量级、底层的插件系统，可以介入Django的请求和响应处理过程，修改Django的输入或输出。中间件的设计为开发者提供了一种无侵入式的开发方式，增强了Django框架的健壮性。</p>
<p>我们可以使用中间件，在Django处理视图的不同阶段对输入或输出进行干预。</p>
<p><a href="https://docs.djangoproject.com/en/1.11/topics/http/middleware/" target="_blank" rel="noopener">中间件文档： https://docs.djangoproject.com/en/1.11/topics/http/middleware/</a></p>
<h4 id="1-中间件的定义方法"><a href="#1-中间件的定义方法" class="headerlink" title="1 中间件的定义方法"></a>1 中间件的定义方法</h4><p>定义一个中间件工厂函数，然后返回一个可以被调用的中间件。</p>
<p>中间件工厂函数需要接收一个可以调用的get_response对象。</p>
<p>返回的中间件也是一个可以被调用的对象，并且像视图一样需要接收一个request对象参数，返回一个response对象。</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_middleware</span><span class="params">(get_response)</span>:</span></span><br><span class="line">    <span class="comment"># 此处编写的代码仅在Django第一次配置和初始化的时候执行一次。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleware</span><span class="params">(request)</span>:</span></span><br><span class="line">        <span class="comment"># 此处编写的代码会在每个请求处理视图前被调用。</span></span><br><span class="line"></span><br><span class="line">        response = get_response(request)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此处编写的代码会在每个请求处理视图之后被调用。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> middleware</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre>

<p>例如，在book应用中新建一个middleware.py文件，</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_middleware</span><span class="params">(get_response)</span>:</span></span><br><span class="line">    print(<span class="string">'init 被调用'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleware</span><span class="params">(request)</span>:</span></span><br><span class="line">        print(<span class="string">'before request 被调用'</span>)</span><br><span class="line">        response = get_response(request)</span><br><span class="line">        print(<span class="string">'after response 被调用'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    <span class="keyword">return</span> middleware</span><br><span class="line"><span class="number">12345678</span></span><br></pre>

<p>定义好中间件后，需要在settings.py 文件中添加注册中间件</p>
<pre class="highlight"><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">'django.middleware.security.SecurityMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">    <span class="comment"># 'django.middleware.csrf.CsrfViewMiddleware',</span></span><br><span class="line">    <span class="string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span>,</span><br><span class="line">    <span class="string">'book.middleware.my_middleware'</span>,  <span class="comment"># 添加中间件</span></span><br><span class="line">]</span><br><span class="line"><span class="number">12345678910</span></span><br></pre>

<p>定义一个视图进行测试</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">middleware</span><span class="params">(request)</span>:</span></span><br><span class="line">    print(<span class="string">'view 视图被调用'</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'OK'</span>)</span><br><span class="line"><span class="number">123</span></span><br></pre>

<p>执行结果<br><img src="https://img-blog.csdnimg.cn/20200425122753290.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425122753290.png" class="lozad post-image"><br>注意：Django运行在调试模式下，中间件init部分有可能被调用两次。</p>
<h4 id="2-多个中间件的执行顺序"><a href="#2-多个中间件的执行顺序" class="headerlink" title="2 多个中间件的执行顺序"></a>2 多个中间件的执行顺序</h4><ul>
<li>在请求视图被处理前，中间件由上至下依次执行</li>
<li>在请求视图被处理后，中间件由下至上依次执行</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200425122825653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425122825653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<p>示例：</p>
<p>定义两个中间件</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_middleware</span><span class="params">(get_response)</span>:</span></span><br><span class="line">    print(<span class="string">'init 被调用'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleware</span><span class="params">(request)</span>:</span></span><br><span class="line">        print(<span class="string">'before request 被调用'</span>)</span><br><span class="line">        response = get_response(request)</span><br><span class="line">        print(<span class="string">'after response 被调用'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    <span class="keyword">return</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_middleware2</span><span class="params">(get_response)</span>:</span></span><br><span class="line">    print(<span class="string">'init2 被调用'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleware</span><span class="params">(request)</span>:</span></span><br><span class="line">        print(<span class="string">'before request 2 被调用'</span>)</span><br><span class="line">        response = get_response(request)</span><br><span class="line">        print(<span class="string">'after response 2 被调用'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    <span class="keyword">return</span> middleware</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre>

<p>注册添加两个中间件</p>
<pre class="highlight"><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">'django.middleware.security.SecurityMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">    <span class="comment"># 'django.middleware.csrf.CsrfViewMiddleware',</span></span><br><span class="line">    <span class="string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span>,</span><br><span class="line">    <span class="string">'users.middleware.my_middleware'</span>,  <span class="comment"># 添加</span></span><br><span class="line">    <span class="string">'users.middleware.my_middleware2'</span>,  <span class="comment"># 添加</span></span><br><span class="line">]</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre>

<p>执行结果</p>
<pre class="highlight"><span class="line">init2 被调用</span><br><span class="line">init 被调用</span><br><span class="line">before request 被调用</span><br><span class="line">before request <span class="number">2</span> 被调用</span><br><span class="line">view 视图被调用</span><br><span class="line">after response <span class="number">2</span> 被调用</span><br><span class="line">after response 被调用</span><br><span class="line"><span class="number">1234567</span></span><br></pre>

<h4 id="django中间件的5个方法"><a href="#django中间件的5个方法" class="headerlink" title="django中间件的5个方法"></a>django中间件的5个方法</h4><ol>
<li>process_request : 请求进来时,权限认证 。</li>
<li>process_view : 路由匹配之后,能够得到视图函数</li>
<li>process_exception : 异常时执行</li>
<li>process_template_responseprocess : 模板渲染时执行</li>
<li>process_response : 请求有响应时执行</li>
</ol>
]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 项目的创建，模型的使用</title>
    <url>/2020/01/25/Django%20%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h5 id="创建Django项目"><a href="#创建Django项目" class="headerlink" title="创建Django项目"></a>创建Django项目</h5><pre class="highlight"><span class="line">django-admin startproject name</span><br><span class="line"><span class="number">1</span></span><br></pre>

<h5 id="创建子应用"><a href="#创建子应用" class="headerlink" title="创建子应用"></a>创建子应用</h5><pre class="highlight"><span class="line">python manager.py startapp name</span><br><span class="line"><span class="number">1</span></span><br></pre>



<h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>在使用Flask框架时，项目工程目录的组织与创建是需要我们自己手动创建完成的。</p>
<p>在django中，项目工程目录可以借助django提供的命令帮助我们创建。</p>
<h5 id="1-gt-创建"><a href="#1-gt-创建" class="headerlink" title="1&gt;. 创建"></a>1&gt;. 创建</h5><p>创建工程的命令为：</p>
<pre class="highlight"><span class="line">django-admin startproject 工程名称</span><br><span class="line"><span class="number">1</span></span><br></pre>

<ul>
<li><p>例如：想要在桌面的code目录中创建一个名为demo的项目工程，可执行如下命令：</p>
<pre class="highlight"><span class="line">cd ~/Desktop/Code</span><br><span class="line">django-admin startproject bookmanager</span><br><span class="line"><span class="number">12</span></span><br></pre>

</li>
</ul>
<p>执行后，会多出一个新目录名为bookmanager，此即为新创建的工程目录。</p>
<h5 id="2-gt-工程目录说明"><a href="#2-gt-工程目录说明" class="headerlink" title="2&gt;. 工程目录说明"></a>2&gt;. 工程目录说明</h5><p>查看创建的工程目录，结构如下<br><img src="https://img-blog.csdnimg.cn/20200405215208813.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200405215208813.png" class="lozad post-image"></p>
<ul>
<li>与项目同名的目录，此处为bookmanager。</li>
<li>settings.py是项目的整体配置文件。</li>
<li>urls.py是项目的URL配置文件。</li>
<li>wsgi.py是项目与WSGI兼容的Web服务器入口。</li>
<li>manage.py是项目管理文件，通过它管理项目。</li>
</ul>
<h5 id="3-gt-运行开发服务器"><a href="#3-gt-运行开发服务器" class="headerlink" title="3&gt;. 运行开发服务器"></a>3&gt;. 运行开发服务器</h5><p>在开发阶段，为了能够快速预览到开发的效果，django提供了一个纯python编写的轻量级web服务器，仅在开发阶段使用。</p>
<p>运行服务器命令如下：</p>
<pre class="highlight"><span class="line">python manage.py runserver ip:端口</span><br><span class="line"></span><br><span class="line"><span class="string">"或："</span></span><br><span class="line"></span><br><span class="line">python manage.py runserver</span><br><span class="line"><span class="number">12345</span></span><br><span class="line">可以不写IP和端口，默认IP是<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>，默认端口为<span class="number">8000</span>。</span><br></pre>

<p>启动后可见如下信息：</p>
<p><img src="https://img-blog.csdnimg.cn/20200405215409574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200405215409574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>在浏览器中输入网址“127.0.0.1:8000”便可看到效果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200405215428599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200405215428599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<ul>
<li>django默认工作在调式Debug模式下，如果增加、修改、删除文件，服务器会自动重启。</li>
<li>按ctrl+c停止服务器。</li>
</ul>
<h3 id="创建子应用-1"><a href="#创建子应用-1" class="headerlink" title="创建子应用"></a>创建子应用</h3><p>在Web应用中，通常有一些业务功能模块是在不同的项目中都可以复用的，故在开发中通常将工程项目拆分为不同的子功能模块，各功能模块间可以保持相对的独立，在其他工程项目中需要用到某个特定功能模块时，可以将该模块代码整体复制过去，达到复用。</p>
<p>在Flask框架中也有类似子功能应用模块的概念，即蓝图Blueprint。</p>
<p>Django的视图编写是放在子应用中的。</p>
<h4 id="1-gt-创建-1"><a href="#1-gt-创建-1" class="headerlink" title="1&gt;. 创建"></a>1&gt;. 创建</h4><p>在django中，创建子应用模块目录仍然可以通过命令来操作，即：</p>
<pre class="highlight"><span class="line">python manage.py startapp 子应用名称</span><br><span class="line"><span class="number">1</span></span><br></pre>

<p>manage.py为上述创建工程时自动生成的管理文件。</p>
<p>例如，在刚才创建的bookmanager工程中，想要创建一个用户book子应用模块，可执行：</p>
<pre class="highlight"><span class="line">cd ~/Desktop/code/book</span><br><span class="line"></span><br><span class="line">python manage.py startapp book</span><br><span class="line"><span class="number">123</span></span><br></pre>

<p>执行后，可以看到工程目录中多出了一个名为book的子目录。</p>
<h4 id="2-gt-子应用目录说明"><a href="#2-gt-子应用目录说明" class="headerlink" title="2&gt;. 子应用目录说明"></a>2&gt;. 子应用目录说明</h4><p>查看此时的工程目录，结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200405215648866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200405215648866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<ul>
<li>admin.py文件跟网站的后台管理站点配置相关。</li>
<li>apps.py文件用于配置当前子应用的相关信息。</li>
<li>migrations目录用于存放数据库迁移历史文件。</li>
<li>models.py文件用户保存数据库模型类。</li>
<li>tests.py文件用于开发测试用例，编写单元测试。</li>
<li>views.py文件用于编写Web应用视图。</li>
</ul>
<h4 id="3-gt-注册安装子应用"><a href="#3-gt-注册安装子应用" class="headerlink" title="3&gt;. 注册安装子应用"></a>3&gt;. 注册安装子应用</h4><p>创建出来的子应用目录文件虽然被放到了工程项目目录中，但是django工程并不能立即直接使用该子应用，需要注册安装后才能使用。</p>
<p>在工程配置文件settings.py中，<strong>INSTALLED_APPS</strong>项保存了工程中已经注册安装的子应用，初始工程中的INSTALLED_APPS如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200405215738560.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200405215738560.png" class="lozad post-image"></p>
<p><strong>注册安装一个子应用的方法，即是将子应用的配置信息文件apps.py中的Config类添加到INSTALLED_APPS列表中。</strong></p>
<p>例如，将刚创建的book子应用添加到工程中，可在INSTALLED_APPS列表中添加’<strong>book.apps.BookConfig</strong>’。</p>
<p><img src="https://img-blog.csdnimg.cn/20200405215817239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200405215817239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<hr>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><h4 id="使用Django进行数据库开发的提示-："><a href="#使用Django进行数据库开发的提示-：" class="headerlink" title="使用Django进行数据库开发的提示 ："></a>使用Django进行数据库开发的提示 ：</h4><ul>
<li>MVT设计模式中的Model, 专门负责和数据库交互.对应(models.py)</li>
<li>由于Model中内嵌了ORM框架, 所以不需要直接面向数据库编程.</li>
<li>而是定义模型类, 通过模型类和对象完成数据库表的增删改查.</li>
<li>ORM框架就是把数据库表的行与相应的对象建立关联, 互相转换.使得数据库的操作面向对象.</li>
</ul>
<h4 id="使用Django进行数据库开发的步骤-："><a href="#使用Django进行数据库开发的步骤-：" class="headerlink" title="使用Django进行数据库开发的步骤 ："></a>使用Django进行数据库开发的步骤 ：</h4><ol>
<li>定义模型类</li>
<li>模型迁移</li>
<li>操作数据库</li>
</ol>
<h5 id="1-定义模型类"><a href="#1-定义模型类" class="headerlink" title="1. 定义模型类"></a>1. 定义模型类</h5><p>根据书籍表结构设计模型类:</p>
<ul>
<li>模型类：BookInfo</li>
<li>书籍名称字段：name</li>
</ul>
<p>根据人物表结构设计模型类：</p>
<ul>
<li><p>模型类：PeopleInfo</p>
</li>
<li><p>人物姓名字段：name</p>
</li>
<li><p>人物性别字段：gender</p>
</li>
<li><p>外键约束：book</p>
<pre class="highlight"><span class="line">外键要指定所属的模型类book &#x3D; models.ForeignKey(BookInfo)</span><br><span class="line">1</span><br></pre>

</li>
</ul>
<p>说明 :</p>
<ul>
<li>书籍-人物的关系为一对多. 一本书中可以有多个英雄.</li>
<li>不需要定义主键字段, 在生成表时会自动添加, 并且值为自增长.</li>
</ul>
<p>根据数据库表的设计</p>
<ul>
<li><p>在models.py中定义模型类,继承自models.Model</p>
</li>
<li><pre><code class="python"><span class="comment"># models.py</span>

<span class="keyword">from</span> django.db <span class="keyword">import</span> models
<span class="comment"># Create your models here.</span>
<span class="comment"># 准备书籍列表信息的模型类</span>

<span class="class"><span class="keyword">class</span> <span class="title">BookInfo</span><span class="params">(models.Model)</span>:</span>
    <span class="comment"># 创建字段，字段类型...</span>
    name = models.CharField(max_length=<span class="number">10</span>)

<span class="comment"># 准备人物列表信息的模型类</span>
<span class="class"><span class="keyword">class</span> <span class="title">PeopleInfo</span><span class="params">(models.Model)</span>:</span>
    name = models.CharField(max_length=<span class="number">10</span>)
    gender = models.BooleanField()
    <span class="comment"># 外键约束：人物属于哪本书</span>
    book = models.ForeignKey(BookInfo)
<span class="number">12345678910111213141516</span>

<pre class="highlight"><span class="line"></span><br><span class="line">#### 2&gt;. 模型迁移(数据库迁移) （建表）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数据迁移（Data migration）是指在存储类型、格式和计算机系统之间的数据转换。</span><br><span class="line"></span><br><span class="line">- 数据迁移当一个机构决定使用新的计算系统或与当前的系统不兼容的数据管理系统时是必须的。</span><br><span class="line">- 数据迁移通常有计划的执行来完成一个自动的迁移，从单调的任务中解放人力资源。当机构或个人改变计算机系统或升级到新的系统时需要它。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">数据库迁移主要分为热迁移和冷迁移：</span><br><span class="line"></span><br><span class="line">热迁移是将内存数据和硬盘数据同步进行迁移。</span><br><span class="line">热迁移的优势在于其对用户业务的影响是非常小的；</span><br><span class="line">热迁移对内存数据进行了迁移，用户业务应用对其是无感知的。</span><br><span class="line">而缺点是热迁移的过程是不可中断的，整个操作过程相对复杂。</span><br><span class="line"></span><br><span class="line">冷迁移就是在关机迁移。</span><br><span class="line">优势是整个冷迁移过程的操作简单，一般为自动化操作。</span><br><span class="line">但其缺点是该方式不支持内存数据的保存，容易导致内存数据的丢失。</span><br><span class="line">12345678910</span><br></pre>
</code></pre>
</li>
</ul>
<p>迁移由两步完成 :</p>
<ul>
<li><p>生成迁移文件：根据模型类生成创建表的语句</p>
<pre class="highlight"><span class="line">python manage.py makemigrations</span><br><span class="line"><span class="number">1</span></span><br></pre>
</li>
<li><p>执行迁移：根据第一步生成的语句在数据库中创建表</p>
<pre class="highlight"><span class="line">python manage.py migrate</span><br><span class="line"><span class="number">1</span></span><br></pre>
</li>
<li><p>迁移前</p>
<p><img src="https://img-blog.csdnimg.cn/20200405221115984.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200405221115984.png" class="lozad post-image"></p>
</li>
<li><p>迁移后</p>
<p><img src="https://img-blog.csdnimg.cn/20200405221146457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200405221146457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
<li><p>提示：默认采用sqlite3数据库来存储数据</p>
</li>
</ul>
]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 介绍，Linux简单安装</title>
    <url>/2020/08/18/Docker%20%E4%BB%8B%E7%BB%8D%EF%BC%8CLinux%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200301143418334.jpg#pic_center" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200301143418334.jpg#pic_center" class="lozad post-image"></p>
<p>什么是 Docker？</p>
<ul>
<li>一个简单的应用程序打包工具</li>
<li>使用最广泛的开源容器</li>
<li>一种操作系统级的虚拟化技术</li>
<li>依赖于Linux内核特性：Namespace 和 Cgroups</li>
</ul>
<ol>
<li>Docker 是应用最广泛的开源容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中</li>
<li>然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。</li>
<li>每个容器拥有一套和宿主机完全隔离的文件系统（共用linux内核），程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。</li>
</ol>
<h5 id="容器："><a href="#容器：" class="headerlink" title="容器："></a>容器：</h5><ol>
<li><p>容器是一个操作系统级别下的虚拟化技术，运行一个容器就行运行一个进程一样</p>
</li>
<li><p>容器依赖linux内核特性：Namespace（资源隔离）和Cgroups（资源限制）</p>
</li>
</ol>
<p>Docker的设计目标</p>
<ul>
<li><p>提供了简单的应用程序打包</p>
</li>
<li><p>开发人员和运维人员职责逻辑分离</p>
</li>
<li><p>多环境保持一致性</p>
</li>
</ul>
<p>Docker的思想</p>
<ol>
<li><p>Docker的思想源于集装箱，集装箱解决了什么问题呢？</p>
</li>
<li><p>在早期运输货物需要不同分类的船，例如运输水果的船，运输生活用品的船</p>
</li>
<li><p>有了集装箱后，在大船上，可以把货物分类到不同的集装箱中，水果一个集装箱，生活用品一个集装箱</p>
</li>
<li><p>它们之间互不影响，只要把货物封装好集装箱里，就可以把不同类的货物一起运走。</p>
</li>
<li><p>通过Docker logo也可以看出所以然来，Docker就像大船，集装箱就是容器。</p>
</li>
<li><p>一条鲸鱼拖着若干个集装箱的经典形象已经深入人心。</p>
</li>
</ol>
<p>Docker的基本组成</p>
<p><img src="https://img-blog.csdnimg.cn/20200301141951332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200301141951332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<table>
<thead>
<tr>
<th>DockerClient</th>
<th>客户端</th>
</tr>
</thead>
<tbody><tr>
<td>Docker Daemon</td>
<td>守护进程</td>
</tr>
<tr>
<td>Docker Images</td>
<td>镜像</td>
</tr>
<tr>
<td>Docker Container</td>
<td>容器</td>
</tr>
<tr>
<td>Docker Registry</td>
<td>镜像仓库</td>
</tr>
</tbody></table>
<p>虚拟机 和 容器</p>
<p><img src="https://img-blog.csdnimg.cn/20200301143040376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200301143040376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<p>VM</p>
<table>
<thead>
<tr>
<th>Infrastructure</th>
<th>代表他 可以是 台式 笔记本 服务器 云主机</th>
</tr>
</thead>
<tbody><tr>
<td>Hypervisor</td>
<td>运行在物理设备上 和 操作糸统之间的 中间软件管理层 ，也叫 宿主机</td>
</tr>
<tr>
<td>Guest OS</td>
<td>虚拟出的系统</td>
</tr>
<tr>
<td>Bins/Libx</td>
<td>二进制文件 / 库</td>
</tr>
<tr>
<td>App</td>
<td>部署的应用</td>
</tr>
</tbody></table>
<p>Container</p>
<table>
<thead>
<tr>
<th>Infrastructure</th>
<th>代表他 可以是 台式 笔记本 服务器 云主机</th>
</tr>
</thead>
<tbody><tr>
<td>Host OS</td>
<td>主机OS，这台机器的操作系统</td>
</tr>
<tr>
<td>Docker</td>
<td>系统级别的虚拟化技术，所以要基于已有的操作系统之上</td>
</tr>
<tr>
<td>Bins/Libx</td>
<td>二进制文件 / 库</td>
</tr>
<tr>
<td>App</td>
<td>部署的应用</td>
</tr>
</tbody></table>
<p><img src="https://img-blog.csdnimg.cn/20200301150926289.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200301150926289.png" class="lozad post-image"><br><img src="https://img-blog.csdnimg.cn/20200301150947377.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200301150947377.png" class="lozad post-image"></p>
<p>由上图可看 容器呢 只包含了 二进制文件 和 库、应用程序，而虚拟机是 Guest OS 承载的 二进制文件 和 库、应用程序</p>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table>
<thead>
<tr>
<th></th>
<th>Container</th>
<th>VM</th>
</tr>
</thead>
<tbody><tr>
<td>启动速度</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>运动性能</td>
<td>接近原生</td>
<td>5%左右损失</td>
</tr>
<tr>
<td>磁盘占用</td>
<td>MB</td>
<td>GB</td>
</tr>
<tr>
<td>数量</td>
<td>成百上千</td>
<td>一般几十台</td>
</tr>
<tr>
<td>隔离性</td>
<td>进程级别</td>
<td>系统级（更彻底）</td>
</tr>
<tr>
<td>操作系统</td>
<td>只支持Linux</td>
<td>几乎所有</td>
</tr>
<tr>
<td>封装程度</td>
<td>只打包项目代码和依赖关系，共享宿主机内核</td>
<td>完整的操作系统</td>
</tr>
</tbody></table>
<h5 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h5><ol>
<li>docker设计小巧，部署迁移快速，运行高效，按照应用隔离，管理人员可以看到所有容器的内容。</li>
<li>虚拟化技术比较臃肿，需要先创建新的系统，按照系统隔离，管理员无法看到系统内部信息。</li>
</ol>
<h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><ul>
<li><p>Docker就是手机中的各种APP，只需要一个系统就可以下载自己所需的应用</p>
</li>
<li><p>虚拟化技术相当于苹果手机安装一个庞大软件，这个软件上安装安卓系统、魅族系统等，每个系统上还要安装各类应用。</p>
</li>
</ul>
<p>Docker 的应用场景</p>
<ul>
<li>应用程序打包和发布</li>
<li>应用程序隔离</li>
<li>持续集成</li>
<li>部署微服务</li>
<li>快速搭建测试环境</li>
<li>提供Paas产品（平台即服务）</li>
</ul>
<h5 id="详解："><a href="#详解：" class="headerlink" title="详解："></a>详解：</h5><ul>
<li><p>节省项目环境部署时间</p>
<ul>
<li><strong>单项目打包</strong></li>
</ul>
<ol>
<li>每次部署项目到测试、生产等环境，都要部署一大堆依赖的软件、工具，时间久，出错概率大。</li>
<li>Docker主要理念就是环境打包部署，可在任意Docker Engine运行。</li>
<li>我们只需要将每个项目环境打包到镜像，push到镜像仓库，当有需要部署这个项目时，直接pull镜像启动容器，这个项目就可以访问了！一次构建多次部署，一劳永逸。</li>
</ol>
<ul>
<li><strong>整套项目打包</strong></li>
</ul>
<ol>
<li>比如有一个产品可以整套部署到客户那里，以往都是派一名实施工程师到客户那部署。</li>
<li>如果用了Docker，我们可以前期将这套项目封装打包起来，实现一键部署，分分钟钟搞定，就不需要再派人过去了。比如官方的Docker Compose编排工具。</li>
</ol>
<ul>
<li><strong>新开源技术试用</strong></li>
</ul>
<ol>
<li>有时，我们想调研一些开源项目，我们可以直接从公共镜像仓库pull项目官方做好镜像启动容器即可。</li>
</ol>
</li>
<li><p>环境一致性</p>
</li>
</ul>
<ol>
<li>项目在开发电脑本地运行没问题，到了测试或生产环境就运行不起来。</li>
<li>Docker将项目环境打包成镜像，可以在任何Docker Engine部署。</li>
</ol>
<ul>
<li>持续集成</li>
</ul>
<ol>
<li>一个项目版本快速迭代的测试场景，需要一个合理的CI（持续集成）/CD（持续部署）环境支撑。</li>
<li>CI/CD是一个周期性自动化项目测试流程，包括构建、部署、测试、发布等工作，很少需要人工干预。</li>
<li>Docker通过项目镜像构建和快速部署，打通测试环境与生产环境，高度保持多个环境之间一致性。</li>
</ol>
<ul>
<li>微服务</li>
</ul>
<ol>
<li><p>微服务指尽可能细粒度拆分业务程序架构，由多个独立服务组成业务系统。</p>
</li>
<li><p>Docker容器作为这些独立服务的部署单元，每个服务单独部署到一个docker容器中。</p>
</li>
</ol>
<p>Linux 上安装 Docker</p>
<h5 id="docker版本"><a href="#docker版本" class="headerlink" title="docker版本"></a>docker版本</h5><pre class="highlight"><span class="line">docker V1.13 版本的时候区分的 以下两个版本，大约是在17年初，我们用的是 最新版 V18.03</span><br></pre>

<ol>
<li>社区版（Community Edition, CE）</li>
<li>企业版（Enterprise Edition, EE）</li>
</ol>
<h4 id="docker安装参考官方文档"><a href="#docker安装参考官方文档" class="headerlink" title="docker安装参考官方文档"></a>docker安装参考官方文档</h4><ol>
<li>docker官方文档：<a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></li>
<li>centos安装docker：<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a><br><code>注：docker CE只支持 centos7 不支持centos6</code></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200301222519716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200301222519716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<pre class="highlight"><span class="line"><span class="comment"># 1.安装依赖包</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.添加Docker软件包源(否则doker安装的不是新版本)</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.安装Docker CE</span></span><br><span class="line">yum install -y docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.启动Docker服务并设置开机启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.测试docker是否安装成功（hello-world是官方提供的一个测试镜像）</span></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看docker基本信息</span></span><br><span class="line">docker info</span><br><span class="line">docker version</span><br></pre>

<h5 id="docker简单使用-创建Nginx容器"><a href="#docker简单使用-创建Nginx容器" class="headerlink" title="docker简单使用 创建Nginx容器"></a>docker简单使用 创建Nginx容器</h5><pre class="highlight"><span class="line"><span class="comment"># 1、创建一个nginx容器</span></span><br><span class="line">docker run -it nginx</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2、查看docker运行的容器(可以获取到这个容器的id)</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、访问这个容器</span></span><br><span class="line"><span class="comment"># 进入这个nginx容器（进入的文件系统和宿主机是完全隔离的，有自己独立的文件系统）</span></span><br><span class="line">docker <span class="keyword">exec</span> -it <span class="number">73877e65</span>c07d bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、查看当前容器的 IP</span></span><br><span class="line">docker inspect <span class="number">73877e65</span>c07d   <span class="comment"># 73877e65c07d是通过docekr ps查看到的容器ID</span></span><br><span class="line">curl <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span>               <span class="comment"># 测试这个nginx容器是否可以访问</span></span><br></pre>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 的基本常用命令</title>
    <url>/2020/08/27/Docker%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200304173914455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200304173914455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" class="lozad post-image"></p>
<p>docker 镜像管理常用命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>示意</th>
</tr>
</thead>
<tbody><tr>
<td>docker help</td>
<td>查看docker帮助</td>
</tr>
<tr>
<td>docker image –help</td>
<td>查看 docker中 镜像相关帮助</td>
</tr>
<tr>
<td>docker image ls</td>
<td>查看当前所有镜像</td>
</tr>
<tr>
<td>docker image inspect nginx</td>
<td>查看指定镜像（nginx镜像）详细信息</td>
</tr>
<tr>
<td>docker pull nginx:1.14</td>
<td>下载指定版本镜像 nginx</td>
</tr>
<tr>
<td>docker image rm nginx:1.14</td>
<td>删除nginx 1.14版本</td>
</tr>
<tr>
<td>docker image save nginx &gt; nginx.tar</td>
<td>导出niginx镜像</td>
</tr>
</tbody></table>
<p>docker创建容器常用命令</p>
<p>docker run 常用参数</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>示意</th>
</tr>
</thead>
<tbody><tr>
<td>-d:</td>
<td>后台运行容器，并返回容器ID；</td>
</tr>
<tr>
<td>-i:</td>
<td>以交互模式运行容器，通常与 -t 同时使用；</td>
</tr>
<tr>
<td>-t:</td>
<td>为容器重新分配一个伪输入终端，通常与 -i 同时使用；</td>
</tr>
<tr>
<td>-P:</td>
<td>随机端口映射，容器内部端口随机映射到主机的高端口</td>
</tr>
<tr>
<td>-p:</td>
<td>指定端口映射，格式为：主机(宿主)端口:容器端口</td>
</tr>
<tr>
<td>–name=“nginx-lb”:</td>
<td>为容器指定一个名称；</td>
</tr>
<tr>
<td>–dns 8.8.8.8:</td>
<td>指定容器使用的DNS服务器，默认和宿主一致；</td>
</tr>
</tbody></table>
<p>docker run 其他参数</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>示意</th>
</tr>
</thead>
<tbody><tr>
<td>–dns-search example.com:</td>
<td>指定容器DNS搜索域名，默认和宿主一致；</td>
</tr>
<tr>
<td>-h “mars”:</td>
<td>指定容器的hostname；</td>
</tr>
<tr>
<td>-e username=“ritchie”:</td>
<td>设置环境变量；</td>
</tr>
<tr>
<td>–env-file=[]:</td>
<td>从指定文件读入环境变量；</td>
</tr>
<tr>
<td>–cpuset=“0-2” or –cpuset=“0,1,2”:</td>
<td>绑定容器到指定CPU运行；</td>
</tr>
<tr>
<td>-m :</td>
<td>设置容器使用内存最大值；</td>
</tr>
<tr>
<td>–net=“bridge”:</td>
<td>指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</td>
</tr>
<tr>
<td>–link=[]:</td>
<td>添加链接到另一个容器；</td>
</tr>
<tr>
<td>–expose=[]:</td>
<td>开放一个端口或一组端口；</td>
</tr>
<tr>
<td>–volume , -v:</td>
<td>绑定一个卷</td>
</tr>
<tr>
<td>-a stdin:</td>
<td>指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</td>
</tr>
<tr>
<td>docker run</td>
<td>其他参数</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>命令</th>
<th>示意</th>
</tr>
</thead>
<tbody><tr>
<td>docker run –help</td>
<td>查看创建容器帮助</td>
</tr>
<tr>
<td>docker run -it centos</td>
<td>创建centos镜像并进入终端</td>
</tr>
<tr>
<td>docker run -d nginx</td>
<td>后台启动nginx容器</td>
</tr>
<tr>
<td>docker stop 6bb09dce461f</td>
<td>关闭一个容器</td>
</tr>
<tr>
<td>docker ps -l</td>
<td>查看最近运行的容器</td>
</tr>
<tr>
<td>docker run -itd centos</td>
<td>启用一个伪终端守护centos容器</td>
</tr>
<tr>
<td>docker container run -d –name web3 -e test=123456 -p 8800:80 -h webhostname –restart always nginx</td>
<td></td>
</tr>
<tr>
<td>-d</td>
<td>后台启动nginx容器</td>
</tr>
<tr>
<td>–name web3</td>
<td>自定义容器名字(默认会是一段随机字符串)</td>
</tr>
<tr>
<td>-e test=123456</td>
<td>启动容器添加变量 test=123456 (echo $test)</td>
</tr>
<tr>
<td>-p 8800:80</td>
<td>宿主机的8800端口映射到docker容器的80端口中</td>
</tr>
<tr>
<td>-h webhostname</td>
<td>docker容器主机名 (a300f394af88)</td>
</tr>
<tr>
<td>–restart always</td>
<td>宿主机重启自动拉起这个docker容器</td>
</tr>
<tr>
<td>nginx</td>
<td>使用这个nginx镜像启动容器</td>
</tr>
<tr>
<td>docker logs web</td>
<td>查看上面启动的web容器的日志</td>
</tr>
<tr>
<td>docker exec -it web bash</td>
<td>进入容器web</td>
</tr>
</tbody></table>
<h4 id="容器资源限制"><a href="#容器资源限制" class="headerlink" title="容器资源限制"></a>容器资源限制</h4><ol>
<li><p>内存限额： 允许容器最多使用500M内存和100M的Swap，并禁用 OOM Killer<br>docker run -d –name nginx03 –memory=“500m” –memory-swap=“600m” –oom-kill-disable nginx</p>
</li>
<li><p>CPU限额：<br>docker run -d –name nginx04 –cpus=“1.5” nginx # 允许容器最多使用一个半的CPU<br>docker run -d –name nginx05 –cpus=”.5” nginx # 允许容器最多使用50%的CPU</p>
</li>
</ol>
<p>docker 管理 容器常用命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>示意</th>
</tr>
</thead>
<tbody><tr>
<td>docker ps</td>
<td>仅列出当前运行的容器</td>
</tr>
<tr>
<td>docker ps -l</td>
<td>列出最新创建得容器</td>
</tr>
<tr>
<td>docker ps -a</td>
<td>列出素有容器(包括 未运行的)</td>
</tr>
<tr>
<td>docker inspect web4</td>
<td>列出指定容器的详细信息</td>
</tr>
</tbody></table>
<p>持久化容器</p>
<table>
<thead>
<tr>
<th>docker exec -it web4 bash</th>
<th>进入容器web4中</th>
</tr>
</thead>
<tbody><tr>
<td>touch 1.txt 2.txt</td>
<td>对容器进行修改</td>
</tr>
<tr>
<td>docker commit web4 nginx:web4</td>
<td>将修改后的web4容器提交为一个新镜像 nginx:web4</td>
</tr>
<tr>
<td>docker images</td>
<td>可以看到 多了一个 TAG标记为 web4 的镜像</td>
</tr>
<tr>
<td>docker run -d –name web4-1 nginx:web4</td>
<td>使用刚刚提交的镜像web4创建一个容器web4-1</td>
</tr>
<tr>
<td>docker exec -it web4-1 bash</td>
<td>进入web4-1的bash环境</td>
</tr>
</tbody></table>
<p>从宿主机复制文件到docker容器</p>
<table>
<thead>
<tr>
<th>docker cp nginx.tar web4-1:/home</th>
<th>将宿主机nginx.tar文件拷贝到容器web4-1的/home目录中</th>
</tr>
</thead>
<tbody><tr>
<td>docker exec -it web4-1 ls /home</td>
<td>在容器web4-1中执行 “ls /home” 命令</td>
</tr>
</tbody></table>
<p>容器常用查询命令</p>
<table>
<thead>
<tr>
<th>docker logs web4-1</th>
<th>查看web4-1中控制台日志</th>
</tr>
</thead>
<tbody><tr>
<td>docker port 55f870061ed9</td>
<td>查看指定容器端口映射</td>
</tr>
<tr>
<td>docker top 00f7ddc96622</td>
<td>查看容器中有哪些进程</td>
</tr>
<tr>
<td>docker stats 00f7ddc96622</td>
<td>查看容器资源使用情况</td>
</tr>
</tbody></table>
<p>启动、停止、删除 容器</p>
<table>
<thead>
<tr>
<th>docker ps -a</th>
<th>列出素有容器(包括 未运行的)</th>
</tr>
</thead>
<tbody><tr>
<td>docker start web</td>
<td>启动容器web</td>
</tr>
<tr>
<td>docker stop web</td>
<td>停止容器web</td>
</tr>
<tr>
<td>docker rm web</td>
<td>删除容器</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 镜像 &amp; 容器和镜像的联系 读写层</title>
    <url>/2020/08/25/Docker%20%E9%95%9C%E5%83%8F%20&amp;%20%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E7%9A%84%E8%81%94%E7%B3%BB%20%E8%AF%BB%E5%86%99%E5%B1%82/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200304131346637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200304131346637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" class="lozad post-image"></p>
<p>Docker 镜像</p>
<h4 id="镜像是什么？"><a href="#镜像是什么？" class="headerlink" title="镜像是什么？"></a>镜像是什么？</h4><ul>
<li>一个分层存储的文件</li>
<li>一个软件的环境</li>
<li>一个镜像可以创建N个容器</li>
<li>一个标准化的交付</li>
<li>一个不包含Linux内核而又精简的Linux操作系统</li>
</ul>
<p>人性化一点 ↓</p>
<ol>
<li>docker镜像不包含Linux内核而又精简的Linux操作系统</li>
<li>docker镜像是一个分层存储的文件，一个镜像可以创建N个容器</li>
<li>可以这么理解，docker 镜像是 docker 容器的静态视角，docker 容器是 docker 镜像的运行状态。</li>
<li>容器只是对docker镜像的引用，如果docker镜像删除，此镜像创建的容器也都失效</li>
</ol>
<p>镜像不是一个单一的文件，而是有多层结构。我们可以通过 docker history &lt;ID/NAME&gt; 查看镜像中各层内容及大小，每层对应着DOckerfile 中的一条命令。Docker镜像默认存储在 /var/lib/docker/<storage-driver>中。</p>
<p>是在驱动中 所以说目录下的文件都有可能 最佳推荐：<code>overlay2</code></p>
<pre class="highlight"><span class="line">docker info  查看</span><br><span class="line"></span><br><span class="line">Storage Driver: overlay2</span><br></pre>

<h4 id="镜像从哪里来的？"><a href="#镜像从哪里来的？" class="headerlink" title="镜像从哪里来的？"></a>镜像从哪里来的？</h4><p>Docker Hub 是由 Docker公司负责维护公共注册中心，包含大量的容器镜像，Docker工具默认从这个公共镜像库下载镜像<br>地址: <a href="https://hub.docker.com/explore" target="_blank" rel="noopener">https://hub.docker.com/explore</a></p>
<p>我们看一下 镜像默认源 docker info<br><img src="https://img-blog.csdnimg.cn/20200304134108864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200304134108864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>拿到了地址 我们 ping 一下<br><img src="https://img-blog.csdnimg.cn/20200304134254433.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200304134254433.png" class="lozad post-image"><br>amazonaws:亚马逊服务器<br>也可以浏览器 访问一下端口<br><img src="https://img-blog.csdnimg.cn/20200304134401377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200304134401377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h5 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h5><p><a href="https://www.daocloud/mirror" target="_blank" rel="noopener">https://www.daocloud/mirror</a></p>
<pre class="highlight"><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh |sh -s http://f1361db2.m.daocloud.io</span><br><span class="line"><span class="number">1</span></span><br></pre>

<p>我们可以通过 命令查看 镜像加速的地址</p>
<pre class="highlight"><span class="line">cat /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">&#123;<span class="string">"registry-mirrors"</span>: [<span class="string">"http://f1361db2.m.daocloud.io"</span>]&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre>

<p>配置完 重启docker</p>
<pre class="highlight"><span class="line">systemctl restart docker</span><br><span class="line"><span class="number">1</span></span><br></pre>



<p>Docker 镜像和容器的联系、区别</p>
<p><img src="https://img-blog.csdnimg.cn/20200304142824563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200304142824563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>图中可以看出</p>
<ul>
<li>容器其实是在镜像的最上面加了一层读写层，在运行容器里文件改动时，会先从镜像里要写的文件复制到容器自己的文件系统中（读写层）。</li>
<li>如果容器删除了，最上面的读写层也就删除了，改动也就丢失了。</li>
<li>所以无论多少个容器共享一个镜像，所做的写操作都是从镜像的文件系统中复制（引用）过来的操作的，并不会修改镜像的源文件，这种方式提高磁盘利用率。</li>
<li>若想持久化这些改动，可以通过 docker commit 将容器保存成一个新的镜像。</li>
</ul>
<h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><pre class="highlight"><span class="line"><span class="comment"># 创建 nginx容器</span></span><br><span class="line">docker run -itd nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="number">12345</span></span><br></pre>

<p><img src="https://img-blog.csdnimg.cn/20200304143630125.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200304143630125.png" class="lozad post-image"><br>我们访问这个 容器的ID</p>
<pre class="highlight"><span class="line"><span class="comment"># 进入镜像</span></span><br><span class="line">docker <span class="keyword">exec</span> -it <span class="number">5</span>ceaf43bd114 bash</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line"><span class="number">1234</span></span><br></pre>

<p><img src="https://img-blog.csdnimg.cn/20200304143824221.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200304143824221.png" class="lozad post-image"><br>可以看出这个是和 镜像一样的。由此证出，docker 容器只是对 镜像进行了引用</p>
<p><code>***</code><br>读写层的意思就是说，</p>
<ul>
<li><p>镜像会将所有数据拷贝到读写层，然后进行操作</p>
</li>
<li><p>你在容器中 进行写入东西的时候 不管你写入多少，是对 引用的镜像是无反应的。<br><code>***</code></p>
</li>
</ul>
<h4 id="docker-容器和镜像的具体区别"><a href="#docker-容器和镜像的具体区别" class="headerlink" title="docker 容器和镜像的具体区别"></a>docker 容器和镜像的具体区别</h4><ol>
<li>当由 ubuntu:14.04 镜像启动容器时，ubuntu:14.04 镜像的镜像层内容将作为容器的 rootfs；</li>
<li>而 ubuntu:14.04 镜像的 json 文件，会由 docker daemon 解析，并提取出其中的容器执行入口 CMD 信息，<br>以及容器进程的环境变量 ENV 信息，最终初始化容器进程。</li>
<li>当然，容器进程的执行入口来源于镜像提供的 rootfs。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2020030414582499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/2020030414582499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="rootfs"><a href="#rootfs" class="headerlink" title="rootfs"></a>rootfs</h4><ol>
<li>rootfs 是 docker 容器在启动时内部进程可见的文件系统，即 docker 容器的根目录。</li>
<li>rootfs 通常包含一个操作系统运行所需的文件系统，例如可能包含典型的类 Unix 操作系统中的目录系统，<br>如 /dev、/proc、/bin、/etc、/lib、/usr、/tmp 及运行 docker 容器所需的配置文件、工具等。</li>
<li>在传统的 Linux 操作系统内核启动时，首先挂载一个只读的 rootfs，当系统检测其完整性之后，再将其切换为读写模式。</li>
<li>而在 docker 架构中，当 docker daemon 为 docker 容器挂载 rootfs 时，沿用了 Linux 内核启动时的做法，即将 rootfs 设为只读模式。</li>
<li>在挂载完毕之后，利用联合挂载(union mount)技术在已有的只读 rootfs 上再挂载一个读写层。</li>
<li>这样，可读写的层处于 docker 容器文件系统的最顶层，其下可能联合挂载了多个只读的层，</li>
<li>只有在 docker 容器运行过程中文件系统发生变化时，才会把变化的文件内容写到可读写层，并隐藏只读层中的旧版本文件。</li>
</ol>
<h4 id="查看容器中镜像内容"><a href="#查看容器中镜像内容" class="headerlink" title="查看容器中镜像内容"></a>查看容器中镜像内容</h4><pre class="highlight"><span class="line"><span class="comment"># 创建web1 容器</span></span><br><span class="line">docker run -itd --name=web1 -p <span class="number">192.168</span><span class="number">.56</span><span class="number">.14</span>:<span class="number">81</span>:<span class="number">80</span> nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器内容</span></span><br><span class="line">docker inspect web1 | more</span><br></pre>

<p>以下就是容器的详细信息</p>
<pre class="highlight"><span class="line"><span class="comment"># 只摘选局部</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"GraphDriver"</span>: &#123;</span><br><span class="line">            <span class="string">"Data"</span>: &#123;</span><br><span class="line">                <span class="string">"LowerDir"</span>: <span class="string">"/var/lib/docker/overlay2/51692869029f819494bb402dc70aa2869b8d1848c3b65c549a010a260e44cc13-init/diff:/var/lib/docker/overlay2/09fa1314e484781dfc1fb25a6cf5df2502fe35dea9025a373a3cb0202732ccce/diff:/var/lib/docker/overlay2/162ec5c9be56e5d718011c09ed087eda04b755e1a68bd1953c60f175e6635e68/diff:/var/lib/docker/overlay2/7c1b27ff59a397ae7d6bd106db579e90476f57bb1ecef9fcb1a6f1ad5ce43b7c/diff"</span>,</span><br><span class="line">                <span class="string">"MergedDir"</span>: <span class="string">"/var/lib/docker/overlay2/51692869029f819494bb402dc70aa2869b8d1848c3b65c549a010a260e44cc13/merged"</span>,</span><br><span class="line">                <span class="string">"UpperDir"</span>: <span class="string">"/var/lib/docker/overlay2/51692869029f819494bb402dc70aa2869b8d1848c3b65c549a010a260e44cc13/diff"</span>,</span><br><span class="line">                <span class="string">"WorkDir"</span>: <span class="string">"/var/lib/docker/overlay2/51692869029f819494bb402dc70aa2869b8d1848c3b65c549a010a260e44cc13/work"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"Name"</span>: <span class="string">"overlay2"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"NetworkSettings"</span>: &#123;</span><br><span class="line">            <span class="string">"Ports"</span>: &#123;</span><br><span class="line">                <span class="string">"80/tcp"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">"HostIp"</span>: <span class="string">"192.168.56.14"</span>,</span><br><span class="line">                        <span class="string">"HostPort"</span>: <span class="string">"81"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:11:00:02"</span>,</span><br><span class="line">            <span class="string">"Networks"</span>: &#123;</span><br><span class="line">                <span class="string">"bridge"</span>: &#123;</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"172.17.0.1"</span>,</span><br><span class="line">                    <span class="string">"IPAddress"</span>: <span class="string">"172.17.0.2"</span>,</span><br><span class="line">                    <span class="string">"IPPrefixLen"</span>: <span class="number">16</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre>

<p>可以看到 读写层（自己 吧下面得数字 Ctrl + F 看吧）</p>
<pre class="highlight"><span class="line">[root@linux-node4 diff] cd /var/lib/docker/overlay2/<span class="number">51692869029</span>f819494bb402dc70aa2869b8d1848c3b65c549a010a260e44cc13</span><br><span class="line"></span><br><span class="line">[root@linux-node4 <span class="number">51692869029</span>f819494bb402dc70aa2869b8d1848c3b65c549a010a260e44cc13]<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读写层的文件 </span></span><br><span class="line">diff  link  lower  merged  work</span><br></pre>

<p>work 是工作的地方<br>diff 是镜像和读写层的差异<br>merged 是镜像引用下来的 读写层</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch 索引、类型、文档。接口的方式 CURD</title>
    <url>/2020/08/05/ElasticSearch%20%E7%B4%A2%E5%BC%95%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E6%96%87%E6%A1%A3%E3%80%82%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E5%BC%8F%20CURD/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/gwd1154978352/article/details/82740424" target="_blank" rel="noopener">参考文档：https://blog.csdn.net/gwd1154978352/article/details/82740424</a></p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>索引是ElasticSearch存放数据的地方，可以理解为Mysql中的一个数据库。<br><code>你可以这么理解，你不能就说他是</code></p>
<p>我们的数据被 <strong>存储和索引在分片(shards)中</strong>，索引只是一个 把一个或多个分片分组在一起的逻辑空间。（就好像说）<code>这是一些内部细节我们不用关心分片。</code></p>
<p>对于我们的程序而言，文档存储在索引(index)中。剩下的细节由Elasticsearch关心既可。（索引的名字必须是全部小写，不能以下划线开头，不能包含逗号）</p>
<p><img src="https://img-blog.csdnimg.cn/20200612235843673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200612235843673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>类型用于区分同一个索引下不同的数据类型，相当于MySQL中的表。在Elasticsearch中，我们使用相同类型(type)的文档表示相同的“事物”，因为他们的数据结构也是相同的。每个类型(type)都有自己的映射(mapping)或者结构定义，就像传统数据库表中的列一样。所有类型下的文档被存储在同一个索引下，但是类型的映射(mapping)会告诉Elasticsearch不同的文档如何被索引。</p>
<p><img src="https://img-blog.csdnimg.cn/20200613000326776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200613000326776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>这个还是比较好理解的</p>
<h5 id="注：5-0版本之前，一个索引可以对应多个类型。5-0版本之后，一个索引只能对应一个类型"><a href="#注：5-0版本之前，一个索引可以对应多个类型。5-0版本之后，一个索引只能对应一个类型" class="headerlink" title="注：5.0版本之前，一个索引可以对应多个类型。5.0版本之后，一个索引只能对应一个类型"></a><code>注：5.0版本之前，一个索引可以对应多个类型。5.0版本之后，一个索引只能对应一个类型</code></h5><p><img src="https://img-blog.csdnimg.cn/20200613000611305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200613000611305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>文档是ElasticSearch中存储的实体，类比MySQL，每个文档相当于数据库表中的一行数据。 在Elasticsearch中，文档 <strong>(document)</strong> 这个术语有着特殊含义。它特指最顶层结构或者根对象(root object)序列化成的JSON数据（以唯一ID标识并存储于Elasticsearch中）。<br>文档由字段组成，相当于关系数据库中列的属性，不同的是ES的不同文档可以具有不同的字段集合。<br>对比关系型数据库：</p>
<pre class="highlight"><span class="line">Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns</span><br><span class="line">Elasticsearch -&gt; Indices   -&gt; Types  -&gt; Documents -&gt; Fields</span><br><span class="line"><span class="number">12</span></span><br></pre>

<h4 id="文档元数据"><a href="#文档元数据" class="headerlink" title="文档元数据"></a>文档元数据</h4><p>一个文档不只有数据。它还包含了元数据(metadata)——关于文档的信息。三个必须的元数据节点是：</p>
<table>
<thead>
<tr>
<th>节点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>_index</td>
<td>文档存储的地方</td>
</tr>
<tr>
<td>_type</td>
<td>文档代表的对象的类</td>
</tr>
<tr>
<td>_id</td>
<td>文档的唯一标识</td>
</tr>
</tbody></table>
<ul>
<li>_index：索引</li>
<li>_type：类型</li>
<li>_id：id仅仅是一个字符串，它与_index和_type组合时，就可以在Elasticsearch中唯一标识一个文档。当创建一个文档，<code>你可以自定义_id，也可以让Elasticsearch帮你自动生成。</code></li>
</ul>
<p>说的也就是这个 ↓<br><img src="https://img-blog.csdnimg.cn/20200613001612214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200613001612214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="索引创建的规则"><a href="#索引创建的规则" class="headerlink" title="索引创建的规则"></a>索引创建的规则</h4><ul>
<li>类似的数据放在一个索引，非类似的数据放不同索引</li>
<li>index中包含了很多类似的document</li>
<li>索引名称必须是小写的，不能用下划线开头，不能包含逗号：product，website，blog</li>
</ul>
<h4 id="创建索引、类型、文档（接口的方式）"><a href="#创建索引、类型、文档（接口的方式）" class="headerlink" title="创建索引、类型、文档（接口的方式）"></a>创建索引、类型、文档（接口的方式）</h4><p>刚才大家也看到了我的截图是在 Kibana上操作的，但现在书写的是以 接口的方式创建，Kibana 会在后续更新出来。</p>
<p>就随便写写</p>
<pre class="highlight"><span class="line">curl -H <span class="string">'Content-Type:application/json'</span> -XPUT http://localhost:<span class="number">9200</span>/Only_for_you/testing_data/<span class="number">1</span> -d <span class="string">"</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">      "</span>private_id<span class="string">": "</span><span class="number">1</span><span class="string">",</span></span><br><span class="line"><span class="string">      "</span>title<span class="string">": "</span>This <span class="keyword">is</span> an interesting piece of data<span class="string">",</span></span><br><span class="line"><span class="string">      "</span>content<span class="string">": "</span>I Really Really, really like yo<span class="string">u",</span></span><br><span class="line"><span class="string">      "</span>tags<span class="string">": ["</span>elasticsearch<span class="string">", "</span>Love Lette<span class="string">r"]</span></span><br><span class="line"><span class="string">&#125;"</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre>

<p>执行后 就会OK了，大家看到我在 类型的后面写了个 1，这个1 就代表了ID。如果不写的话 系统会自动生成的id，长度为20个字符，URL安全，base64编码，GUID，分布式系统并行生成时不可能会发生冲突。</p>
<p>就比如这条数据，我们更新他 <code>更新就不要用 put了，会error</code></p>
<pre class="highlight"><span class="line">curl -H <span class="string">'Content-Type:application/json'</span> -XPOST http://localhost:<span class="number">9200</span>/Only_for_you/testing_data/ -d <span class="string">"</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">      "</span>private_id<span class="string">": "</span><span class="number">1</span><span class="string">",</span></span><br><span class="line"><span class="string">      "</span>title<span class="string">": "</span>This <span class="keyword">is</span> an interesting piece of data<span class="string">",</span></span><br><span class="line"><span class="string">      "</span>content<span class="string">": "</span>I Really Really, really like yo<span class="string">u",</span></span><br><span class="line"><span class="string">      "</span>tags<span class="string">": ["</span>elasticsearch<span class="string">", "</span>Love Lette<span class="string">r"]</span></span><br><span class="line"><span class="string">&#125;"</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre>

<p>返回结果</p>
<pre class="highlight"><span class="line">&#123;</span><br><span class="line">  <span class="string">"_index"</span> : <span class="string">"Only_for_you"</span>,</span><br><span class="line">  <span class="string">"_type"</span> : <span class="string">"testing_data"</span>,</span><br><span class="line">  <span class="string">"_id"</span> : <span class="string">"oJVnqXIBlXk7LCfggxrl"</span>,</span><br><span class="line">  <span class="string">"_version"</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="string">"result"</span> : <span class="string">"updated"</span>,</span><br><span class="line">  <span class="string">"_shards"</span> : &#123;</span><br><span class="line">    <span class="string">"total"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">"successful"</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="string">"failed"</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_seq_no"</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="string">"_primary_term"</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br><span class="line">这里简单的概述下：POST 和 PUT 上的区别</span><br></pre>

<ul>
<li>POST不用加具体的id，它是作用在一个集合资源之上的（/uri）</li>
<li>PUT操作是作用在一个具体资源之上的（/uri/xxx），所以要指定ID</li>
</ul>
<h4 id="查看文档"><a href="#查看文档" class="headerlink" title="查看文档"></a>查看文档</h4><p>查看的话，方法很多种。</p>
<ul>
<li><p>浏览器直接 拼地址</p>
<p><img src="https://img-blog.csdnimg.cn/20200613005052905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200613005052905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
<li><p>使用ES浏览器插件</p>
<p><img src="https://img-blog.csdnimg.cn/20200613005208881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200613005208881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br><a href="https://download.csdn.net/download/weixin_44685869/12518847" target="_blank" rel="noopener">插件地址：https://download.csdn.net/download/weixin_44685869/12518847</a><br>我已经上传到我的 CSDN上传里了，你们可以在那里面找</p>
</li>
<li><p>在Linux中使用如下脚本：</p>
</li>
</ul>
<pre class="highlight"><span class="line">curl -H 'Content-Type:application/json' -XGET http://localhost:9200/Only_for_you/testing_data/1?pretty</span><br><span class="line"><span class="number">1</span></span><br></pre>

<h5 id="美化返回结果"><a href="#美化返回结果" class="headerlink" title="美化返回结果"></a>美化返回结果</h5><p>返回的响应包含了现在熟悉的元数据节点，增加了<code>_source</code>字段，它包含了在创建索引时我们发送给Elasticsearch的原始文档。</p>
<ul>
<li>pretty：在任意的查询字符串中增加pretty参数，类似于上面的例子。会让Elasticsearch美化输出(pretty-print)JSON响应以便更加容易阅读。</li>
<li>_source字段不会被美化，它的样子与我们输入的一致，现在只包含我们请求的字段，而且过滤了date字段。</li>
</ul>
<p>如果你只想得到_source字段而不要其他的元数据，你可以这样请求：</p>
<pre class="highlight"><span class="line">curl -H <span class="string">'Content-Type:application/json'</span> -XGET http://localhost:<span class="number">9200</span>/Only_for_you/testing_data/<span class="number">1</span>/_source</span><br><span class="line"><span class="number">1</span></span><br></pre>

<h5 id="返回响应头消息"><a href="#返回响应头消息" class="headerlink" title="返回响应头消息"></a>返回响应头消息</h5><p>请求返回的响应内容包括 {“found”: true}。这意味着文档已经找到。如果我们请求一个不存在的文档，依旧会得到一个JSON，不过found值变成了false。此外，HTTP响应状态码也会变成’404 Not Found’代替’200 OK’。我们可以在curl后加-i参数得到响应头：</p>
<pre class="highlight"><span class="line">curl -H 'Content-Type:application/json' -i -XGET http://localhost:9200/Only_for_you/testing_data/1?pretty</span><br><span class="line"><span class="number">1</span></span><br></pre>

<p>返回结果：</p>
<pre class="highlight"><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">content-type: application/json; charset=UTF<span class="number">-8</span></span><br><span class="line">content-length: <span class="number">337</span></span><br><span class="line"></span><br><span class="line">*********** 以下数据省略 ************</span><br><span class="line"><span class="number">123456</span></span><br></pre>

<h4 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h4><pre class="highlight"><span class="line">curl -H <span class="string">'Content-Type:application/json'</span> -XPOST http://localhost:<span class="number">9200</span>/Only_for_you/testing_data/<span class="number">1</span>/_update -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "script": "ctx._source.content = \"new content\""</span></span><br><span class="line"><span class="string">123</span></span><br></pre>

<h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><pre class="highlight"><span class="line">curl -XDELETE http://localhost:<span class="number">9200</span>/blog/article/<span class="number">1</span> </span><br><span class="line"><span class="number">1</span></span><br></pre>

<h4 id="增删改查-简单的概述下"><a href="#增删改查-简单的概述下" class="headerlink" title="增删改查 简单的概述下"></a>增删改查 简单的概述下</h4><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>POST</td>
<td>/uri 创建</td>
</tr>
<tr>
<td>DELETE</td>
<td>/uri/xxx 删除</td>
</tr>
<tr>
<td>PUT</td>
<td>/uri/xxx 更新或创建</td>
</tr>
<tr>
<td>GET</td>
<td>/uri/xxx 查看</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>ES检索</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 命令</title>
    <url>/2018/12/26/Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="1-系统信息"><a href="#1-系统信息" class="headerlink" title="1.系统信息"></a>1.系统信息</h2><pre class="highlight"><span class="line">arch 					显示机器的处理器架构</span><br><span class="line">uname -m 				显示机器的处理器架构</span><br><span class="line">uname -r 				显示正在使用的内核版本</span><br><span class="line">cat &#x2F;proc&#x2F;cpuinfo 		显示CPU info的信息</span><br><span class="line">cat &#x2F;proc&#x2F;interrupts 	显示中断</span><br><span class="line">cat &#x2F;proc&#x2F;meminfo 		校验内存使用</span><br><span class="line">cat &#x2F;proc&#x2F;swaps 		显示哪些swap被使用</span><br></pre>

<h2 id="2-关机"><a href="#2-关机" class="headerlink" title="2.关机"></a>2.关机</h2><pre class="highlight"><span class="line">shutdown -h now 		关闭系统</span><br><span class="line">init 0 					关闭系统</span><br><span class="line">telinit 0 				关闭系统</span><br><span class="line">shutdown -h hours:minutes &amp; 	按预定时间关闭系统</span><br><span class="line">shutdown -c 			取消按预定时间关闭系统</span><br><span class="line">shutdown -r now 		重启</span><br><span class="line">reboot 					重启</span><br><span class="line">logout 					注销</span><br></pre>
<h2 id="3-文件和目录"><a href="#3-文件和目录" class="headerlink" title="3.文件和目录"></a>3.文件和目录</h2><pre class="highlight"><span class="line">cd &#x2F;home 				进入 &#39;&#x2F; home&#39; 目录&#39; </span><br><span class="line">cd .. 					返回上一级目录 </span><br><span class="line">cd ..&#x2F;.. 					返回上两级目录 </span><br><span class="line">cd 						进入个人的主目录 </span><br><span class="line">cd ~user1 				进入个人的主目录 </span><br><span class="line">cd - 					返回上次所在的目录</span><br><span class="line"></span><br><span class="line">pwd 					显示工作路径 </span><br><span class="line">ls 						查看目录中的文件 </span><br><span class="line">ls -F 					查看目录中的文件 </span><br><span class="line">ls -l 					显示文件和目录的详细资料 </span><br><span class="line">ls -a 					显示隐藏文件 </span><br><span class="line">ls [0-9] 					显示包含数字的文件名和目录名 </span><br><span class="line">tree 					显示文件和目录由根目录开始的树形结构</span><br><span class="line">lstree 					显示文件和目录由根目录开始的树形结构</span><br><span class="line"></span><br><span class="line">mkdir dir1 				创建一个叫做 &#39;dir1&#39; 的目录&#39; </span><br><span class="line">mkdir dir1 dir2 			同时创建两个目录 </span><br><span class="line">mkdir -p &#x2F;tmp&#x2F;dir1&#x2F;dir2 创建一个目录树 </span><br><span class="line"></span><br><span class="line">rm -f file1 				删除一个叫做 &#39;file1&#39; 的文件&#39; </span><br><span class="line">rmdir dir1 				删除一个叫做 &#39;dir1&#39; 的目录&#39; </span><br><span class="line">rm -rf dir1 				删除一个叫做 &#39;dir1&#39; 的目录并同时删除其内容 </span><br><span class="line">rm -rf dir1 dir2 			同时删除两个目录及它们的内容 </span><br><span class="line">mv dir1 new_dir 		重命名&#x2F;移动 一个目录 </span><br><span class="line"></span><br><span class="line">cp file1 file2 			复制一个文件 </span><br><span class="line">cp dir&#x2F;* . 				复制一个目录下的所有文件到当前工作目录 </span><br><span class="line">cp -a &#x2F;tmp&#x2F;dir1 . 		复制一个目录到当前工作目录 </span><br><span class="line">cp -a dir1 dir2 			复制一个目录</span><br><span class="line">cp -r dir1 dir2 			复制一个目录及子目录</span><br><span class="line"></span><br><span class="line">ln -s file1 lnk1 			创建一个指向文件或目录的软链接 </span><br><span class="line">ln file1 lnk1 			创建一个指向文件或目录的物理链接 </span><br><span class="line">touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)</span><br></pre>

<h2 id="4-文件搜索"><a href="#4-文件搜索" class="headerlink" title="4.文件搜索"></a>4.文件搜索</h2><pre class="highlight"><span class="line">find &#x2F; -name file1 从 &#39;&#x2F;&#39; 	开始进入根文件系统搜索文件和目录 </span><br><span class="line">find &#x2F; -user user1 			搜索属于用户 &#39;user1&#39; 的文件和目录 </span><br><span class="line">find &#x2F;home&#x2F;user1 -name *.bin 	在目录 &#39;&#x2F; home&#x2F;user1&#39; 中搜索带有&#39;.bin&#39; 结尾的文件 </span><br><span class="line">find &#x2F;usr&#x2F;bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 </span><br><span class="line">find &#x2F;usr&#x2F;bin -type f -mtime -10 	搜索在10天内被创建或者修改过的文件 </span><br><span class="line">find &#x2F; -name *.rpm -exec chmod 755 &#39;&#123;&#125;&#39; \; 搜索以 &#39;.rpm&#39; 结尾的文件并定义其权限 </span><br><span class="line">find &#x2F; -xdev -name *.rpm 		搜索以 &#39;.rpm&#39; 结尾的文件，忽略光驱、捷盘等可移动设备 </span><br><span class="line">locate *.ps 				寻找以 &#39;.ps&#39; 结尾的文件 - 先运行 &#39;updatedb&#39; 命令 </span><br><span class="line">whereis halt 			显示一个二进制文件、源码或man的位置 </span><br><span class="line">which halt 				显示一个二进制文件或可执行文件的完整路径</span><br></pre>
<h2 id="5-挂载系统"><a href="#5-挂载系统" class="headerlink" title="5.挂载系统"></a>5.挂载系统</h2><pre class="highlight"><span class="line">mount &#x2F;dev&#x2F;hda2 &#x2F;mnt&#x2F;hda2 	挂载一个叫做hda2的盘 - 确定目录 &#39;&#x2F; mnt&#x2F;hda2&#39; 						已经存在 </span><br><span class="line">umount &#x2F;dev&#x2F;hda2 卸载一个叫做hda2的盘 - 先从挂载点 &#39;&#x2F; mnt&#x2F;hda2&#39; 退出 </span><br><span class="line">fuser -km &#x2F;mnt&#x2F;hda2 			当设备繁忙时强制卸载 </span><br><span class="line">umount -n &#x2F;mnt&#x2F;hda2 运行卸载操作而不写入 &#x2F;etc&#x2F;mtab 文件- 当文件为只读或当磁盘写满时非常有用 </span><br><span class="line">mount &#x2F;dev&#x2F;fd0 &#x2F;mnt&#x2F;floppy 	挂载一个软盘 </span><br><span class="line">mount &#x2F;dev&#x2F;cdrom &#x2F;mnt&#x2F;cdrom 		挂载一个cdrom或dvdrom </span><br><span class="line">mount &#x2F;dev&#x2F;hdc &#x2F;mnt&#x2F;cdrecorder 	挂载一个cdrw或dvdrom </span><br><span class="line">mount &#x2F;dev&#x2F;hdb &#x2F;mnt&#x2F;cdrecorder 	挂载一个cdrw或dvdrom </span><br><span class="line">mount -o loop file.iso &#x2F;mnt&#x2F;cdrom 	挂载一个文件或ISO镜像文件 </span><br><span class="line">mount -t vfat &#x2F;dev&#x2F;hda5 &#x2F;mnt&#x2F;hda5 	挂载一个Windows FAT32文件系统 </span><br><span class="line">mount &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;usbdisk 		挂载一个usb 捷盘或闪存设备</span><br></pre>

<h2 id="6-RPM管理工具"><a href="#6-RPM管理工具" class="headerlink" title="6.RPM管理工具"></a>6.RPM管理工具</h2><pre class="highlight"><span class="line">rpm -ivh package.rpm 	安装一个rpm包 </span><br><span class="line">rpm -ivh --nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告 </span><br><span class="line">rpm -U package.rpm 	更新一个rpm包但不改变其配置文件 </span><br><span class="line">rpm -F package.rpm 	更新一个确定已经安装的rpm包 </span><br><span class="line">rpm -e package_name.rpm 	删除一个rpm包 </span><br><span class="line">rpm -qa 显示系统中所有已经安装的rpm包 </span><br><span class="line">rpm -qa | grep httpd 	显示所有名称中包含 &quot;httpd&quot; 字样的rpm包 </span><br><span class="line">rpm -qi package_name 	获取一个已安装包的特殊信息 </span><br><span class="line">rpm -qg &quot;System Environment&#x2F;Daemons&quot; 显示一个组件的rpm包 </span><br><span class="line">rpm -ql package_name 	显示一个已经安装的rpm包提供的文件列表 </span><br><span class="line">rpm -qc package_name 	显示一个已经安装的rpm包提供的配置文件列表 </span><br><span class="line">rpm -q package_name --whatrequires 	显示与一个rpm包存在依赖关系的列表 </span><br><span class="line">rpm -q package_name --whatprovides 显示一个rpm包所占的体积 </span><br><span class="line">rpm -q package_name --scripts 显示在安装&#x2F;删除期间所执行的脚本l </span><br><span class="line">rpm -q package_name --changelog 	显示一个rpm包的修改历史 </span><br><span class="line">rpm -qf &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf 确认所给的文件由哪个rpm包所提供 </span><br><span class="line">rpm -qp package.rpm -l 	显示由一个尚未安装的rpm包提供的文件列表 </span><br><span class="line">rpm --import &#x2F;media&#x2F;cdrom&#x2F;RPM-GPG-KEY 导入公钥数字证书 </span><br><span class="line">rpm --checksig package.rpm 			确认一个rpm包的完整性 </span><br><span class="line">rpm -qa gpg-pubkey 		确认已安装的所有rpm包的完整性 </span><br><span class="line">rpm -V package_name 	检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 </span><br><span class="line">rpm -Va 				检查系统中所有已安装的rpm包- 小心使用 </span><br><span class="line">rpm -Vp package.rpm 	确认一个rpm包还未安装 </span><br><span class="line">rpm2cpio package.rpm | cpio --extract --make-directories bin 从一个rpm包运行可执行文件 </span><br><span class="line">rpm -ivh &#x2F;usr&#x2F;src&#x2F;redhat&#x2F;RPMS&#x2F;arch&#x2F;package.rpm 从一个rpm源码安装一个构建好的包 </span><br><span class="line">rpmbuild --rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包</span><br></pre>
<h2 id="7-YUM管理工具"><a href="#7-YUM管理工具" class="headerlink" title="7.YUM管理工具"></a>7.YUM管理工具</h2><pre class="highlight"><span class="line">yum install package_name 			下载并安装一个rpm包 </span><br><span class="line">yum localinstall package_name.rpm 	将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 </span><br><span class="line">yum update package_name.rpm 		更新当前系统中所有安装的rpm包 </span><br><span class="line">yum update package_name 			更新一个rpm包 </span><br><span class="line">yum remove package_name 			删除一个rpm包 </span><br><span class="line">yum list 							列出当前系统中安装的所有包 </span><br><span class="line">yum search package_name 			在rpm仓库中搜寻软件包 </span><br><span class="line">yum clean packages 					清理rpm缓存删除下载的包 </span><br><span class="line">yum clean headers 					删除所有头文件 </span><br><span class="line">yum clean all 						删除所有缓存的包和头文件</span><br></pre>
<h2 id="38查看文件内容"><a href="#38查看文件内容" class="headerlink" title="38查看文件内容"></a>38查看文件内容</h2><pre class="highlight"><span class="line">cat file1 		从第一个字节开始正向查看文件的内容 </span><br><span class="line">tac file1 		从最后一行开始反向查看一个文件的内容 </span><br><span class="line">more file1 		查看一个长文件的内容 </span><br><span class="line">less file1 		类似于 &#39;more&#39; 命令，但是它允许在文件中和正向操作一样的反向操作 </span><br><span class="line">head -2 file1 	查看一个文件的前两行 </span><br><span class="line">tail -2 file1 		查看一个文件的最后两行 </span><br><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;messages 	实时查看被添加到一个文件中的内容</span><br></pre>

<h2 id="9-字符设置、文件格式转换"><a href="#9-字符设置、文件格式转换" class="headerlink" title="9.字符设置、文件格式转换"></a>9.字符设置、文件格式转换</h2><pre class="highlight"><span class="line">dos2unix filedos.txt fileunix.txt 	将一个文本文件的格式从MSDOS转换成UNIX </span><br><span class="line">unix2dos fileunix.txt filedos.txt 	将一个文本文件的格式从UNIX转换成MSDOS </span><br><span class="line">recode ..HTML &lt; page.txt &gt; page.html 	将一个文本文件转换成html </span><br><span class="line">recode -l | more 				显示所有允许的转换格式</span><br></pre>

<h2 id="10-备份"><a href="#10-备份" class="headerlink" title="10.备份"></a>10.备份</h2><pre class="highlight"><span class="line"></span><br><span class="line">dump -0aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home 制作一个 &#39;&#x2F;home&#39; 目录的完整备份 </span><br><span class="line">dump -1aj -f &#x2F;tmp&#x2F;home0.bak &#x2F;home 制作一个 &#39;&#x2F;home&#39; 目录的交互式备份 </span><br><span class="line">restore -if &#x2F;tmp&#x2F;home0.bak 还原一个交互式备份 </span><br><span class="line">rsync -rogpav --delete &#x2F;home &#x2F;tmp 同步两边的目录 </span><br><span class="line">rsync -rogpav -e ssh --delete &#x2F;home ip_address:&#x2F;tmp 通过SSH通道</span><br><span class="line">rsync rsync -az -e ssh --delete ip_addr:&#x2F;home&#x2F;public &#x2F;home&#x2F;local 通过ssh和压缩将一个远程目录同步到本地目录 </span><br><span class="line">rsync -az -e ssh --delete &#x2F;home&#x2F;local ip_addr:&#x2F;home&#x2F;public 通过ssh和压缩将本地目录同步到远程目录 </span><br><span class="line">dd bs&#x3D;1M if&#x3D;&#x2F;dev&#x2F;hda | gzip | ssh user@ip_addr &#39;dd of&#x3D;hda.gz&#39; 通过ssh在远程主机上执行一次备份本地磁盘的操作 </span><br><span class="line">dd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D;&#x2F;tmp&#x2F;file1 备份磁盘内容到一个文件 </span><br><span class="line">tar -Puf backup.tar &#x2F;home&#x2F;user 执行一次对 &#39;&#x2F;home&#x2F;user&#39; 目录的交互式备份操作 </span><br><span class="line">( cd &#x2F;tmp&#x2F;local&#x2F; &amp;&amp; tar c . ) | ssh -C user@ip_addr &#39;cd &#x2F;home&#x2F;share&#x2F; &amp;&amp; tar x -p&#39; 通过ssh在远程目录中复制一个目录内容 </span><br><span class="line">( tar c &#x2F;home ) | ssh -C user@ip_addr &#39;cd &#x2F;home&#x2F;backup-home &amp;&amp; tar x -p&#39; 通过ssh在远程目录中复制一个本地目录 </span><br><span class="line">tar cf - . | (cd &#x2F;tmp&#x2F;backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 </span><br><span class="line">find &#x2F;home&#x2F;user1 -name &#39;*.txt&#39; | xargs cp -av --target-directory&#x3D;&#x2F;home&#x2F;backup&#x2F; --parents 从一个目录查找并复制所有以 &#39;.txt&#39; 结尾的文件到另一个目录 </span><br><span class="line">find &#x2F;var&#x2F;log -name &#39;*.log&#39; | tar cv --files-from&#x3D;- | bzip2 &gt; log.tar.bz2 查找所有以 &#39;.log&#39; 结尾的文件并做成一个bzip包 </span><br><span class="line">dd if&#x3D;&#x2F;dev&#x2F;hda of&#x3D;&#x2F;dev&#x2F;fd0 bs&#x3D;512 count&#x3D;1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 </span><br><span class="line">dd if&#x3D;&#x2F;dev&#x2F;fd0 of&#x3D;&#x2F;dev&#x2F;hda bs&#x3D;512 count&#x3D;1 从已经保存到软盘的备份中恢复MBR内容</span><br></pre>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 优化</title>
    <url>/2019/01/12/MySQL%20%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="1-选取最适用的字段属性"><a href="#1-选取最适用的字段属性" class="headerlink" title="1. 选取最适用的字段属性"></a>1. 选取最适用的字段属性</h1><p>表中字段的宽度设得尽可能小：char 的上限为 255 字节（固定占用空间），varchar 的上限 65535 字节（实际占用空间），text 的上限为 65535。char 比 varchar 处理效率高。</p>
<p>尽量把字段设置为 NOT NULL，执行查询的时候，数据库不用去比较 NULL 值。</p>
<h1 id="2-使用连接（JOIN）来代替子查询-Sub-Queries"><a href="#2-使用连接（JOIN）来代替子查询-Sub-Queries" class="headerlink" title="2. 使用连接（JOIN）来代替子查询 (Sub-Queries)"></a>2. 使用连接（JOIN）来代替子查询 (Sub-Queries)</h1><p>连接（JOIN）之所以更有效率一些，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作（联合查询的条件加索引更快）。</p>
<h1 id="3-使用联合-UNION-来代替手动创建的临时表"><a href="#3-使用联合-UNION-来代替手动创建的临时表" class="headerlink" title="3. 使用联合 (UNION) 来代替手动创建的临时表"></a>3. 使用联合 (UNION) 来代替手动创建的临时表</h1><p>把需要使用临时表的两条或更多的 SELECT 查询合并的一个查询中。</p>
<p>SELECT Name, Phone FROM client UNION SELECT Name, BirthDate FROM author UNION SELECT Name, Supplier FROM product;</p>
<h1 id="4-事务"><a href="#4-事务" class="headerlink" title="4. 事务"></a>4. 事务</h1><p>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条 SQL 语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。</p>
<p>作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以 BEGIN 关键字开始，COMMIT 关键字结束。在这之间的一条 SQL 操作失败，那么，ROLLBACK 命令就可以把数据库恢复到 BEGIN 开始之前的状态。</p>
<h1 id="5-锁定表"><a href="#5-锁定表" class="headerlink" title="5. 锁定表"></a>5. 锁定表</h1><p>尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在很大的应用系统中。由于在事务执行的过程中，数据库将会被锁定，因此其它的用户请求只能暂时等待直到该事务结束。</p>
<pre class="highlight"><span class="line">LOCK TABLE inventory WRITE </span><br><span class="line">SELECT Quantity FROM inventory </span><br><span class="line">WHEREItem=<span class="string">'book'</span>; </span><br><span class="line"><span class="meta">... </span></span><br><span class="line">UPDATE inventory SET Quantity=<span class="number">11</span> </span><br><span class="line">WHEREItem=<span class="string">'book'</span>; </span><br><span class="line">UNLOCK TABLES</span><br></pre>
<p>这里，我们用一个 SELECT 语句取出初始数据，通过一些计算，用 UPDATE 语句将新值更新到表中。包含有 WRITE 关键字的 LOCK TABLE 语句可以保证在 UNLOCK TABLES 命令被执行之前，不会有其它的访问来对 inventory 进行插入、更新或者删除的操作。</p>
<h1 id="6、使用外键"><a href="#6、使用外键" class="headerlink" title="6、使用外键"></a>6、使用外键</h1><p>锁定表的方法可以维护数据的完整性，但是它却不能保证数据的关联性。这个时候我们就可以使用外键。例如，外键可以保证每一条销售记录都指向某一个存在的客户。在这里，外键可以把 customerinfo 表中的 CustomerID 映射到 salesinfo 表中 CustomerID，任何一条没有合法 CustomerID 的记录都不会被更新或插入到 salesinfo 中。</p>
<pre class="highlight"><span class="line">CREATE TABLE customerinfo </span><br><span class="line">( </span><br><span class="line">CustomerID INT NOT NULL , </span><br><span class="line">PRIMARY KEY ( CustomerID ) </span><br><span class="line">) TYPE = INNODB; </span><br><span class="line">CREATE TABLE salesinfo </span><br><span class="line">( </span><br><span class="line">SalesID INT NOT NULL, </span><br><span class="line">CustomerID INT NOT NULL, </span><br><span class="line">PRIMARY KEY(CustomerID, SalesID), </span><br><span class="line">FOREIGN KEY (CustomerID) REFERENCES customerinfo </span><br><span class="line">(CustomerID) ON DELETECASCADE </span><br><span class="line">) TYPE = INNODB;</span><br></pre>

<p>注意例子中的参数 “ON DELETE CASCADE”。该参数保证当 customerinfo 表中的一条客户记录被删除的时候，salesinfo 表中所有与该客户相关的记录也会被自动删除。如果要在 MySQL 中使用外键，一定要记住在创建表的时候将表的类型定义为事务安全表 InnoDB 类型。该类型不是 MySQL 表的默认类型。定义的方法是在 CREATE TABLE 语句中加上 TYPE=INNODB。</p>
<h1 id="7-使用索引"><a href="#7-使用索引" class="headerlink" title="7. 使用索引"></a>7. 使用索引</h1><p>查询语句当中包含有 MAX (), MIN () 和 ORDERBY 这些命令的时候，性能提高更为明显。</p>
<p>索引应建立在那些将用于 JOIN, WHERE 判断和 ORDER BY 排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。对于一个 ENUM 类型的字段来说，出现大量重复值是很有可能的情况，例如 customerinfo 中的 “province”.. 字段，在这样的字段上建立索引将不会有什么帮助；相反，还有可能降低数据库的性能。</p>
<p>普通索引（由关键字 KEY 或 INDEX 定义的索引）的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHEREcolumn=）或排序条件（ORDERBYcolumn）中的数据列创建索引。</p>
<p>唯一索引的好处：一是简化了 MySQL 对这个索引的管理工作，这个索引也因此而变得更有效率；二是 MySQL 会在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过了；如果是，MySQL 将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。在许多场合，创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。</p>
<h1 id="8-优化的查询语句"><a href="#8-优化的查询语句" class="headerlink" title="8. 优化的查询语句"></a>8. 优化的查询语句</h1><pre class="highlight"><span class="line">SELECT FROM order WHERE YEAR(OrderDate)&lt;<span class="number">2001</span>; </span><br><span class="line">SELECT FROM order WHERE OrderDate&lt;<span class="string">"2001-01-01"</span>;</span><br><span class="line">SELECT FROM inventory WHERE Amount/<span class="number">7</span>&lt;<span class="number">24</span>; </span><br><span class="line">SELECT FROM inventory WHERE Amount&lt;<span class="number">24</span>*<span class="number">7</span>;</span><br></pre>
<p>避免在查询中让 MySQL 进行自动类型转换，因为转换过程也会使索引变得不起作用。</p>
<h1 id="9-索引失效情况"><a href="#9-索引失效情况" class="headerlink" title="9. 索引失效情况"></a>9. 索引失效情况</h1><p>like 以 % 开头，索引无效；当 like 前缀没有 %，后缀有 % 时，索引有效。</p>
<p>or 语句前后没有同时使用索引。当 or 左右查询字段只有一个是索引，该索引失效，只有当 or 左右查询字段均为索引时，才会生效。</p>
<p>组合索引，不是使用第一列索引，索引失效。</p>
<p>数据类型出现隐式转化。如 varchar 不加单引号的话可能会自动转换为 int 型，使索引无效，产生全表扫描。</p>
<p>在索引字段上使用 not，&lt;&gt;，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 优化方法： key&lt;&gt;0 改为 key&gt;0 or key&lt;0。</p>
<p>当全表扫描速度比索引速度快时，mysql 会使用全表扫描，此时索引失效。</p>
<p>应尽量避免在 where 子句中使用 or,and,in,not in 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，合理使用 union all（允许重复的值，请使用 UNION ALL）。</p>
<pre class="highlight"><span class="line">select id <span class="keyword">from</span> t where num=<span class="number">10</span> <span class="keyword">or</span> num=<span class="number">20</span></span><br></pre>
<p>可以这样查询：</p>
<pre class="highlight"><span class="line">select id <span class="keyword">from</span> t where num=<span class="number">10</span>    </span><br><span class="line">union all    </span><br><span class="line">select id <span class="keyword">from</span> t where num=<span class="number">20</span></span><br></pre>
<h1 id="10-引擎的选取"><a href="#10-引擎的选取" class="headerlink" title="10. 引擎的选取"></a>10. 引擎的选取</h1><p>MyISAM 索引文件在数据库中存放的对应表的磁盘文件有.frm,.MYD,*.MYI 结尾的三个文件：</p>
<p>frm 文件是存放的表结构，表的定义信息；</p>
<p>MYD 文件是存放着表中的数据；</p>
<p>MYI 文件存放着表的索引信息；</p>
<p>InnoDB 存储引擎在磁盘中存放的对应的表的磁盘文件有.frm,.ibd 这两个文件；</p>
<p>frm 文件是存放表结构，表的定义信息；</p>
<p>ibd 文件是存放 表中的数据、索引信息；</p>
<h1 id="性能方面的优化："><a href="#性能方面的优化：" class="headerlink" title="性能方面的优化："></a>性能方面的优化：</h1><h2 id="1-分表的分类（单表记录条数达到百万到千万级别时就要使用分表）"><a href="#1-分表的分类（单表记录条数达到百万到千万级别时就要使用分表）" class="headerlink" title="1.分表的分类（单表记录条数达到百万到千万级别时就要使用分表）"></a>1.分表的分类（单表记录条数达到百万到千万级别时就要使用分表）</h2><ol>
<li>纵向分表</li>
</ol>
<p>文章标题，作者，分类，创建时间等，是变化频率慢，查询次数多，而且最好有很好的实时性的数据，我们把它叫做冷数据。</p>
<p>浏览量，回复数等，类似的统计信息，或者别的变化频率比较高的数据，我们把它叫做活跃数据。</p>
<p>首先存储引擎的使用不同，冷数据使用 MyIsam 可以有更好的查询数据。活跃数据，可以使用 Innodb , 可以有更好的更新速度。</p>
<p>就是把原来一张表里的字段，冷数据的字段和活跃数据的字段分别建立 2 张表来管理。</p>
<ol start="2">
<li>横向分表</li>
</ol>
<p>把大的表结构，横向切割为同样结构的不同表，如，用户信息表，user_1,user_2 等，表结构是完全一样。</p>
<h2 id="2-慢查询"><a href="#2-慢查询" class="headerlink" title="2. 慢查询"></a>2. 慢查询</h2><pre class="highlight"><span class="line">show variables like <span class="string">'slow%'</span>;</span><br><span class="line">show <span class="keyword">global</span> status like <span class="string">'slow%'</span>;</span><br></pre>
<p>使用 mysqlreport；</p>
<p>正确使用索引：explain 分析查询语句，组合索引，索引副作用（占空间、update）</p>
<p>开启慢查询日志、使用慢查询分析工具 mysqlsla；</p>
<p>索引缓存、索引代价（插入更新索引）；</p>
<p>表锁，行锁，行锁副作用（update 多时候变慢），在 select 和 update 混合的情况下，行锁巧妙解决了读写互斥的问题；</p>
<p>开启使用查询缓存；</p>
<p>修改临时表内存空间；</p>
<p>开启线程池；</p>
<h1 id="MySQL-Query-语句优化的基本思路和原则"><a href="#MySQL-Query-语句优化的基本思路和原则" class="headerlink" title="MySQL Query 语句优化的基本思路和原则"></a>MySQL Query 语句优化的基本思路和原则</h1><p>1、优化需要优化的 Query；</p>
<p>2、定位优化对象的性能瓶颈；</p>
<p>3、明确优化目标；</p>
<p>4、从 Explaing 入手；</p>
<p>5、多使用 Profile；</p>
<p>6、永远用小结果集推动大的结果集；</p>
<p>7、尽可能在索引中完成排序；</p>
<p>8、只取自己需要的 Columns；</p>
<p>9、仅仅使用最有效的过滤条件；</p>
<p>10、尽可能避免复杂的 Join 和子查询。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP与HTTPS</title>
    <url>/2018/12/12/HTTP%E4%B8%8EHTTPS/</url>
    <content><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS9IVFRQLXZzLUhUVFBTLnBuZw?x-oss-process=image/format,png" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS9IVFRQLXZzLUhUVFBTLnBuZw?x-oss-process=image/format,png" class="lozad post-image"></p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>HTTP</strong>（HyperText Transfer Protocol：超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。 简单来说就是一种发布和接收 HTML 页面的方法，被用于在 Web 浏览器和网站服务器之间传递信息。</p>
<p>HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 HTTP 服务。</p>
<p>HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p>
<p><strong>HTTPS</strong>（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p>
<p><strong><em>HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：</em></strong></p>
<ol>
<li>TCP 三次同步握手</li>
<li>客户端验证服务器数字证书</li>
<li>DH 算法协商对称加密算法的密钥、hash 算法的密钥</li>
<li>SSL 安全加密隧道协商完成</li>
<li>网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。<h1 id="HTTP-与-HTTPS-区别"><a href="#HTTP-与-HTTPS-区别" class="headerlink" title="HTTP 与 HTTPS 区别"></a>HTTP 与 HTTPS 区别</h1></li>
</ol>
<ul>
<li>HTTP <strong>明文传输</strong>，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是<strong>加密</strong>的，安全性较好。<br>使用 HTTPS 协议需要到 <strong>CA（Certificate Authority，数字证书认证机构） 申请证书</strong>，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li>
<li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li>
<li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 <strong>80</strong>，后者是 <strong>443</strong>。</li>
<li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li>
<li><h1 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h1></li>
</ul>
<p><strong>在TCP/IP协议中，TCP协议通过三次握手建立一个可靠的连接</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS8wNTIzNDIzMy1lZWQ2ZGRjYmE5M2M0MmJlODg0N2U5OGQ2ZGE2MjgwMi5qcGc?x-oss-process=image/format,png" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS8wNTIzNDIzMy1lZWQ2ZGRjYmE5M2M0MmJlODg0N2U5OGQ2ZGE2MjgwMi5qcGc?x-oss-process=image/format,png" class="lozad post-image"></p>
<ul>
<li><strong>第一次握手</strong>：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认</li>
<li><strong>第二次握手</strong>：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态</li>
<li><strong>第三次握手</strong>：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS9kZmZkZmYucG5n?x-oss-process=image/format,png" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxOC8wOS9kZmZkZmYucG5n?x-oss-process=image/format,png" class="lozad post-image"><h1 id="客户端在使用HTTPS方式与Web服务器通信时的步骤"><a href="#客户端在使用HTTPS方式与Web服务器通信时的步骤" class="headerlink" title="客户端在使用HTTPS方式与Web服务器通信时的步骤"></a>客户端在使用HTTPS方式与Web服务器通信时的步骤</h1></li>
</ul>
<p><strong>1. 客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。<br>2. Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。<br>3. 客户端的浏览器与Web服务器开始协商SSL/TLS连接的安全等级，也就是信息加密的等级。<br>4. 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。<br>5. Web服务器利用自己的私钥解密出会话密钥。<br>6. Web服务器利用会话密钥加密与客户端之间的通信。</strong></p>
<p><img src="https://img-blog.csdn.net/20180920154005922?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdn.net/20180920154005922?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" class="lozad post-image"></p>
<p><img src="https://img-blog.csdn.net/20180920154006193?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdn.net/20180920154006193?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" class="lozad post-image"></p>
<p> <strong>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，但他大幅增加了中间人攻击的成本</strong></p>
<h1 id="CA证书的申请及其使用过程"><a href="#CA证书的申请及其使用过程" class="headerlink" title="CA证书的申请及其使用过程"></a>CA证书的申请及其使用过程</h1><p>上面客户端使用HTTPS与服务器通信中使用到了CA认证，这里可能大家会问为什么不直接使用非对称加密的形式直接进行，首先这里先介绍下非对称加密。</p>
<p>非对称加密：客户端和服务端均拥有一个公有密匙和一个私有密匙。公有密匙可以对外暴露，而私有密匙只有自己可见。</p>
<p>使用公有密匙加密的消息，只有对应的私有密匙才能解开。反过来，使用私有密匙加密的消息，只有公有密匙才能解开。这样客户端在发送消息前，先用服务器的公匙对消息进行加密，服务器收到后再用自己的私匙进行解密。<br>重做：</p>
<p><img src="https://img-blog.csdnimg.cn/20190426151155832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2,size_16,color_FFFFFF,t_70" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20190426151155832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h2 id="非对称加密的优点："><a href="#非对称加密的优点：" class="headerlink" title="非对称加密的优点："></a>非对称加密的优点：</h2><p>非对称加密采用公有密匙和私有密匙的方式，解决了http中消息保密性问题，而且使得私有密匙泄露的风险降低。</p>
<p>因为公匙加密的消息只有对应的私匙才能解开，所以较大程度上保证了消息的来源性以及消息的准确性和完整性。</p>
<h2 id="非对称加密的缺点："><a href="#非对称加密的缺点：" class="headerlink" title="非对称加密的缺点："></a>非对称加密的缺点：</h2><p>非对称加密时需要使用到接收方的公匙对消息进行加密，但是公匙不是保密的，任何人都可以拿到，中间人也可以。那么中间人可以做两件事，第一件是中间人可以在客户端与服务器交换公匙的时候，将客户端的公匙替换成自己的。这样服务器拿到的公匙将不是客户端的，而是中间人的。服务器也无法判断公匙来源的正确性。第二件是中间人可以不替换公匙，但是他可以截获客户端发来的消息，然后篡改，然后用服务器的公匙加密再发往服务器，服务器将收到错误的消息。</p>
<p>非对称加密的性能相对对称加密来说会慢上几倍甚至几百倍，比较消耗系统资源。正是因为如此，https将两种加密结合了起来。</p>
<p>为了应对上面非对称加密带来的问题，我们就引入了<strong>数字证书与数字签名</strong></p>
<p>故CA认证介入我们的HTTPS连接的过程如下：</p>
<p>1、服务器拥有自己的私钥与公钥</p>
<p>2、服务器将公钥交给CA认证机构，请求给予一份数字证书</p>
<p>3、CA认证机构生成数字证书，并颁发给服务器</p>
<p>4、服务器将带有公钥信息的数字证书发给客户端</p>
<p>5、进入客户端生成对称密钥再进行对接的过程……</p>
<p><img src="https://img-blog.csdnimg.cn/20190426152200712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2,size_16,color_FFFFFF,t_70" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20190426152200712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjQyMDM2,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h1 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h1><p> 　　<strong>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</strong></p>
<p>　　（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</p>
<p>　　（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p>
<p>　　（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p>
<p>　    （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p>
<p>　　（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p>
<p><strong><em>实践中建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将<a href="http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的" target="_blank" rel="noopener">http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的</a></em></strong></p>
<h1 id="SSL与TLS的区别"><a href="#SSL与TLS的区别" class="headerlink" title="SSL与TLS的区别"></a>SSL与TLS的区别</h1><p><strong>SSL</strong>：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。</p>
<p><strong>TLS</strong>：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。</p>
<h1 id="如何优化HTTPS的速度"><a href="#如何优化HTTPS的速度" class="headerlink" title="如何优化HTTPS的速度"></a>如何优化HTTPS的速度</h1><p><strong>1、HSTS重定向技术</strong></p>
<p>HSTS（HTTP Strict Transport Security）技术，启用HSTS后，将保证浏览器始终连接到网站的 HTTPS 加密版本。</p>
<ol>
<li><p>用户在浏览器里输入 HTTP 协议进行访问时，浏览器会自动将 HTTP 转换为 HTTPS 进行访问，确保用户访问安全；</p>
</li>
<li><p>省去301跳转的出现，缩短访问时间；</p>
</li>
<li><p>能阻止基于 SSL Strip 的中间人攻击，万一证书有错误，则显示错误，用户不能回避警告，从而能够更加有效安全的保障用户的访问。</p>
</li>
</ol>
<p><strong>2、TLS握手优化</strong></p>
<p>  在应用数据之前，客户端必须与服务端协商密钥、加密算法等信息，服务端还要把自己的证书发给客户端表明其身份，这些环节构成 TLS 握手过程。</p>
<p>采用 False Start （抢先开始）技术，浏览器在与服务器完成 TLS 握手前，就开始发送请求数据，服务器在收到这些数据后，完成 TLS 握手的同时，开始发送响应数据。</p>
<p>开启 False Start 功能后，数据传输时间将进一步缩短。</p>
<p><strong>3、Session Identifier（会话标识符）复用</strong></p>
<p>如果用户的一个业务请求包含了多条的加密流，客户端与服务器将会反复握手，必定会导致更多的时间损耗。或者某些特殊情况导致了对话突然中断，双方就需要重新握手，增加了用户访问时间。<br>（1）服务器为每一次的会话都生成并记录一个 ID 号，然后发送给客户端；</p>
<p>（2）如果客户端发起重新连接，则只要向服务器发送该 ID 号；</p>
<p>（3）服务器收到客户端发来的 ID 号，然后查找自己的会话记录，匹配 ID 之后，双方就可以重新使用之前的对称加密秘钥进行数据加密传输，而不必重新生成，减少交互时间。</p>
<p><strong>4、开启OSCP Stapling，提高TLS握手效率</strong></p>
<p>采用OCSP Stapling ，提升 HTTPS 性能。服务端主动获取 OCSP 查询结果并随着证书一起发送给客户端，从而客户端可直接通过 Web Server 验证证书，提高 TLS 握手效率。</p>
<p>服务器模拟浏览器向 CA 发起请求，并将带有 CA 机构签名的 OCSP 响应保存到本地，然后在与客户端握手阶段，将 OCSP 响应下发给浏览器，省去浏览器的在线验证过程。由于浏览器不需要直接向 CA 站点查询证书状态，这个功能对访问速度的提升非常明显。</p>
<p><strong>5、完全前向加密PFS，保护用户数据，预防私钥泄漏</strong></p>
<p>非对称加密算法 RSA，包含了公钥、私钥，其中私钥是保密不对外公开的，由于此算法既可以用于加密也可以用于签名，所以用途甚广，但是还是会遇到一些问题：</p>
<p>（1） 假如我是一名黑客，虽然现在我不知道私钥，但是我可以先把客户端与服务器之前的传输数据（已加密）全部保存下来</p>
<p>（2）如果某一天，服务器维护人员不小心把私钥泄露了，或者服务器被我攻破获取到了私钥</p>
<p>（3）那我就可以利用这个私钥，破解掉之前已被我保存的数据，从中获取有用的信息</p>
<p>所以为了防止上述现象发生，我们必须保护好自己的私钥。</p>
<p><strong><em>如果私钥确实被泄漏了，那我们改如何补救呢？那就需要PFS（perfect forward secrecy）完全前向保密功能，此功能用于客户端与服务器交换对称密钥，起到前向保密的作用，也即就算私钥被泄漏，黑客也无法破解先前已加密的数据。维基解释是：长期使用的主密钥泄漏不会导致过去的会话密钥泄漏</em></strong></p>
<p> <strong><em>实现此功能需要服务器支持以下算法和签名组合：</em></strong></p>
<p>（1）ECDHE 密钥交换、RSA 签名；<br>（2）ECDHE 密钥交换、ECDSA 签名；</p>
<hr>
<hr>
<h1 id="面试常见问题，HTTPS优化总结易记版："><a href="#面试常见问题，HTTPS优化总结易记版：" class="headerlink" title="面试常见问题，HTTPS优化总结易记版："></a>面试常见问题，HTTPS优化总结易记版：</h1><p><strong>1、HSTS重定向技术：将http自动转换为https，减少301重定向<br>2、TLS握手优化：在TLS握手完成前客户端就提前向服务器发送数据<br>3、会话标识符：服务器记录下与某客户端的会话ID，下次连接客户端发ID过来就可以直接用之前的私钥交流了<br>4、OSCP Stapling：服务器将带有 CA 机构签名的 OCSP 响应在握手时发给客户端，省的客户端再去CA查询<br>5、完全前向加密PFS：使用更牛逼复杂的秘钥算法</strong></p>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL存储引擎</title>
    <url>/2019/01/19/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1 id="什么是存储引擎"><a href="#什么是存储引擎" class="headerlink" title="什么是存储引擎"></a>什么是存储引擎</h1><p>数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。</p>
<p>现在许多数据库管理系统都支持多种不同的存储引擎。MySQL 的核心就是存储引擎。</p>
<p><strong><em>提示：InnoDB 事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5 之后，InnoDB 作为默认存储引擎。</em></strong></p>
<p>MyISAM 是基于 ISAM 的存储引擎，并对其进行扩展，是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。</p>
<p>MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他数据提供快速访问。</p>
<h1 id="MySQL-5-7-支持的存储引擎"><a href="#MySQL-5-7-支持的存储引擎" class="headerlink" title="MySQL 5.7 支持的存储引擎"></a>MySQL 5.7 支持的存储引擎</h1><p>MySQL 支持多种类型的数据库引擎，可分别根据各个引擎的功能和特性为不同的数据库处理任务提供各自不同的适应性和灵活性。在 MySQL 中，可以利用 SHOW ENGINES 语句来显示可用的数据库引擎和默认引擎。</p>
<p>MySQL 提供了多个不同的存储引擎，包括处理事务安全表的引擎和处理非事务安全表的引擎。在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。</p>
<p>MySQL 5.7 支持的存储引擎有 InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE 等。可以使用SHOW ENGINES语句查看系统所支持的引擎类型，结果如图所示。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTAyMjIvNC0xWjIyMjFLMDA2MTI1LmdpZg" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTAyMjIvNC0xWjIyMjFLMDA2MTI1LmdpZg" class="lozad post-image"></p>
<p>Support 列的值表示某种引擎是否能使用，<strong>YES</strong>表示可以使用，<strong>NO</strong>表示不能使用，<strong>DEFAULT</strong>表示该引擎为当前默认的存储引擎。</p>
<h1 id="如何选择-MySQL-存储引擎"><a href="#如何选择-MySQL-存储引擎" class="headerlink" title="如何选择 MySQL 存储引擎"></a>如何选择 MySQL 存储引擎</h1><p>不同的存储引擎都有各自的特点，以适应不同的需求，如表所示。为了做出选择，首先要考虑每一个存储引擎提供了哪些不同的功能。</p>
<p><img src="https://img-blog.csdnimg.cn/20200804140854255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU4Nzg2NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200804140854255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU4Nzg2NA==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>可以根据以下的原则来选择 MySQL 存储引擎：</p>
<ul>
<li>如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 是一个很好的选择。</li>
<li>如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。</li>
<li>如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。</li>
<li>如果只有 INSERT 和 SELECT 操作，可以选择Archive 引擎，Archive 存储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive 存储引擎非常适合存储归档数据，如记录日志信息可以使用 Archive 引擎。</li>
</ul>
<p><strong><em>提示：使用哪一种引擎要根据需要灵活选择，一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。</em></strong></p>
<h1 id="MySQL-默认存储引擎"><a href="#MySQL-默认存储引擎" class="headerlink" title="MySQL 默认存储引擎"></a>MySQL 默认存储引擎</h1><p>InnoDB 是系统的默认引擎，支持可靠的事务处理。</p>
<p>使用下面的语句可以修改数据库临时的默认存储引擎</p>
<pre class="highlight"><span class="line">SET default_storage_engine&#x3D;&lt; 存储引擎名 &gt;</span><br></pre>
<p>例如，将 MySQL 数据库的临时默认存储引擎修改为 MyISAM，输入的 SQL 语句和运行结果如图所示。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTAyMjIvNC0xWjIyMjFLNTAxTDEuZ2lm" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTAyMjIvNC0xWjIyMjFLNTAxTDEuZ2lm" class="lozad post-image"></p>
<p>此时，可以发现 MySQL 的默认存储引擎已经变成了 MyISAM。但是当再次重启客户端时，默认存储引擎仍然是 InnoDB。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql事务</title>
    <url>/2019/02/08/Mysql%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h1><ul>
<li>简单来说就是：做一件事件必须有有头有尾，一旦开始，只有两种结果，要么失败，要么成功，而不能出现成功了部分失败了部分。</li>
<li>专业点说就是：一个事务必须具备 ACID属性，所谓得 ACID即：<br> 1. Atomicity–原子性:<br> 事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。<br> 2. Consistency–一致性<br> 事务进行过后和执行前，所有数据都是预期一致的（一致性的理解有很多，大概是这样子的）<br> 3. Isolation–隔离性<br> 并发得事务之间不会互相影响，<br> 4. Durability–持久性<br> 一个事务成功了，那么他的的改变应该是永久性的。<h1 id="为什么要事务"><a href="#为什么要事务" class="headerlink" title="为什么要事务"></a>为什么要事务</h1>这个其实用脚趾头想想也知道它的重要性，举个简单的例子：<br>一个用户提交了一个订单，那么这条数据包含了两个信息，用户信息 和购买的 商品信息，我需要把他们分别存到 用户表 和 商品表，如果不采用事务，可能会出现，商品信息插入成功，而用户信息没有，这时候就会出现无主商品了，用户付了钱，却得不到商品，这就尴尬了，而如果采用事务，就可以保证，用户信息 和 商品信息 都必须插入成功，该次事务才算成功，那就不会出现这种问题了</li>
</ul>
<h1 id="支持事务的引擎"><a href="#支持事务的引擎" class="headerlink" title="支持事务的引擎"></a>支持事务的引擎</h1><p>有时候事务并不一定是必须的，为了提升查询效率，有些mysql引擎是不支持事务的，比如 MyISAM，当然目前新版（好像是5.6以后）默认的引擎是 innoDB 是支持事务的，一般为了提升mysql速度，也会做读写分离，因为事务一般是针对写来说的。</p>
<h1 id="事务的使用"><a href="#事务的使用" class="headerlink" title="事务的使用"></a>事务的使用</h1><p>我们主要从以下几个术语开始：</p>
<ul>
<li><p>事务（transaction）执行一组SQL语句；<br>start transaction即可开始一个事务</p>
</li>
<li><p>回退（rollback）撤销指定SQL语句的过程；<br>rollback即可回退一个事务：rollback 必须是在一个事务里面才能使用，没有事务，就不能谈回退</p>
</li>
<li><p>提交（commit）将未存储的SQL语句结果写入数据库表；<br>commit使用 commit 来结束一个事务的处理：一般使用事务，我们需要自己手动提交，mysql 默认是自动提交的，所以我们需要设置set autocommit = 0来更改提交模式。其中值得注意的是 rollback也会触发提交事务</p>
</li>
<li><p>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），然后你就可以回退到该点。<br>savepoint s1生成一个保留点，然后可以通过 rollback to s1来回退到 s1 这个保留</p>
</li>
</ul>
<p><strong>实例</strong><br>讲了这么多，不来一个实例操作一下，实在是不舒心。。。。下面你可以打开你的mysql 库，按照下面步骤来操作一下，加深下理解：</p>
<pre class="highlight"><span class="line">truncate info：</span><br><span class="line">先清除一下表,记得用测试表噢，数据没了可别赖我</span><br><span class="line">select * from info：</span><br><span class="line">查询一下，这里表应该是空的了</span><br><span class="line">start transaction：</span><br><span class="line">开启一个事务，正式我们的测试</span><br><span class="line">insert into info values(1,&quot;s1 before&quot;,20181019)：</span><br><span class="line">插入一条数据 “s1 before”</span><br><span class="line">savepoint s1：</span><br><span class="line">创建一个保留点</span><br><span class="line">insert into info values(1,&quot;s1 after&quot;,20181019)：</span><br><span class="line">再插入一条数据 “s1 after”</span><br><span class="line">select * from info：</span><br><span class="line">查询看一下数据，此时应该是可以看到我们上面插入的两条数据。但是你要知道，这两条数据是没有正式入库的，他们只存在你的这个session里面，因为我们的事务还没提交呢。。。不信？你重开一个客户端，查看一下这个表，还是空的噢。</span><br><span class="line">rollback to s1：</span><br><span class="line">回滚到 s1 保留点。</span><br><span class="line">select * from info：</span><br><span class="line">这个时候你应该是只能看到 “s1 after” 这条数据了，并且事务没有提交，验证的话，还是重启一个客户端查看就好</span><br><span class="line">rollback：</span><br><span class="line">回滚事务，也就是说，我们之前做的操作我都不要了，回滚到开始事务时候的状态，并结束事务。</span><br><span class="line">insert into info values(1,&quot;no transaction&quot;,20181019)：</span><br><span class="line">再插入一条数据</span><br><span class="line">select * from info：</span><br><span class="line">再另外一个客户端直接查询，立马看到上面插入的数据 “no transaction”，也是验证了事务确实结束了</span><br><span class="line">set autocommit&#x3D;0：</span><br><span class="line">上面我们插入数据，另外一个客户端立马就查询到了，说明是自动提交了我们的插入，现在我们设置不自动提交。</span><br><span class="line">insert into info values(1,&quot;autocommit&#x3D;0&quot;,20181019)：</span><br><span class="line">插入一条数据 “autocommit&#x3D;0”</span><br><span class="line">select * from info;</span><br><span class="line">在另外一个客户端查询，你会发现，上面这条 &quot;autocommit&#x3D;0&quot; 数据并没有插入</span><br><span class="line">commit</span><br><span class="line">提交，这个时候你再去查询，才能查到你提交的数据 &quot;autocommit&#x3D;0&quot;</span><br></pre>

<p><strong><em>这里需要注意的是，不要将非自动提交和事务搞混淆了，非自动提交，一般是为了批次提交从而提升效率，但是并不具备事务性，而事务是在批次提交的基础上保证了事务性，所以还是有一定区别的噢</em></strong></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL慢查询—开启慢查询</title>
    <url>/2019/01/30/MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E2%80%94%E5%BC%80%E5%90%AF%E6%85%A2%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。</p>
<h3 id="二、参数说明"><a href="#二、参数说明" class="headerlink" title="二、参数说明"></a>二、参数说明</h3><p>slow_query_log 慢查询开启状态<br>slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）<br>long_query_time 查询超过多少秒才记录</p>
<h3 id="三、设置步骤"><a href="#三、设置步骤" class="headerlink" title="三、设置步骤"></a>三、设置步骤</h3><p><strong>1.查看慢查询相关参数</strong></p>
<pre class="highlight"><span class="line">mysql&gt; show variables like <span class="string">'slow_query%'</span>;</span><br><span class="line">+---------------------------+----------------------------------+</span><br><span class="line">| Variable_name             | Value                            |</span><br><span class="line">+---------------------------+----------------------------------+</span><br><span class="line">| slow_query_log            | OFF                              |</span><br><span class="line">| slow_query_log_file       | /mysql/data/localhost-slow.log   |</span><br><span class="line">+---------------------------+----------------------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like <span class="string">'long_query_time'</span>;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | <span class="number">10.000000</span> |</span><br><span class="line">+-----------------+-----------+</span><br></pre>

<p><strong>2.设置方法</strong></p>
<p>方法一：全局变量设置<br>将 slow_query_log 全局变量设置为“ON”状态</p>
<pre class="highlight"><span class="line">mysql&gt; set global slow_query_log&#x3D;&#39;ON&#39;;</span><br></pre>

<p>设置慢查询日志存放的位置</p>
<pre class="highlight"><span class="line">mysql&gt; set global slow_query_log_file&#x3D;&#39;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;slow.log&#39;;</span><br></pre>

<p>查询超过1秒就记录</p>
<pre class="highlight"><span class="line">mysql&gt; set global long_query_time&#x3D;1;</span><br></pre>

<p>方法二：配置文件设置<br>修改配置文件my.cnf，在[mysqld]下的下方加入</p>
<pre class="highlight"><span class="line">[mysqld]</span><br><span class="line">slow_query_log &#x3D; ON</span><br><span class="line">slow_query_log_file &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;slow.log</span><br><span class="line">long_query_time &#x3D; 1</span><br></pre>

<p>3.重启MySQL服务</p>
<pre class="highlight"><span class="line">service mysqld restart</span><br></pre>

<p>4.查看设置后的参数</p>
<pre class="highlight"><span class="line">mysql&gt; show variables like &#39;slow_query%&#39;;</span><br><span class="line">+---------------------+--------------------------------+</span><br><span class="line">| Variable_name       | Value                          |</span><br><span class="line">+---------------------+--------------------------------+</span><br><span class="line">| slow_query_log      | ON                             |</span><br><span class="line">| slow_query_log_file | &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;slow.log |</span><br><span class="line">+---------------------+--------------------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#39;long_query_time&#39;;</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Variable_name   | Value    |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| long_query_time | 1.000000 |</span><br><span class="line">+-----------------+----------+</span><br></pre>

<h3 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h3><p>1.执行一条慢查询SQL语句</p>
<pre class="highlight"><span class="line">mysql&gt; select sleep(2);</span><br></pre>

<p>2.查看是否生成慢查询日志</p>
<pre class="highlight"><span class="line">ls &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data&#x2F;slow.log</span><br></pre>

<p>如果日志存在，MySQL开启慢查询设置成功！</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Admin 调整编辑页展示</title>
    <url>/2020/07/09/Python%20Admin%20%E8%B0%83%E6%95%B4%E7%BC%96%E8%BE%91%E9%A1%B5%E5%B1%95%E7%A4%BA/</url>
    <content><![CDATA[<h3 id="调整编辑页展示"><a href="#调整编辑页展示" class="headerlink" title="调整编辑页展示"></a>调整编辑页展示</h3><h4 id="1-显示字段"><a href="#1-显示字段" class="headerlink" title="1. 显示字段"></a>1. 显示字段</h4><p>属性如下：</p>
<pre class="highlight"><span class="line">fields=[]</span><br><span class="line"><span class="number">1</span></span><br></pre>

<ul>
<li>1）点击某行ID的链接，可以转到修改页面，默认效果如下图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200425220830424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425220830424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<ul>
<li>2）打开book/admin.py文件，修改BookInfoAdmin类如下：</li>
</ul>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    fields = [<span class="string">'name'</span>, <span class="string">'pub_date'</span>]</span><br><span class="line"><span class="number">123</span></span><br></pre>

<ul>
<li>3）刷新浏览器效果如下图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200425220857597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425220857597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="2-分组显示"><a href="#2-分组显示" class="headerlink" title="2. 分组显示"></a>2. 分组显示</h4><p>属性如下：</p>
<pre class="highlight"><span class="line">fieldsets=(</span><br><span class="line">    (<span class="string">'组1标题'</span>,&#123;<span class="string">'fields'</span>:(<span class="string">'字段1'</span>,<span class="string">'字段2'</span>)&#125;),</span><br><span class="line">    (<span class="string">'组2标题'</span>,&#123;<span class="string">'fields'</span>:(<span class="string">'字段3'</span>,<span class="string">'字段4'</span>)&#125;),</span><br><span class="line">)</span><br><span class="line"><span class="number">1234</span></span><br></pre>

<ul>
<li>1）打开 <code>admin.py</code> 文件，修改 <code>BookInfoAdmin</code> 类如下：</li>
</ul>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># fields = ['name', 'pub_date']</span></span><br><span class="line">    fieldsets = (</span><br><span class="line">        (<span class="string">'基本'</span>, &#123;<span class="string">'fields'</span>: [<span class="string">'name'</span>, <span class="string">'pub_date'</span>]&#125;),</span><br><span class="line">        (<span class="string">'高级'</span>, &#123;</span><br><span class="line">            <span class="string">'fields'</span>: [<span class="string">'readcount'</span>, <span class="string">'commentcount'</span>],</span><br><span class="line">            <span class="string">'classes'</span>: (<span class="string">'collapse'</span>,)  <span class="comment"># 是否折叠显示</span></span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line"><span class="number">12345678910</span></span><br></pre>

<ul>
<li>2）刷新浏览器效果如下图：<br><img src="https://img-blog.csdnimg.cn/20200425220934262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425220934262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br><code>说明：fields与fieldsets两者选一使用。</code></li>
</ul>
<h4 id="3-关联对象"><a href="#3-关联对象" class="headerlink" title="3. 关联对象"></a>3. 关联对象</h4><p>在一对多的关系中，可以在一端的编辑页面中编辑多端的对象，嵌入多端对象的方式包括表格、块两种。</p>
<ul>
<li>类型InlineModelAdmin：表示在模型的编辑页面嵌入关联模型的编辑。</li>
<li>子类TabularInline：以表格的形式嵌入。</li>
<li>子类StackedInline：以块的形式嵌入。</li>
</ul>
<ul>
<li>1）打开book/admin.py文件，创建PeopleInfoStackInLine类。</li>
</ul>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeopleInfoStackInLine</span><span class="params">(admin.StackedInline)</span>:</span></span><br><span class="line">    model = PeopleInfo <span class="comment">#要关联的模型</span></span><br><span class="line">    extra = <span class="number">2</span> <span class="comment">#附加编辑的数量</span></span><br><span class="line"><span class="number">123</span></span><br></pre>

<ul>
<li>2）打开book/admin.py文件，修改BookInfoAdmin类如下：</li>
</ul>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    inlines = [PeopleInfoStackInLine]</span><br><span class="line"><span class="number">1234</span></span><br></pre>

<ul>
<li>3）刷新浏览器效果如下图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200425222322288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425222322288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>可以用表格的形式嵌入。</p>
<ul>
<li>1）打开book/admin.py文件，创建PeopleInfoTabularInline类。</li>
</ul>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeopleInfoTabularInline</span><span class="params">(admin.TabularInline)</span>:</span></span><br><span class="line">    model = PeopleInfo <span class="comment">#要关联的模型</span></span><br><span class="line">    extra = <span class="number">2</span> <span class="comment">#附加编辑的数量</span></span><br><span class="line"><span class="number">123</span></span><br></pre>

<ul>
<li>2）打开book/admin.py文件，修改BookInfoAdmin类如下：</li>
</ul>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    inlines = [PeopleInfoTabularInline]</span><br><span class="line"><span class="number">1234</span></span><br></pre>

<ul>
<li>3）刷新浏览器效果如下图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200425222424301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425222424301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
]]></content>
      <categories>
        <category>djangobook</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中 uwsgi 获取不到全局变量</title>
    <url>/2020/05/03/Python%20%E4%B8%AD%20uwsgi%20%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h4 id="在使用-uwsgi-启动Python-脚本，或者项目的时候，会出现-访问不到-全局变量的问题。"><a href="#在使用-uwsgi-启动Python-脚本，或者项目的时候，会出现-访问不到-全局变量的问题。" class="headerlink" title="在使用 uwsgi 启动Python 脚本，或者项目的时候，会出现 访问不到 全局变量的问题。"></a>在使用 uwsgi 启动Python 脚本，或者项目的时候，会出现 访问不到 全局变量的问题。</h4><p>大家都知道 uwsgi 是可以指定子进程的数目的，我设置了进程数 为1，那么 我有两个函数，那么他只会处理一个（在同一时刻）。uwsgi为了线程的并发，独立运行了多个进程，所以他具有多个全局变量。</p>
<ul>
<li>uwsgi 的工作方式是启动指定个进程监听端口，接收到请求时就去执行对应的 uwsgi 入口文件，然后将结果返回给指定监听的端口。</li>
<li>当涉及到在一个 python 中修改全局变量或者多个线程访问一个变量的时候会不能获取到全局变量的修改。<br>因为每次请求都会重新执行一遍 python 脚本，从而每次都会重新初始化全局变量。</li>
</ul>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>将全局变量放置在进程里已经不可取了，所以将其拿出来，放入一个“公共访问区域”，让所有进程访问并修改该“公共访问区域”的全局变量。</p>
<ul>
<li>目前该“公共访问区域”可以有多种实现方式：</li>
</ul>
<ol>
<li>使用现成的数据库：redis，mongodb，mysql等;</li>
<li>自己实现一个管理进程对数据进行管理(参考multiprocessing模块);</li>
<li>利用 uwsgi 内置的缓存功能</li>
</ol>
<p>这里着重讲解第3种方式解决,可以最大限度的不依赖与第三方工具,并且借助 <code>uwsgi</code> 内置的方法.</p>
<pre class="highlight"><span class="line">关于“新一代”的缓存，它由uWSGI 1.9引入。 对于旧式缓存 (现在简单称其为“web缓存”)，可以看看 WebCaching框架</span><br><span class="line">1</span><br><span class="line">uWSGI包含了一个非常快速、全内存访问、零IPC、SMP安全、不断优化、高度可调的、键值存储的简单的“缓存框架”。</span><br><span class="line">单个uWSGI实例可以使用不同的设置，出于不同的目的，创建无限个不同的“缓存”。</span><br><span class="line">12</span><br></pre>

<ul>
<li>通过如下命令启动 <code>uwsgi</code>:</li>
</ul>
<pre class="highlight"><span class="line">uwsgi --cache2 name=mycache,items=<span class="number">100</span> --socket :<span class="number">3031</span></span><br><span class="line"><span class="number">1</span></span><br></pre>

<p>这将会创建一个名为<code>”mycache”</code>的缓存，它最多拥有100个项。每个项最大可以是64k。</p>
<ul>
<li>或者在 <code>uwsgi</code> 配置文件中添加如下配置(第一行是注释说明)</li>
</ul>
<pre class="highlight"><span class="line">; create a cache <span class="keyword">with</span> <span class="number">100</span> items (default size per-item <span class="keyword">is</span> <span class="number">64</span>k)</span><br><span class="line">cache2 = name=mycache,items=<span class="number">100</span>,blocksize=<span class="number">5000000</span></span><br><span class="line"><span class="number">12</span></span><br></pre>

<p>配置创建了一个 名为 <code>mycache</code> 的缓存,它最多拥有 100 个项,每个项最大可以是:5MB, 其中 <code>blocksize</code> 用来设置单个缓存的大小,单位是字节(Byte)</p>
<p>在添加好 <code>uwsgi</code> 缓存后就可以在 <code>python</code> 脚本中设置 需要公共访问的变量了,通过引入 <code>uwsgi</code> 模块并且调用下面的方法便可以使用 <code>uwsgi</code> 缓存.</p>
<ul>
<li>cache_get(key[,cache])</li>
<li>cache_set(key,value[,expires,cache])</li>
<li>cache_update(key,value[,expires,cache])</li>
<li>cache_exists(key[,cache])</li>
<li>cache_del(key[,cache])</li>
<li>cache_clear([cache])</li>
</ul>
<p>如果调用该缓存 <code>API</code> 的语言/平台区分了字符串和字节 (例如 <code>Python 3和Java</code>)，那么你必须假设键是字符串，而值是字节 (或者在java之下，是字节数组)。否则，键和值都是无特定编码的字符串，因为在内部，缓存值和缓存键都是简单的二进制blob。</p>
<ul>
<li><code>expires</code> 参数 (默认为0，表示禁用) 是对象失效的秒数 (并当未设置 <code>purge_lru</code> 的时候，由缓存清道夫移除，见下)</li>
<li><code>cache</code> 参数是所谓的“魔法标识符”，它的语法是 <code>cache[@node]</code></li>
</ul>
<p>具体配置方式可以参考:</p>
<ul>
<li><a href="https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/tutorials/CachingCookbook.html" target="_blank" rel="noopener">uWSGI 缓存烹饪指南：https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/tutorials/CachingCookbook.html</a></li>
<li><a href="https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/Caching.html" target="_blank" rel="noopener">uWSGI 缓存框架https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/Caching.html</a></li>
</ul>
<p>除此之外,推荐使用 <code>uwsgi_cache</code> 这个模块,这个模块利用了 <code>python</code> 本身的 <code>pickle</code> 模块对 <code>uwsgi</code> 中的<code>cache api</code> 进行了简单的封装,使得 <code>uwsgi</code> 可以进行缓存 <code>python</code> 的对象,在使用是需要注意的是避免缓存 <code>pickle</code> 不支持的对象,如 <code>python</code> 模块或者打开的文件等.具体原因不在此处讲解,可以参考 <code>python pickle</code> 模块 这篇博文.</p>
<p><code>uwsgi_cache</code> 这个模块本身提供了两个方法,具体内容可以参考 <code>uwsgi_cache</code> 主页</p>
<ul>
<li>使用 <code>uwsgi_cache</code> 模块完成缓存: 首先配置缓存:</li>
</ul>
<pre class="highlight"><span class="line">uwsgi test.py --cache2 name=api,items=<span class="number">1000</span></span><br><span class="line"><span class="number">1</span></span><br></pre>

<p>然后在 <code>test.py</code> 文件中调用 <code>uwsgi</code> 缓存 <code>api</code> 进行全局缓存</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> uwsgi_cache.cache <span class="keyword">import</span> CacheManager</span><br><span class="line"><span class="comment">#        :params:</span></span><br><span class="line"><span class="comment">#            name: the name of the cache that you would like to create</span></span><br><span class="line"><span class="comment">#            expires: the expire time of the cache data</span></span><br><span class="line"><span class="comment"># 这里需要传入两个参数 ,name 为缓存的名字,</span></span><br><span class="line"><span class="comment"># expires 为缓存的有效期, 0 表示禁用(即该缓存永不失效)</span></span><br><span class="line">cache = CacheManager(<span class="string">"cache_name_01"</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 调用缓存方法</span></span><br><span class="line">cache = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cache.exists(<span class="string">"count"</span>):</span><br><span class="line">	cache.set(<span class="string">"count"</span>,<span class="number">0</span>)</span><br><span class="line">	print(<span class="string">"count value is %d"</span>,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	count = cache.get(<span class="string">"count"</span>)</span><br><span class="line">	count +=<span class="number">1</span></span><br><span class="line">	print(<span class="string">"count value is %d"</span>,count)</span><br><span class="line">	cache.set(<span class="string">"count"</span>,count)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">	status = <span class="string">'200 OK'</span></span><br><span class="line">	response_body = <span class="string">"count value is %d"</span>,count</span><br><span class="line">	response_header = [(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)]</span><br><span class="line">	start_response(status, response_header)</span><br><span class="line">	<span class="keyword">return</span> [response_body.encode()]</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre>

<p>启动uwsgi,便会发现 count 的值会随着每次请求调用而不断增加.</p>
<pre class="highlight"><span class="line">uwsgi test.py --cache2 name=api,items=<span class="number">1000</span></span><br><span class="line"><span class="number">1</span></span><br></pre>

<p>参考原址:<a href="https://my.oschina.net/ghimi/blog/2705982" target="_blank" rel="noopener">https://my.oschina.net/ghimi/blog/2705982</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python常见基础算法题</title>
    <url>/2019/03/01/Python%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数"><a href="#1-判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数" class="headerlink" title="1.判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数."></a>1.判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数.</h3><p>示例 1:<br>输入: 121<br>输出: true</p>
<p>示例 2:<br>输入: -121<br>输出: false<br>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p>
<p>示例 3:<br>输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_num</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    判断传递的参数是否是回文数</span></span><br><span class="line"><span class="string">    :param num: 传递的参数</span></span><br><span class="line"><span class="string">    :return: 是回文数返回True 不是则false</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    num1 = str(num)</span><br><span class="line">    <span class="keyword">if</span> num1[::<span class="number">-1</span>] == num1:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(is_num(<span class="number">121</span>))</span><br></pre>

<h3 id="2-分别用生成器和迭代器生成斐波那契"><a href="#2-分别用生成器和迭代器生成斐波那契" class="headerlink" title="2.分别用生成器和迭代器生成斐波那契"></a>2.分别用生成器和迭代器生成斐波那契</h3><p>示例 1:</p>
<p>输出: 1  1   2   3   5  8  13   </p>
<pre class="highlight"><span class="line"><span class="comment"># 迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FibIterator</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,n)</span>:</span></span><br><span class="line">        <span class="string">"""实例属性的初始花和赋值"""</span></span><br><span class="line">        self.n = n      <span class="comment">#  数列长度</span></span><br><span class="line">        self.current = <span class="number">0</span>    <span class="comment">#  设置两个初始值</span></span><br><span class="line">        self.num1 = <span class="number">0</span></span><br><span class="line">        self.num2 = <span class="number">1</span>   <span class="comment">#  初始下标</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回迭代器对象的下一位置数据"""</span></span><br><span class="line">        <span class="comment"># 能拿到数据的情况</span></span><br><span class="line">        <span class="keyword">if</span> self.current &lt; self.n:</span><br><span class="line">            num = self.num1</span><br><span class="line">            self.num1,self.num2 = self.num2,self.num1+self.num2</span><br><span class="line">            self.current+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        <span class="comment"># 拿不到数据的情况</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span>  StopIteration    <span class="comment">#主动抛出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    fib = FibIterator(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> fib:</span><br><span class="line">        print(num)</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span> <span class="comment"># 创建一个函数</span></span><br><span class="line">    num1,num2 = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">    current = <span class="number">1</span>    <span class="comment"># 初始值</span></span><br><span class="line">    <span class="keyword">while</span> current &lt;= n:    <span class="comment"># i小于等于n，n次数 循环的控制条件</span></span><br><span class="line">        <span class="keyword">yield</span> num1    <span class="comment"># 返回a的值，但不结束函数</span></span><br><span class="line">        num1,num2 = num2 , num1 + num2</span><br><span class="line">        current += <span class="number">1</span>     <span class="comment"># 步长值</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> fib(<span class="number">10</span>):    <span class="comment"># 以for循环来获取yield每次的值</span></span><br><span class="line">    print(x)</span><br></pre>

<h3 id="3-字符串相乘：给定两个以字符串形式表示的非负整数-num1-和-num2，返回-num1-和-num2-的乘积，它们的乘积也表示为字符串形式"><a href="#3-字符串相乘：给定两个以字符串形式表示的非负整数-num1-和-num2，返回-num1-和-num2-的乘积，它们的乘积也表示为字符串形式" class="headerlink" title="3.字符串相乘：给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式"></a>3.字符串相乘：给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式</h3><p>示例 :<br>输入: num1 = “123”, num2 = “456”<br>输出: “56088”</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Func</span><span class="params">(num1,num2)</span>:</span></span><br><span class="line">    alist1 = <span class="string">''</span></span><br><span class="line">    alist2 = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num1:</span><br><span class="line">        <span class="keyword">if</span> i.isdigit():</span><br><span class="line">           alist1 += i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> num2:</span><br><span class="line">        <span class="keyword">if</span>  j.isdigit():</span><br><span class="line">            alist2 += j</span><br><span class="line">    str1=str(int(alist1) * int(alist2 ))</span><br><span class="line">    <span class="keyword">return</span> str1</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(Func(<span class="string">'11qq'</span>,<span class="string">'zz99xx'</span>))</span><br></pre>

<h3 id="4-实现一个算法来实现反转字符数组的功能-反转的要求如下：将字符数组的字符进行反转-例如-‘b’-‘-‘-‘a’-‘r’-变成-‘r’-‘a’-‘-‘-‘b’-将字符数组替换为反转后的数组。"><a href="#4-实现一个算法来实现反转字符数组的功能-反转的要求如下：将字符数组的字符进行反转-例如-‘b’-‘-‘-‘a’-‘r’-变成-‘r’-‘a’-‘-‘-‘b’-将字符数组替换为反转后的数组。" class="headerlink" title="4.实现一个算法来实现反转字符数组的功能,反转的要求如下：将字符数组的字符进行反转,例如 [‘b’, ‘ ‘, ‘a’, ‘r’],变成 [‘r’, ‘a’, ‘ ‘, ‘b’] , 将字符数组替换为反转后的数组。"></a>4.实现一个算法来实现反转字符数组的功能,反转的要求如下：将字符数组的字符进行反转,例如 [‘b’, ‘ ‘, ‘a’, ‘r’],变成 [‘r’, ‘a’, ‘ ‘, ‘b’] , 将字符数组替换为反转后的数组。</h3><h5 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h5><p>常规的解法是创建一个相同长度的新数组，<br>然后把第一个数组中的元素，按倒序放入新数组中。<br>但更简单的方法是：利用 Python 交换变量的特性，<br>不需要新建数组，直接在原数组里即可完成</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, chars)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> chars:</span><br><span class="line">        size = len(chars)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size // <span class="number">2</span>):</span><br><span class="line">            chars[i], chars[size - <span class="number">1</span> - i] = chars[size - <span class="number">1</span> - i], chars[i]</span><br><span class="line">        <span class="keyword">return</span> chars</span><br><span class="line">print(reverse(<span class="string">'h'</span>,<span class="string">'a'</span>))</span><br></pre>
<h3 id="5-栈：也称下压栈，堆栈，是仅允许在表尾进行插入和删除操作的线性表"><a href="#5-栈：也称下压栈，堆栈，是仅允许在表尾进行插入和删除操作的线性表" class="headerlink" title="5.栈：也称下压栈，堆栈，是仅允许在表尾进行插入和删除操作的线性表,"></a>5.栈：也称下压栈，堆栈，是仅允许在表尾进行插入和删除操作的线性表,</h3><p>特点：先进后出   后进先出</p>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""初始化"""</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">"""push(item)添加一个新的元素item到栈顶"""</span></span><br><span class="line">        self.stack.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""pop()弹出栈顶元素"""</span></span><br><span class="line">        <span class="keyword">if</span> self.stack == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""peek()返回栈顶元素"""</span></span><br><span class="line">        <span class="keyword">if</span> self.stack == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.stack[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""is_empty()判断栈是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.stack == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""size()返回栈的元素个数"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.stack)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    stack = Stack()</span><br><span class="line">    stack.push(<span class="number">1</span>)</span><br><span class="line">    stack.pop()</span><br><span class="line">    print(stack.peek())</span><br><span class="line">    print(stack.isEmpty())</span><br><span class="line">    print(stack.size())</span><br></pre>
<h3 id="6-队列：是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。"><a href="#6-队列：是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。" class="headerlink" title="6.队列：是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。"></a>6.队列：是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</h3><p>特点：先进先出   后进后出</p>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""实例属性的初始化和赋值创建一个空的队列"""</span></span><br><span class="line">        self.queue = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        <span class="string">"""往队列中添加一个item元素"""</span></span><br><span class="line">        self.queue.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断一个队列是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.queue==[]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""从队列头部删除一个元素"""</span></span><br><span class="line">        <span class="keyword">if</span> self.queue==[]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span>  self.queue.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回队列大小"""</span></span><br><span class="line">        <span class="keyword">return</span>  len(self.queue)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    q=Queue()</span><br><span class="line">    q.enqueue(<span class="number">1</span>)</span><br><span class="line">    q.enqueue(<span class="number">2</span>)</span><br><span class="line">    q.enqueue(<span class="number">3</span>)</span><br><span class="line">    q.enqueue(<span class="number">4</span>)</span><br><span class="line">    q.enqueue(<span class="number">5</span>)</span><br><span class="line">    print(q.is_empty())</span><br><span class="line">    print(<span class="string">"长度为："</span>,q.size())</span><br><span class="line">    print(q.dequeue())</span><br></pre>

<h3 id="7-去掉空格"><a href="#7-去掉空格" class="headerlink" title="7.去掉空格"></a>7.去掉空格</h3><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_num</span><span class="params">(par_str)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param par_str: 字符串</span></span><br><span class="line"><span class="string">    :return: num</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    par_list = par_str.split(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">    print([i <span class="keyword">for</span> i <span class="keyword">in</span> par_list <span class="keyword">if</span> i])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> par_list:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">""</span> <span class="keyword">in</span> par_list:</span><br><span class="line">            par_list.remove(<span class="string">""</span>)</span><br><span class="line">    print(par_list)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    get_num(<span class="string">'hello, python   hello ,   world'</span>)</span><br></pre>
<h3 id="8-两数之和"><a href="#8-两数之和" class="headerlink" title="8.两数之和"></a>8.两数之和</h3><p> 方法1：<br> <pre class="highlight"><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">get_num_index</span><span class="params">(llist,target)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param target: 俩个下标值的和</span></span><br><span class="line"><span class="string">        :param llist: 查看下标所用的列表</span></span><br><span class="line"><span class="string">        :return: 返回符合条件的两个下标值</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,val <span class="keyword">in</span> enumerate(llist):</span><br><span class="line">            y += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> llist[x] +llist[y]==target:</span><br><span class="line">                <span class="keyword">return</span> (x,y)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(get_num_index([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],<span class="number">7</span>))</span><br></pre></p>
<p>方法2：</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_num_index</span><span class="params">(llist, target)</span>:</span></span><br><span class="line">            <span class="string">'''</span></span><br><span class="line"><span class="string">            :param target: 给定值</span></span><br><span class="line"><span class="string">            :param llist: 查看条件列表</span></span><br><span class="line"><span class="string">            :return: 返回符合条件的下标值</span></span><br><span class="line"><span class="string">            '''</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> llist:</span><br><span class="line">                y = target - i</span><br><span class="line">                <span class="keyword">if</span> y != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> y <span class="keyword">in</span> llist:</span><br><span class="line">                        <span class="keyword">if</span> llist.index(i) == llist.index(y):</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="comment"># if llist.index(i) &lt;= llist.index(y):</span></span><br><span class="line">                        <span class="keyword">return</span> llist.index(y), llist.index(i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> llist.index(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(get_num_index([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">13</span>],<span class="number">13</span>))</span><br></pre>
<h3 id="9-比较：取值第三个大的数"><a href="#9-比较：取值第三个大的数" class="headerlink" title="9.比较：取值第三个大的数"></a>9.比较：取值第三个大的数</h3><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(num)&gt;=<span class="number">3</span>:</span><br><span class="line">        alist=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sorted(num):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                alist.index(i)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                alist.append(i)</span><br><span class="line">        <span class="keyword">return</span> alist[<span class="number">-3</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    num=[<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">8</span>]</span><br><span class="line">    print(func(num))</span><br></pre>
<h3 id="10-反转字符数组"><a href="#10-反转字符数组" class="headerlink" title="10.反转字符数组"></a>10.反转字符数组</h3><pre class="highlight"><span class="line"><span class="comment"># 反转字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(s)</span>:</span></span><br><span class="line">    s[<span class="number">0</span>::] = s[::<span class="number">-1</span>]</span><br><span class="line">    print(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    reverseString([<span class="string">'b'</span>, <span class="string">''</span>, <span class="string">'a'</span>, <span class="string">'r'</span>])</span><br></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python *args 和 **kwargs</title>
    <url>/2020/04/30/Python%20%E7%9A%84args%20%E5%92%8C%20kwargs/</url>
    <content><![CDATA[<p>在 python 中，<em>args 和 *</em>kwargs 都代表 1个 或 多个 参数的意思。<em>args 传入tuple 类型的无名参数，而 *</em>kwargs 传入的参数是 dict 类型。下文举例说明。</p>
<ol>
<li>*args 的用法，以下测试代码：</li>
</ol>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(*args)</span>:</span>  </span><br><span class="line">    print(args)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">        print(i)</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出值分别为</span></span><br><span class="line"><span class="comment"># (1,2,3)</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre>

<ol>
<li>**kwargs 的用法，以下测试代码：</li>
</ol>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    print(kwargs)</span><br><span class="line">    keys = kwargs.keys()</span><br><span class="line">    value = kwargs.values()</span><br><span class="line">    print(keys)</span><br><span class="line">    print(value)</span><br><span class="line"></span><br><span class="line">test(a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>,d=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出值分别为</span></span><br><span class="line"><span class="comment"># &#123;'a': 1, 'b': 2, 'c': 3, 'd': 4&#125;</span></span><br><span class="line"><span class="comment"># dict_keys(['a', 'b', 'c', 'd'])</span></span><br><span class="line"><span class="comment"># dict_values([1, 2, 3, 4])</span></span><br></pre>

<p>参考原址：<a href="https://www.cnblogs.com/shenh/p/10487626.html" target="_blank" rel="noopener">https://www.cnblogs.com/shenh/p/10487626.html</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis使用教程</title>
    <url>/2019/04/15/Redis%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-Redis的安装过程"><a href="#1-Redis的安装过程" class="headerlink" title="1. Redis的安装过程"></a>1. Redis的安装过程</h1><p>（1） 下载Redis<br>这里就随便下，无论是安装包也好压缩包也好怎么都行</p>
<p>（2） 配置环境变量<br>配完了之后可以不需要进入Redis的那个目录，然后可以直接敲redis…..把这个服务启动起来。</p>
<p>（3） 把Redis变成一个服务<br>至少你在服务页面估计能看到他，然后定成自动启动，省的天天手动。</p>
<p>（4） 设置密码<br>在Redis这个文件夹里面编辑redis.windows-service.conf，类似的conf文件有两个，千万分清楚这个后面带service的。<br>使用这种方式设置是永久性设置。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDc0Mzk3OS1lMGMwODVmMGRlNDdjZjEyLnBuZw?x-oss-process=image/format,png" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDc0Mzk3OS1lMGMwODVmMGRlNDdjZjEyLnBuZw?x-oss-process=image/format,png" class="lozad post-image"><br>（5） 打开本地客户端<br>如果要查询里面的键值对是什么之类的，就用redis-cli。<br>设置了密码之后，上来输入的就是 auth 123456（根据自己的密码改）</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDc0Mzk3OS0wNDIwZjA0M2U2NWNiN2FjLnBuZw?x-oss-process=image/format,png" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDc0Mzk3OS0wNDIwZjA0M2U2NWNiN2FjLnBuZw?x-oss-process=image/format,png" class="lozad post-image"></p>
<p>安装、打开、设置密码（就是配Redis环境）这些应该也可以用docker完成</p>
<h1 id="2-SpringBoot集成Redis"><a href="#2-SpringBoot集成Redis" class="headerlink" title="2. SpringBoot集成Redis"></a>2. SpringBoot集成Redis</h1><p>（1） 在pom里导入一个jar包<br>（2） yml配置</p>
<pre class="highlight"><span class="line">redis:</span><br><span class="line">   host: localhost # Redis服务器地址</span><br><span class="line">   database: 0 # Redis数据库索引（默认为0）</span><br><span class="line">   port: 6379 # Redis服务器连接端口</span><br><span class="line">   password:&quot;test&quot; # Redis服务器连接密码（默认为空，以及这里带引号！！！）</span><br><span class="line">   jedis:</span><br><span class="line">     pool:</span><br><span class="line">       max-active: 8 # 连接池最大连接数（使用负值表示没有限制），能制造出来的最大的连接数</span><br><span class="line">       max-wait: -1ms # 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">       max-idle: 8 # 连接池中的最大空闲连接，空闲太多可能销毁</span><br><span class="line">       min-idle: 0 # 连接池中的最小空闲连接，务必保持几个控线连接</span><br><span class="line">   timeout: 3000ms # 连接超时时间（毫秒）</span><br></pre>

<p>（3） 注入Template开始用<br>经过了上两个步骤之后，其实就已经配置好了，在代码里面注入Template就可以set、get然后启用了。</p>
<p>Teplate目前已知的有两种，一种是RedisTemplate，一种是<br>StringRedisTemplate（这种其实也就是RedisTemplate&lt;String,String&gt;），就是封装了一下写的高大上了。<br>所以自己用的时候只能用RedisTemplate，如果需要的话自己写泛型。</p>
<p>序列化器：<br>由于RedisTemplate里面注入的直接就是object，需要被缓存的类实现了Serielizable接口才行。</p>
<p>简单写一下Serielizable：<br>Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行状态时，这些对象才能存在，即，这些对象的生命周期不会比JVM更长。但在现实中，就可能要求在JVM运行停止后能够保存（持久化），以便下次运行时重新获取对象，Java对象序列化就能够帮助我们实现该功能。<br>网络上远程传递的时候也需要实现这个功能。</p>
<p>如果仅仅只是让某个类实现Serializable接口，而没有其他处理的话，则就是使用默认序列化机制。使用默认机制，在序列化对象时，不仅会序列化当前对象本身，还会对该对象引用的其他对象也进行序列化，同样的，这些其他对象引用的另外对象也将被序列化，以此类推。所以，如果一个对象的成员变量是容器类对象，而这些容器含有的元素也是容器类对象，那么这个序列化对象的过程就会很复杂，开销也很大。<br>transient关键字可以忽略掉某些字段。</p>
<h1 id="3-Redis连接池"><a href="#3-Redis连接池" class="headerlink" title="3. Redis连接池"></a>3. Redis连接池</h1><p>（1） 为什么要用连接池：<br>连接池定义：连接池是创建和管理一个连接的缓冲池的技术，这些连接准备好被任何需要它们的线程。</p>
<p>连接池管理的就是连接，每次存取数据的时候，都要new一个连接对象出来，建立一个TCP连接要经历三次握手什么的，这样挺浪费时间的，所以每次用完连接对象之后不释放，存到连接池里面去，下次用连接对象的时候去连接池里面获取。</p>
<p>（2） 手写Redis连接池：<br>Redis连接池这东西一共就三个函数，一个init，一个getResource，一个release。<br>其中尤其以getResources为核心。</p>
<p>首先如果要完成连接池保存，要有存储容器，set、list、queue、array、map这些是要选择一下的。<br>频繁的存取，不能用array，不能用array的也不能用list，map不需要key，queue和set两个平分，最终用queue。<br>那就要有两个queue来放置空闲的和被使用的连接。</p>
<p>getResource的调用流程：（中间把config都用上了）<br>如果有空闲连接直接返回<br>没有空闲的但是目前总数还没超过max，可以再new一个<br>总数已经到max了，没法new了就只能等<br>如果超过了等待时间，返回报错</p>
<p>release调用流程：<br>把这个连接从使用中队列移动到空闲队列</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自省机制</title>
    <url>/2020/05/17/Python%E8%87%AA%E7%9C%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h4 id="什么是自省？"><a href="#什么是自省？" class="headerlink" title="什么是自省？"></a>什么是自省？</h4><p>在日常生活中，自省（introspection）是一种自我检查行为。</p>
<p>在计算机编程中，自省是指这种能力：检查某些事物以确定它是什么、它知道什么以及它能做什么。自省向程序员提供了极大的灵活性和控制力。</p>
<ul>
<li><p>说的更简单直白一点：</p>
<p>自省就是面向对象的语言所写的程序在运行时，能够知道对象的类型。简单一句就是，运行时能够获知对象的类型。</p>
</li>
<li><p>例如：</p>
<p>python, buby, object-C, c++都有自省的能力，<br>这里面的c++的自省的能力最弱，只能够知道是什么类型，而像python可以知道是什么类型，还有什么属性。</p>
</li>
</ul>
<p>最好的理解自省就是通过例子： [Type introspection<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Type_introspection">https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Type_introspection</a></p>
<p>](<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Type_introspection)这里是各种编程语言中自省（introspection）的例子。链接里面满满的干货">https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Type_introspection)这里是各种编程语言中自省（introspection）的例子。链接里面满满的干货</a></p>
<p>Python 中比较常见的自省（introspection）机制(函数用法)有： <code>dir()，type(), hasattr(), isinstance()</code>，通过这些函数，我们能够在程序运行时得知对象的类型，判断对象是否存在某个属性，访问对象的属性。</p>
<h4 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h4><p>dir() 函数可能是 Python 自省机制中最著名的部分了。它返回传递给它的任何对象的属性名称经过排序的列表。如果不指定对象，则 dir() 返回当前作用域中的名称。让我们将 dir() 函数应用于 keyword 模块，并观察它揭示了什么：</p>
<pre class="highlight"><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> keyword</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(keyword)</span><br><span class="line">[<span class="string">'__all__'</span>, <span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__file__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'iskeyword'</span>, <span class="string">'kwlist'</span>, <span class="string">'main'</span>] </span><br><span class="line"><span class="number">123</span></span><br></pre>

<h4 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h4><p>type() 函数有助于我们确定对象是字符串还是整数，或是其它类型的对象。它通过返回类型对象来做到这一点，可以将这个类型对象与 types 模块中定义的类型相比较：</p>
<pre class="highlight"><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="number">42</span>)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">([])</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class">1234</span></span><br></pre>

<h4 id="hasattr"><a href="#hasattr" class="headerlink" title="hasattr()"></a>hasattr()</h4><p>对象拥有属性，并且 dir() 函数会返回这些属性的列表。但是，有时我们只想测试一个或多个属性是否存在。如果对象具有我们正在考虑的属性，那么通常希望只检索该属性。这个任务可以由 hasattr() 和 getattr() 函数来完成.</p>
<pre class="highlight"><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(id, <span class="string">'__doc__'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="number">12</span></span><br></pre>

<h4 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance()"></a>isinstance()</h4><p>可以使用 isinstance() 函数测试对象，以确定它是否是某个特定类型或定制类的实例：</p>
<pre class="highlight"><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">"python"</span>, str)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="number">12</span></span><br></pre>

<p><a href="https://www.cnblogs.com/ArsenalfanInECNU/p/9110262.html" target="_blank" rel="noopener">参考原址：https://www.cnblogs.com/ArsenalfanInECNU/p/9110262.html</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis雪崩&amp;穿透&amp;击穿</title>
    <url>/2019/05/16/Redis%E9%9B%AA%E5%B4%A9&amp;%E7%A9%BF%E9%80%8F&amp;%E5%87%BB%E7%A9%BF/</url>
    <content><![CDATA[<h2 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1. 缓存穿透"></a>1. 缓存穿透</h2><pre class="highlight"><span class="line">1）定义</span><br><span class="line">1. 缓存穿透是指查询一个一定不存在的数据，由于缓存不命中，接着查询数据库也无法查询出结果，</span><br><span class="line">2. 虽然也不会写入到缓存中，但是这将会导致每个查询都会去请求数据库，造成缓存穿透；</span><br><span class="line">2）解决方法 ：布隆过滤</span><br><span class="line">1. 对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；</span><br></pre>

<hr>
<h2 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2.缓存雪崩"></a>2.缓存雪崩</h2><pre class="highlight"><span class="line"></span><br><span class="line">1）定义　　　　　　</span><br><span class="line">1. 缓存雪崩是指，由于缓存层承载着大量请求，有效的保护了存储层，但是如果缓存层由于某些原因整体不能提供服务</span><br><span class="line">2. 于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</span><br><span class="line">2）解决方法</span><br><span class="line">1. 保证缓存层服务高可用性：比如 Redis Sentinel 和 Redis Cluster 都实现了高可用</span><br><span class="line">2. 依赖隔离组件为后端限流并降级：比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</span><br></pre>

<hr>
<h2 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3. 缓存击穿"></a>3. 缓存击穿</h2><pre class="highlight"><span class="line">1）定义：</span><br><span class="line">1. 缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况</span><br><span class="line">2. 当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</span><br><span class="line">2）解决方法</span><br><span class="line">1. 解决方式也很简单，可以将热点数据设置为永远不过期；</span><br><span class="line">2. 或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据</span><br></pre>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy &amp; Django项目</title>
    <url>/2019/05/29/Scrapy%20&amp;%20Django%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h3 id="需求-编写爬虫项目与Django项目详解和-将爬取到的数据展示到前端页面上"><a href="#需求-编写爬虫项目与Django项目详解和-将爬取到的数据展示到前端页面上" class="headerlink" title="需求: 编写爬虫项目与Django项目详解和, 将爬取到的数据展示到前端页面上"></a>需求: 编写爬虫项目与Django项目详解和, 将爬取到的数据展示到前端页面上</h3><h4 id="爬虫的编写"><a href="#爬虫的编写" class="headerlink" title="爬虫的编写:"></a>爬虫的编写:</h4><pre class="highlight"><span class="line"># spider编写:</span><br><span class="line">import scrapy</span><br><span class="line">from dl.items import DlItem</span><br><span class="line">class PSpider(scrapy.Spider):</span><br><span class="line">    name &#x3D; &#39;p&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;https:&#x2F;&#x2F;www.kuaidaili.com&#x2F;free&#x2F;&#39;]</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        # print(response)</span><br><span class="line">        tr_list &#x3D; response.xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;list&quot;]&#x2F;table&#x2F;tbody&#x2F;tr&#39;)</span><br><span class="line">        # print(tr_list)</span><br><span class="line">        for tr in tr_list:</span><br><span class="line">            ip &#x3D; tr.xpath(&#39;.&#x2F;td[1]&#x2F;text()&#39;).extract_first()</span><br><span class="line">            port &#x3D; tr.xpath(&#39;.&#x2F;td[2]&#x2F;text()&#39;).extract_first()</span><br><span class="line">            typ &#x3D; tr.xpath(&#39;.&#x2F;td[3]&#x2F;text()&#39;).extract_first()</span><br><span class="line">            protocal &#x3D; tr.xpath(&#39;.&#x2F;td[4]&#x2F;text()&#39;).extract_first()</span><br><span class="line">            position &#x3D; tr.xpath(&#39;.&#x2F;td[5]&#x2F;text()&#39;).extract_first()</span><br><span class="line">            # print(ip, port, protocal, position)</span><br><span class="line">            item &#x3D; DlItem()</span><br><span class="line">            item[&#39;ip&#39;] &#x3D; ip</span><br><span class="line">            item[&#39;port&#39;] &#x3D; port</span><br><span class="line">            item[&#39;typ&#39;] &#x3D; typ</span><br><span class="line">            item[&#39;protocal&#39;] &#x3D; protocal</span><br><span class="line">            item[&#39;position&#39;] &#x3D; position</span><br><span class="line">            print(item)</span><br><span class="line">            yield item</span><br></pre>
<hr>
<h4 id="items编码"><a href="#items编码" class="headerlink" title="items编码"></a>items编码</h4><pre class="highlight"><span class="line"># items编码</span><br><span class="line">import scrapy</span><br><span class="line">class DlItem(scrapy.Item):</span><br><span class="line">    ip &#x3D; scrapy.Field()</span><br><span class="line">    port &#x3D; scrapy.Field()</span><br><span class="line">    typ &#x3D; scrapy.Field()</span><br><span class="line">    protocal &#x3D; scrapy.Field()</span><br><span class="line">    position &#x3D; scrapy.Field()</span><br></pre>
<hr>
<h4 id="Django项目创建与所有配置"><a href="#Django项目创建与所有配置" class="headerlink" title="Django项目创建与所有配置"></a>Django项目创建与所有配置</h4><pre class="highlight"><span class="line"># Django项目创建与所有配置:</span><br><span class="line">1.models创建:</span><br><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line"># Create your models here.</span><br><span class="line"></span><br><span class="line">class Proxy(models.Model):</span><br><span class="line">    ip &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    port &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    typ &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    protocal &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    position &#x3D; models.CharField(max_length&#x3D;50)</span><br><span class="line">    </span><br><span class="line">2.在scrapy框架项目中嵌入django</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line">sys.path.append(os.path.dirname(os.path.abspath(&#39;.&#39;)))</span><br><span class="line">os.environ[&#39;DJANGO_SETTINGS_MODULE&#39;] &#x3D; &#39;proxyscan.settings&#39;</span><br><span class="line"># 手动初始化Django：</span><br><span class="line">import django</span><br><span class="line">django.setup()</span><br><span class="line"></span><br><span class="line">3.修改爬虫item:</span><br><span class="line">import scrapy</span><br><span class="line">from scrapy_djangoitem import DjangoItem</span><br><span class="line">from proxy import models</span><br><span class="line">class DlItem(DjangoItem):</span><br><span class="line">    django_model &#x3D; models.Proxy</span><br><span class="line">    </span><br><span class="line">4.pipeline编码:</span><br><span class="line">class DlPipeline(object):</span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        print(&#39;开启数据库, 进行数据存储&#39;)</span><br><span class="line">        item.save()</span><br><span class="line">        print(&#39;关闭数据库&#39;)</span><br><span class="line">        return item</span><br><span class="line">    </span><br><span class="line">5.Django项目迁移数据库与admin后台配置</span><br><span class="line">Python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br><span class="line"></span><br><span class="line">from proxy.models import Proxy</span><br><span class="line">admin.site.register(Proxy)</span><br><span class="line"></span><br><span class="line"># 创建超级用户:</span><br><span class="line">Python manage.py createsuperuser</span><br></pre>
<hr>
<pre class="highlight"><span class="line"># 路由:</span><br><span class="line">from django.conf.urls import url</span><br><span class="line">from django.contrib import admin</span><br><span class="line">from proxy.views import index</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^admin&#x2F;&#39;, admin.site.urls),</span><br><span class="line">    url(r&#39;^index&#x2F;&#39;, index),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 视图函数:</span><br><span class="line">from django.shortcuts import render</span><br><span class="line">from proxy.models import Proxy</span><br><span class="line">def index(requests):</span><br><span class="line">    p &#x3D; Proxy.objects.all()</span><br><span class="line">    return render(requests, &#39;index.html&#39;, &#123;&quot;p&quot;:p&#125;)</span><br></pre>
<hr>
<h4 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h4><pre class="highlight"><span class="line"># 前端代码:</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.4.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;twitter-bootstrap&#x2F;4.3.1&#x2F;css&#x2F;bootstrap.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;row&quot; &gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;col-md-10 col-md-offset-2&quot; style&#x3D;&quot;margin:0 auto&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;panel panel-primary&quot;&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;panel-heading&quot; style&#x3D;&quot;margin-top:50px&quot;&gt;</span><br><span class="line">                    &lt;h3 class&#x3D;&quot;panel-title&quot;&gt;代理IP一览表&lt;&#x2F;h3&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;panel-body&quot;&gt;</span><br><span class="line">                    &lt;table class&#x3D;&quot;table table-striped&quot;&gt;</span><br><span class="line">                        &lt;thead&gt;</span><br><span class="line">                        &lt;tr&gt;</span><br><span class="line">                            &lt;th&gt;IP&lt;&#x2F;th&gt;</span><br><span class="line">                            &lt;th&gt;Port&lt;&#x2F;th&gt;</span><br><span class="line">                            &lt;th&gt;Type&lt;&#x2F;th&gt;</span><br><span class="line">                            &lt;th&gt;Protocal&lt;&#x2F;th&gt;</span><br><span class="line">                            &lt;th&gt;Positon&lt;&#x2F;th&gt;</span><br><span class="line">                        &lt;&#x2F;tr&gt;</span><br><span class="line">                        &lt;&#x2F;thead&gt;</span><br><span class="line">                        &lt;tbody&gt;</span><br><span class="line">                        &#123;% for i in p %&#125;</span><br><span class="line">                            &lt;tr&gt;</span><br><span class="line">                                &lt;th&gt;&#123;&#123; i.ip &#125;&#125;&lt;&#x2F;th&gt;</span><br><span class="line">                                &lt;td&gt;&#123;&#123; i.port &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                                &lt;td&gt;&#123;&#123; i.typ &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                                &lt;td&gt;&#123;&#123; i.protocal &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                                &lt;td&gt;&#123;&#123; i.position &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                            &lt;&#x2F;tr&gt;</span><br><span class="line">                        &#123;% endfor %&#125;</span><br><span class="line">                        &lt;&#x2F;tbody&gt;</span><br><span class="line">                    &lt;&#x2F;table&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre>]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy框架（2）</title>
    <url>/2019/06/22/Scrapy%E6%A1%86%E6%9E%B6%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1-scrapy-多页爬取"><a href="#1-scrapy-多页爬取" class="headerlink" title="1.scrapy 多页爬取"></a>1.scrapy 多页爬取</h2><pre class="highlight"><span class="line"># spider编码在原基础之上, 构建其他页面的url地址, 并利用scrapy.Request发起新的请求, 请求的回调函数依然是parse:page &#x3D; 1base_url &#x3D; &#39;http:&#x2F;&#x2F;www.xiaohuar.com&#x2F;list-1-%s.html&#39;if self.page &lt; 4:    page_url &#x3D; base_url%self.page    self.page +&#x3D; 1    yield scrapy.Request(url&#x3D;page_url, callback&#x3D;self.parse)# (其他文件不用改动)</span><br></pre>
<hr>
<h2 id="2-scrapy爬取详情页"><a href="#2-scrapy爬取详情页" class="headerlink" title="2.scrapy爬取详情页"></a>2.scrapy爬取详情页</h2><h4 id="需求-爬取笑话的标题与详情页连接-通过详情页链接-爬取详情页笑话内容"><a href="#需求-爬取笑话的标题与详情页连接-通过详情页链接-爬取详情页笑话内容" class="headerlink" title="需求: 爬取笑话的标题与详情页连接, 通过详情页链接, 爬取详情页笑话内容"></a>需求: 爬取笑话的标题与详情页连接, 通过详情页链接, 爬取详情页笑话内容</h4><pre class="highlight"><span class="line"># item编码: 定义数据持久化的字段信息</span><br><span class="line">import scrapy</span><br><span class="line">class JokeItem(scrapy.Item):</span><br><span class="line">    # define the fields for your item here like:</span><br><span class="line">    # name &#x3D; scrapy.Field()</span><br><span class="line">    title &#x3D; scrapy.Field()</span><br><span class="line">    content &#x3D; scrapy.Field()</span><br></pre>
<pre class="highlight"><span class="line"># spider的编码:</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import scrapy</span><br><span class="line">from ..items import JokeItem</span><br><span class="line"></span><br><span class="line">class XhSpider(scrapy.Spider):</span><br><span class="line">    name &#x3D; &#39;xh&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;http:&#x2F;&#x2F;www.jokeji.cn&#x2F;list.htm&#39;]</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        li_list &#x3D; response.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;list_title&quot;]&#x2F;ul&#x2F;li&#39;)</span><br><span class="line">        for li in li_list:</span><br><span class="line">            title &#x3D; li.xpath(&#39;.&#x2F;b&#x2F;a&#x2F;text()&#39;).extract_first()</span><br><span class="line">            link &#x3D; &#39;http:&#x2F;&#x2F;www.jokeji.cn&#39; + li.xpath(&#39;.&#x2F;b&#x2F;a&#x2F;@href&#39;).extract_first()</span><br><span class="line">            yield scrapy.Request(url&#x3D;link, callback&#x3D;self.datail_parse, meta&#x3D;&#123;&quot;title&quot;:title&#125;)</span><br><span class="line"></span><br><span class="line">    def datail_parse(self, response):</span><br><span class="line">        joke_list &#x3D; response.xpath(&#39;&#x2F;&#x2F;span[@id&#x3D;&quot;text110&quot;]&#x2F;&#x2F;text()&#39;).extract()</span><br><span class="line">        title &#x3D; response.meta[&quot;title&quot;]</span><br><span class="line">        content &#x3D; &#39;&#39;</span><br><span class="line">        for s in joke_list:</span><br><span class="line">            content +&#x3D; s</span><br><span class="line">        item &#x3D; JokeItem()</span><br><span class="line">        item[&quot;title&quot;] &#x3D; title</span><br><span class="line">        item[&quot;content&quot;] &#x3D; content</span><br><span class="line">        yield item</span><br></pre>
<pre class="highlight"><span class="line"># Pipeline编码: 数据持久化具体操作</span><br><span class="line">import pymongo</span><br><span class="line"></span><br><span class="line">class JokePipeline(object):</span><br><span class="line">    conn &#x3D; pymongo.MongoClient(&#39;localhost&#39;, 27017)</span><br><span class="line">    db &#x3D; conn.haha</span><br><span class="line">    table &#x3D; db.hahatable</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        self.table.insert(dict(item))</span><br><span class="line">        return item</span><br><span class="line"></span><br><span class="line">    def close_spider(self, spider):</span><br><span class="line">        self.conn.close()</span><br></pre>

<pre class="highlight"><span class="line"># settings配置编码:</span><br><span class="line">UA伪装</span><br><span class="line">Robots协议</span><br><span class="line">Item_Pipeline</span><br></pre>
<hr>
<h2 id="3-scrapy发送post请求"><a href="#3-scrapy发送post请求" class="headerlink" title="3.scrapy发送post请求"></a>3.scrapy发送post请求</h2><pre class="highlight"><span class="line">import scrapy</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FySpider(scrapy.Spider):</span><br><span class="line">    name &#x3D; &#39;fy&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;https:&#x2F;&#x2F;fanyi.baidu.com&#x2F;sug&#39;]</span><br><span class="line">    def start_requests(self):</span><br><span class="line">        data &#x3D; &#123;</span><br><span class="line">            &#39;kw&#39;:&#39;boy&#39;</span><br><span class="line">        &#125;</span><br><span class="line">        yield scrapy.FormRequest(url&#x3D;self.start_urls[0], callback&#x3D;self.parse, formdata&#x3D;data)</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        print(~~~~)</span><br><span class="line">        print(response.text)</span><br><span class="line">        print(json.loads(response.text))</span><br><span class="line"> print(~~~~)</span><br></pre>
<hr>
<h2 id="4-scrapy中间件"><a href="#4-scrapy中间件" class="headerlink" title="4.scrapy中间件"></a>4.scrapy中间件</h2><pre class="highlight"><span class="line"># 中间件分类:</span><br><span class="line">	- 下载中间件: DownloadMiddleware</span><br><span class="line">	- 爬虫中间件: SpiderMiddleware</span><br><span class="line"># 中间件的作用:</span><br><span class="line">	- 下载中间件: 拦截请求与响应, 篡改请求与响应</span><br><span class="line">	- 爬虫中间件: 拦截请求与响应, 拦截管道item, 篡改请求与响应, 处理item</span><br><span class="line"># 下载中间件的主要方法:</span><br><span class="line">process_request</span><br><span class="line">process_response</span><br><span class="line">process_exception</span><br></pre>

<h4 id="下载中间件拦截请求-使用代理ip案例"><a href="#下载中间件拦截请求-使用代理ip案例" class="headerlink" title="下载中间件拦截请求, 使用代理ip案例"></a>下载中间件拦截请求, 使用代理ip案例</h4><pre class="highlight"><span class="line"># spider编码:</span><br><span class="line">import scrapy</span><br><span class="line">class DlproxySpider(scrapy.Spider):</span><br><span class="line">    name &#x3D; &#39;dlproxy&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;ip&#39;]</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        with open(&#39;baiduproxy.html&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">            f.write(response.text)</span><br></pre>

<pre class="highlight"><span class="line"># Downloadermiddleware编码:</span><br><span class="line">def process_request(self, request, spider):</span><br><span class="line">    request.meta[&#39;proxy&#39;] &#x3D; &#39;http:&#x2F;&#x2F;111.231.90.122:8888&#39;</span><br><span class="line">    return None</span><br></pre>

<hr>
<h2 id="5-下载中间件实现UA池"><a href="#5-下载中间件实现UA池" class="headerlink" title="5.下载中间件实现UA池"></a>5.下载中间件实现UA池</h2><pre class="highlight"><span class="line"># spider编码:</span><br><span class="line">class DlproxySpider(scrapy.Spider):</span><br><span class="line">    name &#x3D; &#39;dlproxy&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;,&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;,&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;,&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;,&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;]</span><br><span class="line">    </span><br><span class="line">    def parse(self, response):</span><br><span class="line">        pass</span><br></pre>

<pre class="highlight"><span class="line"># 中间件的编码:</span><br><span class="line">from scrapy import signals</span><br><span class="line">from fake_useragent import UserAgent</span><br><span class="line">import random</span><br><span class="line">ua &#x3D; UserAgent()</span><br><span class="line">ua_list &#x3D; []</span><br><span class="line">for i in range(100):    </span><br><span class="line">    ua_chrome &#x3D; ua.Chrome    </span><br><span class="line">    ua_list.append(ua_chrome)    </span><br><span class="line">class ...():    </span><br><span class="line">    def process_request(self, request, spider):        </span><br><span class="line">        # request.meta[&#39;proxy&#39;] &#x3D; &#39;http:&#x2F;&#x2F;111.231.90.122:8888&#39;        </span><br><span class="line">        print(~~~~)        </span><br><span class="line">        print(self.ua_pool)        </span><br><span class="line">        print(~~~)        </span><br><span class="line">        request.headers[&#39;User-Agent&#39;] &#x3D; random.choice(self.ua_pool)        </span><br><span class="line">        return None   </span><br><span class="line">    def process_response(self, request, response, spider):      print(~~~~)        </span><br><span class="line">         print(request.headers[&quot;User-Agent&quot;])       </span><br><span class="line">         print(~~~)        </span><br><span class="line">         return response</span><br></pre>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 安装 配置axios 后页面一片空白</title>
    <url>/2019/12/15/Vue%20%E5%AE%89%E8%A3%85%20%E9%85%8D%E7%BD%AEaxios%20%E5%90%8E%E9%A1%B5%E9%9D%A2%E4%B8%80%E7%89%87%E7%A9%BA%E7%99%BD/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200716170046551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200716170046551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<p>造成 这个问题的原因有很多</p>
<h5 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h5><p><code>javascript Uncaught TypeError: Cannot set property &#39;$axios&#39; of undefined</code><br><img src="https://img-blog.csdnimg.cn/2020071617012966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/2020071617012966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>报错信息说 $axios of undefined</p>
<p>我们打开 main.js 查看</p>
<p><img src="https://img-blog.csdnimg.cn/20200716170338157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200716170338157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>将箭头所指处 改为小写。</p>
<h5 id="二"><a href="#二" class="headerlink" title="二"></a>二</h5><pre class="highlight"><span class="line">TypeError: setting getter-only property &quot;$axios&quot;</span><br></pre>

<p>vue-cli2 和 vue-cli3和4 安装方法还不一样，我使用的是 vue-cli4.3.1，应使用<code>npm add axios</code>，vue-cli2.0使用的是<code>npm install axios</code></p>
<ul>
<li><p>查看版本</p>
<pre class="highlight"><span class="line">npm -V</span><br><span class="line"><span class="number">1</span></span><br></pre>

</li>
</ul>
<p>main.js 配置如下更改</p>
<pre class="highlight"><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line">Vue.prototype.$ajax = axios</span><br></pre>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue国际化</title>
    <url>/2019/07/13/Vue%E5%9B%BD%E9%99%85%E5%8C%96/</url>
    <content><![CDATA[<h2 id="这里所说的国际化，是根据访问者的浏览器语言来更改页面语言。"><a href="#这里所说的国际化，是根据访问者的浏览器语言来更改页面语言。" class="headerlink" title="这里所说的国际化，是根据访问者的浏览器语言来更改页面语言。"></a>这里所说的国际化，是根据访问者的浏览器语言来更改页面语言。</h2><h3 id="导入插件"><a href="#导入插件" class="headerlink" title="导入插件:"></a>导入插件:</h3><pre class="highlight"><span class="line">npm install vue-i18n --save</span><br></pre>

<hr>
<h3 id="在main的js中注册该组件"><a href="#在main的js中注册该组件" class="headerlink" title="在main的js中注册该组件:"></a>在main的js中注册该组件:</h3><pre class="highlight"><span class="line">// 导入</span><br><span class="line"><span class="keyword">import</span> VueI18n <span class="keyword">from</span> <span class="string">'vue-i18n'</span></span><br><span class="line">// 注册</span><br><span class="line">Vue.use(VueI18n)</span><br></pre>

<hr>
<pre class="highlight"><span class="line">在src目录下新建lang文件夹，在文件夹中新建zh.js和en.js文件</span><br><span class="line"></span><br><span class="line">在两个文件中(如果不止是中文和英文的话就再新建对应的文件)输入对应的文本，具体内容按自己需求而定，</span><br></pre>
<hr>
<h3 id="这是我自己的zh-js文件内容"><a href="#这是我自己的zh-js文件内容" class="headerlink" title="这是我自己的zh.js文件内容:"></a>这是我自己的zh.js文件内容:</h3><pre class="highlight"><span class="line">// 双语规范的变量(中文)</span><br><span class="line"></span><br><span class="line">export const m = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="string">'welcome'</span>: <span class="string">'欢迎您'</span>,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
<hr>
<h3 id="这是我的en-js文件内容"><a href="#这是我的en-js文件内容" class="headerlink" title="这是我的en.js文件内容:"></a>这是我的en.js文件内容:</h3><pre class="highlight"><span class="line">// 双语规范的变量(英文)</span><br><span class="line"></span><br><span class="line">export const m= &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="string">'welcome'</span>: <span class="string">'Welcome!'</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
<hr>
<h5 id="然后再在main-js中加入以下内容，注意要放在上次写的语句下面"><a href="#然后再在main-js中加入以下内容，注意要放在上次写的语句下面" class="headerlink" title="然后再在main.js中加入以下内容，注意要放在上次写的语句下面:"></a>然后再在main.js中加入以下内容，注意要放在上次写的语句下面:</h5><pre class="highlight"><span class="line">// 导入语言包</span><br><span class="line">const i18n = new VueI18n(&#123;</span><br><span class="line">  // 当前默认语言</span><br><span class="line">  locale: <span class="string">'en'</span>,</span><br><span class="line">  // 语言包声明</span><br><span class="line">  messages:&#123;</span><br><span class="line">    <span class="string">'zh'</span>: require(<span class="string">'./lang/zh'</span>),</span><br><span class="line">    <span class="string">'en'</span>: require(<span class="string">'./lang/en'</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre>

<hr>
<h6 id="在new-Vue中加入以下内容"><a href="#在new-Vue中加入以下内容" class="headerlink" title="在new Vue中加入以下内容:"></a>在new Vue中加入以下内容:</h6><pre class="highlight"><span class="line">i18n</span><br></pre>

]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Selenium &amp; PhantomJS</title>
    <url>/2019/07/01/Selenium%20&amp;%20PhantomJS/</url>
    <content><![CDATA[<h2 id="1-selenium介绍"><a href="#1-selenium介绍" class="headerlink" title="1.selenium介绍"></a>1.selenium介绍</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍:"></a>介绍:</h3><p>1.selenium是一个web自动化测试用的框架. 程序员可以通过代码实现对浏览器的控制, 比如打开网页, 点击网页中的元素, 实现鼠标滚动等操作.<br>2.它支持多款浏览器, 如谷歌浏览器, 火狐浏览器等等, 当然也支持无头浏览器.</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的:"></a>目的:</h3><p>在爬取数据的过程中, 经常遇到动态数据加载, 一般动态数据加载有两种, 一种通过ajax请求加载数据, 另一种通过js代码加载动态数据. selenium可以模拟人操作真实浏览器, 获取加载完成的页面数据<br>ajax:<br>    url有规律且未加密, 直接构建url连接请求<br>    url加密过无法破解规律 –&gt; selenium<br>js动态数据加载 –&gt;  selenium</p>
<hr>
<h2 id="2-selenium安装"><a href="#2-selenium安装" class="headerlink" title="2.selenium安装"></a>2.selenium安装</h2><pre class="highlight"><span class="line">pip install selenium</span><br></pre>
<pre class="highlight"><span class="line">三要素: 浏览器, 驱动程序, selenium框架</span><br><span class="line"></span><br><span class="line">浏览器: 推荐谷歌浏览器, 标准稳定版本</span><br><span class="line">驱动程序:http:&#x2F;&#x2F;chromedriver.storage.googleapis.com&#x2F;index.html</span><br><span class="line"></span><br><span class="line"># 测试:</span><br><span class="line">from selenium import webdriver</span><br><span class="line">browser &#x3D; webdriver.Chrome(&#39;.&#x2F;webdriver&#39;)   # 将驱动放在脚本所在的文件夹</span><br><span class="line">browser.get(&#39;www.baidu.com&#39;)</span><br></pre>
<hr>
<h2 id="3-selenium常用操作"><a href="#3-selenium常用操作" class="headerlink" title="3.selenium常用操作"></a>3.selenium常用操作</h2><pre class="highlight"><span class="line"># 实例化浏览器对象:</span><br><span class="line">from selenium import webdriver</span><br><span class="line">browser &#x3D; webdriver.Chrome(&#39;driverpath&#39;)</span><br><span class="line"></span><br><span class="line"># 发送get请求:</span><br><span class="line">browser.get(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;)</span><br><span class="line"></span><br><span class="line"># 获取页面元素:</span><br><span class="line">find_element_by_id:根据元素的id</span><br><span class="line">find_element_by_name:根据元素的name</span><br><span class="line">find_element_by_xpath:根据xpath表达式</span><br><span class="line">find_element_by_class_name:根据class的值</span><br><span class="line">find_element_by_css_selector:根据css选择器</span><br><span class="line"></span><br><span class="line"># 节点交互操作:</span><br><span class="line">click(): 点击</span><br><span class="line">send_keys(): 输入内容</span><br><span class="line">clear(): 清空操作</span><br><span class="line">execute_script(js): 执行指定的js代码</span><br><span class="line"></span><br><span class="line"># JS代码: window.scrollTo(0, document.body.scrollHeight)可以模拟鼠标滚动一屏高度</span><br><span class="line">quit(): 退出</span><br><span class="line"></span><br><span class="line"># 获取网页源码:</span><br><span class="line">browser.page_source  ---&gt;  str类型</span><br><span class="line"></span><br><span class="line"># frame</span><br><span class="line">switch_to.frame(&#39;frameid&#39;)</span><br></pre>
<hr>
<h2 id="4-qq空间模拟登陆"><a href="#4-qq空间模拟登陆" class="headerlink" title="4.qq空间模拟登陆"></a>4.qq空间模拟登陆</h2><pre class="highlight"><span class="line">from selenium import webdriver</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 实例化浏览器对象</span><br><span class="line">browser &#x3D; webdriver.Chrome(&#39;.&#x2F;chromedriver.exe&#39;)</span><br><span class="line"></span><br><span class="line"># 打开qq空间登陆页面</span><br><span class="line">browser.get(&#39;https:&#x2F;&#x2F;qzone.qq.com&#x2F;&#39;)</span><br><span class="line">time.sleep(1)</span><br><span class="line"></span><br><span class="line"># 转至frame子页面</span><br><span class="line">browser.switch_to.frame(&#39;login_frame&#39;)</span><br><span class="line"></span><br><span class="line"># 获取密码登陆选项并点击</span><br><span class="line">a_tag &#x3D; browser.find_element_by_id(&#39;switcher_plogin&#39;)</span><br><span class="line">a_tag.click()</span><br><span class="line">time.sleep(1)</span><br><span class="line"></span><br><span class="line"># 获取账号输入框并输入账号</span><br><span class="line">browser.find_element_by_id(&#39;u&#39;).clear()</span><br><span class="line">user &#x3D; browser.find_element_by_id(&#39;u&#39;)</span><br><span class="line">user.send_keys(&#39;3338003899&#39;)</span><br><span class="line">time.sleep(1)</span><br><span class="line"></span><br><span class="line"># 获取密码输入框并输入密码</span><br><span class="line">browser.find_element_by_id(&#39;p&#39;).clear()</span><br><span class="line">pwd &#x3D; browser.find_element_by_id(&#39;p&#39;)</span><br><span class="line">pwd.send_keys(&#39;qq123456&#39;)</span><br><span class="line">time.sleep(1)</span><br><span class="line"></span><br><span class="line"># 获取登陆按钮并单击</span><br><span class="line">button &#x3D; browser.find_element_by_id(&#39;login_button&#39;)</span><br><span class="line">button.click()</span><br></pre>
<hr>
<h2 id="5-PhantomJS浏览器使用"><a href="#5-PhantomJS浏览器使用" class="headerlink" title="5.PhantomJS浏览器使用"></a>5.PhantomJS浏览器使用</h2><h3 id="PhantomJS下载及配置环境变量"><a href="#PhantomJS下载及配置环境变量" class="headerlink" title="PhantomJS下载及配置环境变量"></a>PhantomJS下载及配置环境变量</h3><pre><code>- 下载, 直接解压
- 将解压文件的bin目录添加至环境变量</code></pre><hr>
<h3 id="PhantomJS无界面浏览器"><a href="#PhantomJS无界面浏览器" class="headerlink" title="PhantomJS无界面浏览器"></a>PhantomJS无界面浏览器</h3><pre class="highlight"><span class="line">from selenium import webdriver</span><br><span class="line">browser &#x3D; webdriver.PhantomJS()</span><br><span class="line">browser.get(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;)</span><br><span class="line">with open(&#39;baidu_phantomjs.html&#39;, &#39;w&#39;, encoding&#x3D;&quot;utf-8&quot;) as f:</span><br><span class="line">    f.write(browser.page_source)</span><br></pre>
<h3 id="谷歌无头浏览器"><a href="#谷歌无头浏览器" class="headerlink" title="谷歌无头浏览器"></a>谷歌无头浏览器</h3><pre class="highlight"><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.chrome.options import Options</span><br><span class="line"></span><br><span class="line">chrome_options &#x3D; Options()</span><br><span class="line">chrome_options.add_argument(&#39;--headless&#39;)</span><br><span class="line">chrome_options.add_argument(&#39;--disable-gpu&#39;)</span><br><span class="line">browser &#x3D; webdriver.Chrome(chrome_options&#x3D;chrome_options)</span><br><span class="line">browser.get(&quot;https:&#x2F;&#x2F;www.baidu.com&quot;)</span><br><span class="line">print(browser.page_source)</span><br><span class="line">with open(&#39;baidu_headerless.html&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">    f.write(browser.page_source)</span><br></pre>
<hr>
<h2 id="6-图片懒加载"><a href="#6-图片懒加载" class="headerlink" title="6..图片懒加载"></a>6..图片懒加载</h2><pre class="highlight"><span class="line">import requests</span><br><span class="line">from lxml import etree</span><br><span class="line">from urllib import request</span><br><span class="line">import urllib</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;sc.chinaz.com&#x2F;tupian&#x2F;index.html&#39;</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;USer-Agent&quot;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line">res.encoding &#x3D; &#39;utf-8&#39;</span><br><span class="line"># print(res.text)</span><br><span class="line">tree &#x3D; etree.HTML(res.text)</span><br><span class="line"></span><br><span class="line">src_list &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[contains(@class,&quot;box&quot;)]&#x2F;div&#x2F;a&#x2F;img&#x2F;@src2&#39;)</span><br><span class="line">for url_img in src_list:</span><br><span class="line">    request.urlretrieve(url_img,&#39;%s.jpg&#39;%src_list.index(url_img))</span><br></pre>
<hr>
<pre class="highlight"><span class="line">from selenium import webdriver</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">browser &#x3D; webdriver.Chrome(&#39;.&#x2F;chromedriver.exe&#39;)</span><br><span class="line">browser.get(&#39;http:&#x2F;&#x2F;image.baidu.com&#x2F;&#39;)</span><br><span class="line">search &#x3D; browser.find_element_by_id(&#39;kw&#39;)</span><br><span class="line">search.send_keys(&#39;安琪拉&#39;)</span><br><span class="line">button &#x3D; browser.find_element_by_class_name(&#39;s_search&#39;)</span><br><span class="line">button.click()</span><br><span class="line">for i in range(3):</span><br><span class="line">    browser.execute_script(&#39;window.scrollTo(0, document.body.scrollHeight)&#39;)</span><br><span class="line">    time.sleep(5)</span><br><span class="line"></span><br><span class="line">text &#x3D; browser.page_source</span><br><span class="line">with open(&#39;baidu_pic.html&#39;, &#39;w&#39;, encoding&#x3D;&quot;utf-8&quot;) as f:</span><br><span class="line">    f.write(text)</span><br><span class="line"></span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup &#x3D; BeautifulSoup(open(&#39;.&#x2F;baidu_pic.html&#39;, &#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;), &#39;lxml&#39;)</span><br><span class="line">li_list &#x3D; soup.select(&#39;.imgpage ul li&#39;)</span><br><span class="line">for url_img in li_list:</span><br><span class="line">    url_img &#x3D; url_img[&#39;data-objurl&#39;]</span><br><span class="line">    print(url_img)</span><br></pre>
<hr>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 父子组件 传值 超详细</title>
    <url>/2019/12/29/Vue%20%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%20%E4%BC%A0%E5%80%BC%20%E8%B6%85%E8%AF%A6%E7%BB%86/</url>
    <content><![CDATA[<p>我们 有两个 Vue页面：</p>
<ol>
<li>father.vue</li>
<li>son.vue</li>
</ol>
<p>son.vue 作为 子组件 是 被 引入的哪一方的<br><strong>父传子</strong><br>发送是直接在 组件上 进行发送的</p>
<pre class="highlight"><span class="line"><span class="comment">// father.vue</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div id=<span class="string">"father"</span>&gt;</span><br><span class="line">		<span class="comment">// 父组件 传递子组件 123  FonS 是 key</span></span><br><span class="line">		&lt;son :FonS=<span class="string">"123"</span>&gt;</span><br><span class="line">		&lt;<span class="regexp">/son&gt;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>div&gt;	</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import son from '@/</span>components/son</span><br><span class="line">	<span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        name: <span class="string">"father"</span>,</span><br><span class="line">        components:&#123;</span><br><span class="line">        	son:son</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">12345678910111213141516171819</span></span><br></pre>

<p>子组件（页面）<br><strong>props 接收（列表格式）</strong></p>
<pre class="highlight"><span class="line"><span class="comment">// son.vue</span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        name: <span class="string">"son"</span>,</span><br><span class="line">        props: [<span class="string">'FonS'</span>],</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">12345678</span></span><br></pre>

<p>此时 这个键（Fons）和 data 中的数据一样，可直接 this.Fons使用</p>
<pre class="highlight"><span class="line">mounted()&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.FonS)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">12345</span></span><br></pre>

<p><strong>子传父</strong><br>一般情况下 都是事件对应着的</p>
<pre class="highlight"><span class="line"><span class="comment">// son.vue</span></span><br><span class="line"><span class="comment">// 此时的 SonF 是 父接收的 事件名 data 是事件名</span></span><br><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'SonF'</span>, <span class="number">321</span>)</span><br><span class="line"><span class="number">123</span></span><br></pre>

<p>父接收 在 父页面上的子组件 进行接收</p>
<pre class="highlight"><span class="line"><span class="comment">// father.vue</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div id=<span class="string">"father"</span>&gt;</span><br><span class="line">		<span class="comment">// data 作为虚拟名字 被当作方法 他的内部就携带了 321 参数 （这个名字随便起）</span></span><br><span class="line">		&lt;son :FonS=<span class="string">"123"</span> @SonF=<span class="string">"data"</span>&gt;</span><br><span class="line">		&lt;<span class="regexp">/son&gt;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>div&gt;	</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import son from '@/</span>components/son</span><br><span class="line">	<span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        name: <span class="string">"father"</span>,</span><br><span class="line">        components:&#123;</span><br><span class="line">        	son:son</span><br><span class="line">        	&#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">        	<span class="comment">// res 就代表了值 （名字随便起 因为内部携带了参数）</span></span><br><span class="line">        	data(res)&#123;</span><br><span class="line">				alert(res)</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">12345678910111213141516171819202122232425</span></span><br></pre>

<p>此时 打印出来的就是 321</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django--模拟登陆注册</title>
    <url>/2020/04/23/d_a/</url>
    <content><![CDATA[<h3 id="django-vue登陆注册"><a href="#django-vue登陆注册" class="headerlink" title="django+vue登陆注册"></a>django+vue登陆注册</h3><h4 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h4><p><strong>django后台做api</strong></p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">api_login</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    登陆接口，get和post方式</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"GET"</span>:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(&#123;<span class="string">"code"</span>: <span class="number">404</span>&#125;))</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">"POST"</span>:</span><br><span class="line">        info = request.POST</span><br><span class="line">        print(info)</span><br><span class="line">        <span class="comment"># 获取到数据以后，做逻辑判断，成功返回200，失败返回404</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(&#123;<span class="string">"code"</span>: <span class="number">200</span>&#125;))</span><br></pre>

<p><strong>使用axios做ajax–post提交数据</strong></p>
<pre class="highlight"><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line">    export default &#123;</span><br><span class="line">        // 获取用户名和密码框输入的内容，用字典的形式返回</span><br><span class="line">        data:function()&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                username: <span class="string">''</span>,</span><br><span class="line">                password: <span class="string">''</span>,</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            </span><br><span class="line">            on_submit()&#123;</span><br><span class="line">                // 创建一个FormData()实例</span><br><span class="line">                let form_data = new FormData()</span><br><span class="line">                // Application/Json -&gt; request.POST(form-data)</span><br><span class="line">                // url: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/api/register</span><br><span class="line">                form_data.append(<span class="string">'username'</span>, this.username)                </span><br><span class="line">                form_data.append(<span class="string">'password'</span>, this.password)</span><br><span class="line">                // 使用axios用post方式提交数据</span><br><span class="line">                axios(&#123;</span><br><span class="line">                    method: <span class="string">'post'</span>,</span><br><span class="line">                    url: <span class="string">'http://127.0.0.1:8000/apilogin/api_login/'</span>,</span><br><span class="line">                    data: form_data</span><br><span class="line">                &#125;).then(function(res)&#123;</span><br><span class="line">                    // 成功以后，返回的内容</span><br><span class="line">                    console.log(res)</span><br><span class="line">                    // 成功以后，做页面跳转</span><br><span class="line">                &#125;).catch((error)=&gt;&#123;</span><br><span class="line">                    // 失败以后，返回的内容</span><br><span class="line">                    console.log(error)</span><br><span class="line">                    // 失败以后，停留在当前页面</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre>


<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><pre class="highlight"><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入加密库</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据库</span></span><br><span class="line"><span class="keyword">from</span> myapp.models <span class="keyword">import</span> User</span><br><span class="line"></span><br><span class="line"><span class="comment"># md5加密方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_password</span><span class="params">(mypass)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成md5对象</span></span><br><span class="line">    md5 = hashlib.md5()</span><br><span class="line">    <span class="comment">#转码操作</span></span><br><span class="line">    mypass_utf8 = str(mypass).encode(encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment"># 加密操作</span></span><br><span class="line">    md5.update(mypass_utf8)</span><br><span class="line">    <span class="comment">#返回密文</span></span><br><span class="line">    <span class="keyword">return</span> md5.hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span><span class="params">(APIView)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接收参数</span></span><br><span class="line">        username = request.GET.get(<span class="string">'username'</span>,<span class="literal">None</span>)</span><br><span class="line">        password = request.GET.get(<span class="string">'password'</span>,<span class="literal">None</span>)</span><br><span class="line">        img = request.GET.get(<span class="string">'img'</span>,<span class="literal">None</span>)</span><br><span class="line">        type = request.GET.get(<span class="string">'type'</span>,<span class="literal">None</span>)</span><br><span class="line">        phone = request.GET.get(<span class="string">'phone'</span>,<span class="literal">None</span>)</span><br><span class="line">        num = request.GET.get(<span class="string">'num'</span>,<span class="literal">None</span>)</span><br><span class="line">        <span class="comment"># 排重操作</span></span><br><span class="line">        user = User.objects.filter(username=username).first()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> user:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>:<span class="number">403</span>,<span class="string">'msg'</span>:<span class="string">'该用户已经存在'</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 入库</span></span><br><span class="line">        user = User(username=username,password=make_password(password),</span><br><span class="line">                    phone=phone,img=img,type=type,num=num</span><br><span class="line">                    )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存结果</span></span><br><span class="line">        user.save()</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>:<span class="number">200</span>,<span class="string">'msg'</span>:<span class="string">'注册成功'</span>&#125;)</span><br></pre>

<h4 id="脚本测试"><a href="#脚本测试" class="headerlink" title="脚本测试"></a>脚本测试</h4><pre class="highlight"><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://127.0.0.1:8000/register'</span></span><br><span class="line">params=&#123;</span><br><span class="line">    <span class="string">'username'</span>:<span class="string">'Amy'</span>,</span><br><span class="line">    <span class="string">'password'</span>:<span class="number">123</span>,</span><br><span class="line">    <span class="string">'img'</span>:<span class="string">'123123'</span>,</span><br><span class="line">    <span class="string">'num'</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">'type'</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">'phone'</span>:<span class="number">2212312312312312312213123133122</span>,</span><br><span class="line">&#125;</span><br><span class="line">res = requests.get(url=url, params=params)</span><br><span class="line">print(res.status_code)</span><br><span class="line">print(res.text)</span><br></pre>

<h4 id="清除pip缓存"><a href="#清除pip缓存" class="headerlink" title="清除pip缓存"></a>清除pip缓存</h4><pre class="highlight"><span class="line">打开命令行</span><br><span class="line">cd pip</span><br><span class="line">然后删除此文件夹下的cache文件就可以清除了</span><br></pre>

<h4 id="生成反向解析表"><a href="#生成反向解析表" class="headerlink" title="生成反向解析表"></a>生成反向解析表</h4><pre class="highlight"><span class="line">Python manage.py inspectdb &gt; mymodels.py</span><br></pre>


]]></content>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>暗夜模式配置</title>
    <url>/2020/05/10/a_s/</url>
    <content><![CDATA[<h4 id="首先在页面找到您要修改的页面的选择器，之后在您的项目中js文件中进行搜索"><a href="#首先在页面找到您要修改的页面的选择器，之后在您的项目中js文件中进行搜索" class="headerlink" title="首先在页面找到您要修改的页面的选择器，之后在您的项目中js文件中进行搜索"></a>首先在页面找到您要修改的页面的选择器，之后在您的项目中js文件中进行搜索</h4><p>例如：</p>
<pre class="highlight"><span class="line">:root&#123;</span><br><span class="line">  --bg--color:&#39;#fff&#39;;</span><br><span class="line">  --a-color:&#39;black&#39;;</span><br><span class="line">&#125;</span><br><span class="line">a.navbar-brand, a.logo &#123;</span><br><span class="line">  font-family: &quot;Lato&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;</span><br><span class="line">  color:var(--a-color);</span><br><span class="line">  font-size: 2rem;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  margin-top: 0; &#125;</span><br><span class="line">  </span><br><span class="line"> .header &#123;</span><br><span class="line">  background:var(--bg-color);</span><br><span class="line">  min-height: 7em;</span><br><span class="line">  height: auto;</span><br><span class="line">  border-radius: 0;</span><br><span class="line">  width: 100%;</span><br><span class="line">  color: #444342;</span><br><span class="line">  padding-top: 1em;</span><br><span class="line">  padding-bottom: 1em;</span><br><span class="line">  border-bottom: 1px solid rgba(0, 0, 0, 0.05); &#125;</span><br><span class="line">  .header li.nav-item &#123;</span><br><span class="line">    font-size: 1.05em;</span><br><span class="line">    margin-left: .5em;</span><br><span class="line">    padding: .75em .35em; &#125;</span><br></pre>

<p>我们将颜色用变量控制</p>
<h4 id="通过变量控制"><a href="#通过变量控制" class="headerlink" title="通过变量控制"></a>通过变量控制</h4><pre class="highlight"><span class="line"># 声明变量</span><br><span class="line">:root&#123;</span><br><span class="line">  --bg--color:&#39;#fff&#39;;</span><br><span class="line">  --a-color:&#39;black&#39;;</span><br><span class="line">&#125;</span><br></pre>

<h4 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h4><pre class="highlight"><span class="line">&#x2F;&#x2F; 变量用法</span><br><span class="line">color:var(--a-color);</span><br></pre>

<h4 id="写方法控制背景和字体颜色"><a href="#写方法控制背景和字体颜色" class="headerlink" title="写方法控制背景和字体颜色"></a>写方法控制背景和字体颜色</h4><p>1 需要个开关按钮</p>
<pre class="highlight"><span class="line">&lt;h-switch v-model&#x3D;&quot;colors&quot; @change&#x3D;&quot;change_back&quot;&gt;白&#x2F;黑&lt;&#x2F;h-switch&gt;</span><br></pre>

<p>注：利用双向绑定给其默认值 </p>
<pre class="highlight"><span class="line">data()&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">			colors:0, &#x2F;&#x2F; 默认代表白色</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre>

<p>2 创建change_back方法</p>
<pre class="highlight"><span class="line">change_back:function()&#123;</span><br><span class="line">		&#x2F;&#x2F; 获取样式表</span><br><span class="line">		var styles &#x3D; getComputedStyle(document.documentElement) </span><br><span class="line">		if (this.colors !&#x3D; 0 )&#123;</span><br><span class="line">			&#x2F;&#x2F; 给背景赋值</span><br><span class="line">			document.documentElement.style.setProperty(&#39;--bg-color&#39;,&quot;#292a2b&quot;)</span><br><span class="line">			&#x2F;&#x2F; 设置字体颜色</span><br><span class="line">			document.documentElement.style.setProperty(&#39;--a-color&#39;,&quot;white&quot;)</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			&#x2F;&#x2F; 给背景赋值</span><br><span class="line">			document.documentElement.style.setProperty(&#39;--bg-color&#39;,&quot;#white&quot;)</span><br><span class="line">			&#x2F;&#x2F; 设置字体颜色</span><br><span class="line">			document.documentElement.style.setProperty(&#39;--a-color&#39;,&quot;#292a2b&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre>

<p>注：切换到暗黑主题时我们将字体改成白色</p>
<h4 id="在指定时间运行代码"><a href="#在指定时间运行代码" class="headerlink" title="在指定时间运行代码"></a>在指定时间运行代码</h4><pre class="highlight"><span class="line">&#x2F;&#x2F; 指定时间运行代码</span><br><span class="line">		runtime:function()&#123;;		</span><br><span class="line">			var data &#x3D; new Date()</span><br><span class="line">			&#x2F;&#x2F; 获取当前hours</span><br><span class="line">			var time &#x3D; data.getHours()</span><br><span class="line">			if(time &#x3D;&#x3D; 22)&#123;</span><br><span class="line">				&#x2F;&#x2F; 获取样式表</span><br><span class="line">				var styles &#x3D; getComputedStyle(document.documentElement) </span><br><span class="line">				&#x2F;&#x2F; 给背景赋值</span><br><span class="line">				document.documentElement.style.setProperty(&#39;--bg-color&#39;,&quot;#292a2b&quot;)</span><br><span class="line">				&#x2F;&#x2F; 设置字体颜色</span><br><span class="line">				document.documentElement.style.setProperty(&#39;--a-color&#39;,&quot;white&quot;)</span><br><span class="line">				this.$Message(&quot;夜深了 您以进入暗黑模式&quot;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre>

<p>到22:00的时候切换到自动切换到暗黑模式，在钩子方法调用这个方法。</p>
]]></content>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Celery+Redis</title>
    <url>/2020/07/17/c_y/</url>
    <content><![CDATA[<p>1、任务（tasks）–用户定义的函数，用于实现用户的功能，比如执行一个耗时很长的任务</p>
<p>2、中间介（Broker）–用于存放tasks的地方，但是这个中间介需要解决一个问题，就是可能需要存放非常非常多的tasks，而且要保证Worker能够从这里拿取</p>
<p>3、执行者（Worker）–用于执行tasks，也就是真正调用我们在tasks中定义的函数</p>
<p>4、存储（Backend）–把执行tasks返回的结果进行存储，以供用户查看或调用</p>
<h2 id="1、各模块功能"><a href="#1、各模块功能" class="headerlink" title="1、各模块功能"></a>1、各模块功能</h2><p>Celery中，以上组件具体功能如下：</p>
<p><strong>任务模块 Task</strong></p>
<p>包含异步任务和定时任务。其中，异步任务通常在业务逻辑中被触发并发往任务队列，而定时任务由 Celery Beat 进程周期性地将任务发往任务队列。</p>
<p><strong>消息中间件 Broker</strong></p>
<p>Broker，即为任务调度队列，接收任务生产者发来的消息（即任务），将任务存入队列。Celery 本身不提供队列服务，官方推荐使用 RabbitMQ 和 Redis 等。</p>
<p><strong>任务执行单元 Worker</strong></p>
<p>Worker 是执行任务的处理单元，它实时监控消息队列，获取队列中调度的任务，并执行它。</p>
<p><strong>任务结果存储 Backend</strong></p>
<p>Backend 用于存储任务的执行结果，以供查询。同消息中间件一样，存储也可使用 RabbitMQ, Redis 和 MongoDB 等。</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Django工程搭建</title>
    <url>/2020/07/23/d_g/</url>
    <content><![CDATA[<h3 id="后端django工程"><a href="#后端django工程" class="headerlink" title="后端django工程"></a>后端django工程</h3><ol>
<li><p>框架</p>
<ul>
<li>django</li>
</ul>
</li>
<li><p>用户模型</p>
<ul>
<li>django内置的user模型<ul>
<li>添加导包路径 apps 目录添加到 sys.path里</li>
<li>配置pycharm的包搜索路径</li>
</ul>
</li>
<li>扩展用户模型: 增加手机号,昵称,头像,地址,…..</li>
</ul>
</li>
<li><p>认证模型</p>
<ul>
<li>前后端不分离: session认证(基于cookie, 服务端存储session信息)</li>
<li>前后端分离: jwt认证(不受限于跨域, 服务端不存储信息)</li>
</ul>
</li>
<li><p>基础结构及配置</p>
<ul>
<li>基础目录配置</li>
<li>cors配置</li>
</ul>
</li>
<li><p>drf初始化</p>
<ul>
<li><p>安装: pip install djangorestframework, django-filter</p>
</li>
<li><p>注册应用: INSTALLED_APPS 中 […’rest_framework’, ‘django_filters’]</p>
</li>
<li><p>添加配置:</p>
<pre class="highlight"><span class="line"><span class="comment"># 过滤器</span></span><br><span class="line"><span class="comment"># 1,安装 django-filter</span></span><br><span class="line"><span class="comment"># 2,注册应用</span></span><br><span class="line"><span class="comment"># 3,配置settings, 在view里配置可过滤的字段</span></span><br><span class="line"><span class="comment"># 4,使用 查询字符串携带过滤信息</span></span><br><span class="line"></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># 文档报错： AttributeError: ‘AutoSchema’ object has no attribute ‘get_link’</span></span><br><span class="line">    <span class="comment"># 用下面的设置可以解决</span></span><br><span class="line">    <span class="string">'DEFAULT_SCHEMA_CLASS'</span>: <span class="string">'rest_framework.schemas.AutoSchema'</span>,</span><br><span class="line">    <span class="comment"># 默认设置是:</span></span><br><span class="line">    <span class="comment"># 'DEFAULT_SCHEMA_CLASS': 'rest_framework.schemas.openapi.AutoSchema',</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 异常处理器</span></span><br><span class="line">    <span class="comment"># 'EXCEPTION_HANDLER': 'user.utils.exception_handler',</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Base API policies</span></span><br><span class="line">    <span class="string">'DEFAULT_RENDERER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.renderers.JSONRenderer'</span>,</span><br><span class="line">        <span class="string">'rest_framework.renderers.BrowsableAPIRenderer'</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'DEFAULT_PARSER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.parsers.JSONParser'</span>,</span><br><span class="line">        <span class="string">'rest_framework.parsers.FormParser'</span>,</span><br><span class="line">        <span class="string">'rest_framework.parsers.MultiPartParser'</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'DEFAULT_AUTHENTICATION_CLASSES'</span>: [  <span class="comment"># 认证器</span></span><br><span class="line">        <span class="string">'rest_framework.authentication.SessionAuthentication'</span>,  <span class="comment"># 使用session时的认证器</span></span><br><span class="line">        <span class="string">'rest_framework.authentication.BasicAuthentication'</span>  <span class="comment"># 提交表单时的认证器</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'DEFAULT_PERMISSION_CLASSES'</span>: [  <span class="comment"># 权限配置, 顺序靠上的严格</span></span><br><span class="line">        <span class="string">'rest_framework.permissions.IsAdminUser'</span>,  <span class="comment"># 管理员可以访问</span></span><br><span class="line">        <span class="string">'rest_framework.permissions.IsAuthenticated'</span>,  <span class="comment"># 认证用户可以访问</span></span><br><span class="line">        <span class="string">'rest_framework.permissions.IsAuthenticatedOrReadOnly'</span>,  <span class="comment"># 认证用户可以访问, 否则只能读取</span></span><br><span class="line">        <span class="string">'rest_framework.permissions.AllowAny'</span>,  <span class="comment"># 所有用户都可以访问</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment"># 限流</span></span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.throttling.AnonRateThrottle'</span>,</span><br><span class="line">        <span class="string">'rest_framework.throttling.UserRateThrottle'</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment"># 限流策略</span></span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_RATES'</span>: &#123;</span><br><span class="line">        <span class="string">'user'</span>: <span class="string">'10/hour'</span>,</span><br><span class="line">        <span class="string">'anon'</span>: <span class="string">'3/day'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">'DEFAULT_CONTENT_NEGOTIATION_CLASS'</span>: <span class="string">'rest_framework.negotiation.DefaultContentNegotiation'</span>,</span><br><span class="line">    <span class="string">'DEFAULT_METADATA_CLASS'</span>: <span class="string">'rest_framework.metadata.SimpleMetadata'</span>,</span><br><span class="line">    <span class="string">'DEFAULT_VERSIONING_CLASS'</span>: <span class="literal">None</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全局分页器, 例如 省市区的数据自定义分页器, 不需要分页</span></span><br><span class="line">    <span class="string">'DEFAULT_PAGINATION_CLASS'</span>: <span class="string">'rest_framework.pagination.PageNumberPagination'</span>,</span><br><span class="line">    <span class="comment"># 每页返回数量</span></span><br><span class="line">    <span class="string">'PAGE_SIZE'</span>: <span class="number">10</span>,  <span class="comment"># 默认 None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 过滤器后端</span></span><br><span class="line">    <span class="string">'DEFAULT_FILTER_BACKENDS'</span>: [</span><br><span class="line">        <span class="string">'django_filters.rest_framework.DjangoFilterBackend'</span>,</span><br><span class="line">        <span class="comment"># 'django_filters.rest_framework.backends.DjangoFilterBackend', 包路径有变化</span></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Filtering 过滤排序</span></span><br><span class="line">    <span class="string">'SEARCH_PARAM'</span>: <span class="string">'search'</span>,</span><br><span class="line">    <span class="string">'ORDERING_PARAM'</span>: <span class="string">'ordering'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">'NUM_PROXIES'</span>: <span class="literal">None</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Versioning  接口版本控制</span></span><br><span class="line">    <span class="string">'DEFAULT_VERSION'</span>: <span class="literal">None</span>,</span><br><span class="line">    <span class="string">'ALLOWED_VERSIONS'</span>: <span class="literal">None</span>,</span><br><span class="line">    <span class="string">'VERSION_PARAM'</span>: <span class="string">'version'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Authentication  认证</span></span><br><span class="line">    <span class="comment"># 未认证用户使用的用户类型</span></span><br><span class="line">    <span class="string">'UNAUTHENTICATED_USER'</span>: <span class="string">'django.contrib.auth.models.AnonymousUser'</span>,</span><br><span class="line">    <span class="comment"># 未认证用户使用的Token值</span></span><br><span class="line">    <span class="string">'UNAUTHENTICATED_TOKEN'</span>: <span class="literal">None</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># View configuration</span></span><br><span class="line">    <span class="string">'VIEW_NAME_FUNCTION'</span>: <span class="string">'rest_framework.views.get_view_name'</span>,</span><br><span class="line">    <span class="string">'VIEW_DESCRIPTION_FUNCTION'</span>: <span class="string">'rest_framework.views.get_view_description'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">'NON_FIELD_ERRORS_KEY'</span>: <span class="string">'non_field_errors'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Testing</span></span><br><span class="line">    <span class="string">'TEST_REQUEST_RENDERER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.renderers.MultiPartRenderer'</span>,</span><br><span class="line">        <span class="string">'rest_framework.renderers.JSONRenderer'</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'TEST_REQUEST_DEFAULT_FORMAT'</span>: <span class="string">'multipart'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Hyperlink settings</span></span><br><span class="line">    <span class="string">'URL_FORMAT_OVERRIDE'</span>: <span class="string">'format'</span>,</span><br><span class="line">    <span class="string">'FORMAT_SUFFIX_KWARG'</span>: <span class="string">'format'</span>,</span><br><span class="line">    <span class="string">'URL_FIELD_NAME'</span>: <span class="string">'url'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Input and output formats</span></span><br><span class="line">    <span class="string">'DATE_FORMAT'</span>: ISO_8601,</span><br><span class="line">    <span class="string">'DATE_INPUT_FORMATS'</span>: [ISO_8601],</span><br><span class="line"></span><br><span class="line">    <span class="string">'DATETIME_FORMAT'</span>: ISO_8601,</span><br><span class="line">    <span class="string">'DATETIME_INPUT_FORMATS'</span>: [ISO_8601],</span><br><span class="line"></span><br><span class="line">    <span class="string">'TIME_FORMAT'</span>: ISO_8601,</span><br><span class="line">    <span class="string">'TIME_INPUT_FORMATS'</span>: [ISO_8601],</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Encoding</span></span><br><span class="line">    <span class="string">'UNICODE_JSON'</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">'COMPACT_JSON'</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">'STRICT_JSON'</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">'COERCE_DECIMAL_TO_STRING'</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">'UPLOADED_FILES_USE_URL'</span>: <span class="literal">True</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Browseable API</span></span><br><span class="line">    <span class="string">'HTML_SELECT_CUTOFF'</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="string">'HTML_SELECT_CUTOFF_TEXT'</span>: <span class="string">"More than &#123;count&#125; items..."</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Schemas</span></span><br><span class="line">    <span class="string">'SCHEMA_COERCE_PATH_PK'</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">'SCHEMA_COERCE_METHOD_NAMES'</span>: &#123;</span><br><span class="line">        <span class="string">'retrieve'</span>: <span class="string">'read'</span>,</span><br><span class="line">        <span class="string">'destroy'</span>: <span class="string">'delete'</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre>

</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django--创建虚拟环境</title>
    <url>/2020/04/17/d_v/</url>
    <content><![CDATA[<h1 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h1><h3 id="为什么需要虚拟环境："><a href="#为什么需要虚拟环境：" class="headerlink" title="为什么需要虚拟环境："></a>为什么需要虚拟环境：</h3><p>到目前位置，我们所有的第三方包安装都是直接通过<code>pip install xx</code>的方式进行安装的，这样安装会将那个包安装到你的系统级的<code>Python</code>环境中。但是这样有一个问题，就是如果你现在用<code>Django 1.18.x</code>写了个网站，然后你的领导跟你说，之前有一个旧项目是用<code>Django 2.1.x</code>开发的，让你来维护，但是<code>Django 1.18.x</code>不再兼容<code>Django 2.1.x</code>的一些语法了。这时候就会碰到一个问题，我如何在我的电脑中同时拥有<code>Django 1.18.x</code>和<code>Django 2.1.x</code>两套环境呢？这时候我们就可以通过虚拟环境来解决这个问题。</p>
<h3 id="虚拟环境原理介绍："><a href="#虚拟环境原理介绍：" class="headerlink" title="虚拟环境原理介绍："></a>虚拟环境原理介绍：</h3><p>虚拟环境相当于一个抽屉，在这个抽屉中安装的任何软件包都不会影响到其他抽屉。并且在项目中，我可以指定这个项目的虚拟环境来配合我的项目。比如我们现在有一个项目是基于<code>Django 1.18.x</code>版本，又有一个项目是基于<code>Django 2.1.x</code>的版本，那么这时候就可以创建两个虚拟环境，在这两个虚拟环境中分别安装<code>Django 1.18.x</code>和<code>Django 2.1.x</code>来适配我们的项目。</p>
<h3 id="安装virtualenv："><a href="#安装virtualenv：" class="headerlink" title="安装virtualenv："></a>安装<code>virtualenv</code>：</h3><p><code>virtualenv</code>是用来创建虚拟环境的软件工具，我们可以通过<code>pip</code>或者<code>pip3</code>来安装：</p>
<pre class="highlight"><span class="line">pip install virtualenv</span><br><span class="line">pip3 install virtualenv  # 一般在linux下用这个命令</span><br><span class="line">pip install virtualenvwrapper-win</span><br></pre>

<h3 id="创建虚拟环境："><a href="#创建虚拟环境：" class="headerlink" title="创建虚拟环境："></a>创建虚拟环境：</h3><p>创建虚拟环境非常简单，通过以下命令就可以创建了：</p>
<pre class="highlight"><span class="line"><span class="comment"># mkvirtualenv [虚拟环境的名字]</span></span><br><span class="line">mkvirtualenv py_dj2</span><br></pre>

<p>如果你当前的<code>Python3/Scripts</code>的查找路径在<code>Python2/Scripts</code>的前面，那么将会使用<code>python3</code>作为这个虚拟环境的解释器。如果<code>python2/Scripts</code>在<code>python3/Scripts</code>前面，那么将会使用<code>Python2</code>来作为这个虚拟环境的解释器。</p>
<h3 id="进入环境："><a href="#进入环境：" class="headerlink" title="进入环境："></a>进入环境：</h3><p>虚拟环境创建好了以后，那么可以进入到这个虚拟环境中，然后安装一些第三方包，进入虚拟环境在不同的操作系统中有不同的方式，一般分为两种，第一种是<code>Windows</code>，第二种是<code>Linux</code>：</p>
<ol>
<li><code>windows</code>进入虚拟环境：进入到虚拟环境的<code>Scripts</code>文件夹中，然后执行workon py_dj2。</li>
<li><code>Linux</code>进入虚拟环境：<code>source /path/to/virtualenv/bin/activate</code><br>一旦你进入到了这个虚拟环境中，你安装包，卸载包都是在这个虚拟环境中，不会影响到外面的环境。</li>
</ol>
<h3 id="退出虚拟环境："><a href="#退出虚拟环境：" class="headerlink" title="退出虚拟环境："></a>退出虚拟环境：</h3><p>退出虚拟环境很简单，通过一个命令就可以完成：<code>deactivate</code>。</p>
<h3 id="virtualenvwrapper："><a href="#virtualenvwrapper：" class="headerlink" title="virtualenvwrapper："></a>virtualenvwrapper：</h3><p><code>virtualenvwrapper</code>这个软件包可以让我们管理虚拟环境变得更加简单。不用再跑到某个目录下通过<code>virtualenv</code>来创建虚拟环境，并且激活的时候也要跑到具体的目录下去激活。</p>
<h4 id="安装virtualenvwrapper："><a href="#安装virtualenvwrapper：" class="headerlink" title="安装virtualenvwrapper："></a>安装<code>virtualenvwrapper</code>：</h4><ol>
<li>Linux：<code>pip install virtualenvwrapper</code>。</li>
<li>windows：<code>pip install virtualenvwrapper-win</code>。</li>
</ol>
<h4 id="virtualenvwrapper基本使用："><a href="#virtualenvwrapper基本使用：" class="headerlink" title="virtualenvwrapper基本使用："></a><code>virtualenvwrapper</code>基本使用：</h4><ol>
<li>创建虚拟环境：</li>
</ol>
<pre class="highlight"><span class="line">mkvirtualenv my_env</span><br></pre>

<p>   那么会在你当前用户下创建一个<code>Env</code>的文件夹，然后将这个虚拟环境安装到这个目录下。<br>   如果你电脑中安装了<code>python2</code>和<code>python3</code>，并且两个版本中都安装了<code>virtualenvwrapper</code>，那么将会使用环境变量中第一个出现的<code>Python</code>版本来作为这个虚拟环境的<code>Python</code>解释器。</p>
<ol start="2">
<li>切换到某个虚拟环境：</li>
</ol>
<pre class="highlight"><span class="line">workon my_env</span><br></pre>

<ol start="3">
<li>退出当前虚拟环境：</li>
</ol>
<pre class="highlight"><span class="line">deactivate</span><br></pre>

<ol start="4">
<li>删除某个虚拟环境：</li>
</ol>
<pre class="highlight"><span class="line">rmvirtualenv my_env</span><br></pre>

<ol start="5">
<li>列出所有虚拟环境：</li>
</ol>
<pre class="highlight"><span class="line">lsvirtualenv</span><br></pre>

<ol start="6">
<li>创建虚拟环境的时候指定<code>Python</code>版本：</li>
</ol>
<p>在使用<code>mkvirtualenv</code>的时候，可以指定<code>--python</code>的参数来指定具体的<code>python</code>路径：</p>
<pre class="highlight"><span class="line">mkvirtualenv --python&#x3D;&#x3D;C:\Python36\python.exe hy_env</span><br></pre>]]></content>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>docker命令集</title>
    <url>/2020/04/26/d_r/</url>
    <content><![CDATA[<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>显示版本号</p>
<pre class="highlight"><span class="line">docker --versions</span><br></pre>



<p>显示镜像</p>
<pre class="highlight"><span class="line">docker images</span><br></pre>



<p>保存镜像 </p>
<pre class="highlight"><span class="line">docker save -o /home/dyufei/tensorflow.tar tensorflow/tensorflow</span><br><span class="line">或者 </span><br><span class="line">docker save tensorflow/tensorflow &gt; /home/dyufei/tensorflow.tar</span><br></pre>



<p>加载镜像</p>
<pre class="highlight"><span class="line">docker load -i tensorflow.tar</span><br></pre>



<p>登录系统 镜像编号</p>
<pre class="highlight"><span class="line">docker run -ti <span class="number">6866</span></span><br><span class="line">docker run -it centos /bin/bash</span><br></pre>



<p>登录系统 容器编号</p>
<pre class="highlight"><span class="line">docker run -d --privileged=true mycentos /usr/sbin/init</span><br><span class="line">docker <span class="keyword">exec</span> –it 容器编号 /bin/bash</span><br></pre>



<p>进入虚拟机</p>
<pre class="highlight"><span class="line">docker-machine ssh</span><br></pre>



<p>挂载共享文件夹</p>
<pre class="highlight"><span class="line">docker run -v /www:/mnt/www</span><br></pre>



<p>查看所有容器</p>
<pre class="highlight"><span class="line">docker ps -a</span><br></pre>



<p>删除容器</p>
<pre class="highlight"><span class="line">docker rm</span><br></pre>



<p>后台启动服务和端口映射</p>
<pre class="highlight"><span class="line">docker run -it -d -p <span class="number">8000</span>:<span class="number">8000</span> mycentos cmd</span><br></pre>




<p>查看宿主ip</p>
<pre class="highlight"><span class="line">docker-machine ip default</span><br><span class="line"><span class="number">192.168</span><span class="number">.99</span><span class="number">.100</span></span><br></pre>




<p>查看容器编号</p>
<pre class="highlight"><span class="line">cat /proc/self/cgroup | head <span class="number">-1</span></span><br></pre>



<p>提交更改</p>
<pre class="highlight"><span class="line">docker commit 容器id 镜像名称</span><br></pre>



<p>删除镜像</p>
<pre class="highlight"><span class="line">docker rmi -f 镜像id</span><br></pre>



<p>检查系统</p>
<pre class="highlight"><span class="line">cat /etc/redhat-release</span><br></pre>



<p>退出镜像</p>
<pre class="highlight"><span class="line">exit</span><br><span class="line">docker run -it ubuntu:rename /bin/echo <span class="string">"Hello World"</span></span><br></pre>



<p>删除镜像缓存</p>
<pre class="highlight"><span class="line"></span><br><span class="line">docker ps -a | grep <span class="string">"Exited"</span> | awk <span class="string">'&#123;print $1 &#125;'</span>|xargs docker stop</span><br><span class="line"></span><br><span class="line">docker ps -a | grep <span class="string">"Exited"</span> | awk <span class="string">'&#123;print $1 &#125;'</span>|xargs docker rm</span><br></pre>

]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>简述详情页</title>
    <url>/2020/05/11/d_l/</url>
    <content><![CDATA[<h4 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h4><pre class="highlight"><span class="line"><span class="comment"># 商品详情</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodInfo</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        id = request.GET.get(<span class="string">'id'</span>,<span class="literal">None</span>)</span><br><span class="line">        <span class="comment"># 查询</span></span><br><span class="line">        good = Goods.objects.get(id=id)</span><br><span class="line">        <span class="comment"># 序列化 </span></span><br><span class="line">        good_str = GoodsSer(good)</span><br><span class="line">        <span class="keyword">return</span> Response(good_str.data)</span><br></pre>

<p>前端代码</p>
<pre class="highlight"><span class="line">&#x2F;&#x2F; 带参跳转</span><br><span class="line">&lt;a :href&#x3D;&quot;&#39;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;item?id&#x3D;&#39;+item.id&quot;&gt;</span><br></pre>



<pre class="highlight"><span class="line">&#x2F;&#x2F; 获取商品id</span><br><span class="line"> this.id &#x3D; this.$route.query.id</span><br></pre>



<pre class="highlight"><span class="line">param:&#123;&#125;</span><br></pre>



<pre class="highlight"><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 获取商品详情</span><br><span class="line">   get_good:function()&#123;</span><br><span class="line"> this.axios.get(&#39;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;goodinfo&#x2F;?id&#x3D;&#39;,&#123;params:&#123;&#39;id&#39;:this.id&#125;&#125;).then((res&#x3D;&gt;&#123;</span><br><span class="line">	 console.log(res)</span><br><span class="line">	 &#x2F;&#x2F; 赋值</span><br><span class="line">	 this.info&#x3D;res.data</span><br><span class="line">	 &#x2F;&#x2F; 类型转换</span><br><span class="line">	 this.param &#x3D; JSON.parse(this.info.params)</span><br><span class="line"> &#125;))</span><br><span class="line">&#125;</span><br></pre>



<h4 id="展示规格"><a href="#展示规格" class="headerlink" title="展示规格"></a>展示规格</h4><pre class="highlight"><span class="line">颜色：&#123;&#123;param.color&#125;&#125; </span><br><span class="line">&lt;br&gt;</span><br><span class="line">尺码：&#123;&#123;param.size&#125;&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">季节：&#123;&#123;param.season&#125;&#125;</span><br></pre>

]]></content>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>分页</title>
    <url>/2020/05/12/d_y/</url>
    <content><![CDATA[<h4 id="分页后端逻辑"><a href="#分页后端逻辑" class="headerlink" title="分页后端逻辑"></a>分页后端逻辑</h4><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodsList</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#当前页</span></span><br><span class="line">        page = request.GET.get(<span class="string">'page'</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#一页显示的个数</span></span><br><span class="line">        size = request.GET.get(<span class="string">'size'</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#计算从哪开始切</span></span><br><span class="line">        data_start = (int(page)<span class="number">-1</span>) *int(size)</span><br><span class="line">        <span class="comment">#计算切到哪</span></span><br><span class="line">        data_end = int(page) * int(size)</span><br><span class="line">        <span class="comment">#查询 切片成当前页数据</span></span><br><span class="line">        goods = Goods.objects.all()[data_start:data_end]</span><br><span class="line">        <span class="comment">#查询所有商品个数</span></span><br><span class="line">        count = Goods.objects.count()</span><br><span class="line">        <span class="comment">#序列化</span></span><br><span class="line">        goods_ser = GoodsSer(goods,many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'data'</span>:goods_ser.data,<span class="string">'total'</span>:count&#125;)</span><br></pre>

<h4 id="前端template中"><a href="#前端template中" class="headerlink" title="前端template中"></a>前端template中</h4><pre class="highlight"><span class="line">&lt;!-- heyui分页器 --&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    	&lt;Pagination v-model&#x3D;&quot;pagination&quot; @change&#x3D;&quot;get_goods&quot;&gt;&lt;&#x2F;Pagination&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br></pre>

<p>data中定义分页器变量</p>
<pre class="highlight"><span class="line">&#x2F;&#x2F;定义分页器变量</span><br><span class="line">  pagination:&#123;</span><br><span class="line">	  page:2,</span><br><span class="line">	  size:2,</span><br><span class="line">	  total:5,</span><br><span class="line">  &#125;</span><br></pre>

<pre class="highlight"><span class="line">&#x2F;&#x2F; 获取商品类表接口</span><br><span class="line">  get_goods:function()&#123;</span><br><span class="line">		&#x2F;&#x2F; 拼接路由</span><br><span class="line">	  this.axios.get(&#39;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;goodslist&#x2F;&#39;,&#123;params:&#123;page:this.pagination.page,size:this.pagination.size&#125;&#125;).then((res&#x3D;&gt;&#123;</span><br><span class="line">		  console.log(res)</span><br><span class="line"></span><br><span class="line">		  this.goodslist &#x3D; res.data.data</span><br><span class="line">		  </span><br><span class="line">			&#x2F;&#x2F;将商品总数传递给total</span><br><span class="line">		  this.pagination.total &#x3D; res.data.total</span><br><span class="line">	  &#125;))</span><br><span class="line">  &#125;</span><br></pre>



<h4 id="获取文件"><a href="#获取文件" class="headerlink" title="获取文件"></a>获取文件</h4><pre class="highlight"><span class="line">图片：&lt;input type&#x3D;&quot;file&quot; ref&#x3D;&quot;upload&quot;&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接收表单数据</span><br><span class="line">var pc &#x3D; this.$refs.upload</span><br><span class="line">let file &#x3D; pc.files[0]</span><br></pre>

]]></content>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>django创建表</title>
    <url>/2018/11/27/django%E5%88%9B%E5%BB%BA%E8%A1%A8/</url>
    <content><![CDATA[<h6 id="在settings-py配置好的前提下，打开models-py"><a href="#在settings-py配置好的前提下，打开models-py" class="headerlink" title="在settings.py配置好的前提下，打开models.py"></a>在settings.py配置好的前提下，打开models.py</h6><h4 id="创建基类-增加代码的复用"><a href="#创建基类-增加代码的复用" class="headerlink" title="创建基类(增加代码的复用)"></a>创建基类(增加代码的复用)</h4><pre class="highlight"><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"></span><br><span class="line"><span class="comment">#基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment">#创建时间 </span></span><br><span class="line">    create_time = models.DateTimeField(default=timezone.now,null=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment">#能否被继承</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用户类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="comment">#  用户名</span></span><br><span class="line">    username = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    <span class="comment">#  密码</span></span><br><span class="line">    password = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    <span class="comment">#  头像</span></span><br><span class="line">    img = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    <span class="comment">#分类 0普通用户 1会员</span></span><br><span class="line">    type = models.IntegerField()</span><br><span class="line">    <span class="comment">#  主页</span></span><br><span class="line">    num = models.IntegerField()</span><br><span class="line">    <span class="comment">#  联系方式</span></span><br><span class="line">    phone = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#  声明表名</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'user'</span></span><br></pre>

<hr>
<h6 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h6><pre class="highlight"><span class="line">python manage.py makemigrations myapp</span><br><span class="line">python manage.py migrate</span><br></pre>

<h4 id="如果迁移不成功"><a href="#如果迁移不成功" class="headerlink" title="如果迁移不成功"></a>如果迁移不成功</h4><ol>
<li>删除myapp下的migrations</li>
<li>通过可视化工具Navicat进行物理删除，及删除数据库中的所有表（有时候删一次删不彻底，记得多重复几次物理删除操作）</li>
<li>重新建立数据库关系映射，迁移数据库</li>
</ol>
<h6 id="Mysql-用Navicat手动建表格"><a href="#Mysql-用Navicat手动建表格" class="headerlink" title="Mysql 用Navicat手动建表格"></a>Mysql 用Navicat手动建表格</h6><p>手动建表格，输入反向数据库入库命令</p>
<pre class="highlight"><span class="line">python manage.py inspectdb &gt; mymodel.py</span><br></pre>

<hr>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>django配置</title>
    <url>/2018/11/27/django%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1-django配置-settings-py"><a href="#1-django配置-settings-py" class="headerlink" title="1.django配置(settings.py)"></a>1.django配置(settings.py)</h2><pre class="highlight"><span class="line">DATABASES = &#123;</span><br><span class="line">   <span class="string">'default'</span>: &#123;</span><br><span class="line">          <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,   <span class="comment">#数据库引擎</span></span><br><span class="line">          <span class="string">'NAME'</span>: <span class="string">'md'</span>,                          <span class="comment">#数据库名</span></span><br><span class="line">          <span class="string">'USER'</span>: <span class="string">'root'</span>,                         <span class="comment">#用户名</span></span><br><span class="line">          <span class="string">'PASSWORD'</span>: <span class="string">''</span>,                         <span class="comment">#密码--根据自身数据库密码填写</span></span><br><span class="line">          <span class="string">'HOST'</span>: <span class="string">'localhost'</span>,                    <span class="comment">#数据库主机，默认为localhost</span></span><br><span class="line">          <span class="string">'PORT'</span>: <span class="number">3306</span>,                           <span class="comment">#数据库端口，MySQL默认为3306</span></span><br><span class="line">          <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">             <span class="string">'autocommit'</span>: <span class="literal">True</span>,</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>

<hr>
<h2 id="2-运行项目"><a href="#2-运行项目" class="headerlink" title="2.运行项目"></a>2.运行项目</h2><pre class="highlight"><span class="line">python manage.py runserver</span><br></pre>

<h2 id="3-django的数据库迁移"><a href="#3-django的数据库迁移" class="headerlink" title="3.django的数据库迁移"></a>3.django的数据库迁移</h2><h6 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h6><pre class="highlight"><span class="line">python manage.py makemigrations myapp</span><br></pre>

<h6 id="注意：首次迁移后面写myapp，以后不用写"><a href="#注意：首次迁移后面写myapp，以后不用写" class="headerlink" title="注意：首次迁移后面写myapp，以后不用写"></a>注意：首次迁移后面写myapp，以后不用写</h6><h6 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h6><pre class="highlight"><span class="line">python manage.py migrate</span><br></pre>

<hr>
<h2 id="3-配置跨域"><a href="#3-配置跨域" class="headerlink" title="3.配置跨域"></a>3.配置跨域</h2><pre class="highlight"><span class="line"></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">'django.middleware.security.SecurityMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class="line">    <span class="string">'corsheaders.middleware.CorsMiddleware'</span>, <span class="comment">#这里是新增的中间件</span></span><br><span class="line">    <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">    <span class="comment">#'django.middleware.csrf.CsrfViewMiddleware',</span></span><br><span class="line">    <span class="string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span>,</span><br><span class="line">    <span class="comment">#加载自定义中间件   文件夹名.文件名.类名</span></span><br><span class="line">    <span class="comment">#'myapp.views.MyMiddleware'</span></span><br><span class="line">]</span><br></pre>
<h6 id="设置跨域"><a href="#设置跨域" class="headerlink" title="设置跨域"></a>设置跨域</h6><pre class="highlight"><span class="line">CORS_ALLOW_CREDENTIALS = <span class="literal">True</span></span><br><span class="line">CORS_ORIGIN_ALLOW_ALL = <span class="literal">True</span></span><br></pre>

<h6 id="定义上传文件夹的路径"><a href="#定义上传文件夹的路径" class="headerlink" title="定义上传文件夹的路径"></a>定义上传文件夹的路径</h6><pre class="highlight"><span class="line">UPLOAD_ROOT = os.path.join(BASE_DIR,<span class="string">'static/upload'</span>)</span><br></pre>

<hr>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>简易购物车代码</title>
    <url>/2020/04/22/g_h/</url>
    <content><![CDATA[<h3 id="如下"><a href="#如下" class="headerlink" title="如下"></a>如下</h3><pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;名称&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;数量&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;价格&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr v-<span class="keyword">for</span>=<span class="string">"(itemone,indexone) in tlist "</span> :key=<span class="string">"indexone"</span>&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &#123;&#123; itemone.text &#125;&#125;</span><br><span class="line">    &lt;/td&gt;</span><br><span class="line"></span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &lt;button @click="numchange(indexone,'-')" &gt;-&lt;/button&gt;</span><br><span class="line">            &#123;&#123;itemone.num&#125;&#125;</span><br><span class="line">        &lt;button @click="numchange(indexone,'+')"&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;/td&gt;</span><br><span class="line"></span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &#123;&#123; itemone.price &#125;&#125;</span><br><span class="line">    &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">&lt;/table&gt;</span><br><span class="line">    总价格:&#123;&#123; totalprice() &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">// 定义数据</span><br><span class="line">    data()&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">    tlist:[&#123;text:<span class="string">'汽车'</span>,num:<span class="number">1</span>,<span class="string">'price'</span>:<span class="number">100</span>&#125;,&#123;text:<span class="string">'化妆品'</span>,num:<span class="number">1</span>,<span class="string">'price'</span>:<span class="number">100</span>,&#125;,&#123;text:<span class="string">'衣服'</span>,num:<span class="number">1</span>,<span class="string">'price'</span>:<span class="number">100</span>&#125;,&#123;text:<span class="string">'书籍'</span>,num:<span class="number">1</span>,<span class="string">'price'</span>:<span class="number">100</span>&#125;],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    //自定方法</span><br><span class="line">    methods:&#123;</span><br><span class="line">        // 计算总的价格 </span><br><span class="line">        totalprice:function()&#123;</span><br><span class="line">            let total =<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(var i=<span class="number">0</span>,l=this.tlist.length;i&lt;l;i++)&#123;</span><br><span class="line">                total += (this.tlist[i].num * this.tlist[i].price);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">return</span> total;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 自动清除操作</span><br><span class="line">        delete_one:function(indexone)&#123;</span><br><span class="line">            this.tlist.splice(indexone,<span class="number">1</span>);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 购物车的加减操作</span><br><span class="line">        numchange:function(indexone,type)&#123;</span><br><span class="line">            <span class="keyword">if</span>(type==<span class="string">"+"</span>)&#123;</span><br><span class="line">            this.tlist[indexone].num ++</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (this.tlist[indexone].num &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    this.tlist[indexone].num --</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    this.delete_one(indexone);</span><br><span class="line">                    </span><br><span class="line">                &#125;	</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre>]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>django实现文件上传操作</title>
    <url>/2018/11/30/django%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h5 id="思路：先从前端接受到图片-后台进行重命名-压缩-入库-之后将图片名返回前端-用于展示图片"><a href="#思路：先从前端接受到图片-后台进行重命名-压缩-入库-之后将图片名返回前端-用于展示图片" class="headerlink" title="思路：先从前端接受到图片 后台进行重命名/压缩/入库 之后将图片名返回前端 用于展示图片"></a>思路：先从前端接受到图片 后台进行重命名/压缩/入库 之后将图片名返回前端 用于展示图片</h5><p><img src="/hugoblog/%E9%80%BB%E8%BE%91%E5%9B%BE.png" alt="~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E9%80%BB%E8%BE%91%E5%9B%BE.png" class="lozad post-image"></p>
<hr>
<h5 id="修改配置settings"><a href="#修改配置settings" class="headerlink" title="修改配置settings"></a>修改配置settings</h5><pre class="highlight"><span class="line">STATIC_URL = <span class="string">'/static/'</span></span><br><span class="line"></span><br><span class="line">STATICFILES_DIRS=[</span><br><span class="line">     os.path.join(BASE_DIR,<span class="string">'static'</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义上传文件夹的路径</span></span><br><span class="line">UPLOAD_ROOT = os.path.join(BASE_DIR,<span class="string">'static/upload'</span>)</span><br></pre>

<hr>
<h5 id="前端发送post请求"><a href="#前端发送post请求" class="headerlink" title="前端发送post请求"></a>前端发送post请求</h5><pre class="highlight"><span class="line">upload(e) &#123;  //@change=<span class="string">"upload"</span> 侦听操作 e是变化的数据</span><br><span class="line">      // 获取文件</span><br><span class="line">      let file = e.target.files[<span class="number">0</span>];</span><br><span class="line">      // 生名表单参数</span><br><span class="line">      let formdata = new FormData();</span><br><span class="line">      var uid = localStorage.getItem(<span class="string">"uid"</span>);</span><br><span class="line">      formdata.append(<span class="string">"file"</span>, file, file.name);</span><br><span class="line">      formdata.append(<span class="string">"uid"</span>, uid);</span><br><span class="line">      // 请求头</span><br><span class="line">      let config = &#123; headers: &#123; <span class="string">"Content-Type"</span>: <span class="string">"multipart/form-data"</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">      // 请求后台</span><br><span class="line">      this.axios</span><br><span class="line">        .post(<span class="string">"http://127.0.0.1:8000/myapp/upload/"</span>, formdata, config)</span><br><span class="line">        .then(result =&gt; &#123;</span><br><span class="line">          console.log(result.data);</span><br><span class="line">          <span class="keyword">if</span> (result.data.code == <span class="number">200</span>) &#123;</span><br><span class="line">            this.src =<span class="string">"http://127.0.0.1:8000/static/upload/"</span> + result.data.filename;</span><br><span class="line">            this.$Message(result.data.msg);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            this.$Message(result.data.msg);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre>

<hr>
<h5 id="后台获取数据"><a href="#后台获取数据" class="headerlink" title="后台获取数据"></a>后台获取数据</h5><pre class="highlight"><span class="line">为了防止文件名重复 使用了md5和时间模块 进行加密</span><br><span class="line"></span><br><span class="line">在更改图片之后 我们要删除之前的 防止垃圾过多</span><br><span class="line"></span><br><span class="line">造成资源浪费</span><br><span class="line"></span><br><span class="line">加水印函数：</span><br></pre>
<pre class="highlight"><span class="line"><span class="comment"># 压缩</span></span><br><span class="line"><span class="comment">#压缩 两种压缩模式，png不适合压缩，jpg适合</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment">#读图</span></span><br><span class="line">img = cv2.imread(<span class="string">'./dingding.png'</span>)</span><br><span class="line"><span class="comment">#开始压缩 png压缩等级清晰0-9模糊</span></span><br><span class="line">cv2.imwrite(<span class="string">'./dingding1.png'</span>,img,[cv2.IMWRITE_PNG_COMPRESSION,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#jpg压缩等级清晰0-100模糊 </span></span><br><span class="line">cv2.imwrite(<span class="string">'./dingding1.jpg'</span>,img,[cv2.IMWRITE_JPEG_QUALITY,<span class="number">50</span>])</span><br></pre>

<hr>
<pre class="highlight"><span class="line"><span class="comment"># 加水印</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cn_logo</span><span class="params">(img_name)</span>:</span></span><br><span class="line">    img = Image.open(<span class="string">'.//static/upload/'</span>+img_name)</span><br><span class="line">    <span class="comment"># 获取宽高</span></span><br><span class="line">    width, height = img.size</span><br><span class="line">    <span class="comment"># 根据图片大小定义logo大小</span></span><br><span class="line">    text = <span class="string">'美多商城'</span></span><br><span class="line">    font = ImageFont.truetype(<span class="string">'msyh.ttc'</span>, (width - height) // <span class="number">10</span>)</span><br><span class="line">    <span class="comment"># 获取字体宽高</span></span><br><span class="line">    font_width, font_height = font.getsize(text)</span><br><span class="line">    <span class="comment"># 使用画笔</span></span><br><span class="line">    draw = ImageDraw.Draw(img)</span><br><span class="line">    <span class="comment"># 写入文本</span></span><br><span class="line">    draw.text((width - font_width, height - font_height - <span class="number">10</span>), text, (<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>), font=font)</span><br><span class="line">    <span class="comment"># 加密下文件名防止重复</span></span><br><span class="line">    filename = make_password(img_name) + str((int(round(time.time() * <span class="number">1000</span>)))) + <span class="string">".jpg"</span></span><br><span class="line">    <span class="comment"># 根据路径保存文件</span></span><br><span class="line">    img.save(os.path.join(UPLOAD_ROOT, <span class="string">''</span>, filename))</span><br><span class="line">    os.remove(<span class="string">'.//static/upload/'</span> + img_name)  <span class="comment"># 删除原图片</span></span><br><span class="line">    <span class="keyword">return</span> filename</span><br></pre>

<hr>
<h5 id="文件接口"><a href="#文件接口" class="headerlink" title="文件接口"></a>文件接口</h5><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">    myfile=request.FILES.get(<span class="string">'file'</span>)</span><br><span class="line">    uid=request.POST.get(<span class="string">'uid'</span>)</span><br><span class="line">    <span class="comment"># 判断文件类型</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> re.match(<span class="string">'.*(jpg|png|jpeg)$'</span>, myfile.name):</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>: <span class="number">403</span>,<span class="string">'msg'</span>:<span class="string">'请上传png或者jpg格式'</span>&#125;)</span><br><span class="line">    <span class="keyword">with</span> open(os.path.join(UPLOAD_ROOT,<span class="string">''</span>,myfile.name),<span class="string">'wb'</span>)<span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> myfile.chunks():</span><br><span class="line">            f.write(chunk)</span><br><span class="line">            <span class="comment"># 调用水印函数</span></span><br><span class="line">    filename=cn_logo(myfile.name)</span><br><span class="line">            <span class="comment"># 更改数据库</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        user=User.objects.filter(pk=uid).first()</span><br><span class="line">        <span class="keyword">if</span> user.img:  <span class="comment"># 删除旧图片</span></span><br><span class="line">           os.remove(<span class="string">'.//static/upload/'</span>+user.img)</span><br><span class="line">           user.img=filename</span><br><span class="line">           user.save()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"> 	<span class="keyword">return</span> Response(&#123;<span class="string">"code"</span>:<span class="number">200</span>,<span class="string">"msg"</span>:<span class="string">"更改成功"</span>,<span class="string">'filename'</span>:filename&#125;)</span><br></pre>

<hr>
<pre class="highlight"><span class="line">上面进行了 更改数据库 删除文件 写入文件</span><br><span class="line"></span><br><span class="line">那么如何进行展示呢？</span><br><span class="line"></span><br><span class="line">写一个get方法 根据用户返回图片名</span><br></pre>

<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">    <span class="comment"># 获取参数</span></span><br><span class="line">    uid=request.GET.get(<span class="string">'uid'</span>,<span class="literal">None</span>)</span><br><span class="line">    user=User.objects.filter(pk=uid).first()</span><br><span class="line">    <span class="keyword">if</span> user.img:</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">"code"</span>:<span class="number">200</span>,<span class="string">'filename'</span>:user.img&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">"code"</span>:<span class="number">200</span>,<span class="string">'filename'</span>:<span class="string">'user.png'</span>&#125;)</span><br></pre>

<hr>
<h5 id="前端进行get请求"><a href="#前端进行get请求" class="headerlink" title="前端进行get请求"></a>前端进行get请求</h5><pre class="highlight"><span class="line">get_avatar() &#123;</span><br><span class="line">    var uid = localStorage.getItem(<span class="string">"uid"</span>);</span><br><span class="line">    this.axios.get(<span class="string">"http://127.0.0.1:8000/myapp/upload/"</span>, &#123;</span><br><span class="line">        params: &#123; <span class="string">'uid'</span>: uid &#125;</span><br><span class="line">    &#125;).then(result =&gt; &#123;</span><br><span class="line">        this.src =<span class="string">"http://127.0.0.1:8000/static/upload/"</span> + result.data.filename;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre>

<pre class="highlight"><span class="line">这里将src 拼接为图片路径之后用img 标签就可以显示了</span><br></pre>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>国际化支持</title>
    <url>/2020/05/08/g_z/</url>
    <content><![CDATA[<h4 id="首先-我们需要一个库：国际化支持模块"><a href="#首先-我们需要一个库：国际化支持模块" class="headerlink" title="首先 我们需要一个库：国际化支持模块"></a>首先 我们需要一个库：国际化支持模块</h4><pre class="highlight"><span class="line">npm install vue-i18n -- save</span><br></pre>

<p>save -&gt; 在当前项目下安装</p>
<h4 id="在您的项目main-js下-导入"><a href="#在您的项目main-js下-导入" class="headerlink" title="在您的项目main.js下 导入"></a>在您的项目main.js下 导入</h4><pre class="highlight"><span class="line">import VueI18n from &#39;vue-i18n&#39;</span><br></pre>

<h4 id="导入成功进行注册使用"><a href="#导入成功进行注册使用" class="headerlink" title="导入成功进行注册使用"></a>导入成功进行注册使用</h4><pre class="highlight"><span class="line">Vue.use(VueI18n)</span><br></pre>

<h4 id="在你的src下创建语言包文件"><a href="#在你的src下创建语言包文件" class="headerlink" title="在你的src下创建语言包文件"></a>在你的src下创建语言包文件</h4><pre class="highlight"><span class="line">文件夹名称  简写成：lang</span><br></pre>

<h4 id="在lang文件夹中创建中文包-zh-js-and英文包-en-js"><a href="#在lang文件夹中创建中文包-zh-js-and英文包-en-js" class="headerlink" title="在lang文件夹中创建中文包(zh.js)and英文包(en.js)"></a>在lang文件夹中创建中文包(zh.js)and英文包(en.js)</h4><pre class="highlight"><span class="line">例如：</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 双语规范的变量（英文）</span><br><span class="line">    export const m &#x3D; &#123;</span><br><span class="line">        &#39;index&#39;:&#39;Mei Duo Shp&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 双语规范的变量（中文）</span><br><span class="line">    export const m &#x3D; &#123;</span><br><span class="line">        &#39;index&#39;:&#39;美多商城&#39;</span><br><span class="line">    &#125;</span><br></pre>

<h4 id="回到main-js-导入语言包"><a href="#回到main-js-导入语言包" class="headerlink" title="回到main.js 导入语言包"></a>回到main.js 导入语言包</h4><pre class="highlight"><span class="line">&#x2F;&#x2F; 导入语言包</span><br><span class="line">const i18n &#x3D; new VueI18n(&#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 当前默认语言的声明</span><br><span class="line">  locale:&#39;zh&#39;,</span><br><span class="line">  messages:&#123;</span><br><span class="line">     		&#x2F;&#x2F; 相对路径</span><br><span class="line">    &#39;zh&#39;:require(&#39;.&#x2F;lang&#x2F;zh&#39;),</span><br><span class="line">    &#39;en&#39;:require(&#39;.&#x2F;lang&#x2F;en&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 引用i18n</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  router,</span><br><span class="line">  i18n, </span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;,</span><br><span class="line">  render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;)</span><br></pre>

<h4 id="最后使用"><a href="#最后使用" class="headerlink" title="最后使用"></a>最后使用</h4><pre class="highlight"><span class="line">&#123;&#123;$t(&#39;m.index&#39;)&#125;&#125;</span><br><span class="line">m:代表规范的变量</span><br><span class="line">index: key的名称  也就是你自己定义的变量</span><br></pre>

<h4 id="在钩子方法中可以自动切换语言"><a href="#在钩子方法中可以自动切换语言" class="headerlink" title="在钩子方法中可以自动切换语言"></a>在钩子方法中可以自动切换语言</h4><p>指在浏览器中，例如默认是中文，我们就切换成中文，也就可以理解成老外访问直接是英文状态。</p>
<pre class="highlight"><span class="line">if(navigator.language &#x3D;&#x3D; &#39;en&#39;)&#123;	</span><br><span class="line">		&#x2F;&#x2F; 切换语言</span><br><span class="line">		this.$i18n.locale &#x3D; &#39;en&#39;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		this.$i18n.locale &#x3D; &#39;zh&#39;</span><br><span class="line">	&#125;</span><br></pre>

<h4 id="添加个按钮切换语言"><a href="#添加个按钮切换语言" class="headerlink" title="添加个按钮切换语言"></a>添加个按钮切换语言</h4><p>首先我们得有个开关标签</p>
<pre class="highlight"><span class="line">&lt;h-switch v-model&#x3D;&quot;lang&quot; @change&#x3D;&quot;lang_change&quot;&gt;中&#x2F;英&lt;&#x2F;h-switch&gt;</span><br></pre>

<p>定义开关变量</p>
<pre class="highlight"><span class="line">data()&#123;</span><br><span class="line">       return&#123;</span><br><span class="line">		&#x2F;&#x2F;定义开关变量</span><br><span class="line">		lang:1  &#x2F;&#x2F; 代表中文</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br></pre>

<p>定义切换时间 change  也就是在你methods方法中</p>
<pre class="highlight"><span class="line">methods:&#123;</span><br><span class="line">	&#x2F;&#x2F; 切换方法</span><br><span class="line">	lang_change:function()&#123;</span><br><span class="line">		console.log(this.lang)</span><br><span class="line">		if(this.lang &#x3D;&#x3D; true)&#123;</span><br><span class="line">			&#x2F;&#x2F; 切换语言</span><br><span class="line">			this.$i18n.locale &#x3D; &#39;zh&#39;</span><br><span class="line">			localStorage.setItem(&#39;lang&#39;,&#39;zh&#39;)</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			this.$i18n.locale &#x3D; &#39;en&#39;</span><br><span class="line">			</span><br><span class="line">			localStorage.setItem(&#39;lang&#39;,&#39;en&#39;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br></pre>

<p>简述逻辑： 首先我们在控制台打印按钮默认为1,0，也就时候判断是true，false。得到之后，我们需要判断如果lang为true 则赋值为中文，则else则是英文，同时我们将lang值存入localstorage中，在钩子函数中判断。首先我们考虑到问题是，用户是否点击按钮切换语言，只要用户发生动作，我们则记录在localstorage中，最终我们判断用户是否点过按钮，如果没有则默认赋值到localstorage里。</p>
<pre class="highlight"><span class="line">&#x2F;&#x2F; 判断本地local有没有</span><br><span class="line">		var lang_locale &#x3D; localStorage.getItem(&quot;lang&quot;)</span><br><span class="line">		if(lang_locale)&#123;</span><br><span class="line">			this.$i18n.locale &#x3D; lang_locale</span><br><span class="line">			if(lang_locale &#x3D;&#x3D; &#39;zh&#39;)&#123;</span><br><span class="line">				this.lang &#x3D; 1</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				this.lang &#x3D; 0</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			this.$i18n.locale &#x3D; &#39;zh&#39;;</span><br><span class="line">			this.lang &#x3D; 1</span><br><span class="line">		&#125;</span><br></pre>

<p>以上代码，我们默认赋值为中文，里层的If是为变量双赋值！</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是Git ?</title>
    <url>/2020/04/20/g_x/</url>
    <content><![CDATA[<p>GIT，全称是分布式版本控制系统，git通常在编程中会用到，并且git支持分布式部署，可以有效、高速的处理从很小到非常大的项目版本管理。分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库。</p>
<h3 id="git命令介绍"><a href="#git命令介绍" class="headerlink" title="git命令介绍"></a>git命令介绍</h3><pre class="highlight"><span class="line">git clone 代码库的url</span><br><span class="line">将线上库克隆到本地</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line">初始化git</span><br><span class="line"></span><br><span class="line">git renote add origin (address) <span class="comment"># 仓库地址</span></span><br><span class="line">添加到远程仓库</span><br><span class="line"></span><br><span class="line">git add -A</span><br><span class="line">将工作区的修改提交到暂存区</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'msg'</span></span><br><span class="line">将暂存区的文件或目录提交到版本库区</span><br><span class="line"></span><br><span class="line">git push origin master</span><br><span class="line">将提交到本地库中的内容推送到远程库中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看日志：git log</span><br><span class="line">回滚（本地）：git reset --hard 版本id  </span><br><span class="line">回滚（服务器）：git push HEAD --force  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git崩溃解决方法</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>):删除项目，全部重做</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span>):删除.git，清空仓库，重新链接库，重新上传文件</span><br></pre>




]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>简述逻辑外键</title>
    <url>/2020/05/11/j_b/</url>
    <content><![CDATA[<h4 id="goods表创建逻辑外键"><a href="#goods表创建逻辑外键" class="headerlink" title="goods表创建逻辑外键"></a>goods表创建逻辑外键</h4><p>前端数据我需要做二次处理，获取表单数据进行二次处理，转成json数据，这样后端接收存入数据库。</p>
<h4 id="之后在添加方法中获取id-向后端发起请求"><a href="#之后在添加方法中获取id-向后端发起请求" class="headerlink" title="之后在添加方法中获取id 向后端发起请求"></a>之后在添加方法中获取id 向后端发起请求</h4><pre class="highlight"><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加商品事件</span><br><span class="line">submit:function()&#123;</span><br><span class="line">    &#x2F;&#x2F; 非空验证</span><br><span class="line">    if (this.name &#x3D;&#x3D; &#39;&#39;)&#123;</span><br><span class="line">        this.$Message(&quot;商品名称不能为空&quot;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        &#x2F;&#x2F; 存入字段为json</span><br><span class="line">        var param &#x3D; &#123;&#125;;</span><br><span class="line">        param[&#39;color&#39;] &#x3D; this.color</span><br><span class="line">        param[&#39;size&#39;] &#x3D; this.size</span><br><span class="line">        param[&#39;season&#39;] &#x3D; this.season</span><br><span class="line">        &#x2F;&#x2F;转为json数据</span><br><span class="line">        param&#x3D;JSON.stringify(param)</span><br><span class="line">        &#x2F;&#x2F; 接收表单数据</span><br><span class="line">        var pc &#x3D; this.$refs.upload</span><br><span class="line">        let file &#x3D; pc.files[0]</span><br><span class="line">        var data &#x3D; new FormData()</span><br><span class="line">        data.append(&#39;img&#39;,file)</span><br><span class="line">        data.append(&#39;flows&#39;,this.flows)</span><br><span class="line">        &#x2F;&#x2F; 反向赋值</span><br><span class="line">        data.append(&#39;cid&#39;,this.cate[this.selected])</span><br><span class="line">        &#x2F;&#x2F; 声明请求头</span><br><span class="line">        let config&#x3D;&#123;</span><br><span class="line">            &#39;Content-Type&#39;:&#39;multipart&#x2F;form-data&#39;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 发起请求</span><br><span class="line">        this.axios.post(&#39;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;addgoods&#x2F;&#39;,data,config).then((res&#x3D;&gt;&#123;</span><br><span class="line">            console.log(res)</span><br><span class="line">            this.$Message(res.data.msg)</span><br><span class="line">        &#125;))</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>

<p>把json数据存入规格字段中，cid存入外键的cid</p>
<p>之后，我们展示分类</p>
<pre class="highlight"><span class="line">// 定义规格名称</span><br><span class="line">color:<span class="string">''</span>,</span><br><span class="line">       size:<span class="string">''</span>,</span><br><span class="line">       season:<span class="string">''</span>,</span><br><span class="line">       // 分类表默认选中</span><br><span class="line">       selected:<span class="string">'衣服'</span>,</span><br><span class="line">       cate:[]，</span><br><span class="line">       // 接受商品分类</span><br><span class="line">       category:[]</span><br><span class="line">       </span><br><span class="line">       // 创建方法</span><br><span class="line">       	</span><br><span class="line">       // 获取商品分类</span><br><span class="line">       get_cate:function()&#123;</span><br><span class="line">           //发送请求</span><br><span class="line">           this.axios.get('http://127.0.0.1:8000/cate/').then((res=&gt;&#123;</span><br><span class="line">               console.log(res)</span><br><span class="line">               // 二次处理数据</span><br><span class="line">               var mycate=[]</span><br><span class="line">               <span class="keyword">for</span>(let i=<span class="number">0</span>;i&lt;res.data.length;i++)&#123;</span><br><span class="line">                   mycate.push(res.data[i][<span class="string">'name'</span>])</span><br><span class="line">                   // 反向赋值 将分类表的id存入goods表中</span><br><span class="line">                   this.cate[res.data[i][<span class="string">'name'</span>]] = res.data[i][<span class="string">'id'</span>];</span><br><span class="line">               &#125;</span><br><span class="line">               // 赋值</span><br><span class="line">               this.category = mycate</span><br><span class="line">           &#125;))</span><br><span class="line">       &#125;,</span><br></pre>

]]></content>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Hexo创建博客</title>
    <url>/2020/04/21/h_o/</url>
    <content><![CDATA[<h3 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo ?"></a>什么是Hexo ?</h3><p>Hexo 是一个快速、简洁且高效的博客框架。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre class="highlight"><span class="line"><span class="number">1</span>：安装hexo，在安装之前，需要安装的程序如下：</span><br><span class="line">    a): Node.js</span><br><span class="line">    b): Git</span><br><span class="line"><span class="number">2</span>: 安装hexo，打开终端，输入安装hexo命令：</span><br><span class="line">    npm install -g hexo-cli</span><br></pre>

<h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><pre class="highlight"><span class="line"><span class="number">1</span>：安装Hexo之后，执行命令，Hexo会在指定文件夹中创建博客框架</span><br><span class="line">    hexo init &lt;blog&gt;</span><br><span class="line">    cd &lt;blog&gt;</span><br><span class="line"><span class="number">2</span>：新建完成后，目录如下：</span><br><span class="line">    _config.yml -&gt; 网站的 配置 信息，您可以在此配置大部分的参数。</span><br><span class="line">    package.json -&gt; 应用程序的信息。</span><br><span class="line">    scaffolds -&gt; 模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</span><br><span class="line">    source -&gt; 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</span><br><span class="line">    themes -&gt; 主题文件夹。Hexo 会根据主题来生成静态页面。</span><br><span class="line"><span class="number">3</span>：启动服务器</span><br><span class="line"></span><br><span class="line">    hexo server <span class="comment">#即可浏览博客</span></span><br></pre>

<h3 id="部署到git"><a href="#部署到git" class="headerlink" title="部署到git"></a>部署到git</h3><pre class="highlight"><span class="line"><span class="number">1</span>：安装 hexo-deployer-git</span><br><span class="line"></span><br><span class="line">    npm install hexo-deployer-git --save</span><br></pre>



<h3 id="修改hexo配置-config"><a href="#修改hexo配置-config" class="headerlink" title="修改hexo配置 # _config"></a>修改hexo配置 # _config</h3><pre class="highlight"><span class="line"></span><br><span class="line">url: https:&#x2F;&#x2F;lu_hao_nan.gitee.io</span><br><span class="line">root: &#x2F;</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: https:&#x2F;&#x2F;lu_hao_nan.gitee.io  # 库（Repository）地址</span><br><span class="line">    branch: master # 	分支名称</span><br></pre>



<h3 id="打包成public"><a href="#打包成public" class="headerlink" title="打包成public"></a>打包成public</h3><pre class="highlight"><span class="line"></span><br><span class="line">hexo -clean</span><br><span class="line">hexo -d <span class="comment"># 开始部署</span></span><br><span class="line">hexo -g <span class="comment"># 生成新的public文件</span></span><br><span class="line"></span><br><span class="line">之后打包public远程推送到git上就点击服务gitee pages就可以启动啦！</span><br></pre>

]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>安慰剂进度条</title>
    <url>/2020/05/07/j_t/</url>
    <content><![CDATA[<pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &#x2F;&#x2F; 因为我们只有两种情况 所以使用v-show v-show默认是0  也可用v-if</span><br><span class="line">    &lt;Progress v-show&#x3D;&quot;load_int&quot; :percent&#x3D;&quot;load_int&quot; color&#x3D;&#39;green&#39;&gt;&lt;&#x2F;Progress&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">	data()&#123;</span><br><span class="line">		return&#123;</span><br><span class="line">			&#x2F;&#x2F; 定义变量</span><br><span class="line">			load_percnet&#x3D;&#39;&#39;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	methods:&#123;</span><br><span class="line">		&#x2F;&#x2F;在某方法下写入</span><br><span class="line">		</span><br><span class="line">            &#x2F;&#x2F; 上传过程中的方法</span><br><span class="line">            onUploadProgress:(e)&#x3D;&gt;&#123;</span><br><span class="line">              &#x2F;&#x2F; 计算上传百分比</span><br><span class="line">              var complete &#x3D; (e.loaded &#x2F; e.total)</span><br><span class="line">              &#x2F;&#x2F; 处理美化</span><br><span class="line">              if(complete &lt; 1)&#123;</span><br><span class="line">               &#x2F;&#x2F; %代表转换字符串</span><br><span class="line">                this.load_percent &#x3D; (complete * 100).toFixed(2) + &#39;%&#39;，</span><br><span class="line">                this.load_int &#x3D; parseInt((complete * 100).toFixed(2))</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">          &#x2F;&#x2F; 成功之后</span><br><span class="line">          </span><br><span class="line">          &#x2F;&#x2F; 直接赋值成百分之百</span><br><span class="line">          this.load_percent &#x3D; &#39;100%&#39;</span><br><span class="line">          &#x2F;&#x2F; 整形赋值</span><br><span class="line">          this.load_int &#x3D; 100;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre>

]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>gitee 分支 命令大全</title>
    <url>/2019/10/14/gitee%20%E5%88%86%E6%94%AF%20%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p>在安装好 gitee 之后。我们会有新的一些业务需求。<br>场景：L在公司中再使用 gitee 上传自己的代码，一天上传一次~那其他人的代码怎么办、岂不是乱套了。那全部写完之后再上传，可是项目进度又要每天核实。<br>这个时候就体会到了分支的作用：</p>
<h3 id="分支管理创建"><a href="#分支管理创建" class="headerlink" title="分支管理创建"></a>分支管理创建</h3><p>简易的命令行入门教程:<br>Git 全局设置:</p>
<pre class="highlight"><span class="line">git config --global user.name &quot;****&quot;</span><br><span class="line">git config --global user.email &quot;*******&quot;</span><br></pre>

<h3 id="创建-git-仓库"><a href="#创建-git-仓库" class="headerlink" title="创建 git 仓库:"></a>创建 git 仓库:</h3><pre class="highlight"><span class="line">mkdir djang</span><br><span class="line">cd djang</span><br><span class="line">git init</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin git@地址</span><br></pre>

<h3 id="已有仓库"><a href="#已有仓库" class="headerlink" title="已有仓库?"></a>已有仓库?</h3><pre class="highlight"><span class="line">cd existing_git_repo</span><br><span class="line">git remote add origin git@gitee.com:H_sen&#x2F;djang.git</span><br><span class="line">git push -u origin master</span><br></pre>

<pre class="highlight"><span class="line"># 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下</span><br><span class="line"></span><br><span class="line">git clone &lt;远程仓库的网址&gt;</span><br><span class="line"></span><br><span class="line"># 指定本地仓库的目录</span><br><span class="line"></span><br><span class="line">git clone &lt;远程仓库的网址&gt; &lt;本地目录&gt;</span><br><span class="line"></span><br><span class="line"># -b 指定要克隆的分支，默认是master分支</span><br><span class="line"></span><br><span class="line">git clone &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt;</span><br></pre>
<pre class="highlight"><span class="line"></span><br><span class="line"># 新建分支 并转移到此位置</span><br><span class="line">git checkout -b NewBranch</span><br><span class="line"></span><br><span class="line"># 查看所有分支</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"># 切换分支 切换到 master</span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line"># 删除本地分支 NewBranch</span><br><span class="line">git branch -D NewBranch</span><br></pre>


<h3 id="场景：假设我们现在创建分支-NewBranch-已经成功，如果需要对此传入代码。"><a href="#场景：假设我们现在创建分支-NewBranch-已经成功，如果需要对此传入代码。" class="headerlink" title="场景：假设我们现在创建分支 NewBranch 已经成功，如果需要对此传入代码。"></a>场景：假设我们现在创建分支 NewBranch 已经成功，如果需要对此传入代码。</h3><pre class="highlight"><span class="line">git add -A (或文件名)</span><br><span class="line">git commit -m &quot;new branch&quot;</span><br><span class="line">git push origin NewBrLanch   # 将代码上传到分支</span><br></pre>

<p>场景：假设项目全部完毕，有多个分支~我们需要将他们合并</p>
<h3 id="合并分支到主分支"><a href="#合并分支到主分支" class="headerlink" title="合并分支到主分支"></a>合并分支到主分支</h3><pre class="highlight"><span class="line"># 回到主分支 master</span><br><span class="line">git checkout master</span><br><span class="line"># 将主分支数据拉到本地</span><br><span class="line">git pull</span><br><span class="line"># 强行合并 (可能会出错， master很有可能也更新)</span><br><span class="line">git merge NewBranch</span><br><span class="line"></span><br><span class="line"># 假设说上面的 和合并出现问题 那就手动合并</span><br><span class="line">vim Readme   # 手动合并标识文件</span><br><span class="line">git add -A</span><br><span class="line">git push origin master    # 合并之后 就可以提交到 master 了</span><br><span class="line"></span><br><span class="line"># 查看从什么地方出现的分支</span><br><span class="line">git log -graph</span><br></pre>
<p>现在都可以理解 为什么要用分支了。<br>而且再公司中 分支也是有规定的，如 master 不可以轻易的上传啦，要用 dev 开发的分支进行项目开发，而每个组还要有 pyTeam 分支，知道组中的我 H_sen 分支。只有等测试排除所有的问题后才会发布到 master 分支。<br>那么会不会有 BUG 分支呢？ 有！！！</p>
<h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>场景：假设说所有的拦截手段还是没有挡住 BUG 上传到 master (没错，你写的)，而你这个时候正在开发别的模块。怎么办呢？</p>
<ol>
<li>停下手头的工作，</li>
<li>切换 master 分支去解决 master 上的 bug<br>这样会很麻烦</li>
</ol>
<h3 id="git-stash-脱颖而出"><a href="#git-stash-脱颖而出" class="headerlink" title="git stash 脱颖而出"></a>git stash 脱颖而出</h3><p>如何使用：</p>
<ol>
<li><p>找到 bug</p>
<pre class="highlight"><span class="line"># 突然出现的 bug</span><br><span class="line">vim Readme </span><br><span class="line"># 将 dev 中未保存的代码存放到临时区</span><br><span class="line">git stash    # 这样做完全的避免了 将 代码带入到 Bug 分支</span><br></pre></li>
<li><p>修复 bug</p>
<pre class="highlight"><span class="line"># 切换到 bug 分支</span><br><span class="line">git checkout -b bug-100</span><br><span class="line"># 切换后 修复 bug</span><br><span class="line">vim Readme</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &quot;修复 bug&quot;  # 提交到工作区</span><br></pre>
</li>
<li><p>将修复后的 bug 和 master 合并</p>
<pre class="highlight"><span class="line"># 切换到 master</span><br><span class="line">git checkout master</span><br><span class="line"># 强行合并</span><br><span class="line">git merge bug-100</span><br><span class="line"># 推送 到主分支</span><br><span class="line">git origin master</span><br></pre>

</li>
</ol>
<p>bug 排完了。之前的文件怎么恢复状态?</p>
<ol>
<li>找回之前的 dev 分支，并恢复 状态</li>
</ol>
<pre class="highlight"><span class="line"># 切换回开发的分支</span><br><span class="line">git checkout dev</span><br><span class="line"># 查看状态</span><br><span class="line">git status</span><br><span class="line">more Readme    # 发现之前工作区 未提交的数据都消失了</span><br><span class="line">git stash list    # 查看之前使用 git stash 保存的数据</span><br><span class="line">git stash apply    # 恢复之前的文件</span><br><span class="line"># 查看状态</span><br><span class="line">git status    # 此时就可以看到排bug 之前的完美状态了</span><br></pre>

<h4 id="git-stash-其他操作"><a href="#git-stash-其他操作" class="headerlink" title="git stash 其他操作"></a>git stash 其他操作</h4><pre class="highlight"><span class="line">git stash drop  # 删除最久的那个 使用 git stash 临时保持状态</span><br><span class="line">git stash apply stash&#123;&#123;0&#125;&#125;  # 指定恢复到那个临时状态</span><br><span class="line">git stash pop    # 恢复并删除上一个临时状态</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">注意！！！ git stash aplpy恢复后 stash的内容并不删除，需要 git stash drop 才能删除</span><br><span class="line">git stash pop 就简单许多 恢复的时候直接删除</span><br><span class="line">&#39;&#39;&#39;</span><br></pre>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动验证码</title>
    <url>/2020/04/27/h_g/</url>
    <content><![CDATA[<h4 id="在template中"><a href="#在template中" class="headerlink" title="在template中"></a>在template中</h4><pre class="highlight"><span class="line">&lt;drag-verify :width=<span class="string">"width"</span></span><br><span class="line">             :height=<span class="string">"height"</span></span><br><span class="line">             :text=<span class="string">"text"</span></span><br><span class="line">             ref=<span class="string">"Verify"</span>&gt;</span><br><span class="line">&lt;/drag-verify&gt;</span><br></pre>

<h4 id="在script设置属性–-gt-npm-install-vue-drag-verify-–save"><a href="#在script设置属性–-gt-npm-install-vue-drag-verify-–save" class="headerlink" title="在script设置属性–&gt; (npm install vue-drag-verify –save)"></a>在script设置属性–&gt; (npm install vue-drag-verify –save)</h4><pre class="highlight"><span class="line">&#x2F;&#x2F; 导包</span><br><span class="line">import dragVerify from &#39;vue-drag-verify&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      &#x2F;&#x2F; 在data里面设置滑动的属性</span><br><span class="line">      width: 320,</span><br><span class="line">      height: 42,</span><br><span class="line">      text: &#39;请将滑块拖到最右侧&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;，</span><br><span class="line">  &#x2F;&#x2F; 注册标签</span><br><span class="line">  components: &#123;</span><br><span class="line">    &#39;dragVerify&#39;: dragVerify</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F;检验是否拖动</span><br><span class="line">  methods：&#123;</span><br><span class="line">      &#x2F;&#x2F;滑块是否拖动false为未拖动至最右侧反之为true</span><br><span class="line">			if(this.$refs.Verify.isPassing &#x3D;&#x3D; false)&#123;</span><br><span class="line">				this.$Notice(&#39;请拖动滑块&#39;)</span><br><span class="line">			&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre>



<h4 id="使用selnium破解滑块"><a href="#使用selnium破解滑块" class="headerlink" title="使用selnium破解滑块"></a>使用selnium破解滑块</h4><pre class="highlight"><span class="line">from selenium import webdriverfrom selenium.webdriver import ChromeOptionsfrom selenium.webdriver import ActionChainsoption &#x3D; ChromeOptions()  # 实例化一个ChromeOptions对象option.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-automation&#39;])  # 以键值对的形式加入参数browser &#x3D; webdriver.Chrome(options&#x3D;option)#发起请求browser.get(&#39;http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;login)#定位滑块button &#x3D; browser.find_element_by_class_name(&quot;dv_handler&quot;)action &#x3D; ActionChains(browser)#获取小球长度mybutton &#x3D; button.size.get(&#39;width&#39;)#获取滑块轨道总长mytext &#x3D; browser.find_element_by_class_name(&#39;dv_text&#39;).size.get(&#39;width&#39;)#按住拖动action.click_and_hold(button).perform()#拖动位置action.move_by_offset(int(mytext)-int(mybutton),0).perform()</span><br></pre>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>账号锁定功能</title>
    <url>/2020/04/29/l_k/</url>
    <content><![CDATA[<h4 id="利用redis数据库实现账户锁定"><a href="#利用redis数据库实现账户锁定" class="headerlink" title="利用redis数据库实现账户锁定"></a>利用redis数据库实现账户锁定</h4><ul>
<li>需求 –&gt;  用户输入密码错误，连续错误三次以上，封锁账号在设定时间内不能再登录，直至封锁时间结束后用户才能再登录。 </li>
<li>首先我们用到redis中的 lpush – expire – ttl – llen 其方法</li>
</ul>
<pre class="highlight"><span class="line"></span><br><span class="line"><span class="comment"># 建立连接连接</span></span><br><span class="line">host = <span class="string">"localhost"</span></span><br><span class="line">port = <span class="number">6379</span></span><br><span class="line">r = redis.Redis(host=host,port=port)</span><br><span class="line"><span class="comment">#用户名</span></span><br><span class="line">username = <span class="string">'123'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#账号密码输入错误5次后锁住账号逻辑</span></span><br><span class="line"><span class="comment">#列表操作</span></span><br><span class="line">r.lpush(username,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置过期时间,单位是秒</span></span><br><span class="line">r.expire(username,<span class="number">30</span>)</span><br><span class="line"><span class="comment">#打印过期时间</span></span><br><span class="line">print(r.ttl(username))</span><br><span class="line"><span class="comment">#打印列表长度</span></span><br><span class="line">print(r.llen(username))</span><br><span class="line"><span class="keyword">if</span> r.llen(username) &gt; <span class="number">3</span>:</span><br><span class="line">    print(<span class="string">'你的账号被锁定'</span>)</span><br></pre>

<h4 id="以下是在项目中实现锁定功能"><a href="#以下是在项目中实现锁定功能" class="headerlink" title="以下是在项目中实现锁定功能"></a>以下是在项目中实现锁定功能</h4><pre class="highlight"><span class="line"><span class="comment">#登录接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#接收参数</span></span><br><span class="line">        username = request.GET.get(<span class="string">'username'</span>,<span class="literal">None</span>)</span><br><span class="line">        password = request.GET.get(<span class="string">'password'</span>,<span class="literal">None</span>)</span><br><span class="line">        <span class="comment">#验证验证码</span></span><br><span class="line">        <span class="keyword">if</span> code != redis_code:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>:<span class="number">403</span>,<span class="string">'message'</span>:<span class="string">'验证码错误'</span>&#125;)</span><br><span class="line">        <span class="comment">#如果用户的列表长度大于等于3</span></span><br><span class="line">        <span class="keyword">if</span> r.llen(username) &gt;= <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>:<span class="number">403</span>,<span class="string">'message'</span>:<span class="string">'你的账号已被锁定'</span>&#125;)</span><br><span class="line">        <span class="comment">#查询用户数据</span></span><br><span class="line">        user = User.objects.filter(username=username).first()</span><br><span class="line">        <span class="keyword">if</span> user:</span><br><span class="line">            <span class="comment">#比较密码是否一致，如果一致则登录成功</span></span><br><span class="line">            <span class="keyword">if</span> user.password == make_password(password):</span><br><span class="line">                <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>:<span class="number">200</span>,<span class="string">'message'</span>:<span class="string">'登陆成功'</span>,<span class="string">'uid'</span>:user.id,<span class="string">'username'</span>:user.username&#125;)</span><br><span class="line">            <span class="comment">#不一致则计数加1，返回密码错误</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r.lpush(username,<span class="number">1</span>)</span><br><span class="line">                r.expire(username,<span class="number">30</span>)</span><br><span class="line">                <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>:<span class="number">403</span>,<span class="string">'message'</span>:<span class="string">'用户名或密码错误'</span>&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>:<span class="number">403</span>,<span class="string">'message'</span>:<span class="string">'用户名或密码错误'</span>&#125;)</span><br></pre>

]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>json的转换</title>
    <url>/2018/12/18/json%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="在vue中-我们需要将数据转成json格式和将json格式转成字符串"><a href="#在vue中-我们需要将数据转成json格式和将json格式转成字符串" class="headerlink" title="在vue中,我们需要将数据转成json格式和将json格式转成字符串"></a>在vue中,我们需要将数据转成json格式和将json格式转成字符串</h4><pre class="highlight"><span class="line">改为json格式：JSON.stringify()</span><br><span class="line">将json格式转为字典格式：JSON.parse()</span><br></pre>

<hr>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    商品名称：</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;input type=<span class="string">"text"</span> v-model=<span class="string">"name"</span> placeholder=<span class="string">"请输入商品名称"</span>&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    商品价格：</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;input type=<span class="string">"number"</span> v-model=<span class="string">"price"</span> placeholder=<span class="string">"请输入商品价格"</span>&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    商品颜色：</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;input type=<span class="string">"text"</span> v-model=<span class="string">"color"</span> placeholder=<span class="string">"请输入商品颜色"</span>&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    商品尺寸：</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;input type=<span class="string">"text"</span> v-model=<span class="string">"size"</span> placeholder=<span class="string">"请输入商品尺寸"</span>&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    商品季节：</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;input type=<span class="string">"text"</span> v-model=<span class="string">"season"</span> placeholder=<span class="string">"请输入商品季节"</span>&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt; </span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;Button color="blue" @click="submit"&gt;添加商品&lt;/Button&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;      </span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;  </span><br><span class="line">      name:<span class="string">""</span>,//商品名</span><br><span class="line">      price:<span class="number">0</span>,//商品价格</span><br><span class="line">      color:<span class="string">""</span>,//商品颜色</span><br><span class="line">      size:<span class="string">""</span>,//商品尺寸</span><br><span class="line">      season:<span class="string">""</span>,//商品季节</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">      //进行添加商品</span><br><span class="line">      submit()&#123;</span><br><span class="line">          //将季节，颜色规格等字段转换为json</span><br><span class="line">          var param = &#123;&#125;;</span><br><span class="line">          param[<span class="string">'color'</span>] = this.color;</span><br><span class="line">          param[<span class="string">'size'</span>] = this.size;</span><br><span class="line">          param[<span class="string">'season'</span>] = this.season;</span><br><span class="line">          console.log(param);         //&#123;color: <span class="string">"green"</span>, size: <span class="string">"xxl"</span>, season: <span class="string">"夏季"</span>&#125;</span><br><span class="line">          //将字段转换为json类型      JSON.stringify</span><br><span class="line">          param = JSON.stringify(param)</span><br><span class="line">          console.log(param)          //&#123;<span class="string">"color"</span>:<span class="string">"green"</span>,<span class="string">"size"</span>:<span class="string">"xxl"</span>,<span class="string">"season"</span>:<span class="string">"夏季"</span>&#125;</span><br><span class="line">          //将json类型转为字符串      JSON.parse</span><br><span class="line">          // param = JSON.parse(param)</span><br><span class="line">          // console.log(param)          //&#123;color: <span class="string">"gray"</span>, size: <span class="string">"xxl"</span>, season: <span class="string">"秋季"</span>&#125;</span><br><span class="line">          this.axios(&#123;</span><br><span class="line">              url: <span class="string">"http://localhost:8000/insertgoods/"</span>,</span><br><span class="line">              method: <span class="string">'GET'</span>,</span><br><span class="line">              params:&#123;</span><br><span class="line">                  name:this.name,</span><br><span class="line">                  price:this.price,</span><br><span class="line">                  params:param,</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;).then(resp =&gt; &#123;</span><br><span class="line">              console.log(resp)</span><br><span class="line">              this.$Message(resp.data.message)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件操作</title>
    <url>/2020/07/14/l_n/</url>
    <content><![CDATA[<h2 id="Linux文件操作（看大小，tail-f-n-grep-head-cut-wc-sort）"><a href="#Linux文件操作（看大小，tail-f-n-grep-head-cut-wc-sort）" class="headerlink" title="Linux文件操作（看大小，tail -f -n grep head cut wc sort）"></a>Linux文件操作（看大小，tail -f -n grep head cut wc sort）</h2><p>命令head默认是查看文件的前10行，通过命令head /etc/passwd查看文件的前10行，也可以增加参数-n 15查看前15行，参数n在这里是指定行数的意思。我们可以通过命令man head查看更多的参数使用方法。</p>
<p>命令tail默认是查看文件的最后10行，通过命令tail /etc/passwd查看文件的最后10行，也可以增加参数-n 5查看最后5行，参数n在这里是指定行数的意思。我们可以通过man tail查看更多的参数使用方法。命令tail经常被用来查看最新的日志信息。可以用tailf命令或者tail –f来实时查看日志信息。</p>
<p>命令grep用来过滤信息，通过命令cat /etc/passwd | grep thomas从passwd文件中快速找到还有thomas信息的内容。通过命令cat /etc/passwd | grep –n tcpdump从passwd文件中快速找到tcpdump信息的内容并显示出行号，参数-v是取反，如上面2个例子找的信息里面不包括thomas和tcpdump的信息，我们通过man grep可以学习更多的参数使用方法。</p>
<p>命令cut可以只显示某一列的内容，如果我们只想看某个文件的第一列的话可以用cut –d: -f1 /etc/passwd,参数f1在这里的意思是第一列，我们可以通过man cut来查看更多的参数使用方法。</p>
<p>命令wc是用来统计字符数的，为文件信息的搜集提供帮助，如我们想知道根目录下有多少个目录，直接可以用ls / | wc –l直接计算出根目录下有多少行数，在目录和文件数特别多的时候非常好用。如我们用ls –R /etc | wc –l来查看/etc目录和文件数行数是多少，其中参数R是递归查找，意思是可以查到目录下面的文件。通过man wc查看更多的参数使用方法。</p>
<p>命令sort是用来排序的，我们用命令sort –n 参数n是以数字排列顺序，参数t是以什么为分隔符，参数k是选择第几列，通过命令sort –n –t: -k3 /etc/passwd来对/etc/目录下passwd文件已冒号为分界符第3列用数字排序。我们通过man sort可以查看更多的参数使用方法。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>微博的第三方登陆</title>
    <url>/2020/04/28/l_o/</url>
    <content><![CDATA[<h4 id="申请新浪微博应用流程"><a href="#申请新浪微博应用流程" class="headerlink" title="申请新浪微博应用流程"></a>申请新浪微博应用流程</h4><pre class="highlight"><span class="line">创建微博账号 --&gt; 完善开发者信息 --&gt; 点击应用 --&gt; 如果没有应用我们 点击微连接 --&gt;网站接入 --&gt; 点击立即接入 --&gt; 创建就OK</span><br><span class="line"></span><br><span class="line">创建完成后 -- 点击应用信息</span><br><span class="line"></span><br><span class="line"> <span class="number">1</span>  App Key：<span class="number">4216464481</span> -- appID</span><br><span class="line">    App Secret：a58f0f7f68a0c78fecbb150c163035c9 -- app秘钥</span><br><span class="line"> <span class="number">2</span> 高级信息 -- 自定义回调页</span><br><span class="line"> <span class="number">3</span> 测试信息 -- 加入测试账号</span><br></pre>



<h4 id="第三方登陆流程图"><a href="#第三方登陆流程图" class="headerlink" title="第三方登陆流程图"></a>第三方登陆流程图</h4><pre class="highlight"><span class="line">login (登陆页面)--&gt;新浪微博拼接跳转地址--&gt;新浪微博登陆--&gt;1:如果登陆不成功，则需找回密码 2:如果成功</span><br><span class="line">2 --&gt; 成功之后，回调到django系统 返回code --&gt; 后端接收code，利用code和新浪微博交换token,token带表获取新浪微博的名称 -----&gt;&gt;&gt; 以下 有两种情况</span><br><span class="line">						</span><br><span class="line">			1：曾经登陆过--&gt; 我们直接帮助用户登陆</span><br><span class="line">			<span class="number">2</span>：如果没有登陆过，我直接存入到user库中</span><br><span class="line">			</span><br><span class="line">			   最后共同目标将账号返回给前端</span><br></pre>



<h4 id="创建-click点击事件"><a href="#创建-click点击事件" class="headerlink" title="创建@click点击事件"></a>创建@click点击事件</h4><pre class="highlight"><span class="line"></span><br><span class="line">// 新浪微博</span><br><span class="line">xinliang:function()&#123;</span><br><span class="line"></span><br><span class="line">	//拼接url</span><br><span class="line"> 		let clinet_id = <span class="number">4216464481</span>;</span><br><span class="line"></span><br><span class="line"> 		let url = <span class="string">"https://api.weibo.com/oauth2/authorize?client_id=4216464481&amp;redirect_uri=http://127.0.0.1:8000/md_admin_weibo"</span>;</span><br><span class="line"></span><br><span class="line"> 		//跳转</span><br><span class="line">	  window.location.href = url;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre>



<h4 id="将urls路由中配置回调参数"><a href="#将urls路由中配置回调参数" class="headerlink" title="将urls路由中配置回调参数"></a>将urls路由中配置回调参数</h4><pre class="highlight"><span class="line">path(<span class="string">'md_admin_weibo/'</span>,wb_back),</span><br></pre>



<h4 id="获取code值"><a href="#获取code值" class="headerlink" title="获取code值"></a>获取code值</h4><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wb_back</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># 接收参数</span></span><br><span class="line">    code = request.GET.get(<span class="string">'code'</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义token接口地址</span></span><br><span class="line">    url = <span class="string">"https://api.weibo.com/oauth2/access_token"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义参数</span></span><br><span class="line">    re = requests.post(url, data=&#123;</span><br><span class="line">        <span class="string">"client_id"</span>: <span class="string">"4216464481"</span>,</span><br><span class="line">        <span class="string">"client_secret"</span>: <span class="string">"a58f0f7f68a0c78fecbb150c163035c9"</span>,</span><br><span class="line">        <span class="string">"grant_type"</span>: <span class="string">"authorization_code"</span>, <span class="comment"># 写死</span></span><br><span class="line">        <span class="string">"code"</span>: code,</span><br><span class="line">        <span class="comment"># 回调的地址</span></span><br><span class="line">        <span class="string">"redirect_uri"</span>: <span class="string">"http://127.0.0.1:8000/md_admin_weibo"</span></span><br><span class="line">    &#125;)</span><br></pre>

<h5 id="post-请求-是将access-token值-取出来，-还有你的微博user-id"><a href="#post-请求-是将access-token值-取出来，-还有你的微博user-id" class="headerlink" title="post 请求 是将access_token值 取出来， 还有你的微博user_id"></a>post 请求 是将access_token值 取出来， 还有你的微博user_id</h5><h4 id="之后换取新浪微博用户昵称"><a href="#之后换取新浪微博用户昵称" class="headerlink" title="之后换取新浪微博用户昵称"></a>之后换取新浪微博用户昵称</h4><pre class="highlight"><span class="line">res = requests.get(<span class="string">'https://api.weibo.com/users/show.json'</span>,params=&#123;<span class="string">'access_token'</span>:re.json()[<span class="string">'access_token'</span>],<span class="string">'uid'</span>:re.json()[<span class="string">'uid'</span>]&#125;)</span><br><span class="line"></span><br><span class="line">    sina_id = <span class="string">''</span>  <span class="comment"># 1009_nan</span></span><br><span class="line">    user_id = <span class="string">''</span>  <span class="comment"># 10</span></span><br><span class="line">    <span class="comment"># 判断是否用新浪微博登陆过</span></span><br><span class="line">    user = User.objects.filter(username=str(res.json()[<span class="string">'name'</span>])).first()</span><br><span class="line">    <span class="keyword">if</span> user:</span><br><span class="line">        <span class="comment"># 代表曾经用账号登陆过</span></span><br><span class="line">        sina_id = user.username</span><br><span class="line">        user_id = user.id</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 首次登陆，入库新浪微博账号</span></span><br><span class="line">        user = User(username=str(res.json()[<span class="string">'name'</span>]),password=<span class="string">''</span>)</span><br><span class="line">        user.save()</span><br><span class="line">        user = User.objects.filter(username=str(res.json()[<span class="string">'name'</span>])).first()</span><br><span class="line">    <span class="comment"># 重定向到主页面</span></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">"http://localhost:8080?sina_id="</span>+str(sina_id)+<span class="string">"&amp;uid="</span>+str(user_id))</span><br></pre>



<h4 id="返回前端-接收第三方参数"><a href="#返回前端-接收第三方参数" class="headerlink" title="返回前端 接收第三方参数"></a>返回前端 接收第三方参数</h4><pre class="highlight"><span class="line">var sina_id = this.$route.query.sina_id  // weibo名称</span><br><span class="line">var user_id = this.$route.query.uid   // userid</span><br><span class="line"><span class="keyword">if</span> (sina_id)&#123;</span><br><span class="line">	//自动帮用户进行登录操作</span><br><span class="line">	// 存入localStorage 取则用localStorage.getItem()</span><br><span class="line">	localStorage.setItem(<span class="string">"username"</span>,sina_id)</span><br><span class="line">	localStorage.setItem(<span class="string">"uid"</span>,user_id)</span><br><span class="line">	this.username = sina_id</span><br><span class="line">&#125;</span><br></pre>





]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>拦截器</title>
    <url>/2020/05/01/ljq/</url>
    <content><![CDATA[<pre class="highlight"><span class="line">beforeEnter:(to,from,next) =&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span> (localStorage.getItem(<span class="string">"username"</span>))&#123;</span><br><span class="line">    console.log(<span class="string">'已经登陆'</span>)</span><br><span class="line">    next();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  console.log(<span class="string">'没有登陆'</span>)</span><br><span class="line">  next(<span class="string">'/login'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre>

]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>jwt认证</title>
    <url>/2020/05/07/jwt/</url>
    <content><![CDATA[<h4 id="JWT认证"><a href="#JWT认证" class="headerlink" title="JWT认证"></a>JWT认证</h4><p> <code>Json web token (JWT)</code>, 根据官网的定义，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密 </p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>发送请求用户信息   —&gt;   axios(uid)(同时获取令牌)   —&gt;   获取uid查询数据库以Json的形式返回给前端（验证token成功返回）   —&gt;   发送请求用户信息（如果错误返回没有权限）(正确返回用户信息)</p>
<h4 id="token的构成"><a href="#token的构成" class="headerlink" title="token的构成"></a>token的构成</h4><ol>
<li>头部信息.载荷(playload) –&gt; uid或username</li>
<li>密钥</li>
<li>jwt=&gt;token</li>
</ol>
<h4 id="jwt安装"><a href="#jwt安装" class="headerlink" title="jwt安装"></a>jwt安装</h4><pre class="highlight"><span class="line">pip install pyjwt</span><br></pre>

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>体积小,传输快</p>
</li>
<li><p>支持跨域验证</p>
</li>
<li><p>基本认证的一个优点是基本上所有流行的网页浏览器都支持基本认证。 </p>
</li>
</ul>
<h4 id="在用户登陆成功生成token"><a href="#在用户登陆成功生成token" class="headerlink" title="在用户登陆成功生成token"></a>在用户登陆成功生成token</h4><pre class="highlight"><span class="line">encode_jwt = jwt.encode(&#123;<span class="string">'uid'</span>: user.id&#125;, <span class="string">'qwe123'</span>, algorithm=<span class="string">'HS256'</span>)</span><br><span class="line">encode_str = str(encode_jwt, <span class="string">'utf-8'</span>)</span><br></pre>

<p> 将这个token交给前端，前端访问任意接口都将在header里带着jwt也就指token，用来做认证，我们把代码逻辑写成装饰器，这样前端访问那个接口，后端直接调用装饰器！</p>
<h4 id="定义装饰器"><a href="#定义装饰器" class="headerlink" title="定义装饰器"></a>定义装饰器</h4><p>因为在每次登陆时，我们将jwt的值存入localstorage中，所以我们在前端param传参将其读出，这样后端接收jwt 。</p>
<pre class="highlight"><span class="line"><span class="comment"># 类视图专用</span></span><br><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义权限检测装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 接收参数</span></span><br><span class="line">        uid = request.GET.get(<span class="string">"uid"</span>, <span class="literal">None</span>)</span><br><span class="line">	    <span class="comment"># 变量不能是关键字 </span></span><br><span class="line">        myjwt = request.GET.get(<span class="string">"jwt"</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        print(myjwt)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 验证用户合法性</span></span><br><span class="line">        decode_jwt = jwt.decode(myjwt, <span class="string">'qwe123'</span>, algorithms=[<span class="string">'HS256'</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进行比对</span></span><br><span class="line">        <span class="keyword">if</span> int(uid) != int(decode_jwt[<span class="string">'uid'</span>]):</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>: <span class="number">401</span>, <span class="string">'message'</span>: <span class="string">'您的密钥无权限'</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> func(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#  最后类视图使用method_decorator(装饰器名称)调用</span></span><br></pre>



<h4 id="载荷中加入生命周期"><a href="#载荷中加入生命周期" class="headerlink" title="载荷中加入生命周期"></a>载荷中加入生命周期</h4><pre class="highlight"><span class="line">playload = &#123;</span><br><span class="line">	// 代表过期时间        当前时间+延迟加载（以秒计时）</span><br><span class="line">	<span class="string">'exp'</span>: int((datatime.datatime.now() + datetime.timedelta(seconds=<span class="number">30</span>)).timestamp())  //强转时间戳 按照整形</span><br><span class="line">	<span class="string">'data'</span>:&#123;<span class="string">'uid'</span>:<span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 生成</span></span><br><span class="line">encode_jwt = jwt.encode(playload,<span class="string">'lhn123'</span>,algorithm=<span class="string">'HS256'</span>)</span><br><span class="line"><span class="comment"># 转码</span></span><br><span class="line">encode_str = str(encode_jwt,<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment"># 解密操作</span></span><br><span class="line">decode_jwt = jwt.decode(encode_str,<span class="string">'lhn123'</span>,algorithms=[<span class="string">'HS256'</span>])</span><br><span class="line">print(encode_str)</span><br><span class="line">print(decode_jwt[<span class="string">'uid'</span>])</span><br></pre>



]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>MD5加密</title>
    <url>/2020/04/24/m_5/</url>
    <content><![CDATA[<h3 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h3><pre class="highlight"><span class="line"><span class="comment">#导入加密库</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># md5加密方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_password</span><span class="params">(mypass)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成md5对象</span></span><br><span class="line">    md5 = hashlib.md5()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#转码操作</span></span><br><span class="line">    mypass_utf8 = str(mypass).encode(encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加密操作</span></span><br><span class="line">    md5.update(mypass_utf8)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#返回密文</span></span><br><span class="line">    <span class="keyword">return</span> md5.hexdigest()</span><br></pre>]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>mongoDB语法</title>
    <url>/2020/04/20/m_b/</url>
    <content><![CDATA[<h4 id="mongoDB"><a href="#mongoDB" class="headerlink" title="mongoDB"></a>mongoDB</h4><pre class="highlight"><span class="line">数据库分为：关系型，非关系型</span><br><span class="line">关系型：Myspl，spllit</span><br><span class="line">非关系型：Redis，MongoDB</span><br><span class="line">主要区别：数据存储结构不同</span><br></pre>

<h4 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h4><pre class="highlight"><span class="line">查看：show dbs <span class="comment">#只能查看非空的库</span></span><br><span class="line">创库：use 库名</span><br><span class="line">新增：db.表名.insert(&#123;<span class="string">'key'</span>：<span class="string">'value'</span>&#125;)  <span class="comment">#如果给一个字典就添加一条，如果给一个列表就添加多条</span></span><br><span class="line">查看：db.表名.find(&#123;&#125;)  <span class="comment">#查看全部</span></span><br><span class="line">     show tables  <span class="comment">#查看库中所有的表</span></span><br><span class="line">     db  <span class="comment">#查看当前使用的库</span></span><br><span class="line">删除：db.表名.drop()  <span class="comment">#删表</span></span><br><span class="line">     db.dropDatabase()  <span class="comment">#删库</span></span><br></pre>



<h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><pre class="highlight"><span class="line"><span class="comment">#增：</span></span><br><span class="line">    新增：db.表名.insert(&#123;<span class="string">'key'</span>：<span class="string">'value'</span>&#125;)  <span class="comment">#如果给一个字典就添加一条，如果给一个列表就添加多条</span></span><br><span class="line">    插入一条：db.表名.insertOne(&#123;<span class="string">"key"</span>:<span class="string">'value'</span>&#125;)  <span class="comment">#给一个字典添加一条</span></span><br><span class="line">    插入多条：db.表名.insertMany([&#123;<span class="string">"key1"</span>:<span class="string">'value1'</span>&#125;,&#123;<span class="string">'key2'</span>,<span class="string">"value2"</span>&#125;])  <span class="comment">#给一个列表添加多条</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查：条件中&#123;"_id":0&#125;意为不显示id</span></span><br><span class="line">    查看全部：db.表名.find(&#123;&#125;)  <span class="comment">#</span></span><br><span class="line">    排序：db.表名.find(&#123;&#125;).sort(&#123;<span class="string">"字段名"</span>:<span class="number">1</span>/<span class="number">-1</span>&#125;)  <span class="comment">#1代表升序 -1代表降序</span></span><br><span class="line">    分页：db.表名.find(&#123;&#125;).limit(个数)</span><br><span class="line">    等值查询：db.表名.find(&#123;<span class="string">"字段名"</span>:<span class="string">"value"</span>&#125;)</span><br><span class="line">    多值查询：db.表名.find(&#123;<span class="string">"字段名1"</span>:<span class="string">"value1"</span>，<span class="string">"字段名2"</span>:<span class="string">"value2"</span>&#125;)</span><br><span class="line">    包含查询：db.表名.find(&#123;$<span class="keyword">or</span>[&#123;<span class="string">"字段名1"</span>:<span class="string">"value1"</span>&#125;,&#123;<span class="string">"字段名2"</span>:<span class="string">"value2"</span>&#125;]&#125;)</span><br><span class="line">    非等值查询：db.表名.find(&#123;<span class="string">"字段名"</span>:&#123;条件：值&#125;&#125;)  <span class="comment">#大于$gt，小于$lt，大等$gte，小等$lte，不等$ne</span></span><br><span class="line">    正则查询(模糊查询)：db.表名.find(&#123;<span class="string">"字段名"</span>：&#123;$regex:<span class="string">"正则表达式"</span>&#125;&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#改</span></span><br><span class="line">    db.表名.update(&#123;<span class="string">"存在的key"</span>:<span class="string">"存在的value"</span>&#125;,&#123;<span class="string">"存在的key"</span>:<span class="string">"修改后的value"</span>&#125;)  <span class="comment">#只改第一个符合条件的</span></span><br><span class="line">    db.表名.update(&#123;<span class="string">"存在的key"</span>:<span class="string">"存在的value"</span>&#125;,&#123;$set&#123;<span class="string">"存在的key"</span>:<span class="string">"修改后的value"</span>&#125;&#125;)  <span class="comment">#只改第一个符合条件的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删</span></span><br><span class="line">    删除一条：db.表名.remove(&#123;<span class="string">"key"</span>:<span class="string">"value"</span>&#125;)</span><br><span class="line">    删除所有数据：db.表名.remove(&#123;&#125;)</span><br></pre>

<h4 id="python交互"><a href="#python交互" class="headerlink" title="python交互"></a>python交互</h4><pre class="highlight"><span class="line">   <span class="keyword">import</span> pymongo</span><br><span class="line">   conn = pymongo.MongoClient()</span><br><span class="line">   db = conn.库名</span><br><span class="line">   table = db.表名</span><br><span class="line">   <span class="comment">#增</span></span><br><span class="line">   table.insert(&#123;<span class="string">'key'</span>：<span class="string">'value'</span>&#125;) <span class="comment">#如果给一个字典就添加一条，如果给一个列表就添加多条</span></span><br><span class="line">   table.insert_one(&#123;<span class="string">'key'</span>：<span class="string">'value'</span>&#125;)  <span class="comment">#添加一条</span></span><br><span class="line">    teble.insertMany([&#123;<span class="string">"key1"</span>:<span class="string">'value1'</span>&#125;,&#123;<span class="string">'key2'</span>,<span class="string">"value2"</span>&#125;])  <span class="comment">#给一个列表添加多条</span></span><br><span class="line"><span class="comment">#查</span></span><br><span class="line">   table.find(&#123;&#125;)  <span class="comment">#返回的是一个mongo对象，可以用list强转或者for循环遍历</span></span><br><span class="line">   <span class="comment">#改</span></span><br><span class="line">   table.update_one(&#123;<span class="string">"key1"</span>:<span class="string">"value1"</span>&#125;,&#123;<span class="string">"key1"</span>:<span class="string">"value2"</span>&#125;)  <span class="comment">#修改</span></span><br></pre>

]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>LocalStorage简介</title>
    <url>/2020/04/27/l_e/</url>
    <content><![CDATA[<h4 id="localstorage（本地存储）与sessionStorage-会话存储"><a href="#localstorage（本地存储）与sessionStorage-会话存储" class="headerlink" title="localstorage（本地存储）与sessionStorage( 会话存储 )"></a>localstorage（本地存储）与sessionStorage( 会话存储 )</h4><p> localstorage（本地存储）以文件的方式存储在本地,永久保存（不主动删除，则一直存在）；sessionstorage( 会话存储 ) ,临时保存。 </p>
<p> localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理。 </p>
<h4 id="localstorage"><a href="#localstorage" class="headerlink" title="localstorage"></a>localstorage</h4><p> localStorage中一般浏览器支持的是4M大小，这个在不同的浏览器中localStorage会有所不同。 </p>
<h5 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h5><pre class="highlight"><span class="line">localStorage.setItem(<span class="string">"username"</span>,this.username)</span><br></pre>

<h5 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h5><pre class="highlight"><span class="line">name = localStorage.getItem(<span class="string">"username"</span>)</span><br></pre>

<h5 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h5><pre class="highlight"><span class="line">localStorage.removeItem(<span class="string">'username'</span>)</span><br></pre>

<h5 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h5><pre class="highlight"><span class="line">localStorage.setItem(<span class="string">'username'</span>, <span class="string">' '</span> + response.data.result.username)</span><br></pre>

]]></content>
      <tags>
        <tag>localstorage</tag>
      </tags>
  </entry>
  <entry>
    <title>关于mysql优化</title>
    <url>/2020/07/14/m_s/</url>
    <content><![CDATA[<h4 id="优化数据的访问"><a href="#优化数据的访问" class="headerlink" title="优化数据的访问"></a>优化数据的访问</h4><ol>
<li><p>确认应用程序是否检索了大量超过需要的数据。通常以为访问太多的行，或者访问太多的列</p>
</li>
<li><p>确认mysql服务器层是否存在分析大量超过需要的数据行</p>
</li>
<li><p>当访问量过大时，考虑数据库读写分离原则，当我们使用分离，数据库的压力还是很大的时候，这就需要使用数据拆分了。数据库的拆分原则：就是通过某种特定的条件，按照某个维度，将我们存放同一个数据库中的数据分散存到多个数据库（主机）上面已达到分散单裤（主机）负载的效果。</p>
<ul>
<li><p>首选是垂直拆分：一个数据库是由多个表组成，每个表对应着不同的业务，垂直切分指按照业务进行分类，分布到不同的数据库上面，这样也就将压力分布到不同的数据库上。 <strong>优点</strong> ：1 拆分后业务清晰，拆分规则明确 2 系统之间整合或扩展容易 3 数据维护简单 <strong>缺点</strong> ：1 部分代码无法join，只能通过接口方式解决，提高了系统复杂度 2 事物处理复杂</p>
</li>
<li><p>水平拆分：相似与垂直拆分，水平拆分不是将表的数据做分类，而是按照某个字段的某种规则分散到多个库之中，每个表包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行进行切分，就是讲表中的某些行切分到一个数据库，而另外的某些行又切分到其他的数据库中。</p>
</li>
<li><p><strong>总</strong> ： 如果分库后仍然查的满的话，按照分库的思想做分表的工作数据库采用分布式数据库（所有的节点加起来才是整体数据），服务器满足不了大型系统增长的业务需求，数据库读写分离随着业务的发展，最终也无法满足，需要分布式数据库及分布式文件系统来支撑。</p>
<p>优先考虑缓存讲题对数据库的操作</p>
<p>在考录读写分离，降低数据库写操作</p>
<p>首先垂直拆分在水平拆分</p>
<p>先分库在分表</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传功能</title>
    <url>/2020/04/30/p_c/</url>
    <content><![CDATA[<h4 id="上传文件流程"><a href="#上传文件流程" class="headerlink" title="上传文件流程"></a>上传文件流程</h4><p>vue.js–&gt;axios–&gt;django接口–&gt;file来写文件–&gt;文件操作(可压缩文件，可同步到七牛云-又拍云)–&gt;提取文件名称–&gt;vue.js</p>
<h4 id="上传文件vue-js"><a href="#上传文件vue-js" class="headerlink" title="上传文件vue.js"></a>上传文件vue.js</h4><pre class="highlight"><span class="line">&lt;div&gt;</span><br><span class="line">        &lt;table&gt;</span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">            // Avatar 使图片展示为圆形</span><br><span class="line">            &lt;Avatar :src="src" :width="150" height="150px"&gt;&lt;/Avatar&gt;</span><br><span class="line">          &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;用户头像：&lt;/td&gt;</span><br><span class="line">            //当图片发生改变是@change不是click点击</span><br><span class="line">            &lt;td&gt;&lt;input type="file" @change="upload"&gt;&lt;/td&gt;</span><br><span class="line">          &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/table&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// <span class="keyword">return</span>中定义s变量</span><br><span class="line"></span><br><span class="line">src:<span class="string">''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//上传文件</span><br><span class="line">    upload:function (e) &#123;</span><br><span class="line"></span><br><span class="line">      //获取文件</span><br><span class="line">      let file = e.target.files[<span class="number">0</span>];</span><br><span class="line">      //声明表单参数</span><br><span class="line">      let param = new FormData();</span><br><span class="line"></span><br><span class="line">      param.append(<span class="string">'file'</span>,file,file.name);</span><br><span class="line"></span><br><span class="line">      //声明请求头</span><br><span class="line">       let config = &#123;headers:&#123;<span class="string">'Content-Type'</span>:<span class="string">'multipart/form-data'</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">      // 发送请求</span><br><span class="line">      this.axios.post('http://localhost:8000/upload/',param,config).then((res)=&gt;&#123;</span><br><span class="line">      </span><br><span class="line">            console.log(res);</span><br><span class="line">            </span><br><span class="line">            //图片的路径要拼接起来</span><br><span class="line">            this.src = <span class="string">'http://localhost:8000/static/upload/'</span>+res.data.filename;</span><br><span class="line">            </span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br></pre>



<h4 id="配置setting文件上传路径"><a href="#配置setting文件上传路径" class="headerlink" title="配置setting文件上传路径"></a>配置setting文件上传路径</h4><pre class="highlight"><span class="line">STATIC_URL = <span class="string">'/static/'</span></span><br><span class="line"></span><br><span class="line">STATICFILES_DIRS[</span><br><span class="line">	os.path.join(BASE_DIR,<span class="string">'static'</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义文件夹</span></span><br><span class="line">UPLOAD_ROOT = os.path.join(BASE_DIR,<span class="string">'static/upload'</span>)</span><br></pre>



<h4 id="上传文件接口"><a href="#上传文件接口" class="headerlink" title="上传文件接口"></a>上传文件接口</h4><pre class="highlight"><span class="line"><span class="comment">#导入上传文件夹配置</span></span><br><span class="line"><span class="keyword">from</span> mydjango.settings <span class="keyword">import</span> UPLOAD_ROOT</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">#文件上传通用类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadFile</span><span class="params">(APIView)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#接收参数</span></span><br><span class="line">        myfile = request.FILES.get(<span class="string">'file'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#建立文件流对象</span></span><br><span class="line">        f = open(os.path.join(UPLOAD_ROOT,<span class="string">''</span>,myfile.name.replace(<span class="string">'"'</span>,<span class="string">''</span>)),<span class="string">'wb'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#写入</span></span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> myfile.chunks():</span><br><span class="line">            f.write(chunk)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'filename'</span>:myfile.name.replace(<span class="string">'"'</span>,<span class="string">''</span>)&#125;)</span><br></pre>







]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>图片压缩水印</title>
    <url>/2020/04/29/p_s/</url>
    <content><![CDATA[<h4 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h4><pre class="highlight"><span class="line"><span class="comment">#压缩 两种压缩模式，png不适合压缩，jpg适合</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment">#读图</span></span><br><span class="line">img = cv2.imread(<span class="string">'./dingding.png'</span>)</span><br><span class="line"><span class="comment">#开始压缩 png压缩等级清晰0-9模糊</span></span><br><span class="line">cv2.imwrite(<span class="string">'./dingding1.png'</span>,img,[cv2.IMWRITE_PNG_COMPRESSION,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#jpg压缩等级清晰0-100模糊 </span></span><br><span class="line">cv2.imwrite(<span class="string">'./dingding1.jpg'</span>,img,[cv2.IMWRITE_JPEG_QUALITY,<span class="number">50</span>])</span><br></pre>

<h4 id="加水印"><a href="#加水印" class="headerlink" title="加水印"></a>加水印</h4><pre class="highlight"><span class="line"><span class="comment">#绘画库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageDraw</span><br><span class="line"><span class="comment">#字体库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFont</span><br><span class="line"><span class="comment">#图片库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment">#加水印</span></span><br><span class="line">img = Image.open(<span class="string">'.//static/upload/'</span>+myfile_name)</span><br><span class="line"><span class="comment"># 获取宽高</span></span><br><span class="line">width, height = img.size</span><br><span class="line"><span class="comment"># 根据图片大小定义logo大小</span></span><br><span class="line">text = <span class="string">'哈哈哈'</span></span><br><span class="line"><span class="comment">#字体</span></span><br><span class="line">font = ImageFont.truetype(font=<span class="string">'C:\Windows\Fonts\FZXKJW.TTF'</span>,size=<span class="number">35</span>)</span><br><span class="line"><span class="comment"># 获取字体宽高</span></span><br><span class="line">font_width, font_height = font.getsize(text)</span><br><span class="line"><span class="comment"># 使用画笔</span></span><br><span class="line">draw = ImageDraw.Draw(img)</span><br><span class="line"><span class="comment"># 写入文本 参数（（x,y），水印文字，颜色，字体）</span></span><br><span class="line">draw.text((width-font_width,height-font_height), text,fill=(<span class="number">76</span>,<span class="number">234</span>,<span class="number">124</span>,<span class="number">180</span>), font=font)</span><br><span class="line"><span class="comment"># 根据路径保存文件 </span></span><br><span class="line">img.save(os.path.join(UPLOAD_ROOT, <span class="string">''</span>, myfile_name))</span><br></pre>

]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python面试算法题</title>
    <url>/2020/07/06/p_y/</url>
    <content><![CDATA[<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">num</span><span class="params">()</span>:</span></span><br><span class="line">          <span class="keyword">return</span> [<span class="keyword">lambda</span> x: i*x <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">print([m(<span class="number">2</span>) <span class="keyword">for</span> m <span class="keyword">in</span> num()])     <span class="comment"># 输出: [6, 6, 6, 6]</span></span><br></pre>

<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>这题涉及到了闭包延时绑定，当循环执行完了之后才会执行传参，循环四次，每一次循环完 i=3 然后再和x相乘 所以结果是6，6，6，6。 如果把 [ lambda x: i<em>x for i in range(4) ] 改成 （ lambda x: i</em>x for i in range(4) ）这样就变成了一个生成器 自动实现迭代器协议，一边循环一边计算的机制， 这样结果就是 0，2，4，6.</p>
<hr>
<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><pre class="highlight"><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre>

<h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>这里可以使用字典来解题，通过enumerate方法遍历获取数据的下标包括对应值，然后以key，value形式把该数据的下标和对应值存入字典，然后再出通过enumerate方法遍历数据，每一次获取数据就从字典拿出一个值，用目标值减去从字典拿出的这个值得到一个结果值，如果结果值存在字典当中，那么返回两个数的下标，如果为None，说明字典中没有这个值。</p>
<h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_index_list</span><span class="params">(nums, target)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Todo 作为一个方法来实现，批量解决这个获取索引的问题</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :params nums：传的参数的列表</span></span><br><span class="line"><span class="string">    :params target: 目标值</span></span><br><span class="line"><span class="string">    :return: 返回索引</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> enumerate(nums):  <span class="comment"># a是下标 b是对应值</span></span><br><span class="line"></span><br><span class="line">        dic[b] = a  <span class="comment"># 对应值存入字典</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, b <span class="keyword">in</span> enumerate(nums):</span><br><span class="line"></span><br><span class="line">        j = dic.get(target-b)  <span class="comment"># 从字典中拿出对应值 用目标值减去对应值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> j <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 判断如果减去的对应值不为空，则返回下标</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> [i, j]</span><br></pre>

<hr>
<h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h2><p>示例：</p>
<pre class="highlight"><span class="line">输入:</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">2</span> 或 <span class="number">3</span></span><br></pre>

<h3 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h3><p>这道题想到的是，使用列表中的count方法，定义一个空列表，遍历数据然后进行判断，如果数据值出现个数大于或等于2，说明该数据是重复的，然后把重复的筛取出来之后存入空列表，再进行返回输出。</p>
<h3 id="实现代码：-1"><a href="#实现代码：-1" class="headerlink" title="实现代码："></a>实现代码：</h3><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_number</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :params nums：传的参数的数组</span></span><br><span class="line"><span class="string">    :return: 返回重复数字</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    nub = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> nums.count(i) &gt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> str(i) <span class="keyword">not</span> <span class="keyword">in</span> nub:</span><br><span class="line">                nub.append(str(i))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'或'</span>.join(nub))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    get_number([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>])</span><br></pre>

<h2 id="队列实现一个栈"><a href="#队列实现一个栈" class="headerlink" title="队列实现一个栈"></a>队列实现一个栈</h2><h3 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h3><p>使用一个队列，实现栈的一些基本操作，栈（后进先出）的特性。</p>
<h3 id="实现代码：-2"><a href="#实现代码：-2" class="headerlink" title="实现代码："></a>实现代码：</h3><pre class="highlight"><span class="line"><span class="comment"># 队列实现一个栈 （栈：后进先出）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 定义一个队列</span></span><br><span class="line">        self.lst = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_None</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 判断栈是否为空 返回 ture false</span></span><br><span class="line">        <span class="keyword">return</span> self.lst == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        <span class="comment"># 加入元素</span></span><br><span class="line">        self.lst.append(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 出栈</span></span><br><span class="line">        <span class="keyword">return</span> self.lst.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stack_top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回栈顶元素</span></span><br><span class="line">        <span class="keyword">return</span> self.lst[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 栈的大小</span></span><br><span class="line">        <span class="keyword">return</span> len(self.lst)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    stack = Stack()</span><br><span class="line">    print(stack.is_None())</span><br><span class="line">    stack.push(<span class="number">1</span>)</span><br><span class="line">    stack.push(<span class="number">2</span>)</span><br><span class="line">    stack.push(<span class="number">3</span>)</span><br><span class="line">    print(stack.lst)</span><br><span class="line">    print(stack.pop())</span><br><span class="line">    print(stack.stack_top())</span><br><span class="line">    print(stack.size())</span><br></pre>

<hr>
<h2 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p>示例1：</p>
<pre class="highlight"><span class="line">输入: <span class="number">121</span></span><br><span class="line">输出: true</span><br></pre>

<p>示例2：</p>
<pre class="highlight"><span class="line">输入: <span class="number">-121</span></span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右，为 <span class="number">-121</span> 。 从右向左读，为<span class="number">121</span>- 。 因此它不是一个回文数</span><br></pre>

<p>示例3：</p>
<pre class="highlight"><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读，为 01 。 因此它不是一个回文数</span><br></pre>

<h3 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h3><p>这题可以使用字符串 双指针的方法 将数据转化为字符串 首先定义好第一个元素下标和最后一个元素下标，while循环 只要条件不满足 一直循环 循环判断第一个和最后一个元素是否相等 不相等返回false 相等继续循环，如果循环条件满足之后都相等，返回 false</p>
<h3 id="实现代码：-3"><a href="#实现代码：-3" class="headerlink" title="实现代码："></a>实现代码：</h3><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">palindromic_number</span><span class="params">(x)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :params x：传的参数的列表</span></span><br><span class="line"><span class="string">    :return: 返回Ture False</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    lst = list(str(x))</span><br><span class="line">    print(lst)</span><br><span class="line">    L, R = <span class="number">0</span>, len(lst)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">        print(L, R)</span><br><span class="line">        <span class="keyword">if</span> lst[L] != lst[R]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        L += <span class="number">1</span></span><br><span class="line">        R -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(palindromic_number(<span class="number">1231</span>))</span><br></pre>

<hr>
<h2 id="分别用生成器和迭代器生成斐波那契数列"><a href="#分别用生成器和迭代器生成斐波那契数列" class="headerlink" title="分别用生成器和迭代器生成斐波那契数列"></a>分别用生成器和迭代器生成斐波那契数列</h2><p>示例：</p>
<pre class="highlight"><span class="line">输出: 1 1 2 3 5 8 13</span><br></pre>

<pre class="highlight"><span class="line"><span class="comment"># 使用迭代器生成斐波那契数列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibonacii</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,all_num)</span>:</span></span><br><span class="line">        self.all_num = all_num</span><br><span class="line">        self.cur_idx = <span class="number">0</span></span><br><span class="line">        self.a = <span class="number">0</span>  </span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.cur_idx &gt;= self.all_num:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        ret = self.a</span><br><span class="line">        </span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        self.cur_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"> </span><br><span class="line">fibo = Fibonacii(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fibo:</span><br><span class="line">    print(i)</span><br></pre>

<pre class="highlight"><span class="line"><span class="comment"># 使用生成器生成斐波那契数列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibnacii</span><span class="params">(count)</span>:</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> num &lt; count:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fi = fibnacii(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fi:</span><br><span class="line">    print(i)</span><br></pre>

<h2 id="反转字符数组"><a href="#反转字符数组" class="headerlink" title="反转字符数组"></a>反转字符数组</h2><h3 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h3><p>直接使用反转</p>
<h3 id="实现代码：-4"><a href="#实现代码：-4" class="headerlink" title="实现代码："></a>实现代码：</h3><pre class="highlight"><span class="line"><span class="comment"># 反转字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseString</span><span class="params">(s)</span>:</span></span><br><span class="line">    s[<span class="number">0</span>::] = s[::<span class="number">-1</span>]</span><br><span class="line">    print(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    reverseString([<span class="string">'b'</span>, <span class="string">''</span>, <span class="string">'a'</span>, <span class="string">'r'</span>])</span><br></pre>











]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>md5加密原理</title>
    <url>/2018/12/31/md5%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h6 id="用户在进行注册和登录行为时-都会涉及到密码这一敏感参数的传递-出于保护隐私的需求-我们要对于接收到的敏感参数做加密处理-对于django自带的加密算法-步骤如下："><a href="#用户在进行注册和登录行为时-都会涉及到密码这一敏感参数的传递-出于保护隐私的需求-我们要对于接收到的敏感参数做加密处理-对于django自带的加密算法-步骤如下：" class="headerlink" title="用户在进行注册和登录行为时 都会涉及到密码这一敏感参数的传递 出于保护隐私的需求 我们要对于接收到的敏感参数做加密处理 对于django自带的加密算法  步骤如下："></a>用户在进行注册和登录行为时 都会涉及到密码这一敏感参数的传递 出于保护隐私的需求 我们要对于接收到的敏感参数做加密处理 对于django自带的加密算法  步骤如下：</h6><ol>
<li>首先导入django自带的加密算法模块<pre class="highlight"><span class="line"><span class="keyword">from</span> django.contrib.auth.hashers <span class="keyword">import</span> make_password, check_password</span><br></pre>
<pre class="highlight"><span class="line">make_password(参数1， 参数2， 参数3)</span><br><span class="line">参数1： 需要加密的字符串</span><br><span class="line"></span><br><span class="line">参数2： 是否每次都生成不同的加密串，默认为None, 如果给定任意一个字符串，    则表示每次生成相同的加密串。</span><br><span class="line"></span><br><span class="line">参数3： 表示加密算法，常见的加密算法如下： df2_sha256’,  ‘pbkdf2_sha1’,   ‘bcrypt_sha256’,  ‘unsalted_md5’ 等…</span><br></pre>

</li>
</ol>
<pre class="highlight"><span class="line">my_password = make_password(<span class="string">'1234567890'</span>, <span class="literal">None</span>, <span class="string">'pbkdf2_sha256'</span>)</span><br><span class="line">print(my_password)</span><br></pre>

<h6 id="加密后的效果："><a href="#加密后的效果：" class="headerlink" title="加密后的效果："></a>加密后的效果：</h6><pre class="highlight"><span class="line">pbkdf2_sha256$<span class="number">12000</span>$xzMLhCNvQbb8$i1XDnJIpb/cRRGRX2x7Ym74RNfPRCUp5pbU6Sn+V3J0=</span><br></pre>

<pre class="highlight"><span class="line">check_password（参数1， 参数2）</span><br><span class="line">返回值： True或False 参数： 参数1：原始密码，参数2： 数据库查询出的密码</span><br></pre>
<pre class="highlight"><span class="line">isSame = check_password(<span class="string">'1234567890'</span>, sha_pwd )</span><br><span class="line">print(isSame)</span><br><span class="line"><span class="comment"># 如果为： True: 表示密码相同，如果为：False，则表示密码不相同。</span></span><br></pre>

<hr>
<h3 id="md5加密的内部逻辑"><a href="#md5加密的内部逻辑" class="headerlink" title="md5加密的内部逻辑"></a>md5加密的内部逻辑</h3><h4 id="转码时需要注意接收到的数据类型-如果是int需要强转"><a href="#转码时需要注意接收到的数据类型-如果是int需要强转" class="headerlink" title="转码时需要注意接收到的数据类型,如果是int需要强转"></a>转码时需要注意接收到的数据类型,如果是int需要强转</h4><pre class="highlight"><span class="line"><span class="comment">#导入加密库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># md5加密方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_password</span><span class="params">(pass)</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">#生成md5对象</span></span><br><span class="line"></span><br><span class="line">	md5 = hashlib.md5()</span><br><span class="line"></span><br><span class="line">	<span class="comment">#转码操作</span></span><br><span class="line"></span><br><span class="line">	new_pass = str(<span class="keyword">pass</span>).encode(encoding=<span class="string">"utf-8"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#加密操作</span></span><br><span class="line"></span><br><span class="line">	md5.update(new_pass)</span><br><span class="line"></span><br><span class="line">	<span class="comment">#返回密文</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> md5.hexdigest()</span><br></pre>

<hr>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>集群or分布式</title>
    <url>/2020/07/20/r_d/</url>
    <content><![CDATA[<h3 id="集群-or-分布式"><a href="#集群-or-分布式" class="headerlink" title="集群 or 分布式"></a>集群 or 分布式</h3><p>一开始, 一个人干</p>
<p>能力不足了,  为了提高性能</p>
<p>一群人一起干,   干同样的事情,   集群( 一个地点)</p>
<p>分布式(分步式),  炒菜</p>
<p>每个人擅长的部分不一样, </p>
<p>买菜,  一个人</p>
<p>洗菜,  一个人</p>
<p>切菜, 两个人(集群)</p>
<p>炒菜, 五个人(集群)</p>
<p>分布式 (很多业务, 每个业务又是一个集群)</p>
<p>结论:  </p>
<p>​    集群: (很多机器, 合作起来提供一个服务)</p>
<p>​    分布式: 分步骤, 合作完成一个功能 </p>
]]></content>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>七牛云存储</title>
    <url>/2020/05/01/q_u/</url>
    <content><![CDATA[<h4 id="安装七牛云"><a href="#安装七牛云" class="headerlink" title="安装七牛云"></a>安装七牛云</h4><pre class="highlight"><span class="line">pip install qiniu</span><br></pre>

<h4 id="django接口获取token"><a href="#django接口获取token" class="headerlink" title="django接口获取token"></a>django接口获取token</h4><pre class="highlight"><span class="line"><span class="comment"># 七牛云 换取token的一个凭证</span></span><br><span class="line"><span class="keyword">from</span> qiniu <span class="keyword">import</span> Auth</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QiNiu</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment"># 声明验证对象   传参数</span></span><br><span class="line">        q = Auth(<span class="string">'xl8p2s1KY20muvLAL6OKNP7LnJhWX_XLiu2I3QhE'</span>,<span class="string">'8y0ehfGfHy55b2Y8ZvMTpOr34SbsS4a5r88v-7jF'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取token           空间的名称</span></span><br><span class="line">        token  = q.upload_token(<span class="string">"pc1009"</span>)</span><br><span class="line">        <span class="comment"># 返回token</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'token'</span>:token&#125;)</span><br></pre>

<h4 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h4><pre class="highlight"><span class="line">path(<span class="string">'qiniu/'</span>,QiNiu.as_view()),</span><br></pre>

<h4 id="vue接口请求图片上传"><a href="#vue接口请求图片上传" class="headerlink" title="vue接口请求图片上传"></a>vue接口请求图片上传</h4><pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                七牛用户头像：</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;input type=<span class="string">"file"</span> @change=<span class="string">"qiniu"</span>&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;img :src=<span class="string">"src"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">        //图片路径变量</span><br><span class="line">            src:<span class="string">''</span>,</span><br><span class="line">        //获取token变量</span><br><span class="line">            token:<span class="string">''</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    //钩子函数</span><br><span class="line">    mounted:function()&#123;</span><br><span class="line">        //获取token</span><br><span class="line">        this.get_token();</span><br><span class="line">        &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">    	// 获取后端token</span><br><span class="line">        get_token:function()&#123;</span><br><span class="line">            this.axios.get('http://127.0.0.1:8000/qiniu/').then(res=&gt;&#123;         </span><br><span class="line">                    console.log(res)</span><br><span class="line">                    this.token = res.data.token</span><br><span class="line">                    console.log(this.token)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        //七牛上传</span><br><span class="line">        qiniu:function(e)&#123;</span><br><span class="line">            //获取文件</span><br><span class="line">            let file = e.target.files[<span class="number">0</span>];</span><br><span class="line">            //声明表单</span><br><span class="line">            let param = new FormData()    </span><br><span class="line">            param.append(<span class="string">'file'</span>,file,file.name)</span><br><span class="line">            param.append(<span class="string">'token'</span>,this.token)   </span><br><span class="line">            //自定义zxios</span><br><span class="line">            const axios_qiniu = this.axios.create(&#123;withCredentials:false&#125;)</span><br><span class="line"></span><br><span class="line">            //发送请求</span><br><span class="line">            axios_qiniu(&#123;</span><br><span class="line">                method:<span class="string">'POST'</span>,</span><br><span class="line">                // 华北</span><br><span class="line">                url:<span class="string">'http://up-z1.qiniu.com'</span>,</span><br><span class="line">                data:param,</span><br><span class="line">                timeout:<span class="number">30000</span></span><br><span class="line">            &#125;).then(res=&gt;&#123;</span><br><span class="line">                console.log(res)</span><br><span class="line">   			    // 拼接照片路由</span><br><span class="line">            	this.src = <span class="string">'http://q9v2u2gy5.bkt.clouddn.com/'</span>+result.data.key</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre>

]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>django之redis和django-redis的使用</title>
    <url>/2020/07/15/r_z/</url>
    <content><![CDATA[<p>-redis</p>
<p>　　-非关系型内存数据（nosql:mongodb,redis），key-value的存储<br>　　-单线程单进程，qps:10w<br>　　-Memcached：多线程，支持的数据类型少：只支持字符串类型，不支持持久化<br>　　-redis：5大数据类型<br>　　　　k1:‘123‘, 字符串<br>　　　　k2:[1,2,3,4], 列表/数组<br>　　　　k3:{1,2,3,4} 集合：去重，爬虫去重<br>　　　　k4:{name:lqz,age:12} 字典/哈希表<br>　　　　k5:{(‘lqz‘,18),(‘egon‘,33)} 有序集合：游戏排行榜<br>　　-redis支持持久化：两种持久化的方案</p>
<p>-python操作redis<br>　　from redis import Redis<br>　　conn=Redis()</p>
<p>-redis连接池<br>　　#pool需要做成单例<br>　　pool=ConnectionPool(host=‘127.0.0.1‘,port=6379,max_connections=100)<br>　　conn=Redis(connection_pool=pool)</p>
<p>-redis之字符串操作<br>　　-set<br>　　-get<br>　　-mset<br>　　-mget<br>　　-incr<br>　　-decr<br>　　-append</p>
<p>-redis之hash操作<br>　　-hset<br>　　-hmset<br>　　-hget<br>　　-hmget<br>　　-hgetall<br>　　-hlen<br>　　-hdel<br>　　-hincrby<br>　　-hscan<br>　　-hscan_iter</p>
<p>-redis之列表操作<br>　　-lpush<br>　　-llen<br>　　-linsert<br>　　-lpop<br>　　-blpop</p>
<p>　　-自定义增量迭代</p>
<p>只支持一层的5大数据类型：也就是说字典的value值只能是字符串，列表的value值只能是字符串</p>
<p>-redis的其他操作<br>　　-delete<br>　　-exisit<br>　　-rename<br>　　-keys 模糊匹配key值<br>　　-expire<br>　　-type</p>
<p>-事务（重点）<br>　　conn=Redis()<br>　　pipe = conn.pipeline(transaction=True)<br>　　pipe.multi()<br>　　pipe.set(‘name‘, ‘alex‘)<br>　　pipe.set(‘role‘, ‘sb‘)<br>　　pipe.execute()</p>
<p>-在django中使用redis<br>　　-所有框架都能用的方式：<br>　　　　-先新建一个py文件，生成一个redis连接池<br>　　　　-在哪用，导过来，<br>　　　　　　conn=Redis(connection_pool=POOL)<br>　　　　　　conn.set(‘xxx‘,‘yyyy‘)<br>　　-django中使用：django-redis模块<br>　　　　-在setting中配置：<br>　　　　　　CACHES = {<br>　　　　　　　　“default”: {<br>　　　　　　　　　　“BACKEND”: “django_redis.cache.RedisCache”,<br>　　　　　　　　　　“LOCATION”: “redis://127.0.0.1:6379”,<br>　　　　　　　　　　“OPTIONS”: {<br>　　　　　　　　　　　　“CLIENT_CLASS”: “django_redis.client.DefaultClient”,<br>　　　　　　　　　　　　“CONNECTION_POOL_KWARGS”: {“max_connections”: 100}}}}<br>　　　　-使用<br>　　　　　　在使用的位置：<br>　　　　　　from django_redis import get_redis_connection<br>　　　　　　conn=get_redis_connection()<br>　　　　　　conn.set</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>验证码的时效性</title>
    <url>/2020/07/14/r_s/</url>
    <content><![CDATA[<p>redis场景，服务器内存不够了，怎么办（或者说被人干蹦了），我们的redis信息是不是就没了，redis服务hi不是挂了，如何优化？容灾方式？分配redis多大内存，是否满足我们的生产的需求，一般我们会缓存到多大的一个数据量，峰值是多少？</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>Redis场景，服务器内存不够了：</p>
<p>一，增加内存</p>
<p>redis存储在内存中，数据太多，占用大多内存，那么增加内存就是直接的方法，但是这个方法一般不采用，因为内存满了就加内存，满了就加，那代价太大，相当于用钱解决的问题，不首先考虑，一般有方面都做到最优化，才考虑此方法。</p>
<p>二，搭建Redis集群</p>
<ol>
<li>所有的redis节点批次互联（PING-PONG机制),内部使用二进制协议优化传输速度和宽带。</li>
<li>节点的fail是通过集群中超过半数的节点检测时效时才生效。</li>
<li>客户端与redis节点智联，不需要中间proxy层，客户端不需要连接集群所有的节点，连接集群中任何一个可用的节点即可。</li>
<li>redis-cluster把所有的物理节点映射到[0-16383]slot上，cluster负责维护node&lt;-&gt;slot&lt;-&gt;value</li>
</ol>
<p>Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点，最多16384个节点。</p>
<p>节点间相互通信，一半以上节点ping不同一个节点，则说明此节点挂掉，从节点顶上</p>
<p>(1)集群中所有master参与投票,如果半数以上master节点与其中一个master节点通信超过(cluster-node-timeout),认为该master节点挂掉.</p>
<p>(2):什么时候整个集群不可用(cluster_state:fail)? </p>
<ul>
<li>如果集群任意master挂掉,且当前master没有slave，则集群进入fail状态。也可以理解成集群的[0-16383]slot映射不完全时进入fail状态。</li>
<li>如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态。</li>
</ul>
<h4 id="Redis服务器因某种原因崩掉了，redis的信息是不是就没了-（容灾方式）"><a href="#Redis服务器因某种原因崩掉了，redis的信息是不是就没了-（容灾方式）" class="headerlink" title="Redis服务器因某种原因崩掉了，redis的信息是不是就没了 （容灾方式）"></a>Redis服务器因某种原因崩掉了，redis的信息是不是就没了 （容灾方式）</h4><p>redis 持久化策略：</p>
<p>　　RDB：对redis中的数据周期性的持久化</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="　　　优点"></a>　　　优点</h4><p>​              1、会生成多个数据文件，每个数据文件都代表了某一个时间的全部数据。非常适合做冷备。可以将数据上传到云服务备份。</p>
<p>　　　　2、RDB对redis对外提供的服务影响小，可以让redis保持高性能。</p>
<p>　　　　3、相比较来说，基于RDB文件重启恢复redis更快</p>
<p>　　AOF：对每条写入命令作为日志。以append-only模式写入日志。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="　　　优点"></a>　　　优点</h4><p>​              1、可以更好的保护数据不丢失，一般AOF每隔1秒，通过后台线程执行一次fsync操作。最多丢失1s数据</p>
<p>　　　　2、文件以append-only模式写入，没有io开销。文件不容易损坏。损坏也很容易恢复。</p>
<p>　　　　3、AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在rewrite log的时候，会对其中的指导进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的merge后的日志文件ready的时候，再交换新老日志文件即可。</p>
<p>　　　　4、日志文件可读性强。适合做灾难性的误删除的紧急恢复。</p>
<p>一般线上环境我们会将2中机制都开启。具体的RDB策略和AOF策略都可以在redis.conf里面配置</p>
<p>RDB： save 60 1000 : 表示每60s有超过1000条数据更新就备份。</p>
<p>AOF： append-only : true 开启aof策略</p>
<p>　　　　everysec: 每秒备份</p>
<p>　　　　auto-aof-rewrite-percentage 100 : 当aof大小膨胀到上次2倍就备份</p>
<p>　　　　auto-aof-rewrite-min-size 64mb ： 和上面是 且 关系。 aof文件必须超过64m才会备份</p>
<h4 id="通过RDB恢复数据的步骤："><a href="#通过RDB恢复数据的步骤：" class="headerlink" title="通过RDB恢复数据的步骤："></a>通过RDB恢复数据的步骤：</h4><p>先将云服务的RDB备份数据copy到redis配置的备份目录。然后将aof关闭（一定要关闭，否则优先从aof日志文件本分，但是如果没有的话就创建空的。所以redis是无法加载rdb备份文件的）。然后重启redis，此时我们redis-cli 进入redis发现redis已经自动加载备份的rdb文件数据了。这时候手动命令启动aof。这时候redis就会备份aof日志。这启动aof是暂时的。我们停掉redis，在配置文件中修改将aof开启，然后再开启，现在redis已经恢复数据，且AOF已经开启了。</p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Python算法时间复杂度</title>
    <url>/2020/07/06/s_d/</url>
    <content><![CDATA[<p> 时间复杂度分为：</p>
<ul>
<li><p>时间复杂度</p>
</li>
<li><p>空间复杂度</p>
<p>时间复杂度用于度量算法的计算工作量，空间复杂度用于度量算法占用的内存空间。 </p>
</li>
</ul>
<p><strong>渐进时间复杂度</strong></p>
<p>时间复杂度是算法运算所消耗的时间，因为不同大小的输入数据，算法处理所要消耗的时间是不同的，因此评估一个算运行时间是比较困难的，所以通常关注的是时间频度，即算法运行计算操作的次数，记为T(n)，其中n称为问题的规模。</p>
<p>同样，因为n是一个变量，n发生变化时，时间频度T(n) 也在发生变化，我们称时间复杂度的极限情形称为算法的渐近时间复杂度，记为O(n)，不包含函数的低阶和首项系数。</p>
<h5 id="时间复杂度分为："><a href="#时间复杂度分为：" class="headerlink" title="时间复杂度分为："></a>时间复杂度分为：</h5><ul>
<li>常数阶 O(1) </li>
<li>线性阶 O(n) </li>
<li>平方阶 O(n^2) </li>
<li>立方阶 O(n^3) </li>
<li>对数阶 O(logn) </li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫概述</title>
    <url>/2020/04/26/s_r/</url>
    <content><![CDATA[<pre class="highlight"><span class="line"><span class="comment"># 爬虫分类</span></span><br><span class="line">聚焦爬虫: 针对特定领域, 抓取特定数据的爬虫程序</span><br><span class="line">    <span class="number">1.</span>确定url, 发起请求, 获取响应</span><br><span class="line">    2.数据解析  --&gt; 目标数据</span><br><span class="line">    <span class="number">3.</span>数据持久化</span><br><span class="line">通用爬虫: 爬取数据, 为搜索引擎提供检索服务</span><br><span class="line">    <span class="number">1.</span>将自己的网站被搜索引擎收录的手段: 竞价排名, 主动提交, 友情链接, DNS服务商</span><br><span class="line">    <span class="number">2.</span>SEO: seo搜索引擎优化, 提高排名</span><br><span class="line">    <span class="number">3.</span>robots协议:规定哪些爬虫不能够爬取本网站的哪些页面, 聚焦爬虫不遵守, robots协议是道德层面.</span><br></pre>

<pre class="highlight"><span class="line"><span class="comment"># 网络模型:</span></span><br><span class="line"><span class="number">1.</span>OSI七层模型: 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层</span><br><span class="line"><span class="number">2.</span>TCP/IP五层模型: </span><br><span class="line">    应用层: http  https ftp sftp ssh</span><br><span class="line">    传输层: TCP / UDP</span><br><span class="line">    网络层: IP</span><br><span class="line">    数据链路层:ARP </span><br><span class="line">    物理层: 以太网协议</span><br></pre>

<pre class="highlight"><span class="line"><span class="comment"># http &amp; https:</span></span><br><span class="line"><span class="number">1.</span>http端口<span class="number">80</span>, https端口<span class="number">443</span>, https需要CA证书, 可能需要一定费用</span><br><span class="line"><span class="number">2.</span>http是超文本传输协议, 明文传输, https是在http的基础上增加了ssl安全套接层, 数据的加密传输</span><br><span class="line"><span class="number">3.</span>HTTP和HTTPS使用的是完全不同的连接方式, 都是无状态的, HTTP和HTTPS使用的是完全不同的连接方式</span><br></pre>

<h4 id="爬虫的概念"><a href="#爬虫的概念" class="headerlink" title="爬虫的概念"></a>爬虫的概念</h4><pre class="highlight"><span class="line">爬虫, 又称网页蜘蛛或网络机器人.</span><br><span class="line">爬虫是 模拟人操作客户端(浏览器, APP)   向服务器发起网络请求    抓取数据的自动化程序或脚本.(*****)</span><br><span class="line">Pyinstaller</span><br><span class="line"><span class="comment"># 说明:</span></span><br><span class="line">	<span class="number">1.</span>模拟: 用爬虫程序伪装出人的行为, 避免被服务识别为爬虫程序</span><br><span class="line">	<span class="number">2.</span>客户端: 浏览器, APP都可以实现人与服务器之间的交互行为, 应用客户端从服务器获取数据</span><br><span class="line">	<span class="number">3.</span>自动化: 数据量较小时可以人工获取数据, 但往往在公司中爬取的数据量在百万条, 千万条级别的, 所以要程序自动化获取数据.</span><br></pre>

<h4 id="爬虫的语言"><a href="#爬虫的语言" class="headerlink" title="爬虫的语言"></a>爬虫的语言</h4><pre class="highlight"><span class="line"><span class="comment"># 爬虫语言:PHP, C/C++, Java, Python, GoLang, nodejs</span></span><br><span class="line"><span class="comment"># 对比:</span></span><br><span class="line">	PHP: 并发能力差, 对多进程和多线程支持不好, 数据量较大时爬虫效率较低</span><br><span class="line">    C/C++: 语言效率高, 但学习成本高, 对程序员的技术能力要求较高,  所以目前还停留在研究层面, 市场需求量很小</span><br><span class="line">    Java: Python爬虫的主要竞争对手, 由于Java语言的特点, 代码臃肿, 代码量大, 维护成本重构成本高, 开发效率低. 但目前市场上岗位需求比较旺盛.</span><br><span class="line">    Python: 语法简单, 学习成本较低, 对新手比较友好. Python语言良好的生态, 大量库和框架的支持是的Python爬虫目前处于爬虫圈的主导地位.</span><br></pre>

<h4 id="爬虫的分类"><a href="#爬虫的分类" class="headerlink" title="爬虫的分类"></a>爬虫的分类</h4><ol>
<li><p>通用爬虫</p>
</li>
<li><p>聚焦爬虫（可分为）</p>
<p>增量式</p>
<p>深度爬虫</p>
</li>
</ol>
<pre class="highlight"><span class="line"><span class="number">1.</span>通用爬虫:搜索引擎</span><br><span class="line"><span class="comment"># 实例: 百度, 搜狗, Google的搜索引擎</span></span><br><span class="line"><span class="comment"># 功能: 访问网页 -&gt; 抓取数据 -&gt; 数据处理 -&gt; 提供检索服务</span></span><br><span class="line"><span class="comment"># 工作流:</span></span><br><span class="line">        <span class="number">1.</span>给定一个起始URL, 存于爬取队列中</span><br><span class="line">        <span class="number">2.</span>爬虫程序从队列中取出url, 爬取数据</span><br><span class="line">        <span class="number">3.</span>解析爬取数据, 获取网页内的所有url, 需要的数据, 放入爬取队列</span><br><span class="line">        <span class="number">4.</span>重复第二个步骤</span><br><span class="line"><span class="comment"># 使搜索引擎获取网站链接:</span></span><br><span class="line">        <span class="number">1.</span>主动将url提交给搜索引擎(https://ziyuan.baidu.com/linksubmit/url)</span><br><span class="line">        <span class="number">2.</span>在其他热门网站设置友情连接</span><br><span class="line">        <span class="number">3.</span>百度和DNS服务商合作, 收录新网站</span><br><span class="line"><span class="comment"># 网站排名(SEO):</span></span><br><span class="line">		<span class="number">1.</span>根据PageRank值进行排名(流量, 点击率)</span><br><span class="line">		<span class="number">2.</span>百度竞价排名, 钱多就靠前排</span><br><span class="line"><span class="comment"># 缺点:</span></span><br><span class="line">		<span class="number">1.</span>抓取的内容多数无用</span><br><span class="line">		<span class="number">2.</span>无法精确获取数据</span><br><span class="line"><span class="comment"># 协议: robots协议 --&gt;  约定哪些内容允许哪些爬虫抓取</span></span><br><span class="line">		<span class="number">1.</span>无需遵守, 该协议适用于通用爬虫同样也适用于聚焦爬虫, 而我们写的是聚焦爬虫</span><br><span class="line">		<span class="number">2.</span>查看方法: 网站url/robots.txt, 如https://www.baidu.com/robots.txt</span><br></pre>

<pre class="highlight"><span class="line"><span class="number">2.</span>聚焦爬虫</span><br><span class="line"><span class="comment"># 概念:</span></span><br><span class="line">	聚焦爬虫指针对某一领域根据特定要求实现的爬虫程序, 抓取需要的数据(垂直领域爬取)</span><br><span class="line"><span class="comment"># 设计思路:*****</span></span><br><span class="line">	(<span class="number">1</span>).确定爬取的url, 模拟浏览器向服务器发送请求</span><br><span class="line">	(<span class="number">2</span>).获取响应数据并进行数据解析</span><br><span class="line">	(<span class="number">3</span>).将目标数据持久化到本地</span><br></pre>

<h4 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP UDP"></a>TCP UDP</h4><pre class="highlight"><span class="line"><span class="comment"># TCP与UDP</span></span><br><span class="line"><span class="number">1.</span>TCP协议:是一种面向连接的, 可靠的, 基于字节流的传输层通信协议</span><br><span class="line">    <span class="number">1</span>).有序性: 数据包编号, 判断数据包的正确次序</span><br><span class="line">    <span class="number">2</span>).正确性: 使用checksum函数检查数据包是否损坏, 发送接收时都会计算校验和</span><br><span class="line">    <span class="number">3</span>).可靠性:	发送端有超时重发, 并有确认机制识别错误和数据的丢失</span><br><span class="line">    <span class="number">4</span>).可控性: 滑动窗口协议与拥塞控制算法控制数据包的发送速度</span><br><span class="line"><span class="number">2.</span>UDP协议: 用户数据报协议, 面向无连接的传输层协议, 传输不可靠.</span><br><span class="line">    <span class="number">1</span>).无连接, 数据可能丢失或损坏</span><br><span class="line">    <span class="number">2</span>).报文小, 传输速度快</span><br><span class="line">    <span class="number">3</span>).吞吐量大的网络传输, 可以在一定程度上承受数据丢失</span><br></pre>

<h4 id="服务器常见的默认端口"><a href="#服务器常见的默认端口" class="headerlink" title="服务器常见的默认端口"></a>服务器常见的默认端口</h4><pre class="highlight"><span class="line"><span class="number">1.</span>ftp: File Transfer Protocol的缩写, 即文件传输协议. 端口:<span class="number">21</span></span><br><span class="line"><span class="number">2.</span>ssh: Secure Shell的缩写, 用于远程登录会话. 端口:<span class="number">22</span></span><br><span class="line"><span class="number">3.</span>MySQL: 关系型数据库, 端口:<span class="number">3306</span></span><br><span class="line"><span class="number">4.</span>MongoDB: 非关系型数据库, 端口:<span class="number">27017</span></span><br><span class="line"><span class="number">5.</span>Redis: 非关系型数据库, 端口:<span class="number">6379</span></span><br></pre>

]]></content>
      <tags>
        <tag>spider</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象五大原则SOLID</title>
    <url>/2020/07/29/s_i/</url>
    <content><![CDATA[<h4 id="浅谈面向对象五大原则-S-O-L-I-D"><a href="#浅谈面向对象五大原则-S-O-L-I-D" class="headerlink" title="浅谈面向对象五大原则 S.O.L.I.D"></a>浅谈面向对象五大原则 S.O.L.I.D</h4><p>设计模式中的SOLID原则，分别是单一原则、开闭原则、里氏替换原则、接口隔离原则、依赖倒置原则。前辈们总结出来的，遵循五大原则可以使程序解决紧耦合，更加健壮。<br>s<br>SRP    单一责任原则<br>OCP    开放封闭原则<br>LSP    里氏替换原则<br>ISP    接口隔离原则<br>DIP    依赖倒置原则</p>
<h4 id="单一责任原则"><a href="#单一责任原则" class="headerlink" title="单一责任原则"></a>单一责任原则</h4><p>指的是一个类或者一个方法只做一件事。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化就可能抑制或者削弱这个类完成其他职责的能力。例如餐厅服务员负责把订单给厨师去做，而不是服务员又要订单又要炒菜。</p>
<h4 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h4><p>对扩展开放，对修改关闭。意为一个类独立之后就不应该去修改它，而是以扩展的方式适应新需求。例如一开始做了普通计算器程序，突然添加新需求，要再做一个程序员计算器，这时不应该修改普通计算器内部，应该使用面向接口编程，组合实现扩展</p>
<h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><p>所有基类出现的地方都可以用派生类替换而不会程序产生错误。子类可以扩展父类的功能，但不能改变父类原有的功能。例如机动车必须有轮胎和发动机，子类宝马和奔驰不应该改写没轮胎或者没发动机。</p>
<h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p>指的是高级模块不应该依赖低级模块，而是依赖抽象。抽象不能依赖细节，细节要依赖抽象。比如类A内有类B对象，称为类A依赖类B，但是不应该这样做，而是选择类A去依赖抽象。例如垃圾收集器不管垃圾是什么类型，要是垃圾就行。</p>
<h4 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h4><p>没人写一款程序能完全遵守SOLID原则，甚至有些设计模式是违反SOLID原则。如何权衡就要看利是否大于弊。不足之处望指教。s</p>
<p>转载于：<a><a href="https://www.cnblogs.com/suli0827/p/9515842.html" target="_blank" rel="noopener">https://www.cnblogs.com/suli0827/p/9515842.html</a></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础数据类型</title>
    <url>/2020/07/06/s_u/</url>
    <content><![CDATA[<h4 id="python的主要数据类型包括："><a href="#python的主要数据类型包括：" class="headerlink" title="python的主要数据类型包括："></a>python的主要数据类型包括：</h4><ol>
<li>int (整形)</li>
<li>long(长整型)</li>
<li>float(浮点型)</li>
<li>complex（复数）</li>
<li>字符串</li>
<li>布尔型</li>
<li>列表</li>
<li>元组</li>
<li>字典</li>
<li>集合</li>
</ol>
<h5 id="int（整型）"><a href="#int（整型）" class="headerlink" title="int（整型）"></a>int（整型）</h5><p>在32位机器上，整数的位数是32位，取值范围是-231<del>231-1，即-2147483648</del>214748364；在64位系统上，整数的位数为64位，取值范围为-263<del>263-1，即9223372036854775808</del>9223372036854775807。</p>
<h5 id="long（长整型）"><a href="#long（长整型）" class="headerlink" title="long（长整型）"></a>long（长整型）</h5><p>Python长整型没有指定位宽，但是由于机器内存有限，使用长的长整数数值也不可能无限大。</p>
<h5 id="float（浮点型）"><a href="#float（浮点型）" class="headerlink" title="float（浮点型）"></a>float（浮点型）</h5><p>浮点型也就是带有小数点的数，其精度和机器有关。</p>
<h5 id="complex（复数）"><a href="#complex（复数）" class="headerlink" title="complex（复数）"></a>complex（复数）</h5><p>Python还支持复数，复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型。</p>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>Python中的字符串有两种数据类型，分别是str类型和unicode类型，str类型采用的ASCII编码，无法表示中文，unicode类型采用unicode编码，能够表示任意字符，包括中文和其他语言。</p>
<pre class="highlight"><span class="line">状态获取：islower，isupper，isdigit，isalpha，isalnum，istitle，startswith，endswith</span><br><span class="line">状态转换：lower，casefold，upper，swapcase，title(单词首字母大写)，capitalize(字符串首字母大写)</span><br><span class="line">格式转换：strip(去掉左右两边参数字符串中的字符)，ljust，rjust，center，zfill（左侧补零）</span><br><span class="line">拆分：partition，rpartiton，spilt，splitlines</span><br><span class="line">连接：join，+</span><br><span class="line">查询：index，find，count</span><br><span class="line">替换操作：replace，expandtabs</span><br><span class="line">基本操作：索引取值，len，max，min，<span class="keyword">in</span>，<span class="keyword">not</span> <span class="keyword">in</span></span><br></pre>



<h5 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h5><p>和其他编程语言一样，Python布尔类型也是用于逻辑运算，有两个值：True（真）和False（假）。</p>
<h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><p>列表是Python中使用最频繁的数据类型，集合中可以放任何数据类型，可对集合进行创建、查找、切片、增加、修改、删除、循环和排序操作。</p>
<pre class="highlight"><span class="line">增加：append,insert,extend</span><br><span class="line">删除：remove,pop,clear</span><br><span class="line">查询：index,count</span><br></pre>



<h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5><p>元组和列表一样，也是一种序列，与列表不同的是，元组是不可修改的，元组用”()”标识，内部元素用逗号隔开。</p>
<pre class="highlight"><span class="line">查询：index，count</span><br></pre>



<h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5><p>字典是一种键值对的集合，是除列表以外Python之中最灵活的内置数据结构类型，列表是有序的对象集合，字典是无序的对象集合。</p>
<pre class="highlight"><span class="line">增加：add</span><br><span class="line">删除：pop（第一个），clear，remove</span><br><span class="line">交集：&amp;</span><br><span class="line">并集：|</span><br><span class="line">差集：set1-set2</span><br><span class="line">对称差集：并集-交集</span><br></pre>



<h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p>集合是一个无序的、不重复的数据组合，它的主要作用有两个，分别是去重和关系测试。</p>
<pre class="highlight"><span class="line">增加:字典[<span class="string">'键'</span>] = 值</span><br><span class="line">删除：pop,popitem,clear</span><br><span class="line">修改：update(dict)</span><br><span class="line">查询：get,keys,items,values,setdefault:有对应的键则返回对应的值，没有则返回默认给定的值</span><br></pre>

]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>啊这！生成器</title>
    <url>/2019/07/29/scq/</url>
    <content><![CDATA[<p>在python中，一边循环一边计算的机制，称之为生成器（generator）</p>
<h4 id="生成器的存在："><a href="#生成器的存在：" class="headerlink" title="生成器的存在："></a>生成器的存在：</h4><p>列表所有的数据都在内存中，如果有海量的数据将会非常消耗内存。<br>如：仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。<br>如果列表元素按照某种算法退出来，那我们就可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的list，从而节省大量的空间。</p>
<p>说白点！！ 要想得到庞大的数据，又想让它占用空间少，就就就就用生成器！</p>
<p>第一种生成生成器的方法把【】改成（）则就是生成器</p>
<p>第二种 如果一个函数中包含yield关键字，那么这个函数就不在是个普通的函数，而是一个generator。调用函数就是创建了一个生成器。</p>
<h4 id="生成器的工作原理："><a href="#生成器的工作原理：" class="headerlink" title="生成器的工作原理："></a>生成器的工作原理：</h4><p>首先，生成器是一种特殊的迭代器，它的yield方法将迭代器的next，封装到了yield关键字中，他与return不同的是：遇见return就已经返回了，而遇见yield则我们去计算下一个元素的位置。</p>
<p>我们也可以通过next（）进行取值，也可以利用for循环（每次执行一次，取生成器里面一个值） 可以使用send（）强行修改yield的值。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>什么是生成器？<br>生成器仅仅保存了一套生成数值的算法，并且没有让这个算法现在就开始执行，而是我什么时候调它，它什么时候开始计算一个新的值，并给你返回。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>又拍云存储</title>
    <url>/2020/05/06/u_y/</url>
    <content><![CDATA[<h4 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h4><pre class="highlight"><span class="line">pip install upyun</span><br></pre>

<h4 id="django接口"><a href="#django接口" class="headerlink" title="django接口"></a>django接口</h4><pre class="highlight"><span class="line"><span class="comment"># 又拍云存储</span></span><br><span class="line"><span class="keyword">import</span> upyun</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpYun</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment"># 获取文件</span></span><br><span class="line">        file = request.FILES.get(<span class="string">'file'</span>)</span><br><span class="line">        <span class="comment"># 新建又拍云实例</span></span><br><span class="line">        print(file)</span><br><span class="line">        up = upyun.UpYun(<span class="string">'pc-upyun'</span>,<span class="string">'test111'</span>,<span class="string">'3KgVpePLSHkBF0EmWWWkOcgNak2e2STd'</span>)</span><br><span class="line">        <span class="comment"># 声明头部信息</span></span><br><span class="line">        headers=&#123;<span class="string">'x-gmkerl-rotate'</span>:<span class="string">'auto'</span>&#125;</span><br><span class="line">        <span class="comment"># 上传图像</span></span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> file.chunks():</span><br><span class="line">            res = up.put(<span class="string">'/touxiang_test1.jpg'</span>,chunk,checksum=<span class="literal">True</span>,headers=headers)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'filename'</span>:file.name&#125;)</span><br></pre>

<h4 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h4><pre class="highlight"><span class="line">path(<span class="string">'upyun/'</span>,UpYun.as_view())</span><br></pre>



<h4 id="vue接口"><a href="#vue接口" class="headerlink" title="vue接口"></a>vue接口</h4><pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;!-- &lt;/img :src="src" /&gt; --&gt;</span><br><span class="line">        又拍云存储：&lt;Avatar :src="yp_url" :width='150' fil='fill'&gt;&lt;/Avatar&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"file"</span> @change=<span class="string">"upload_upyun"</span> /&gt;</span><br><span class="line">        &lt;div class="upload"&gt;</span><br><span class="line">            拖拽上传</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            src :<span class="string">''</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  mounted:function()&#123;</span><br><span class="line">    // 每次进入页面 获取最新的token</span><br><span class="line">    this.get_token()</span><br><span class="line">    // 注册拖拽容器</span><br><span class="line">    let upload = document.querySelector(<span class="string">"#upload"</span>)</span><br><span class="line">    // 声明监听事件</span><br><span class="line">    upload.addEventListener(<span class="string">'dragenter'</span>,this.onDrag,false);</span><br><span class="line">    upload.addEventListener(<span class="string">'dragover'</span>,this.onDrag,false)</span><br><span class="line">    upload.addEventListener(<span class="string">'drop'</span>,this.onDrop,false)</span><br><span class="line">&#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">        // 监听用户鼠标</span><br><span class="line">        onDrag(e)&#123;</span><br><span class="line">          e.stopPropagation();</span><br><span class="line">          e.preventDefault();</span><br><span class="line">        &#125;,</span><br><span class="line">        onDrop(e)&#123;</span><br><span class="line">          e.stopPropagation();</span><br><span class="line">          e.preventDefault();</span><br><span class="line">          // 调用自定义方法</span><br><span class="line">          this.upload_upyun(e.dataTransfer.files)</span><br><span class="line">        &#125;,</span><br><span class="line">      // 又拍云 拖拽方法</span><br><span class="line">        upload_upyun:function(e)&#123;</span><br><span class="line">          // 获取拖拽文件</span><br><span class="line">          let file = e.target.files[<span class="number">0</span>]</span><br><span class="line">          // 声明参数</span><br><span class="line">          let param = new FormData();</span><br><span class="line">          param.append(<span class="string">'file'</span>,file);</span><br><span class="line">          // 声明头部信息</span><br><span class="line">          const config = &#123;</span><br><span class="line">            headers:&#123;</span><br><span class="line">              <span class="string">'Content-Type'</span>:<span class="string">'multipart/form-data'</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;     this.axios.post('http://127.0.0.1:8000/upyun/',param,config).then((result=&gt;&#123;</span><br><span class="line">            console.log(result)</span><br><span class="line">          &#125;))</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.upload &#123;</span><br><span class="line">  margin: <span class="number">100</span>px auto;</span><br><span class="line">  width: <span class="number">300</span>px;</span><br><span class="line">  height: <span class="number">150</span>px;</span><br><span class="line">  border: <span class="number">2</span>px dashed <span class="comment">#f00;</span></span><br><span class="line">  padding-top: <span class="number">50</span>px;</span><br><span class="line">  padding-left: <span class="number">80</span>px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre>

<h4 id="又拍云文件操作"><a href="#又拍云文件操作" class="headerlink" title="又拍云文件操作"></a>又拍云文件操作</h4><pre class="highlight"><span class="line"><span class="keyword">import</span> upyun</span><br><span class="line"><span class="comment">#实例化</span></span><br><span class="line">up = upyun.UpYun(<span class="string">"空间名"</span>,<span class="string">'操作员'</span>,<span class="string">'密码'</span>)</span><br><span class="line"><span class="comment">#读内存上传</span></span><br><span class="line">up.put(<span class="string">'自定义文件名'</span>,<span class="string">'文件内容'</span>)</span><br><span class="line"><span class="comment">#文件流操作（节省内存）</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'文件路径/文件名'</span>,<span class="string">'rb'</span>)<span class="keyword">as</span> f:</span><br><span class="line">    res = up.put(<span class="string">'自定义文件名'</span>,f,checksum=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#目录操作</span></span><br><span class="line">up.mkdir(<span class="string">'/文件夹名/'</span>)</span><br><span class="line"><span class="comment">#移动文件</span></span><br><span class="line">up.move(<span class="string">'/文件路径/文件名'</span>,<span class="string">'/新文件路径/文件名'</span>)</span><br><span class="line"><span class="comment">#复制文件</span></span><br><span class="line">up.copy(<span class="string">'/文件路径/文件名'</span>,<span class="string">'/新文件路径/文件名'</span>)</span><br><span class="line"><span class="comment">#断点续传</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'文件路径/文件名'</span>,<span class="string">'rb'</span>)<span class="keyword">as</span> f:</span><br><span class="line">    res = up.put(<span class="string">'自定义文件名'</span>,f,checksum=<span class="literal">True</span>，need_resume=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#下载</span></span><br><span class="line">res = up.get(<span class="string">'/文件路径/文件名'</span>)</span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line">up.delete(<span class="string">'/文件路径/文件名'</span>)</span><br></pre>

]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python五大排序算法</title>
    <url>/2020/07/06/suan/</url>
    <content><![CDATA[<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>插入排序：插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序；首先将第一个作为已经排好序的，然后每次从后的取出插入到前面并排序；</p>
<p>时间复杂度：O(n²)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：稳定</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(ilist)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ilist)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">            <span class="keyword">if</span> ilist[i] &lt; ilist[j]:</span><br><span class="line">                ilist.insert(j, ilist.pop(i))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> ilist</span><br></pre>

<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成</p>
<p>时间复杂度：O(n²)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：稳定</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(blist)</span>:</span></span><br><span class="line">    count = len(blist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, count):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, count):</span><br><span class="line">            <span class="keyword">if</span> blist[i] &gt; blist[j]:</span><br><span class="line">                blist[i], blist[j] = blist[j], blist[i]</span><br><span class="line">    <span class="keyword">return</span> blist</span><br><span class="line"></span><br><span class="line">blist = bubble_sort([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br><span class="line">print(blist)</span><br></pre>

<h4 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h4><p>快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</p>
<p>时间复杂度：O(nlog₂n)</p>
<p>空间复杂度：O(nlog₂n)</p>
<p>稳定性：不稳定</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(qlist)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> qlist == []:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        qfirst = qlist[<span class="number">0</span>]</span><br><span class="line">        qless = quick_sort([l <span class="keyword">for</span> l <span class="keyword">in</span> qlist[<span class="number">1</span>:] <span class="keyword">if</span> l &lt; qfirst])</span><br><span class="line">        qmore = quick_sort([m <span class="keyword">for</span> m <span class="keyword">in</span> qlist[<span class="number">1</span>:] <span class="keyword">if</span> m &gt;= qfirst])</span><br><span class="line">        <span class="keyword">return</span> qless + [qfirst] + qmore</span><br><span class="line"></span><br><span class="line">qlist = quick_sort([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br></pre>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序：第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕</p>
<p>时间复杂度：O(n²)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：不稳定</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(slist)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(slist)):</span><br><span class="line">        x = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(slist)):</span><br><span class="line">            <span class="keyword">if</span> slist[j] &lt; slist[x]:</span><br><span class="line">                x = j</span><br><span class="line">        slist[i], slist[x] = slist[x], slist[i]</span><br><span class="line">    <span class="keyword">return</span> slist</span><br><span class="line"></span><br><span class="line">slist = select_sort([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>])</span><br></pre>

<h4 id="归并算法"><a href="#归并算法" class="headerlink" title="归并算法"></a>归并算法</h4><p>归并排序：采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并</p>
<p>时间复杂度：O(nlog₂n)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：稳定</p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge_arr</span><span class="params">(arr_l, arr_r)</span>:</span></span><br><span class="line">        array = []</span><br><span class="line">        <span class="keyword">while</span> len(arr_l) <span class="keyword">and</span> len(arr_r):</span><br><span class="line">            <span class="keyword">if</span> arr_l[<span class="number">0</span>] &lt;= arr_r[<span class="number">0</span>]:</span><br><span class="line">                array.append(arr_l.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">elif</span> arr_l[<span class="number">0</span>] &gt; arr_r[<span class="number">0</span>]:</span><br><span class="line">                array.append(arr_r.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">if</span> len(arr_l) != <span class="number">0</span>:</span><br><span class="line">            array += arr_l</span><br><span class="line">        <span class="keyword">elif</span> len(arr_r) != <span class="number">0</span>:</span><br><span class="line">            array += arr_r</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recursive</span><span class="params">(array)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(array) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> array</span><br><span class="line">        mid = len(array) // <span class="number">2</span></span><br><span class="line">        arr_l = recursive(array[:mid])</span><br><span class="line">        arr_r = recursive(array[mid:])</span><br><span class="line">        <span class="keyword">return</span> merge_arr(arr_l, arr_r)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recursive(array)</span><br></pre>

]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务</title>
    <url>/2020/07/29/v_w/</url>
    <content><![CDATA[<p>微服务（Microservice）这个概念是2012年出现的，作为加快Web和移动应用程序开发进程的一种方法，2014年开始受到各方的关注，而2015年，可以说是微服务的元年；</p>
<p>越来越多的论坛、社区、blog以及互联网行业巨头开始对微服务进行讨论、实践，可以说这样更近一步推动了微服务的发展和创新。而微服务的流行，Martin Fowler功不可没。</p>
<p>1 互联网的快速发展</p>
<p>2 敏捷开发 精益方法的深入人心</p>
<p>3 容器技术的成熟</p>
<h4 id="传统的项目架构？"><a href="#传统的项目架构？" class="headerlink" title="传统的项目架构？"></a>传统的项目架构？</h4><p><strong>优点：</strong></p>
<p>①开发简单，集中式管理</p>
<p>②基本不会重复开发</p>
<p>③功能都在本地，没有分布式的管理和调用消耗</p>
<p><strong>缺点：</strong></p>
<p>1、效率低：开发都在同一个项目改代码，相互等待，冲突不断</p>
<p>2、维护难：代码功功能耦合在一起，新人不知道何从下手</p>
<p>3、不灵活：构建时间长，任何小修改都要重构整个项目，耗时</p>
<p>4、稳定性差：一个微小的问题，都可能导致整个应用挂掉</p>
<p>5、扩展性不够：无法满足高并发下的业务需求</p>
<p><strong>常见的系统架构遵循的三个标准和业务驱动力：</strong></p>
<p>1、提高敏捷性：及时响应业务需求，促进企业发展</p>
<p>2、提升用户体验：提升用户体验，减少用户流失</p>
<p>3、降低成本：降低增加产品、客户或业务方案的成本</p>
<h4 id="现在我们来看一下微服务必须需要的原则？"><a href="#现在我们来看一下微服务必须需要的原则？" class="headerlink" title="现在我们来看一下微服务必须需要的原则？"></a>现在我们来看一下微服务必须需要的原则？</h4><p>1，单一功能职责</p>
<p>   单一功能职责是SOLID设计模式之一，它意味着一个单元，无论是类、函数还是微服务，都应该有且只有一个职责。在任何时候，一个微服务都不应该有一个以上的职责。</p>
<p>2，围绕着业务功能设计</p>
<p>   微服务应该专注于特定的业务功能，并确保它有助于完成任务。微服务绝不应限制自己采用最适合解决业务目的的适当技术栈或后端数据库存储。当我们设计单个应用程序时，这常常是一个约束，我们试图在某些领域中使用一些折中来解决多个业务解决方案。微服务使您能够选择最适合当前问题的解决方案。（某个微服务不仅仅只为一个微服务来服务，他要为其他的微服务提供支持，也就是全局的架构）</p>
<p>3，你建造它，你拥有它。</p>
<p>这种设计的另一个重要方面与开发前后的职责有关。在大型组织中，通常由一个团队开发app location(应用)，经过一些知识转移会议后，将项目移交给维护团队。在微服务中，构建服务的团队拥有它，并负责在将来维护它。这使开发人员能够接触到他们的软件的日常操作，并且他们能够更好地理解他们构建的产品在现实世界中是如何被客户使用的。</p>
<p>4，基础设施自动化</p>
<p>准备和构建微服务的基础设施是另一个非常重要的需求，服务应该是可独立部署的，并且应该捆绑所有依赖项，包括库依赖项，甚至是执行环境，如抽象物理资源（web服务器和容器或虚拟机）。</p>
<p>微服务和SOA之间的一个主要区别在于它们的自治级别。虽然大多数SOA实现提供了服务级抽象，但是微服务更进一步抽象了实现和执行环境。</p>
<p>在传统的应用程序开发中，我们构建一个WAR或EAR，然后将其部署到JEE应用程序服务器中，例如使用JBoss、WebLogic、WebSphere等等。我们可以将多个应用程序部署到同一个JEE容器中。在理想的场景中，在微服务方法中，每个微服务将构建为一个胖Jar，嵌入所有依赖项，并作为独立的Java进程运行。</p>
<p>5，容错设计</p>
<p>微服务的设计应考虑到故障情况。如果服务失败，或者宕机一段时间，该怎么办?这些都是非常重要的问题，必须在实际编码开始之前解决——以便清楚地估计服务故障将如何影响用户体验。</p>
<p>快速故障是另一个用于构建容错、弹性系统的概念。这种哲学提倡预期失败的系统，而不是构建永远不会失败的系统。由于服务在任何时候都可能失败，因此能够快速检测故障并在可能的情况下自动恢复服务非常重要。</p>
<p>微服务应用程序非常重视应用程序的实时监控，检查体系结构元素(数据库每秒接收多少请求)和业务相关指标(例如每分钟接收多少订单)。语义监视可以提供出错的早期预警系统，从而触发开发团队进行跟踪和调查。</p>
<h4 id="微服务的目的？"><a href="#微服务的目的？" class="headerlink" title="微服务的目的？"></a>微服务的目的？</h4><p><strong>目的：</strong>有效的拆分应用，实现敏捷开发和部署</p>
<h4 id="微服务的优点-？"><a href="#微服务的优点-？" class="headerlink" title="微服务的优点 ？"></a>微服务的优点 ？</h4><p>微服务有许多优点相比传统的多层架构（单体庞大应用），微服务的优点如下：</p>
<p>1，使用微服务，架构师和开发人员可以为每个微服务选择适合于特定用途的架构和技术(通晓多种语言对应的熟悉语言的架构)。这为以更经济有效的方式设计更适合的解决方案提供了灵活性。</p>
<p>2，由于服务相当简单，而且规模更小，企业可以试验新的流程、算法、业务逻辑等等。它通过提供快速试验和失败的能力，使企业能够进行颠覆性创新。</p>
<p>3，微服务能够实现选择性的可伸缩性，即每个服务都可以独立地伸缩，而且伸缩的成本相对于单体应用方面要低。</p>
<p>4，微服务是自包含的、独立的部署模块，当第二个微服务没有按照我们的需要执行时，可以使用另一个类似的微服务替换一个微服务。它有助于做出正确的“购买构建”决策，而这通常是许多企业面临的挑战。</p>
<p>5，微服务帮助我们构建本质上是有机的系统(有机的系统是通过添加越来越多的功能在一段时间内横向增长的系统)。因为微服务都是关于独立可管理的服务——它允许在需要时添加越来越多的服务，而对现有服务的影响最小。</p>
<p>6，技术变化是软件开发中的障碍之一。使用微服务，可以单独更改或升级每个服务的技术，而不是升级整个应用程序。</p>
<p>7，由于microservices将服务运行时环境和服务本身打包在一起，因此允许在同一环境中共存多个版本的服务。</p>
<p>8，最后，微服务还支持更小、更专注的敏捷开发团队。团队将根据微服务的边界进行组织。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义图片验证码</title>
    <url>/2020/04/24/y_m/</url>
    <content><![CDATA[<h4 id="首先我们需要用到一下库"><a href="#首先我们需要用到一下库" class="headerlink" title="首先我们需要用到一下库"></a>首先我们需要用到一下库</h4><pre class="highlight"><span class="line"><span class="comment">#绘画库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageDraw</span><br><span class="line"><span class="comment">#图片库</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="comment">#随机库</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#文件流</span></span><br><span class="line"><span class="keyword">import</span> io</span><br></pre>
<h4 id="后台代码如下"><a href="#后台代码如下" class="headerlink" title="后台代码如下"></a>后台代码如下</h4><pre class="highlight"><span class="line"><span class="comment"># 自定义图片验证码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCode</span><span class="params">(View)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义rgb随机颜色</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_random_color</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        R = random.randrange(<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">        G = random.randrange(<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">        B = random.randrange(<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (R,G,B)</span><br><span class="line">    <span class="comment"># 定义图片视图</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,reuqest)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 画布</span></span><br><span class="line">        img_size = (<span class="number">120</span>,<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义图片对象</span></span><br><span class="line">        image = Image.new(<span class="string">'RGB'</span>,img_size,<span class="string">'white'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义画笔</span></span><br><span class="line">        draw = ImageDraw.Draw(image,<span class="string">'RGB'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 随机字母</span></span><br><span class="line">        source = <span class="string">'1256453534&amp;32qwertyyuiycvbnbdsf'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接收容器</span></span><br><span class="line">        code_str = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 进入循环绘制</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 获取字母颜色</span></span><br><span class="line">            text_color = self.get_random_color()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 获取随机下标</span></span><br><span class="line">            tmp_num = random.randrange(len(source))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 随机字符串</span></span><br><span class="line">            random_str = source[tmp_num]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 装入容器中</span></span><br><span class="line">            code_str += random_str</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 绘制字符串</span></span><br><span class="line">            draw.text((<span class="number">10</span>+<span class="number">30</span>*i,<span class="number">20</span>),random_str,text_color)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取缓存区</span></span><br><span class="line">        buf = io.BytesIO()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 临时图图片保存在缓冲</span></span><br><span class="line">        image.save(buf,<span class="string">'png'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(buf.getvalue(),<span class="string">'image/png'</span>)</span><br></pre>
<p> 简单的验证码绘制完成</p>
<h3 id="在前端的操作"><a href="#在前端的操作" class="headerlink" title="在前端的操作"></a>在前端的操作</h3><pre class="highlight"><span class="line"><span class="number">1.</span>首先我们需要的input文本</span><br><span class="line"></span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        验证码：&lt;input type=<span class="string">"text"</span> v-model=<span class="string">"code"</span>&gt;</span><br><span class="line">    &lt;/td&gt;</span><br><span class="line"></span><br><span class="line">    注：我们需要双向绑定一个code 这个code作为验证码的信息传给后端</span><br></pre>

<h3 id="获取后台的验证码的地址"><a href="#获取后台的验证码的地址" class="headerlink" title="获取后台的验证码的地址"></a>获取后台的验证码的地址</h3><pre class="highlight"><span class="line">path(<span class="string">'code/'</span>,MyCode.as_view()) <span class="comment">#这是我们设定路由为code 运行django项目 进入这个路由 导航栏的地址 ctrl+c</span></span><br></pre>

<h3 id="之后前端验证码进行展示"><a href="#之后前端验证码进行展示" class="headerlink" title="之后前端验证码进行展示"></a>之后前端验证码进行展示</h3><pre class="highlight"><span class="line">首先我们需要个img标签来展示验证码    </span><br><span class="line"></span><br><span class="line">    &lt;img :src="src" alt="点击刷新" @click="changecode" class="imagecode"&gt;</span><br><span class="line"></span><br><span class="line">    注：用v-bind绑定,src代表地址，此时我们从后端复制的地址，则定义变量进行存储\</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        code:<span class="string">''</span>, <span class="comment"># 验证码,</span></span><br><span class="line">        src:<span class="string">'http://127.0.0.1:8000/code/'</span>, <span class="comment"># 图片地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    就是这个样子</span><br></pre>

<h3 id="我们点击验证码的时候需要刷新-点一下刷新一下"><a href="#我们点击验证码的时候需要刷新-点一下刷新一下" class="headerlink" title="我们点击验证码的时候需要刷新 点一下刷新一下"></a>我们点击验证码的时候需要刷新 点一下刷新一下</h3><pre class="highlight"><span class="line">   <span class="number">1.</span>看见@click这个点击事件，所以我们在下面定义一个叫changecode的方法 用于点击刷新</span><br><span class="line">       </span><br><span class="line">       <span class="comment"># 点击刷新</span></span><br><span class="line">       changecode:function()&#123;</span><br><span class="line">           <span class="comment"># 生成随机数</span></span><br><span class="line">           var num = Math.ceil(Math.random()*<span class="number">100</span>)</span><br><span class="line">           <span class="comment"># 进行传参	</span></span><br><span class="line">           this.src = this.src + <span class="string">'?num ='</span>+num   <span class="comment"># 路由拼接</span></span><br><span class="line">&#125;</span><br></pre>

<h3 id="存储redis"><a href="#存储redis" class="headerlink" title="存储redis"></a>存储redis</h3><pre class="highlight"><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="comment"># 连接redis</span></span><br><span class="line">host = <span class="string">"localhost"</span> <span class="comment"># 本地端口</span></span><br><span class="line">port = <span class="number">6379</span> <span class="comment"># redis端口号</span></span><br><span class="line">r = redis.Redis(host=host,port=port) <span class="comment">#连接  </span></span><br><span class="line"><span class="comment"># 保存随机码</span></span><br><span class="line">r.set(<span class="string">'code'</span>,code_str)</span><br><span class="line"><span class="comment"># 读取则用 </span></span><br><span class="line">r.get(<span class="string">'code'</span>)</span><br><span class="line"></span><br><span class="line">ok廖！！</span><br></pre>

<h3 id="之后登陆就简单了"><a href="#之后登陆就简单了" class="headerlink" title="之后登陆就简单了"></a>之后登陆就简单了</h3><pre class="highlight"><span class="line">code = request.GET.get(<span class="string">'code'</span>,<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 比对验证码</span></span><br><span class="line">redis_code = r.get(<span class="string">'code'</span>)</span><br><span class="line"><span class="comment"># 转码</span></span><br><span class="line">redis_code = redis_code.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment"># if贩判断</span></span><br><span class="line"><span class="keyword">if</span> code != redis_code:</span><br><span class="line">    <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>:<span class="number">403</span>,<span class="string">'msg'</span>:<span class="string">"您输入的验证码有误"</span>&#125;)</span><br><span class="line"></span><br><span class="line">注：在这里有一个坑需要suo一下 我们必须进行转码操作，这样才能进行判断。</span><br><span class="line">    如果不进行转码，则无法比较，因为不转码 redis_code的值将会是二进制，所以decode一下。</span><br></pre>

]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>智能识别验证码</title>
    <url>/2020/04/26/y_p/</url>
    <content><![CDATA[<p>百度云识别攻略： <a href="https://v3u.cn/a_id_134" target="_blank" rel="noopener">https://v3u.cn/a_id_134</a> </p>
<h4 id="识别"><a href="#识别" class="headerlink" title="识别"></a>识别</h4><pre class="highlight"><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"></span><br><span class="line">option = ChromeOptions()  <span class="comment"># 实例化一个ChromeOptions对象</span></span><br><span class="line">option.add_experimental_option(<span class="string">'excludeSwitches'</span>, [<span class="string">'enable-automation'</span>])  <span class="comment"># 以键值对的形式加入参数</span></span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br><span class="line"></span><br><span class="line"><span class="comment">#发起请求</span></span><br><span class="line">browser.get(<span class="string">'http://127.0.0.1:8080/login)</span></span><br><span class="line"><span class="string"># 获取验证码标签 并截图到本地 get_screenshot_as_file截全图</span></span><br><span class="line">browser.find_element_by_xpath('//img[@class="code"]').screenshot('./code_img/code.png')</span><br><span class="line"><span class="comment">#读图</span></span><br><span class="line">img = cv2.imread(<span class="string">'./code_img/code.png'</span>,cv2.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="comment">#写图</span></span><br><span class="line">cv2.imwrite(<span class="string">'./code_img/code1.png'</span>,img)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取密钥</span></span><br><span class="line">res = requests.get(<span class="string">"https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=RQSCANnqoAs9Bk1cTnOWSema&amp;client_secret=G318YSye2P5vxv5g7xBfkwO9NOjBFd72"</span>)  <span class="comment">#这个url是由https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials，加client_id=，加应用API Key，加client_secret=，加应用的Secret Key</span></span><br><span class="line">token = res.json()[<span class="string">'access_token'</span>]</span><br><span class="line"><span class="comment"># 定义头部信息</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-from/urlencoded'</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">'https://aip.baidubce.com/rest/2.0/ocr/v1/accurate_basic?access_token='</span> + token</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图片</span></span><br><span class="line">my_img = open(<span class="string">'./code_img/code1.png'</span>, <span class="string">'rb'</span>)</span><br><span class="line">tem_img = my_img.read()</span><br><span class="line">my_img.close()</span><br><span class="line"><span class="comment"># 进行base64编码</span></span><br><span class="line">temp_data = &#123;<span class="string">'image'</span>: base64.b64encode(tem_img)&#125;</span><br><span class="line"><span class="comment"># 对图片地址进行urlencode操作</span></span><br><span class="line">temp_data = urllib.parse.urlencode(temp_data)</span><br><span class="line"><span class="comment"># 请求视图接口</span></span><br><span class="line">res = requests.post(url=url, data=temp_data, headers=headers)</span><br><span class="line">code = res.json()[<span class="string">'words_result'</span>][<span class="number">0</span>][<span class="string">'words'</span>].replace(<span class="string">' '</span>, <span class="string">''</span>)</span><br><span class="line"><span class="comment">#print(code)</span></span><br><span class="line">browser.find_element_by_xpath(<span class="string">'//table/tr[4]/td[1]/input'</span>).send_keys(code)</span><br></pre>



]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>vue页面结构&amp;语法</title>
    <url>/2019/07/30/vue%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84&amp;%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1-vue页面结构"><a href="#1-vue页面结构" class="headerlink" title="1.vue页面结构"></a>1.vue页面结构</h2><pre class="highlight"><span class="line">//页面骨架</span><br><span class="line">&lt;template&gt;  </span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// 页面行为</span><br><span class="line">&lt;script&gt;  </span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//页面样式</span><br><span class="line">&lt;style&gt;  </span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre>

<hr>
<h2 id="2-vue基本语法"><a href="#2-vue基本语法" class="headerlink" title="2.vue基本语法"></a>2.vue基本语法</h2><pre class="highlight"><span class="line">v-html:显示（能解析html格式）</span><br><span class="line"></span><br><span class="line">&#123;&#123; &#125;&#125;：显示（原样显示）</span><br><span class="line"></span><br><span class="line">v-show：隐藏（true/<span class="number">1</span>显示，fales/<span class="number">0</span>不显示）</span><br><span class="line"></span><br><span class="line">v-<span class="keyword">if</span>/v-<span class="keyword">else</span>-<span class="keyword">if</span>/v-<span class="keyword">else</span>:条件判断，多重判断</span><br><span class="line"></span><br><span class="line">v-<span class="keyword">for</span>=<span class="string">'(item,index) in data'</span>:循环遍历  <span class="comment">#item:遍历输出的个体 index：</span></span><br><span class="line">列表的下标 data：循环的列表</span><br><span class="line"></span><br><span class="line">v-bind:简写为‘：’绑定（标签里使用的绑定）</span><br><span class="line">v-on:简写为‘@’双向绑定（标签里使用的绑定）</span><br><span class="line"></span><br><span class="line">v-model:双向数据绑定（表单里使用的绑定）</span><br></pre>

<hr>
<h2 id="3-vue基础行为"><a href="#3-vue基础行为" class="headerlink" title="3.vue基础行为"></a>3.vue基础行为</h2><pre class="highlight"><span class="line"></span><br><span class="line">//定义数据</span><br><span class="line">data:&#123;  </span><br><span class="line">    <span class="keyword">return</span>&#123;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//钩子函数：样式加载前</span><br><span class="line">mounted（）&#123;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//钩子函数：所有数据加载前 比mounted更快</span><br><span class="line">created（）&#123;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//计算属性（在不改变原始值的情况下进行操作，非必须）</span><br><span class="line">computed：&#123;  </span><br><span class="line">    reverse_msg:function()&#123;</span><br><span class="line">        console_log()控制台输出</span><br><span class="line">        <span class="keyword">return</span> this.msg.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)<span class="comment">#反转        </span></span><br><span class="line">    &#125;，</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//监听属性(监听自定义变量的变化)</span><br><span class="line">watch：&#123;  </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//自定义函数方法</span><br><span class="line">methods:&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>
<pre class="highlight"><span class="line">//vue的各种互动用法</span><br><span class="line">console.log(res) //控制台输出</span><br><span class="line">this.$Message(res.data.message)  //提示框</span><br><span class="line">this.$Notice(res.data.message)  //警示框</span><br><span class="line">this.$router.push(<span class="string">'/'</span>)  //页面跳转</span><br><span class="line">this.$route.query.键 //从url里获取参数值</span><br></pre>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>vue目录</title>
    <url>/2019/07/24/vue%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="1-npm相关操作"><a href="#1-npm相关操作" class="headerlink" title="1.npm相关操作"></a>1.npm相关操作</h2><pre class="highlight"><span class="line">npm改源：npm set registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">npm版本查询：npm -v</span><br><span class="line"></span><br><span class="line">npm升级：npm install -g npm</span><br><span class="line"></span><br><span class="line">安装所有依赖：npm install  <span class="comment">#在vue项目目录下进行</span></span><br><span class="line"></span><br><span class="line">npm run dev 启动不了：</span><br><span class="line"></span><br><span class="line">​	删除node_modules:</span><br><span class="line"></span><br><span class="line">​		安装npm install rimraf -g</span><br><span class="line"></span><br><span class="line">​		然后rimraf node_modules</span><br></pre>
<hr>
<h2 id="2-vue目录"><a href="#2-vue目录" class="headerlink" title="2.vue目录"></a>2.vue目录</h2><pre class="highlight"><span class="line">build：打包文件</span><br><span class="line"></span><br><span class="line">​config：配置文件</span><br><span class="line"></span><br><span class="line">​disk:打包后的文件在这个里面，一开始没有</span><br><span class="line"></span><br><span class="line">​node_modules：根据package.json下载的所有依赖在这里面，不能上传库，解决方法：.gitignore文件中写入不上传的文件名。  <span class="comment">#vue和django项目中都有.gitignore</span></span><br><span class="line"></span><br><span class="line">​src：所有代码在这个里面</span><br><span class="line"></span><br><span class="line">​   assets：放样式和静态</span><br><span class="line">        bootstrap：手机模式样式</span><br><span class="line"></span><br><span class="line">​   components：组件文件夹  <span class="comment">#所有页面在这里面</span></span><br><span class="line"></span><br><span class="line">​   router：放所有路由的</span><br><span class="line">        mode：<span class="string">'history'</span>  <span class="comment">#去掉url中的#</span></span><br><span class="line">        path：url</span><br><span class="line">        name：命名空间  <span class="comment">#模板跳转使用</span></span><br><span class="line">        component：组件名称</span><br><span class="line"></span><br><span class="line">   App.vue:渲染组件，绑定vue和页面节点</span><br><span class="line">   </span><br><span class="line">   config:项目配置  <span class="comment">#自定义</span></span><br><span class="line"></span><br><span class="line">​   main.js:入口文件，实例生成，组件引用</span><br><span class="line"></span><br><span class="line">static:静态文件夹</span><br><span class="line"></span><br><span class="line">​package.json：所有模块依赖的集合 npm install 根据这个进行安装</span><br><span class="line"></span><br><span class="line">.gitignore：文件中写入不上传的文件名</span><br></pre>

<hr>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>中间件应用</title>
    <url>/2020/05/08/z_j/</url>
    <content><![CDATA[<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p> 客户端发起请求   –&gt;  进到wsgi(模型) –&gt; 中间件(request_process)  –&gt;  路由(urls.py)  –&gt;  中间件(view_process)  –&gt; view(视图操作 -&gt; orm操作 -&gt; mysql )  –&gt; 中间件(process_response before_template) –&gt; wsgi(模型)</p>
<h4 id="在Python项目中一直都在有使用中间件，在django项目中的setting-py文件中看到MIDDLEWARE配置项"><a href="#在Python项目中一直都在有使用中间件，在django项目中的setting-py文件中看到MIDDLEWARE配置项" class="headerlink" title="在Python项目中一直都在有使用中间件，在django项目中的setting.py文件中看到MIDDLEWARE配置项"></a>在Python项目中一直都在有使用中间件，在django项目中的setting.py文件中看到MIDDLEWARE配置项</h4><pre class="highlight"><span class="line"><span class="comment">#加载自定义中间件   文件夹名.文件名.类名</span></span><br><span class="line"><span class="string">'myapp.md_user.MyMiddleware'</span></span><br></pre>

<h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><pre class="highlight"><span class="line"><span class="keyword">from</span> django.utils.deprecation <span class="keyword">import</span> MiddlewareMixin</span><br></pre>

<h4 id="中间件的四种方法"><a href="#中间件的四种方法" class="headerlink" title="中间件的四种方法"></a>中间件的四种方法</h4><pre class="highlight"><span class="line"><span class="comment"># 自定义中间件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMiddleware</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    <span class="comment"># 请求之前</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        print(<span class="string">"过滤中间件"</span>)</span><br><span class="line">        <span class="comment"># 获取路由</span></span><br><span class="line">        <span class="keyword">if</span> request.path_info.startswith(<span class="string">"/login"</span>):</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(json.dumps(&#123;<span class="string">'msg'</span>:<span class="string">'您篡改了id'</span>&#125;,ensure_ascii=<span class="literal">False</span>,indent=<span class="number">4</span>),</span><br><span class="line">                            content_type=<span class="string">'application/json'</span>)</span><br><span class="line">    <span class="comment"># 进入视图之前</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self,request,view_func,view_args,view_kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># request是httprequest对象。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># view_func是即将使用的视图函数，它是实际的函数对象，而不是函数的名称作为字符串。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># view_args是将传递给视图位置的参数的列表。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># view_kargs是将传递给视图的关键字参数的字典。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># view_args和view_kargs都不包含第一个视图参数（request）</span></span><br><span class="line">    <span class="comment"># 异常捕获方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exception</span><span class="params">(self,request,exception)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 返回之前</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self,request,response)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre>

<p>​      1.中间件的process_request方法是在执行视图函数之前执行的</p>
<p>​      2.当配置中间件时，会按照MIDDLEWARE的注册顺序，也就是列表的索引值，从前到后依次执行的。</p>
<p>​      3.不同中间件之间传递的request都是同一个对象。</p>
<h4 id="中间件的应用场景"><a href="#中间件的应用场景" class="headerlink" title="中间件的应用场景"></a>中间件的应用场景</h4><p>1.做IP限制  –&gt; 放在中间件类的列表中，阻止某些ip访问；</p>
<p>2.URL访问过滤  –&gt; 如果用户访问的是logo视图（放过）如果访问其他视图，需要检测是否已经有session或localstrage，已经有了放行，如果没有返回login，这样就省的在多个视图函数上写装饰器了！</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>vue 路由传参 query 和 params 的区别</title>
    <url>/2019/11/13/vue%20%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%20query%20%E5%92%8C%20params%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="query使用-path-和-name-传参跳转都可以，而-params-只能使用-name-传参跳转。"><a href="#query使用-path-和-name-传参跳转都可以，而-params-只能使用-name-传参跳转。" class="headerlink" title="query使用 path 和 name 传参跳转都可以，而 params 只能使用 name 传参跳转。"></a>query使用 path 和 name 传参跳转都可以，而 params 只能使用 name 传参跳转。</h4><ul>
<li>query传参：</li>
</ul>
<pre class="highlight"><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">   routes: [</span><br><span class="line">     &#123; <span class="attr">path</span>: <span class="string">'/login'</span>, <span class="attr">component</span>: login &#125;,</span><br><span class="line">     &#123; <span class="attr">name</span>:<span class="string">'register'</span>,<span class="attr">path</span>: <span class="string">'/register'</span>, <span class="attr">component</span>: register &#125; </span><br><span class="line">   ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：这是 query 两种传参方式 一种是直接跳转把字符串传过去 一种是传描述目标位置的对象</span></span><br><span class="line">&lt;router-link to=<span class="string">"/login?id=10&amp;name=zs"</span>&gt;登录&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">&lt;router-link :to="&#123;path:'/</span>register<span class="string">',query:&#123;id:5,name:'</span>lili<span class="string">'&#125;&#125;"&gt;注册&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">或</span></span><br><span class="line"><span class="string">&lt;router-link :to="&#123;name:'</span>register<span class="string">',query:&#123;id:5,name:'</span>lili<span class="string">'&#125;&#125;"&gt;注册&lt;/router-link&gt;  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">等同于：</span></span><br><span class="line"><span class="string">this.$router.push('</span>/login?id=<span class="number">10</span>&amp;name=zs<span class="string">')</span></span><br><span class="line"><span class="string">this.$router.push(&#123;path:'</span>/register<span class="string">',query:&#123;id:5,name:'</span>lili<span class="string">'&#125;&#125;)</span></span><br><span class="line"><span class="string">或</span></span><br><span class="line"><span class="string">this.$router.push(&#123;name:'</span>register<span class="string">',query:&#123;id:5,name:'</span>lili<span class="string">'&#125;&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">接收参数：this.content = this.$route.query;</span></span><br><span class="line"><span class="string">123456789101112131415161718192021</span></span><br><span class="line"><span class="string">注意接收参数的时候，已经是$route而不是$router了哦！！</span></span><br></pre>

<ul>
<li>params传参：</li>
</ul>
<pre class="highlight"><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/login/:id/:name'</span>, <span class="attr">component</span>: login &#125;,<span class="comment">// 这里不传入对应的参数（:/id/:name） 刷新页面 参数会消失,页面中就丢失了数据</span></span><br><span class="line">    &#123; <span class="attr">name</span>:<span class="string">'register'</span>, <span class="attr">path</span>: <span class="string">'/register'</span>, <span class="attr">component</span>: register &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：这是 params 两种传参方式 一种是直接跳转把字符串传过去 一种是传描述目标位置的对象</span></span><br><span class="line">&lt;router-link to=<span class="string">"/login/12/ls"</span>&gt;登录&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">&lt;router-link :to="&#123;name:'register',params:&#123;id:10,name:'lili'&#125;&#125;"&gt;注册&lt;/</span>router-link&gt;</span><br><span class="line"></span><br><span class="line">等同于：</span><br><span class="line"><span class="keyword">this</span>.$router.push(<span class="string">'/login/12/ls'</span>)</span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;<span class="attr">name</span>:<span class="string">'register'</span>,<span class="attr">params</span>:&#123;<span class="attr">id</span>:<span class="number">10</span>,<span class="attr">name</span>:<span class="string">'lili'</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接收参数：<span class="keyword">this</span>.content = <span class="keyword">this</span>.$route.params;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre>

<p>传参跳转页面时，query 不需要再路由上配参数就能在新的页面获取到参数，params 也可以不用配，但是 params 不在路由配参数的话，当用户刷新当前页面的时候，参数就会消失。</p>
<p><strong>也就是说使用params不在路由配参数跳转，只有第一次进入页面参数有效，刷新页面参数就会消失。</strong></p>
<hr>
<h5 id="效果的展示"><a href="#效果的展示" class="headerlink" title="效果的展示"></a>效果的展示</h5><p>query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</p>
<ul>
<li>query:<br><img src="https://img-blog.csdnimg.cn/20200415233537686.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200415233537686.png" class="lozad post-image"><br><img src="https://img-blog.csdnimg.cn/20200415234817949.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200415234817949.png" class="lozad post-image"></li>
<li>params:<br><img src="https://img-blog.csdnimg.cn/20200415233923380.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200415233923380.png" class="lozad post-image"><br><img src="https://img-blog.csdnimg.cn/20200415234827149.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200415234827149.png" class="lozad post-image"><br><code>注意：这里的12和ls 对应的是/:id/:name 这两个参数可以不写 那么就不会在地址栏上显示 不过刷新页面参数会消失 写上参数刷新页面 参数不会消失</code></li>
</ul>
<p><a href="https://blog.csdn.net/alokka/article/details/84307161" target="_blank" rel="noopener">参考地址</a></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>七牛云存储</title>
    <url>/2018/09/22/%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h6 id="当今有很多云服务-比如什么百度云-阿里云-可以自己的文件存储到云端服务器进行保存-好处是-防止占用空间-防止数据丢失-一劳永逸-而我们结合云端存储-将数据存储到云端服务器中-而就防止我们自己的服务器的空间占用大-当用户使用数据时-服务器就像中间桥一样进行链接-用户-服务器-云端数据-而我们思路就是在用户上传文件的时候就上传到云端，而本地数据库只是更改一下文件名-这样在访问的时候根据域名-文件名就可以展示出文件"><a href="#当今有很多云服务-比如什么百度云-阿里云-可以自己的文件存储到云端服务器进行保存-好处是-防止占用空间-防止数据丢失-一劳永逸-而我们结合云端存储-将数据存储到云端服务器中-而就防止我们自己的服务器的空间占用大-当用户使用数据时-服务器就像中间桥一样进行链接-用户-服务器-云端数据-而我们思路就是在用户上传文件的时候就上传到云端，而本地数据库只是更改一下文件名-这样在访问的时候根据域名-文件名就可以展示出文件" class="headerlink" title="当今有很多云服务 比如什么百度云 阿里云 可以自己的文件存储到云端服务器进行保存,好处是 防止占用空间 防止数据丢失 一劳永逸,而我们结合云端存储 将数据存储到云端服务器中 而就防止我们自己的服务器的空间占用大,当用户使用数据时 服务器就像中间桥一样进行链接 用户-服务器-云端数据,而我们思路就是在用户上传文件的时候就上传到云端，而本地数据库只是更改一下文件名,这样在访问的时候根据域名+文件名就可以展示出文件"></a>当今有很多云服务 比如什么百度云 阿里云 可以自己的文件存储到云端服务器进行保存,好处是 防止占用空间 防止数据丢失 一劳永逸,而我们结合云端存储 将数据存储到云端服务器中 而就防止我们自己的服务器的空间占用大,当用户使用数据时 服务器就像中间桥一样进行链接 用户-服务器-云端数据,而我们思路就是在用户上传文件的时候就上传到云端，而本地数据库只是更改一下文件名,这样在访问的时候根据域名+文件名就可以展示出文件</h6><h5 id="七牛云流程图"><a href="#七牛云流程图" class="headerlink" title="七牛云流程图"></a>七牛云流程图</h5><p><img src="/hugoblog/%E6%80%9D%E8%B7%AF%E5%9B%BE.png" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E6%80%9D%E8%B7%AF%E5%9B%BE.png" class="lozad post-image"></p>
<h6 id="先到七牛云注册账号七牛云-之后选择-产品-对象存储-选择使用对象存储并创建空间"><a href="#先到七牛云注册账号七牛云-之后选择-产品-对象存储-选择使用对象存储并创建空间" class="headerlink" title="先到七牛云注册账号七牛云,之后选择 产品-对象存储,选择使用对象存储并创建空间"></a>先到七牛云注册账号七牛云,之后选择 产品-对象存储,选择使用对象存储并创建空间</h6><p><img src="/hugoblog/%E5%88%9B%E5%BB%BA%E7%A9%BA%E9%97%B4.png" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E5%88%9B%E5%BB%BA%E7%A9%BA%E9%97%B4.png" class="lozad post-image"></p>
<h6 id="之后点击秘钥"><a href="#之后点击秘钥" class="headerlink" title="之后点击秘钥"></a>之后点击秘钥</h6><p><img src="/hugoblog/%E5%AF%86%E9%92%A5.png" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E5%AF%86%E9%92%A5.png" class="lozad post-image"></p>
<h6 id="python根据秘钥来请求token"><a href="#python根据秘钥来请求token" class="headerlink" title="python根据秘钥来请求token"></a>python根据秘钥来请求token</h6><p><img src="/hugoblog/%E6%9F%A5%E7%9C%8B%E5%AF%86%E9%92%A5.png" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/%E6%9F%A5%E7%9C%8B%E5%AF%86%E9%92%A5.png" class="lozad post-image"></p>
<pre class="highlight"><span class="line">python中有一个qiniu的模块</span><br><span class="line"></span><br><span class="line">可以使用该模块 直接请求到token</span><br></pre>

<pre class="highlight"><span class="line"><span class="comment"># 七牛token</span></span><br><span class="line"><span class="keyword">from</span> qiniu <span class="keyword">import</span>  Auth</span><br><span class="line"><span class="comment"># qiniu 对象会自动请求token</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">    <span class="comment"># 声明认证对象</span></span><br><span class="line">    q = Auth(access_key=<span class="string">'4CmF2Dy-Xi7PQwHm7Ovpk7YlOiw2pqzUqyf7ybhA'</span>,</span><br><span class="line">             secret_key=<span class="string">'y3tlCWWdvmgsm2a9j6Plu_WWM4b0jFRTD-f3bHZ7'</span>)</span><br><span class="line">    <span class="comment"># 获取token</span></span><br><span class="line">    token=q.upload_token(<span class="string">'md1907rgzn'</span>)</span><br><span class="line">    <span class="keyword">return</span> Response(&#123;<span class="string">'token'</span>:token&#125;)</span><br></pre>

<hr>
<pre class="highlight"><span class="line">然后前端vue 接受到对应的token 并存入全局变量</span><br></pre>
<pre class="highlight"><span class="line">get_token()&#123;</span><br><span class="line">    this.axios.get("http://127.0.0.1:8000/myapp/qiniu/").then(result =&gt; &#123;</span><br><span class="line">        console.log(result.data.token)</span><br><span class="line">        this.token = result.data.token</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre>
<hr>
<h6 id="对表单设置提交按钮的函数"><a href="#对表单设置提交按钮的函数" class="headerlink" title="对表单设置提交按钮的函数"></a>对表单设置提交按钮的函数</h6><pre class="highlight"><span class="line"></span><br><span class="line">// 存入七牛云</span><br><span class="line">upload_qiniu:function()&#123;</span><br><span class="line">    //获取文件</span><br><span class="line">    var img=document.getElementById(<span class="string">"img"</span>)</span><br><span class="line">    //声明表单参数</span><br><span class="line">    let param = new FormData();</span><br><span class="line">    param.append(<span class="string">"img"</span>,img.files[<span class="number">0</span>])</span><br><span class="line">    param.append(<span class="string">'token'</span>,this.token);</span><br><span class="line">    //自定义axios 不允许传输cookie</span><br><span class="line">    const axios_qiniu = this.axios.create(&#123;withCredentials:false&#125;);</span><br><span class="line">    //发送请求</span><br><span class="line">    axios_qiniu(&#123;</span><br><span class="line">        method:<span class="string">'POST'</span>,</span><br><span class="line">        url:<span class="string">'http://up-z1.qiniup.com/'</span>,  // 七牛域名</span><br><span class="line">        data:param,</span><br><span class="line">        timeout:<span class="number">30000</span>  //超时设置</span><br><span class="line">    &#125;).then(result =&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span>(result.status==<span class="number">200</span>)&#123;</span><br><span class="line">            // 拼接七牛空间的域名 进行展示</span><br><span class="line">            this.src = <span class="string">"http://q9ksotoly.bkt.clouddn.com/"</span>+result.data.key;</span><br><span class="line">            // this.videosrc = config[<span class="string">'baseurl'</span>]+result.data.key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是 MongoDB</title>
    <url>/2019/08/06/%E4%BB%80%E4%B9%88%E6%98%AF%20MongoDB/</url>
    <content><![CDATA[<p><strong>MongoDB</strong> 是一个介于关系数据库和非关系数据库之间的开源产品，是最接近于关系型数据库的 NoSQL 数据库。它在轻量级JSON 交换基础之上进行了扩展，即称为 BSON 的方式来描述其无结构化的数据类型。尽管如此它同样可以存储较为复杂的数据类型。它和上一篇文章讲到的Redis有异曲同工之妙。虽然两者均为 NoSQL ，但是 MongoDB 相对于 Redis 而言，MongoDB 更像是传统的数据库。早些年我们是先有了 Relation Database (关系型数据库)，然后出现了很多很复杂的query ，里面用到了很多嵌套，很多 join 操作。所以在设计数据库的时候，我们也考虑到了如何应用他们的关系，使得写 query 可以使 database 效率达到最高。后来人们发现，不是每个系统，都需要如此复杂的关系型数据库。有些简单的网站，比如博客，比如社交网站，完全可以斩断数据库之间的一切关系。这样做带来的好处是，设计数据库变得更加简单，写 query 也变得更加简单。然后，query 消耗的时间可能也会变少。因为 query 简单了，少了许多消耗资源的 join 操作，速度自然会上去。正如所说的， query 简单了，很有以前 MySQL 可以找到的东西，现在关系没了，通过 Mongo 找不到了。我们只能将几组数据都抓到本地，然后在本地做 join ，所以在这点上可能会消耗很多资源。这里我们可以发现。如何选择数据库，完全取决于你所需要处理的数据的模型，即 Data Model 。如果它们之间，关系错综复杂，千丝万缕，这个时候 MySQL 一定是首选。如果他们的关系并不是那么密切，那么， NoSQL 将会是利器。</p>
<h5 id="MongoDB-和-Redis-一样均为-key-value-存储系统，它具有以下特点："><a href="#MongoDB-和-Redis-一样均为-key-value-存储系统，它具有以下特点：" class="headerlink" title="MongoDB 和 Redis 一样均为 key-value 存储系统，它具有以下特点："></a>MongoDB 和 Redis 一样均为 key-value 存储系统，它具有以下<strong>特点</strong>：</h5><p>面向集合存储，易存储对象类型的数据。 模式自由。 支持动态查询。 支持完全索引，包含内部对象。 支持查询。 支持复制和故障恢复。 使用高效的二进制数据存储，包括大型对象(如视频等)。 自动处理碎片，以支持云计算层次的扩展性 支持 Python ， PHP ， Ruby ， Java ， C ， C# ， Javascript ，Perl 及 C++ 语言的驱动程序，社区中也提供了对 Erlang 及 .NET 等平台的驱动程序。 文件存储格式为 BSON (一种 JSON 的扩展)。 可通过网络访问。</p>
<h3 id="MongoDB-与-MySQL-性能比较"><a href="#MongoDB-与-MySQL-性能比较" class="headerlink" title="MongoDB 与 MySQL 性能比较"></a>MongoDB 与 MySQL 性能比较</h3><p>像 MySQL 一样， MongoDB 提供了丰富的远远超出了简单的键值存储中提供的功能和功能。 MongoDB 具有查询语言，功能强大的辅助索引(包括文本搜索和地理空间)，数据分析功能强大的聚合框架等。相比使用关系数据库而言，使用MongoDB ，您还可以使用如下表所示的这些功能，跨越更多样化的数据类型和数据规模。</p>
<p>MySQLMongoDB丰富的数据模型否是动态 Schema否是数据类型是是数据本地化否是字段更新是是易于编程否是复杂事务是否审计是是自动分片否是</p>
<p>MySQL 中的许多概念在 MongoDB 中具有相近的类比。本表概述了每个系统中的一些常见概念。</p>
<p>MySQLMongoDB表集合行文档列字段joins嵌入文档或者链接</p>
<h3 id="MongoDB应用范围和限制"><a href="#MongoDB应用范围和限制" class="headerlink" title="MongoDB应用范围和限制"></a>MongoDB应用范围和限制</h3><p>MongoDB 的主要目标是在 key-value (键/值)存储方式(提供了高性能和高度伸缩性)以及传统的 RDBMS 系统(丰富的功能)架起一座桥梁，集两者的优势于一身。 MongoDB 适用范围如下：</p>
<p>网站数据： Mongo 非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。 缓存：由于性能很高， Mongo 也适合作为信息基础设施的缓存层。在系统重启之后，由 Mongo 搭建的持久化缓存层可以避免下层的数据源过载。 大尺寸，低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。 高伸缩性的场景： Mongo 非常适合由数十或数百台服务器组成的数据库。 Mongo 的路线图中已经包含对 MapReduce 引擎的内置支持。 用于对象及 JSON 数据的存储： Mongo 的 BSON 数据格式非常适合文档化格式的存储及查询。 MongoDB 当然也会有以下场景的限制：</p>
<p>高度事物性的系统：例如银行或会计系统。传统的关系型数据库目前还是更适用于需要大量原子性复杂事务的应用程序。 传统的商业智能应用：针对特定问题的 BI 数据库会对产生高度优化的查询方式。对于此类应用，数据仓库可能是更合适的选择。 需要 SQL 的问题。</p>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>八大排序</title>
    <url>/2019/09/02/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序：插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序；首先将第一个作为已经排好序的，然后每次从后的取出插入到前面并排序；</p>
<p>时间复杂度：O(n²)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：稳定</p>
<pre class="highlight"><span class="line">def insert_sort(ilist):</span><br><span class="line">    for i in range(len(ilist)):</span><br><span class="line">        for j in range(i):</span><br><span class="line">            if ilist[i] &lt; ilist[j]:</span><br><span class="line">                ilist.insert(j, ilist.pop(i))</span><br><span class="line">                break</span><br><span class="line">    return ilist</span><br></pre>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成</p>
<p>时间复杂度：O(n²)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：稳定</p>
<pre class="highlight"><span class="line">def bubble_sort(blist):</span><br><span class="line">    count &#x3D; len(blist)</span><br><span class="line">    for i in range(0, count):</span><br><span class="line">        for j in range(i + 1, count):</span><br><span class="line">            if blist[i] &gt; blist[j]:</span><br><span class="line">                blist[i], blist[j] &#x3D; blist[j], blist[i]</span><br><span class="line">    return blist</span><br><span class="line"></span><br><span class="line">blist &#x3D; bubble_sort([4,5,6,7,3,2,6,9,8])</span><br><span class="line">print(blist)</span><br></pre>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>快速排序：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</p>
<p>时间复杂度：O(nlog₂n)</p>
<p>空间复杂度：O(nlog₂n)</p>
<p>稳定性：不稳定</p>
<pre class="highlight"><span class="line">def quick_sort(qlist):</span><br><span class="line">    if qlist &#x3D;&#x3D; []:</span><br><span class="line">        return []</span><br><span class="line">    else:</span><br><span class="line">        qfirst &#x3D; qlist[0]</span><br><span class="line">        qless &#x3D; quick_sort([l for l in qlist[1:] if l &lt; qfirst])</span><br><span class="line">        qmore &#x3D; quick_sort([m for m in qlist[1:] if m &gt;&#x3D; qfirst])</span><br><span class="line">        return qless + [qfirst] + qmore</span><br><span class="line"></span><br><span class="line">qlist &#x3D; quick_sort([4,5,6,7,3,2,6,9,8])</span><br></pre>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序：第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕</p>
<p>时间复杂度：O(n²)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：不稳定</p>
<pre class="highlight"><span class="line">def select_sort(slist):</span><br><span class="line">    for i in range(len(slist)):</span><br><span class="line">        x &#x3D; i</span><br><span class="line">        for j in range(i, len(slist)):</span><br><span class="line">            if slist[j] &lt; slist[x]:</span><br><span class="line">                x &#x3D; j</span><br><span class="line">        slist[i], slist[x] &#x3D; slist[x], slist[i]</span><br><span class="line">    return slist</span><br><span class="line"></span><br><span class="line">slist &#x3D; select_sort([4,5,6,7,3,2,6,9,8])</span><br></pre>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序：采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并</p>
<p>时间复杂度：O(nlog₂n)</p>
<p>空间复杂度：O(1)</p>
<p>稳定性：稳定</p>
<pre class="highlight"><span class="line">def merge_sort(array):</span><br><span class="line">    def merge_arr(arr_l, arr_r):</span><br><span class="line">        array &#x3D; []</span><br><span class="line">        while len(arr_l) and len(arr_r):</span><br><span class="line">            if arr_l[0] &lt;&#x3D; arr_r[0]:</span><br><span class="line">                array.append(arr_l.pop(0))</span><br><span class="line">            elif arr_l[0] &gt; arr_r[0]:</span><br><span class="line">                array.append(arr_r.pop(0))</span><br><span class="line">        if len(arr_l) !&#x3D; 0:</span><br><span class="line">            array +&#x3D; arr_l</span><br><span class="line">        elif len(arr_r) !&#x3D; 0:</span><br><span class="line">            array +&#x3D; arr_r</span><br><span class="line">        return array</span><br><span class="line"></span><br><span class="line">    def recursive(array):</span><br><span class="line">        if len(array) &#x3D;&#x3D; 1:</span><br><span class="line">            return array</span><br><span class="line">        mid &#x3D; len(array) &#x2F;&#x2F; 2</span><br><span class="line">        arr_l &#x3D; recursive(array[:mid])</span><br><span class="line">        arr_r &#x3D; recursive(array[mid:])</span><br><span class="line">        return merge_arr(arr_l, arr_r)</span><br><span class="line"></span><br><span class="line">    return recursive(array)</span><br></pre>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是 编程？</title>
    <url>/2020/04/26/%E4%BB%80%E4%B9%88%E6%98%AF%20%E7%BC%96%E7%A8%8B%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/2020042022121417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/2020042022121417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" class="lozad post-image"></p>
<h4 id="什么是编程语言？"><a href="#什么是编程语言？" class="headerlink" title="什么是编程语言？"></a>什么是编程语言？</h4><p>编程语言（programming language）可以简单的理解为一种计算机和人都能识别的语言。一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。</p>
<h4 id="编程语言种类"><a href="#编程语言种类" class="headerlink" title="编程语言种类"></a>编程语言种类</h4><p>计算机编程语言能够实现人与机器之间的交流和沟通，而计算机编程语言主要包括汇编语言、机器语言以及高级语言，具体内容如下：</p>
<ul>
<li><p>汇编语言</p>
<p>该语言主要是以缩写英文作为标符进行编写的，运用汇编语言进行编写的一般都是较为简练的小程序，其在执行方面较为便利，但汇编语言在程序方面较为冗长，所以具有较高的出错率。</p>
</li>
<li><p>机器语言</p>
<p>这种语言主要是利用<strong>二进制编码进行指令</strong>的发送，能够被计算机快速地识别，其灵活性相对较高，且执行速度较为可观，机器语言与汇编语言之间的相似性较高，但由于具有局限性，所以在使用上存在一定的约束性。</p>
</li>
<li><p>高级语言</p>
<p>所谓的高级语言，其实是由多种编程语言结合之后的总称，其可以对多条指令进行整合，将其变为单条指令完成输送，其在操作细节指令以及中间过程等方面都得到了适当的简化，所以，整个程序更为简便，具有较强的操作性，而这种编码方式的简化，使得计算机编程对于相关工作人员的专业水平要求不断放宽。</p>
</li>
</ul>
<p><strong>编程语言的种类就是这样 ，然后 由于编程语言种类的繁多，诞生的时间线不同，根据时间和编程语言的特性，又分类如下几类：</strong></p>
<p>编程语言一般分为：低级语言、高级语言和面向对象时代。</p>
<h4 id="低级语言时代"><a href="#低级语言时代" class="headerlink" title="低级语言时代"></a>低级语言时代</h4><pre class="highlight"><span class="line">低级语言时代（1946－1953）主要包括被称为“天书”的机器语言以及汇编语言。</span><br></pre>

<p>计算机工作基于二进制，从根本上说，计算机只能识别和接受由0和1组成的指令。这些指令的集合就是该计算机的机器语言。机器语言包括的缺点有：难学、难写、难记、难检查、难修改，难以推广使用。因此初期只有极少数的计算机专业人员会编写计算机程序。</p>
<p>汇编语言由于机器语言的难以理解，莫奇莱等人开始想到用助记符来代替0，1代码，于是汇编语言出现了。</p>
<h4 id="高级语言时代"><a href="#高级语言时代" class="headerlink" title="高级语言时代"></a>高级语言时代</h4><p>高级语言时代（1954－至今）——随着世界上第一个高级语言fortran的出现，新的编程语言开始不断涌现出来。数十年来，全世界涌现了2500种以上高级语言，一些流行至今，一些则逐渐消失。</p>
<ul>
<li><p>第一个高级语言—Fortran。</p>
<p>为了克服低级语言的缺点，20世纪50年代由美国约翰·贝克斯（John Backus）创造出了第一个计算机高级语言——FORTRAN语言。它很接近人们习惯使用的自然语言和数学语言。程序中所用运算符和运算表达式，很容易理解，使用也十方便。并且FORTRAN以其特有的功能在数值、科学和工程计算领域发挥着重要作用。</p>
</li>
<li><p>第一个结构化程序设计语言—ALGOL</p>
<p>这是在计算机发展史上首批清晰定义的高级语言，由欧美计算机学家合力所组成的联席大会于仍是晶体管计算机流行的1950年代所开发国际计算机学会（ACM）将ALGOL模式列为算法描述的标准，<code>启发ALGOL类现代语言Pascal、Ada、C语言等出现。</code></p>
</li>
<li><p>最简单的语言——BASIC</p>
<p>1964年BASIC语言正式发布。是由达特茅斯学院院长、匈牙利人约翰·凯梅尼（John G.Kemeny）与数学系教师托马斯·库尔茨（Thomas E.Kurtz）共同研制出来的。该语言只有26个变量名，17条语句，12个函数和3个命令。这门语言叫做“初学者通用符号指令代码。</p>
</li>
<li><p>编程语言里一个重要的里程碑——Pascal Pasca<br>这是基于ALGOL编程语言，为纪念法国数学家、哲学家、电脑先驱布莱兹·帕斯卡而命名。它由瑞士Niklaus Wirth教授于六十年代末设计并创立的。Pascal具有语法严谨、层次分明等特点，是第一个结构化编程语言，被称为“编程语言里一个重要的里程碑”。</p>
</li>
<li><p>现代程序语言革命的起点——C语言<br>C语言的祖先是BCPL（Basic Combined Programming Language）语言，在1970年美国贝尔实验室的Ken Thompson在BCPL语言的基础上，设计出了B语言。接着在1972到1973年间，美国贝尔实验室的Dennis M.Ritchie在Ken Thompson的基础上设计出了C语言。</p>
</li>
</ul>
<h4 id="面向对象时代"><a href="#面向对象时代" class="headerlink" title="面向对象时代"></a>面向对象时代</h4><p>面向对象时代（90年代初－至今）——面向对象程序设计（Object－Oriented Programming，简称OOP）如今在整个程序设计中十分重要，其最突出的特点为封装性、继承性和多态性。</p>
<ul>
<li>Java</li>
</ul>
<p>Java是由Sun Microsystem于1995年推出的高级编程语言。近几年来，Java企业级应用飞速发展，主要被运用于电信、金融、交通等行业的信息化平台建设。Java是一个普遍适用的软件平台，其具有易学易用、平台独立、可移植、多线程、健壮、动态、安全等主要特性。</p>
<ul>
<li>Python</li>
</ul>
<p>近几年来，Python语言上升势头比较迅速，其主要原因在于大数据和人工智能领域的发展，随着产业互联网的推进，Python语言未来的发展空间将进一步得到扩大。Python是一种高层次的脚本语言，目前应用于Web和Internet开发、科学计算和统计、教育、软件开发和后端开发等领域，且有着简单易学、运行速度快、可移植、可扩展、可嵌入等优点。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用python发送QQ邮件</title>
    <url>/2018/10/10/%E4%BD%BF%E7%94%A8python%E5%8F%91%E9%80%81QQ%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="这里用到了Python的两个包来发送邮件：-smtplib-和-email-。"><a href="#这里用到了Python的两个包来发送邮件：-smtplib-和-email-。" class="headerlink" title="这里用到了Python的两个包来发送邮件： smtplib 和 email 。"></a>这里用到了Python的两个包来发送邮件： smtplib 和 email 。</h3><p>Python 的 <strong>email</strong> 模块里包含了许多实用的邮件格式设置函数，可以用来创建邮件“包裹”。使用的 MIMEText 对象，为底层的 MIME（Multipurpose Internet MailExtensions，多用途互联网邮件扩展类型）协议传输创建了一封空邮件，最后通过高层的SMTP 协议发送出去。 MIMEText 对象 <strong>msg</strong> 包括收发邮箱地址、邮件正文和主题，Python 通过它就可以创建一封格式正确的邮件。smtplib 模块用来设置服务器连接的相关信息。<br>　　要想通过QQ邮箱来发送邮件，需要开启QQ邮箱的设置-账户里<strong>SMTP服务</strong>，接下来会通过发送短信验证来获得<strong>授权码</strong>，有了授权码后就可以在代码里添加了。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTAwMTc1My8yMDE3MDQvMTAwMTc1My0yMDE3MDQxMjIxNTAyODExMS0xMDg1MjI3NTc1LnBuZw?x-oss-process=image/format,png" alt="alt" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTAwMTc1My8yMDE3MDQvMTAwMTc1My0yMDE3MDQxMjIxNTAyODExMS0xMDg1MjI3NTc1LnBuZw?x-oss-process=image/format,png" class="lozad post-image">        接下来看看QQ的邮件服务器配置：</p>
<h6 id="使用SSL的通用配置：pop-qq-com，使用SSL，端口号995"><a href="#使用SSL的通用配置：pop-qq-com，使用SSL，端口号995" class="headerlink" title="使用SSL的通用配置：pop.qq.com，使用SSL，端口号995"></a>使用SSL的通用配置：pop.qq.com，使用SSL，端口号995</h6><h6 id="发送邮件服务器：smtp-qq-com，使用SSL，端口号465或587"><a href="#发送邮件服务器：smtp-qq-com，使用SSL，端口号465或587" class="headerlink" title="发送邮件服务器：smtp.qq.com，使用SSL，端口号465或587"></a>发送邮件服务器：smtp.qq.com，使用SSL，端口号465或587</h6><p>根据此配置来设置smtplib.SMTP_SSL()函数的参数。<br>具体代码如下：</p>
<pre class="highlight"><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"></span><br><span class="line"><span class="comment"># come_from 是自己的邮箱，password是邮箱的授权码</span></span><br><span class="line">come_from = <span class="string">'3426628229@qq.com'</span>  <span class="comment">#  用户是谁  用户名</span></span><br><span class="line">password = <span class="string">'qtyohkdcrbozdbcf'</span>   <span class="comment">#  秘钥串  相当于密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  to_email 是接收的邮箱</span></span><br><span class="line">to_email = <span class="string">'1052117505@qq.com'</span>  <span class="comment">#  要发送给谁</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 邮箱服务器</span></span><br><span class="line">smtp_server = <span class="string">'smtp.qq.com'</span></span><br><span class="line"></span><br><span class="line">infos = <span class="string">'董老师好，我是海日汉，有机会来我们大内蒙骑马丫~~'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  邮箱正文，第一个参数为内容，第二个参数为格式，默认为纯文本，第三个参数是编码</span></span><br><span class="line"><span class="comment">#  这里我用把发送内容赋值给变量infos</span></span><br><span class="line">msg = MIMEText(infos,<span class="string">'plain'</span>,<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#  邮件头部信息</span></span><br><span class="line">msg[<span class="string">'From'</span>] = Header(come_from)</span><br><span class="line"><span class="comment">#  发送给谁</span></span><br><span class="line">msg[<span class="string">'To'</span>] = Header(to_email)</span><br><span class="line"><span class="comment">#  邮件主题</span></span><br><span class="line">msg[<span class="string">'Subject'</span>] = Header(<span class="string">'1908大实训'</span>)</span><br><span class="line"><span class="comment">#  创建实例</span></span><br><span class="line">server = smtplib.SMTP_SSL(smtp_server)</span><br><span class="line"><span class="comment">#  QQ邮箱SMTP的端口号时465或者587</span></span><br><span class="line">server.connect(smtp_server,<span class="number">465</span>)</span><br><span class="line"><span class="comment">#  登录邮件</span></span><br><span class="line">server.login(come_from,password)</span><br><span class="line"><span class="comment">#  发送邮件</span></span><br><span class="line">server.sendmail(come_from,to_email,msg.as_string())</span><br><span class="line">print(<span class="string">'邮件已发送'</span>)</span><br><span class="line"><span class="comment">#  退出邮件</span></span><br><span class="line">server.quit()</span><br></pre>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>八大查找</title>
    <url>/2019/09/10/%E5%85%AB%E5%A4%A7%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>算法简介 顺序查找又称为线性查找，是一种最简单的查找方法。适用于线性表的顺序存储结构和链式存储结构。该算法的时间复杂度为O(n)。 基本思路 从第一个元素m开始逐个与需要查找的元素x进行比较，当比较到元素值相同(即m=x)时返回元素m的下标，如果比较到最后都没有找到，则返回-1。 优缺点 缺点：是当n 很大时，平均查找长度较大，效率低； 优点：是对表中数据元素的存储没有要求。另外，对于线性链表，只能进行顺序查找。 算法实现</p>
<pre class="highlight"><span class="line">def sequential_search(lis, key):</span><br><span class="line">  length &#x3D; len(lis)</span><br><span class="line">  for i in range(length):</span><br><span class="line">    if lis[i] &#x3D;&#x3D; key:</span><br><span class="line">      return i</span><br><span class="line">    else:</span><br><span class="line">      return False</span><br></pre>

<h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><p>二分查找（Binary Search），是一种在有序数组中查找某一特定元素的查找算法。查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则查找过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。 这种查找算法每一次比较都使查找范围缩小一半。</p>
<p>算法描述 给予一个包含 个带值元素的数组A 1、 令 L为0 ， R为 n-1 2、 如果L&gt;R，则搜索以失败告终 3、 令 m (中间值元素)为 ⌊(L+R)/2⌋ 4、 如果 AmT，令 R为 m - 1 并回到步骤二 复杂度分析 时间复杂度：折半搜索每次把搜索区域减少一半，时间复杂度为 O(logn) 空间复杂度：O(1)</p>
<pre class="highlight"><span class="line">def binary_search(lis, key):</span><br><span class="line">  low &#x3D; 0</span><br><span class="line">  high &#x3D; len(lis) - 1</span><br><span class="line">  time &#x3D; 0</span><br><span class="line">  while low &lt; high:</span><br><span class="line">    time +&#x3D; 1</span><br><span class="line">    mid &#x3D; int((low + high) &#x2F; 2)</span><br><span class="line">    if key &lt; lis[mid]:</span><br><span class="line">      high &#x3D; mid - 1</span><br><span class="line">    elif key &gt; lis[mid]:</span><br><span class="line">      low &#x3D; mid + 1</span><br><span class="line">    else:</span><br><span class="line">      # 打印折半的次数</span><br><span class="line">      print(&quot;times: %s&quot; % time)</span><br><span class="line">      return mid</span><br><span class="line">  print(&quot;times: %s&quot; % time)</span><br><span class="line">  return False</span><br></pre>

<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>算法简介</p>
<p>插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的 查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])*(high-low)。 时间复杂度o(logn)但对于表长较大而关键字分布比较均匀的查找表来说，效率较高。</p>
<p>算法思想 基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。 注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</p>
<p>复杂度分析 时间复杂性：如果元素均匀分布，则O（log log n）），在最坏的情况下可能需要O（n）。 空间复杂度：O（1）。</p>
<pre class="highlight"><span class="line">def binary_search(lis, key):</span><br><span class="line">  low &#x3D; 0</span><br><span class="line">  high &#x3D; len(lis) - 1</span><br><span class="line">  time &#x3D; 0</span><br><span class="line">  while low &lt; high:</span><br><span class="line">    time +&#x3D; 1</span><br><span class="line">    # 计算mid值是插值算法的核心代码</span><br><span class="line">    mid &#x3D; low + int((high - low) * (key - lis[low])&#x2F;(lis[high] - lis[low]))</span><br><span class="line">    print(&quot;mid&#x3D;%s, low&#x3D;%s, high&#x3D;%s&quot; % (mid, low, high))</span><br><span class="line">    if key &lt; lis[mid]:</span><br><span class="line">      high &#x3D; mid - 1</span><br><span class="line">    elif key &gt; lis[mid]:</span><br><span class="line">      low &#x3D; mid + 1</span><br><span class="line">    else:</span><br><span class="line">      # 打印查找的次数</span><br><span class="line">      print(&quot;times: %s&quot; % time)</span><br><span class="line">      return mid</span><br><span class="line">  print(&quot;times: %s&quot; % time)</span><br><span class="line">  return False</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">  LIST &#x3D; [1, 5, 7, 8, 22, 54, 99, 123, 200, 222, 444]</span><br><span class="line">  result &#x3D; binary_search(LIST, 444)</span><br><span class="line">  print(result)</span><br></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端的好处</title>
    <url>/2019/06/22/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%A5%BD%E5%A4%84/</url>
    <content><![CDATA[<p>Web应用模式<br>在开发Web应用中，有两种应用模式：</p>
<p>前后端不分离</p>
<p>前后端分离</p>
<p>1 前后端不分离<br>在这里插入图片描述<br>在前后端不分离的应用模式中，前端页面看到的效果都是由后端控制，由后端渲染页面或重定向，也就是后端需要控制前端的展示，前端与后端的耦合度很高。</p>
<p>这种应用模式比较适合纯网页应用，但是当后端对接App时，App可能并不需要后端返回一个HTML网页，而仅仅是数据本身，所以后端原本返回网页的接口不再适用于前端App应用，为了对接App后端还需再开发一套接口。</p>
<p>2 前后端分离<br>在这里插入图片描述<br>在前后端分离的应用模式中，后端仅返回前端所需的数据，不再渲染HTML页面，不再控制前端的效果。至于前端用户看到什么效果，从后端请求的数据如何加载到前端中，都由前端自己决定，网页有网页的处理方式，App有App的处理方式，但无论哪种前端，所需的数据基本相同，后端仅需开发一套逻辑对外提供数据即可。</p>
<p>在前后端分离的应用模式中 ，前端与后端的耦合度相对较低。</p>
<p>在前后端分离的应用模式中，我们通常将后端开发的每个视图都称为一个接口，或者API，前端通过访问接口来对数据进行增删改查。</p>
<p>认识RESTful<br>在前后端分离的应用模式里，后端API接口如何定义？</p>
<p>例如对于后端数据库中保存了商品的信息，前端可能需要对商品数据进行增删改查，那相应的每个操作后端都需要提供一个API接口：</p>
<p>POST /add-goods 增加商品<br>POST /delete-goods 删除商品<br>POST /update-goods 修改商品<br>GET /get-goods 查询商品信息<br>对于接口的请求方式与路径，每个后端开发人员可能都有自己的定义方式，风格迥异。</p>
<p>是否存在一种统一的定义方式，被广大开发人员接受认可的方式呢？</p>
<p>这就是被普遍采用的API的RESTful设计风格。</p>
<ol>
<li><p>起源<br>REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。<br>在这里插入图片描述<br>Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。</p>
</li>
<li><p>名称<br>Fielding 将他对互联网软件的架构原则，定名为 REST，即 Representational State Transfer 的缩写。维基百科称其为“具象状态传输”，国内大部分人理解为“表现层状态转化”。</p>
</li>
</ol>
<p>RESTful是一种开发理念。维基百科说：REST是设计风格而不是标准。 REST描述的是在网络中client和server的一种交互形式；REST本身不实用，实用的是如何设计 RESTful API（REST风格的网络接口）,一种万维网软件架构风格。</p>
<p>我们先来具体看下RESTful风格的url,比如我要查询商品信息，那么</p>
<p>可以看出 REST特点：url简洁，将参数通过url传到服务器，而传统的url比较啰嗦，而且现实中浏览器地址栏会拼接一大串字符，想必你们都见过吧。但是采用REST的风格就会好很多，现在很多的网站已经采用这种风格了，这也是潮流方向，典型的就是url的短化转换。</p>
<p>那么，到底什么是RESTFul架构： 如果一个架构符合REST原则，就称它为RESTful架构。</p>
<p>要理解 RESTful 架构，理解 Representational State Transfer 这三个单词的意思。</p>
<p>具象的，就是指表现层，要表现的对象也就是“资源”，什么是资源呢？网站就是资源共享的东西，客户端（浏览器）访问web服务器，所获取的就叫资源。比如html，txt，json，图片，视频等等。</p>
<p>表现，比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p>
<p>浏览器通过URL确定一个资源，但是如何确定它的具体表现形式呢？应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p>
<p>状态转换，就是客户端和服务器互动的一个过程，在这个过程中, 势必涉及到数据和状态的变化, 这种变化叫做状态转换。</p>
<p>互联网通信协议HTTP协议，客户端访问必然使用HTTP协议，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。</p>
<p>HTTP协议实际上含有4个表示操作方式的动词，分别是 GET,POST,PUT,DELETE,他们分别对应四种操作。GET用于获取资源，POST用于新建资源，PUT用于更新资源，DElETE用于删除资源。GET和POST是表单提交的两种基本方式，比较常见，而PUT和DElETE不太常用。</p>
<p>而且HTTP协议是一种无状态协议，这样就必须把所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）</p>
<ol start="3">
<li>总结<br>综合上面的解释，RESTful架构就是：</li>
</ol>
<p>每一个URL代表一种资源；</p>
<p>客户端通过四个HTTP动词，对服务器端资源进行操作。</p>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>切换主题模式</title>
    <url>/2018/09/27/%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="设置主题按钮，点击即从白天模式切换为暗黑模式：背景色由白转黑，字体颜色由黑转白。"><a href="#设置主题按钮，点击即从白天模式切换为暗黑模式：背景色由白转黑，字体颜色由黑转白。" class="headerlink" title="设置主题按钮，点击即从白天模式切换为暗黑模式：背景色由白转黑，字体颜色由黑转白。"></a>设置主题按钮，点击即从白天模式切换为暗黑模式：背景色由白转黑，字体颜色由黑转白。</h3><ol>
<li>首先在前端查找控制背景色的style样式是由哪个属性控制的。<br><img src="/hugoblog/ppp.png" alt="~~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/ppp.png" class="lozad post-image"></li>
</ol>
<h6 id="找到是-header中的background控制的。"><a href="#找到是-header中的background控制的。" class="headerlink" title="找到是.header中的background控制的。"></a>找到是.header中的background控制的。</h6><h6 id="从main-js发现样式是从-src-assets-bootstrap-style-css引入的。"><a href="#从main-js发现样式是从-src-assets-bootstrap-style-css引入的。" class="headerlink" title="从main.js发现样式是从/src/assets/bootstrap/style.css引入的。"></a>从main.js发现样式是从/src/assets/bootstrap/style.css引入的。</h6><hr>
<h3 id="定义背景颜色变量，然后将定义的变量替换为写死的背景变量；然后前端设置按钮，封装改变背景变量的方法。"><a href="#定义背景颜色变量，然后将定义的变量替换为写死的背景变量；然后前端设置按钮，封装改变背景变量的方法。" class="headerlink" title="定义背景颜色变量，然后将定义的变量替换为写死的背景变量；然后前端设置按钮，封装改变背景变量的方法。"></a>定义背景颜色变量，然后将定义的变量替换为写死的背景变量；然后前端设置按钮，封装改变背景变量的方法。</h3><pre class="highlight"><span class="line">/* 定义变量 */</span><br><span class="line"> :root&#123;</span><br><span class="line">  --bg-color:<span class="comment">#fff;</span></span><br><span class="line">  --a-color:black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.navbar-brand, a.logo &#123;</span><br><span class="line">  font-family: <span class="string">"Lato"</span>, <span class="string">"Helvetica Neue"</span>, Helvetica, Arial, sans-serif;</span><br><span class="line">  color: var(--a-color);</span><br><span class="line">  font-size: <span class="number">2</span>rem;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  margin-top: <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">.header &#123;</span><br><span class="line">  /* 使用变量 */</span><br><span class="line">  background:var(--bg-color);</span><br><span class="line">  min-height: <span class="number">7</span>em;</span><br></pre>
<hr>
<ol start="2">
<li>定义变量<pre class="highlight"><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">	  //夜间模式切换开关信息</span><br><span class="line">	  style_night:<span class="string">'夜间模式'</span>,</span><br><span class="line">	  style:<span class="number">0</span>,</span><br><span class="line">	  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre>

</li>
</ol>
<hr>
<h3 id="在前端vue页面methods里定义开关切换主题方法。"><a href="#在前端vue页面methods里定义开关切换主题方法。" class="headerlink" title="在前端vue页面methods里定义开关切换主题方法。"></a>在前端vue页面methods里定义开关切换主题方法。</h3><pre class="highlight"><span class="line"> methods:&#123;</span><br><span class="line">      //按钮切换主题颜色方法</span><br><span class="line">      change_back:function()&#123;</span><br><span class="line">        console.log(this.style)</span><br><span class="line">          <span class="keyword">if</span>(this.style==true)&#123;</span><br><span class="line">                //获取样式表 所有节点</span><br><span class="line">                var styles = getComputedStyle(document.documentElement)</span><br><span class="line">                //动态更改 背景颜色</span><br><span class="line">                document.documentElement.style.setProperty(<span class="string">"--bg-color"</span>,<span class="string">"#292a2d"</span>);</span><br><span class="line">                //字体颜色</span><br><span class="line">                document.documentElement.style.setProperty(<span class="string">"--a-color"</span>,<span class="string">"white"</span>)</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              //获取样式表 所有节点</span><br><span class="line">                var styles = getComputedStyle(document.documentElement)</span><br><span class="line">                //动态更改 背景颜色</span><br><span class="line">                document.documentElement.style.setProperty(<span class="string">"--bg-color"</span>,<span class="string">"white"</span>);</span><br><span class="line">                //字体颜色</span><br><span class="line">                document.documentElement.style.setProperty(<span class="string">"--a-color"</span>,<span class="string">"black"</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">      &#125;,</span><br><span class="line">&#125;</span><br></pre>
<hr>
<h3 id="最后设置一个开关，绑定切换主题方法和变量。"><a href="#最后设置一个开关，绑定切换主题方法和变量。" class="headerlink" title="最后设置一个开关，绑定切换主题方法和变量。"></a>最后设置一个开关，绑定切换主题方法和变量。</h3><pre class="highlight"><span class="line">&lt;h-switch v-model="style" @change="change_back" &gt;&#123;&#123;style_night&#125;&#125;&lt;/h-switch&gt;</span><br></pre>

]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>压缩 -压缩实现方法、常用的压缩格式</title>
    <url>/2019/09/19/%E5%8E%8B%E7%BC%A9%20-%E5%8E%8B%E7%BC%A9%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<ul>
<li>压缩是通过 特定的算法来减少机算机对文件的大小机制，可以减少 Bytes<br>有很多的公司 对 存储的数据，都是用压缩包的形式，很少会用到数据库，一朋友 ，新跳了一家公司 分配好项目之后，没想到，发来的 数据都是 压缩包，其中有一个包 里面有着 4000W 的用户信息 （具体啥玩意我也不知道）他的电脑 打都打不开。<br>（ 咱不是程序大佬 小白白 ）</li>
</ul>
<p>让我突然重视了起来 压缩，因为平时 除了用快压 解压一些小电影剩下的好像什么都没有办，所以 度妈妈 了一些相关知识想着分享一下、也放在这里希望 大佬 能够指点</p>
<p><strong>言归正传</strong><br>我们大众化的理解就是解压 就是去除空格 其实也不完全对<br>接下来我们来说说 压缩</p>
<ol>
<li>文件</li>
</ol>
<ul>
<li><p>（ 文件 ）压缩技术 简单的来说 就是查找文件内的重复 Bytes，然后建立一个具有相同 Bytes 的 字典 文件，并且用一个代码来 表示。</p>
</li>
<li><p>比如原文件里，有多处重复的 Bytes or word 如：LiEnze 我爱你，这个时候 就会生产出一个代码来表示 如：sb 当然只是举例、真实的操作要麻烦的多</p>
</li>
</ul>
<ol start="2">
<li>图片</li>
</ol>
<ul>
<li>（ 图片 ）计算机处理信息 用的是 二进制表示、在一张图片内 有数不清的 相同颜色点对吧，压缩就会 在某个位置上 有多少个 蓝色点、在通过 公式用 （0， 1）来表示出来</li>
</ul>
<p><strong>压缩 方法分为：</strong><br>（ 有的时候想追求效率 必然质量会打点折扣 ）</p>
<ol>
<li>有损压缩：</li>
</ol>
<ul>
<li>举个例子 在压缩 图片的时候 你图片的左上角 少了一个 像素点 你的肉眼能看出来么？对吧！</li>
<li>所以有损压缩 非常适用于 压缩 图片 音频 视频 典型的代表格式就是 .mpeg</li>
</ul>
<ol start="2">
<li>无损压缩：</li>
</ol>
<ul>
<li>当我们对数据追求完美 不是特别考虑效率的时候 无损压缩就用到了、代表格式就太多了 如：.zip .rar 这些啊<br>其实压缩 最重要的 一点还是去重 也就是 重复压缩</li>
</ul>
<p><strong>重复压缩 也有两种：</strong></p>
<ol>
<li>段语句的重复</li>
</ol>
<ul>
<li><p>Bytes 在重复三个以上就成为短语句</p>
</li>
<li><p>在压缩这种类型时候 zip 用的是 两个数字 一个是 重复位置到当前位置的 距离，另一个是重复的长度</p>
</li>
<li><p>比如：abcddddd 我这个当前重复的位置是第 3个（第一个位置索引是 0），重复的长度是 5，那么我就可以 d(3,5) 来表示重复的 d。</p>
</li>
</ul>
<p>不要觉得一个 Bytes 有256个可能 三个字节就是有 256 ^ 3 种可能、这种压缩方法简直就是天方夜谭、</p>
<ul>
<li>比如：一篇小说中出现的 主人公的名字，和女主角去酒店的名字，极大程度地多次出现、这样就恰恰的符合了 重复压缩的做法，但是重复压缩只适合进行一次压缩</li>
<li>如果对文件进行第二次重复压缩 意义不大，因为第一次压缩 已经大大的破坏了 源语句的重复倾向。</li>
</ul>
<ol>
<li>单 Bytes 的重复</li>
</ol>
<ul>
<li><p>一个字节有 236 中可能、这样重复的几率岂不是更大？因为他是单字节，所以范围缩小了好多的。</p>
</li>
<li><p>比如在 ASCII 文本文件中 常用的就是 字母 和 数字，据说 E 的使用率是最高的 。</p>
</li>
<li><p>图片就更好理解了 肯定 深色调 和 浅色调 使用的多嘛<br>这里顺便提一下：png图片格式是一种无损压缩，其核心算法就是 zip 算法，它和 zip 格式的文件的主要区别在于：作为一种图片格式，它在文件头处存放了图片的大小、使用的颜色数等信息。</p>
</li>
<li><p>上面提到的短语式压缩的结果也有这种倾向：重复倾向于出现在离当前压缩位置较近的地方，重复长度倾向于比较短（20字节以内）。</p>
</li>
</ul>
<p><strong>常见的压缩格式：</strong></p>
<ol>
<li><p><a href="https://baike.baidu.com/item/JAR/919533?fr=aladdin" target="_blank" rel="noopener">JAR</a>– Java Archive File<br>他是 Java 的一种文档格式、你也可以理解为他就是 ZIP文件 ，叫他文件包，他和 ZIP 的最大区别就是 JAR 文件的内容中包含了一个 META-INF/MANIFEST.MF 文件，这个文件是在生成 JAR 文件的时候自动创建的</p>
</li>
<li><p><a href="https://baike.baidu.com/item/Zip/16684862?fr=aladdin" target="_blank" rel="noopener">ZIP</a>–<br>zip 是 very常见的一种压缩格式了它不需要单独的一个压缩或者解压缩软件，因为Windows系统已经集成了对 ZIP 压缩格式的支持。</p>
</li>
<li><p><a href="https://baike.baidu.com/item/RAR" target="_blank" rel="noopener">RAR</a>–<br>RAR 的压缩地位仅次于 ZIP ,因为 RAR 的压缩率 要比 ZIP 高很多。有一个后起之秀 叫 7Z 有着 比 RAR 更高的压缩率 但是 没办法 RAR 在压缩领域奠定了一定的基础、不可撼动。</p>
</li>
<li><p><a href="https://baike.baidu.com/item/CAB/10159898" target="_blank" rel="noopener">CAB</a><br>CAB 是微软推出的压缩文件格式，主要都是用于安装程序上，所以 CAB 文件包含的文件都是被经过处理的，代价就是咱们自己解压后可能还用不了</p>
</li>
<li><p><a href="https://jingyan.baidu.com/article/ceb9fb10868f6d8cad2ba0ee.html" target="_blank" rel="noopener">ISO</a> –<br>ISO 是 一种光盘镜像格式，是吧数据保存到光盘上。你一可以理解 这就是文件提取。</p>
</li>
<li><p><a href="https://baike.baidu.com/item/Tar/13886925?fr=aladdin" target="_blank" rel="noopener">TAR</a>–<br>TAR .tar 为后缀的文件，WinZIP、WinRAR、都可以打开，因为 他们两个都对 TAR 进行了关联，注意说的一点是 TAR是linux 常用的文件格式</p>
</li>
<li><p><a href="https://baike.baidu.com/item/119%E5%8F%B7%E5%85%83%E7%B4%A0/4817562?fromtitle=uue&fromid=9922593" target="_blank" rel="noopener">UUE</a>–<br>UUE 这个比较牛逼、是压缩遇到邮件编码混合 引起 乱码 的情况下就用压缩格式，可以用WinZIP、WinRAR打开。</p>
</li>
</ol>
<p>压缩的操作相比较来说 还是比较麻烦的  要慢慢钻研<del>~</del></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>分页器的使用</title>
    <url>/2018/08/23/%E5%88%86%E9%A1%B5%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="根据商品列表展示分页"><a href="#根据商品列表展示分页" class="headerlink" title="根据商品列表展示分页"></a>根据商品列表展示分页</h3><h6 id="django代码"><a href="#django代码" class="headerlink" title="django代码"></a>django代码</h6><pre class="highlight"><span class="line">url:    path(<span class="string">'goodslist/'</span>,GoodsList.as_view()),</span><br><span class="line"><span class="comment">#商品列表分页页</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodsList</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#当前页</span></span><br><span class="line"></span><br><span class="line">        page = int(request.GET.get(<span class="string">'page'</span>,<span class="number">1</span>))</span><br><span class="line">        <span class="comment">#一页显示个数</span></span><br><span class="line"></span><br><span class="line">        size = int(request.GET.get(<span class="string">'size'</span>,<span class="number">4</span>))</span><br><span class="line">        <span class="comment">#计算从哪开始切</span></span><br><span class="line"></span><br><span class="line">        data_start = (page<span class="number">-1</span>)*size</span><br><span class="line">        <span class="comment">#计算切到哪</span></span><br><span class="line"></span><br><span class="line">        data_end = page*size</span><br><span class="line">        <span class="comment">#查询 切片操作</span></span><br><span class="line"></span><br><span class="line">        goods = Goods.objects.all()[data_start:data_end]</span><br><span class="line">        <span class="comment">#查询所有个数</span></span><br><span class="line"></span><br><span class="line">        count = Goods.objects.count()</span><br><span class="line">        <span class="comment">#序列化操作</span></span><br><span class="line"></span><br><span class="line">        ser = GoodsSer(goods,many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'data'</span>:ser.data,<span class="string">"total"</span>:count&#125;)</span><br></pre>

<hr>
<h6 id="前端：根据heyui自带的分页器实现"><a href="#前端：根据heyui自带的分页器实现" class="headerlink" title="前端：根据heyui自带的分页器实现"></a>前端：根据heyui自带的分页器实现</h6><pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-<span class="keyword">for</span>=<span class="string">"(item,index) in goodslist"</span> :key=<span class="string">"index"</span>&gt;</span><br><span class="line">      &lt;a :href="'http://localhost:8080/item?id='+item.id"&gt;&#123;&#123;item.name&#125;&#125;&lt;/a&gt;</span><br><span class="line">      &lt;p&gt;&lt;span class="emphasis"&gt;$&#123;&#123;item.price&#125;&#125;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">      &lt;Pagination v-model="pagination" align="center" small @change="get_goods"&gt;&lt;/Pagination&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      //分页器变量</span><br><span class="line">      pagination:&#123;</span><br><span class="line">          //当前页</span><br><span class="line">          page: <span class="number">1</span>,</span><br><span class="line">          //每页多少个</span><br><span class="line">          size: <span class="number">2</span>,</span><br><span class="line">          //总数</span><br><span class="line">          total: <span class="number">4</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted:&#123;</span><br><span class="line">    //调用商品列表分页</span><br><span class="line">    this.get_goods();</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    	//获取商品列表</span><br><span class="line">      get_goods()&#123;</span><br><span class="line">        this.axios(&#123;</span><br><span class="line">          url:<span class="string">'http://localhost:8000/goodslist/'</span>,</span><br><span class="line">          method:<span class="string">'GET'</span>,</span><br><span class="line">          params:&#123;</span><br><span class="line">            //分页传参</span><br><span class="line">            page:this.pagination.page,</span><br><span class="line">            size:this.pagination.size,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).then(resp=&gt;&#123;</span><br><span class="line">          console.log(resp)</span><br><span class="line">          //获取商品列表和总页码</span><br><span class="line">          this.goodslist = resp.data.data;</span><br><span class="line">          this.pagination.total =resp.data.total;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre>

<hr>
<h6 id="前端：自主分页和分页偏移"><a href="#前端：自主分页和分页偏移" class="headerlink" title="前端：自主分页和分页偏移"></a>前端：自主分页和分页偏移</h6><pre class="highlight"><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">				&lt;span&gt;&lt;a @click="get_goods_self(1)"&gt;首页&lt;/a&gt;&lt;/span&gt;</span><br><span class="line">				&amp;emsp;&amp;emsp;</span><br><span class="line">				&lt;Button v-show="lastpage" @click="get_goods_self(lastpage)"&gt;上一页&lt;/Button&gt;</span><br><span class="line">				&lt;!-- &lt;span v-for="index in allpage"&gt;&lt;a @click="get_goods_self(index)"&gt;&#123;&#123;index&#125;&#125;&lt;/a&gt;&amp;emsp;&amp;emsp;&lt;/span&gt; --&gt;</span><br><span class="line">				&lt;!-- 左侧分页偏移 --&gt;</span><br><span class="line">				&lt;span v-for="item in last_page"&gt;&lt;a @click="get_goods_self(item)"&gt;&#123;&#123;item&#125;&#125;&lt;/a&gt;&amp;emsp;&amp;emsp;&lt;/span&gt;</span><br><span class="line">				&lt;!-- 当前页 --&gt;</span><br><span class="line">				&lt;a @click="get_goods_self(page)"&gt;&#123;&#123;page&#125;&#125;&amp;emsp;&amp;emsp;&lt;/a&gt;</span><br><span class="line">				&lt;!-- 右侧分页品偏移 --&gt;</span><br><span class="line">				&lt;span v-for="item in next_page"&gt;&lt;a @click="get_goods_self(item)"&gt;&#123;&#123;item&#125;&#125;&lt;/a&gt;&amp;emsp;&amp;emsp;&lt;/span&gt;</span><br><span class="line">				&lt;Button v-show="nextpage" @click="get_goods_self(nextpage)"&gt;下一页&lt;/Button&gt;</span><br><span class="line">				&lt;!-- 跳转分页  --&gt;</span><br><span class="line">				&lt;input type=<span class="string">"text"</span> style=<span class="string">"width:40px;"</span> @input=<span class="string">"jump_page($event)"</span>&gt;</span><br><span class="line">				&amp;emsp;&amp;emsp;</span><br><span class="line">				&lt;span&gt;&lt;a @click="get_goods_self(allpage)"&gt;尾页&lt;/a&gt;&lt;/span&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      //上一页</span><br><span class="line">      lastpage:<span class="number">0</span>,</span><br><span class="line">      //下一页</span><br><span class="line">      nextpage:<span class="number">0</span>,</span><br><span class="line">      //当前页</span><br><span class="line">      page:<span class="number">1</span>,</span><br><span class="line">      //每页展示个数</span><br><span class="line">      size:<span class="number">1</span>,</span><br><span class="line">      //总页数</span><br><span class="line">      allpage:<span class="number">0</span>,</span><br><span class="line">      //自主分页总个数</span><br><span class="line">      total_self:<span class="number">0</span>,</span><br><span class="line">      //商品列表</span><br><span class="line">      goodslist_self:[],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted()&#123;</span><br><span class="line">    //因为打开页面是从第一页开始的，所以参数是<span class="number">1</span></span><br><span class="line">    this.get_goods_self(<span class="number">1</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    //input输入页面跳转</span><br><span class="line">	  jump_page(e)&#123;</span><br><span class="line">      this.page = e.target.value</span><br><span class="line">      var val = e.target.value</span><br><span class="line">      console.log(val)</span><br><span class="line">      <span class="keyword">if</span>(val!=<span class="string">""</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(val&gt;this.allpage)&#123;</span><br><span class="line">          this.$Message(<span class="string">'您输入的页码有误'</span>)</span><br><span class="line">          <span class="keyword">return</span> false;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(val&lt;this.page)&#123;</span><br><span class="line">          this.$Message(<span class="string">'您输入的页码有误'</span>)</span><br><span class="line">          <span class="keyword">return</span> false;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">      &#125;</span><br><span class="line">      this.get_goods_self(val);</span><br><span class="line">    &#125;,</span><br><span class="line">    //自定义分页</span><br><span class="line">	  get_goods_self(page)&#123;</span><br><span class="line">      //确定当前页</span><br><span class="line">      this.page = page</span><br><span class="line">      this.axios(&#123;</span><br><span class="line">        url:<span class="string">'http://localhost:8000/goodslist/'</span>,</span><br><span class="line">        method:<span class="string">'GET'</span>,</span><br><span class="line">        params:&#123;</span><br><span class="line">          page:page,</span><br><span class="line">          size:this.size,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).then(resp=&gt;&#123;</span><br><span class="line">        console.log(resp)</span><br><span class="line">        //获取列表内容</span><br><span class="line">        this.goodslist_self = resp.data.data;</span><br><span class="line">        //商品总数</span><br><span class="line">        this.total_self =resp.data.total;</span><br><span class="line">        //判断上一页</span><br><span class="line">        <span class="keyword">if</span>(page==<span class="number">1</span>)&#123;</span><br><span class="line">          //如果当前页为<span class="number">1</span>，就是第一页，没有上一页</span><br><span class="line">          this.lastpage = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          //如果当前页不是第一个，上一页就是当前页<span class="number">-1</span></span><br><span class="line">          this.lastpage = page<span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        //计算总页数</span><br><span class="line">        //Meth.ceil向上取整，只要有余数，就为整数</span><br><span class="line">        this.allpage = Math.ceil(this.total_self / this.size);</span><br><span class="line">        //判断下一页</span><br><span class="line">        <span class="keyword">if</span>(page == this.allpage)&#123;</span><br><span class="line">          //如果最后一页和总页数相同，该页数就是最后一页</span><br><span class="line">          this.nextpage = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          //如果最后一页和总页数不同，下一页就是当前页+<span class="number">1</span></span><br><span class="line">          this.nextpage = page+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        //设置偏移量</span><br><span class="line">        var move_page = <span class="number">2</span>;</span><br><span class="line">        var my_last = [];</span><br><span class="line">        </span><br><span class="line">        //计算左侧偏移量</span><br><span class="line">        <span class="keyword">for</span>(let i=page-move_page;i&lt;page;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            my_last.push(i)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //计算右侧偏移量</span><br><span class="line">        var my_next = [];</span><br><span class="line">        //计算左侧偏移量</span><br><span class="line">        <span class="keyword">for</span>(let i=page+<span class="number">1</span>;i&lt;=page+move_page;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(i&lt;=this.allpage)&#123;</span><br><span class="line">            my_next.push(i)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.last_page = my_last;</span><br><span class="line">        this.next_page = my_next;</span><br><span class="line">        </span><br><span class="line">      &#125;)</span><br><span class="line">	  &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>又拍云存储</title>
    <url>/2018/11/27/%E5%8F%88%E6%8B%8D%E4%BA%91%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class="highlight"><span class="line">pip install upyun</span><br></pre>
<hr>
<h2 id="django接口"><a href="#django接口" class="headerlink" title="django接口"></a>django接口</h2><pre class="highlight"><span class="line"><span class="comment">#又拍云</span></span><br><span class="line"><span class="keyword">import</span> upyun</span><br><span class="line"><span class="comment">#定义文件上传类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YouPai</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#接受参数</span></span><br><span class="line">        img = request.FILES.get(<span class="string">'file'</span>)</span><br><span class="line">        <span class="comment"># 生成独特的文件名</span></span><br><span class="line">        filename = make_password(img.name) + str((int(round(time.time() * <span class="number">1000</span>)))) + <span class="string">".jpg"</span></span><br><span class="line">        <span class="comment"># 实例化对象</span></span><br><span class="line">        up = upyun.UpYun(<span class="string">'md-admin'</span>, username=<span class="string">'a2925087209'</span>, password=<span class="string">'by0sFyYQ62GfZSIqCPVRXJLHlierRJsT'</span>)</span><br><span class="line">        headers = &#123; <span class="string">'x-gmkerl-rotate'</span>: <span class="string">'50'</span> &#125;</span><br><span class="line">        <span class="comment"># 分块上传</span></span><br><span class="line">        <span class="keyword">for</span> chunk <span class="keyword">in</span> img.chunks():</span><br><span class="line">            res = up.put(<span class="string">'/%s'</span>%filename,chunk,checksum=<span class="literal">True</span>,headers=headers)</span><br><span class="line">        <span class="comment">#返回结果</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(json.dumps(&#123;<span class="string">'filename'</span>:filename&#125;),content_type=<span class="string">'application/json'</span>)</span><br></pre>

<hr>
<h2 id="vue接口"><a href="#vue接口" class="headerlink" title="vue接口"></a>vue接口</h2><pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;!-- &lt;/img :src="src" /&gt; --&gt;</span><br><span class="line">        又拍云存储：&lt;Avatar :src="yp_url" :width='150' fil='fill'&gt;&lt;/Avatar&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">"file"</span> @change=<span class="string">"upload_upyun"</span> /&gt;</span><br><span class="line">        &lt;div class="upload"&gt;</span><br><span class="line">            拖拽上传</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            yp_url :<span class="string">''</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mounted:function()&#123;</span><br><span class="line">    //又拍云</span><br><span class="line">    //注册推托拽容器</span><br><span class="line">    let upload = document.querySelector(<span class="string">'.upyun'</span>);</span><br><span class="line">    //声明监听事件</span><br><span class="line">    //点击</span><br><span class="line">    upload.addEventListener(<span class="string">'dragenter'</span>, this.onDrag, false);</span><br><span class="line">    //悬停</span><br><span class="line">    upload.addEventListener(<span class="string">'dragover'</span>, this.onDrag, false);</span><br><span class="line">    //释放</span><br><span class="line">    upload.addEventListener(<span class="string">'drop'</span>, this.onDrop, false);</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        //又拍云上传</span><br><span class="line">        //监听鼠标</span><br><span class="line">        onDrag (e) &#123;</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        &#125;,</span><br><span class="line">        onDrop (e) &#123;</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        this.upyun(e.dataTransfer.files);</span><br><span class="line">        &#125;,</span><br><span class="line">        //上传又拍云</span><br><span class="line">        upyun:function(files)&#123;</span><br><span class="line">            //获取文件对象</span><br><span class="line">        //   let file = e.target.files[<span class="number">0</span>];</span><br><span class="line">            let file = files[<span class="number">0</span>];</span><br><span class="line">            //声明参数</span><br><span class="line">            let param = new FormData();</span><br><span class="line">            param.append(<span class="string">'file'</span>,file);</span><br><span class="line"></span><br><span class="line">            const config = &#123;</span><br><span class="line">            headers: &#123; <span class="string">'Content-Type'</span>: <span class="string">'multipart/form-data'</span> &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            var a = this</span><br><span class="line">            a.axios.post(<span class="string">'http://localhost:8000/youpai/'</span>, param, config)// 上传图片</span><br><span class="line">            .then(function(res) &#123;</span><br><span class="line">                console.log(res)	</span><br><span class="line">                a.yp_url = <span class="string">'http://md-admin.test.upcdn.net/'</span>+res.data.filename</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.upload &#123;</span><br><span class="line">  margin: <span class="number">100</span>px auto;</span><br><span class="line">  width: <span class="number">300</span>px;</span><br><span class="line">  height: <span class="number">150</span>px;</span><br><span class="line">  border: <span class="number">2</span>px dashed <span class="comment">#f00;</span></span><br><span class="line">  padding-top: <span class="number">50</span>px;</span><br><span class="line">  padding-left: <span class="number">80</span>px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre>

<h2 id="又拍云文件操作"><a href="#又拍云文件操作" class="headerlink" title="又拍云文件操作"></a>又拍云文件操作</h2><pre class="highlight"><span class="line"></span><br><span class="line"><span class="keyword">import</span> upyun</span><br><span class="line"><span class="comment">#实例化</span></span><br><span class="line">up = upyun.UpYun(<span class="string">"空间名"</span>,<span class="string">'操作员'</span>,<span class="string">'密码'</span>)</span><br><span class="line"><span class="comment">#读内存上传</span></span><br><span class="line">up.put(<span class="string">'自定义文件名'</span>,<span class="string">'文件内容'</span>)</span><br><span class="line"><span class="comment">#文件流操作（节省内存）</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'文件路径/文件名'</span>,<span class="string">'rb'</span>)<span class="keyword">as</span> f:</span><br><span class="line">    res = up.put(<span class="string">'自定义文件名'</span>,f,checksum=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#目录操作</span></span><br><span class="line">up.mkdir(<span class="string">'/文件夹名/'</span>)</span><br><span class="line"><span class="comment">#移动文件</span></span><br><span class="line">up.move(<span class="string">'/文件路径/文件名'</span>,<span class="string">'/新文件路径/文件名'</span>)</span><br><span class="line"><span class="comment">#复制文件</span></span><br><span class="line">up.copy(<span class="string">'/文件路径/文件名'</span>,<span class="string">'/新文件路径/文件名'</span>)</span><br><span class="line"><span class="comment">#断点续传</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'文件路径/文件名'</span>,<span class="string">'rb'</span>)<span class="keyword">as</span> f:</span><br><span class="line">    res = up.put(<span class="string">'自定义文件名'</span>,f,checksum=<span class="literal">True</span>，need_resume=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#下载</span></span><br><span class="line">res = up.get(<span class="string">'/文件路径/文件名'</span>)</span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line">up.delete(<span class="string">'/文件路径/文件名'</span>)</span><br></pre>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>反序列化</title>
    <url>/2018/08/15/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h3 id="反序列化是将所有参数打包为一个dict-之后将dict提交给序列化类-通过save就可以直接入库保存了"><a href="#反序列化是将所有参数打包为一个dict-之后将dict提交给序列化类-通过save就可以直接入库保存了" class="headerlink" title="反序列化是将所有参数打包为一个dict   之后将dict提交给序列化类 通过save就可以直接入库保存了"></a>反序列化是将所有参数打包为一个dict   之后将dict提交给序列化类 通过save就可以直接入库保存了</h3><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInsert</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化参数</span></span><br><span class="line">        name = request.GET.get(<span class="string">'name'</span>)</span><br><span class="line">        password = request.GET.get(<span class="string">'password'</span>)</span><br><span class="line">        <span class="comment"># 反序列化添加</span></span><br><span class="line">        data=&#123;</span><br><span class="line">            <span class="string">'name'</span>:name,</span><br><span class="line">            <span class="string">'password'</span>:password</span><br><span class="line">        &#125;</span><br><span class="line">        user = User_Ser(data=data)</span><br><span class="line">        <span class="comment"># 验证字段是否错误</span></span><br><span class="line">        <span class="keyword">if</span> user.is_valid():</span><br><span class="line">            <span class="comment"># 进行入库操作</span></span><br><span class="line">            user.save()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>:<span class="number">200</span>,<span class="string">'msg'</span>:<span class="string">'ok'</span>&#125;)</span><br></pre>
<h3 id="在反序列化时候一定要注意字段的类型-要与字段个数一致"><a href="#在反序列化时候一定要注意字段的类型-要与字段个数一致" class="headerlink" title="在反序列化时候一定要注意字段的类型(要与字段个数一致)"></a>在反序列化时候一定要注意字段的类型(要与字段个数一致)</h3>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>安装 简单使用 HeyUI</title>
    <url>/2020/04/10/%E5%AE%89%E8%A3%85%20%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%20HeyUI/</url>
    <content><![CDATA[<p>我们需要有 Vue.js 环境，要提前安装好，</p>
<p><a href="https://www.heyui.top/component/quickstart" target="_blank" rel="noopener">HeyUI参考使用文档：https://www.heyui.top/component/quickstart</a></p>
<ul>
<li><p>支持环境</p>
<p>现代浏览器和 IE9 及以上。</p>
</li>
<li><p>兼容</p>
<p>HeyUI支持 Vue.js 2.x版本</p>
</li>
</ul>
<h4 id="安装-步骤："><a href="#安装-步骤：" class="headerlink" title="安装 步骤："></a>安装 步骤：</h4><ul>
<li><p>安装heyui</p>
<pre class="highlight"><span class="line">cnpm install heyui --save-dev</span><br></pre>
</li>
<li><p>安装less</p>
<pre class="highlight"><span class="line">cnpm install less --save-dev</span><br></pre>
</li>
<li><p>安装less-loader</p>
<pre class="highlight"><span class="line">cnmp install less-loader --save-dev</span><br></pre>

</li>
</ul>
<p><code>注：Less 是一门 CSS 预处理语言,它扩展了 CSS 语言,增加了变量、Mixin、函数等特性。Less 可以运行在 Node 或浏览器端。</code> <strong>是必需品</strong></p>
<h4 id="安装-需要用的之后，我们就要-全局配置了。"><a href="#安装-需要用的之后，我们就要-全局配置了。" class="headerlink" title="安装 需要用的之后，我们就要 全局配置了。"></a>安装 需要用的之后，我们就要 全局配置了。</h4><ul>
<li>样式引用 在全局的 <code>main.js</code> 里</li>
</ul>
<pre class="highlight"><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 HeyUI</span></span><br><span class="line"><span class="keyword">import</span> HeyUI <span class="keyword">from</span> <span class="string">'heyui'</span></span><br><span class="line">vue.use(HeyUI)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入 css 和 js 样式，全局</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"heyui/themes/index.css"</span>);</span><br><span class="line"><span class="keyword">import</span> <span class="string">"heyui/themes/index.less"</span>;</span><br></pre>

<ul>
<li>同时，HeyUI 也可以设置为全局引用，因为 HeyUI 拥有Message, Loadding等全局可以调用的方法。</li>
</ul>
<pre class="highlight"><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),      <span class="comment">// 新增</span></span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;);</span><br></pre>

<h4 id="我们还可以-按需使用"><a href="#我们还可以-按需使用" class="headerlink" title="我们还可以 按需使用"></a>我们还可以 按需使用</h4><p>借助插件 <code>babel-plugin-import</code> 可以实现按需加载组件，减少文件体积。</p>
<pre class="highlight"><span class="line">npm install babel-plugin-<span class="keyword">import</span> --save-dev</span><br><span class="line"><span class="number">1</span></span><br></pre>

<p>随便选择个样式，复制代码。</p>
<p><img src="https://img-blog.csdnimg.cn/20200412005055880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200412005055880.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<p><img src="https://img-blog.csdnimg.cn/20200412005319789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200412005319789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<p>大家可以看到效果实现了，具体的如何操作还是 观看，官方文档 。</p>
<p>HeyUI还有 强大的 admin，连接 参考文档：<a href="https://heyui.github.io/heyui-admin-docs/" target="_blank" rel="noopener">https://heyui.github.io/heyui-admin-docs/</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>实现微博第三方登录</title>
    <url>/2018/10/02/%E5%AE%9E%E7%8E%B0%E5%BE%AE%E5%8D%9A%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h6 id="在微博网站-注册使用apphttps-open-weibo-com"><a href="#在微博网站-注册使用apphttps-open-weibo-com" class="headerlink" title="在微博网站 注册使用apphttps://open.weibo.com/"></a>在微博网站 注册使用app<a href="https://open.weibo.com/" target="_blank" rel="noopener">https://open.weibo.com/</a></h6><h5 id="登录账号选择网站接入"><a href="#登录账号选择网站接入" class="headerlink" title="登录账号选择网站接入"></a>登录账号选择网站接入</h5><p><img src="/myimg/%E7%BD%91%E7%AB%99%E6%8E%A5%E5%85%A5.png" alt="~````" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/myimg/%E7%BD%91%E7%AB%99%E6%8E%A5%E5%85%A5.png" class="lozad post-image"></p>
<hr>
<h5 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h5><p><img src="/myimg/%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8.png" alt="~````" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/myimg/%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8.png" class="lozad post-image"></p>
<hr>
<h5 id="应用创建成功后，会立即跳转审核页面，需要填写一些资质，用来进行审核，其实这些审核字段都不用搭理，应用压根就不需要通过审核"><a href="#应用创建成功后，会立即跳转审核页面，需要填写一些资质，用来进行审核，其实这些审核字段都不用搭理，应用压根就不需要通过审核" class="headerlink" title="应用创建成功后，会立即跳转审核页面，需要填写一些资质，用来进行审核，其实这些审核字段都不用搭理，应用压根就不需要通过审核"></a>应用创建成功后，会立即跳转审核页面，需要填写一些资质，用来进行审核，其实这些审核字段都不用搭理，应用压根就不需要通过审核</h5><p><img src="/myimg/3.png" alt="~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/myimg/3.png" class="lozad post-image"></p>
<hr>
<h5 id="之后填写指定的回调路径"><a href="#之后填写指定的回调路径" class="headerlink" title="之后填写指定的回调路径"></a>之后填写指定的回调路径</h5><p><img src="/myimg/%E5%9B%9E%E8%B0%83%E4%BF%A1%E6%81%AF.png" alt="~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/myimg/%E5%9B%9E%E8%B0%83%E4%BF%A1%E6%81%AF.png" class="lozad post-image"></p>
<hr>
<h5 id="此时我们有了-App-Key-App-Secret-回调页-需要构思编码的流程"><a href="#此时我们有了-App-Key-App-Secret-回调页-需要构思编码的流程" class="headerlink" title="此时我们有了 App Key App Secret 回调页 需要构思编码的流程"></a>此时我们有了 App Key App Secret 回调页 需要构思编码的流程</h5><p><img src="/myimg/%E6%80%9D%E8%B7%AF.png" alt="~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/myimg/%E6%80%9D%E8%B7%AF.png" class="lozad post-image"></p>
<hr>
<h5 id="首先根据-app-key-来访问请求API接口"><a href="#首先根据-app-key-来访问请求API接口" class="headerlink" title="首先根据 app key 来访问请求API接口"></a>首先根据 app key 来访问请求API接口</h5><pre class="highlight"><span class="line">//新浪微博第三方登录</span><br><span class="line">sina()&#123;</span><br><span class="line">    let client_id=<span class="number">2464168997</span></span><br><span class="line">    let url=<span class="string">"https://api.weibo.com/oauth2/authorize?client_id="</span>+client_id+<span class="string">"&amp;redirect_uri=回调路由"</span></span><br><span class="line">    window.location.href=url</span><br><span class="line">&#125;</span><br></pre>

<hr>
<h5 id="在指定回调路由下-接受参数"><a href="#在指定回调路由下-接受参数" class="headerlink" title="在指定回调路由下 接受参数"></a>在指定回调路由下 接受参数</h5><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wb_back</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># 初始返回一个code</span></span><br><span class="line">    code=request.GET.get(<span class="string">'code'</span>,<span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># 微博接口地址</span></span><br><span class="line">    access_token_url = <span class="string">"https://api.weibo.com/oauth2/access_token"</span></span><br><span class="line">    <span class="comment"># 定义参数</span></span><br><span class="line">    re = requests.post(access_token_url, data=&#123;</span><br><span class="line">        <span class="string">"client_id"</span>: <span class="string">'app key'</span>,</span><br><span class="line">        <span class="string">"client_secret"</span>: <span class="string">"secert key"</span>,</span><br><span class="line">        <span class="string">"grant_type"</span>: <span class="string">"authorization_code"</span>,</span><br><span class="line">        <span class="string">"code"</span>: code,</span><br><span class="line">        <span class="string">"redirect_uri"</span>: <span class="string">"回调路由"</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment"># 获取用户信息</span></span><br><span class="line">    res=requests.get(<span class="string">'https://api.weibo.com/2/users/show.json'</span>,params=&#123;<span class="string">"access_token"</span>:re.json()[<span class="string">"access_token"</span>],<span class="string">"uid"</span>:re.json()[<span class="string">"uid"</span>]&#125;)</span><br><span class="line">    <span class="comment"># res.json（）就是用户登录的信息</span></span><br><span class="line">    print(res.json())</span><br><span class="line">上面代码实现了接受用户的参数</span><br><span class="line"></span><br><span class="line">下面根据用户参数实现一些判断逻辑</span><br><span class="line"></span><br><span class="line">    username=str(res.json()[<span class="string">'name'</span>])</span><br><span class="line">    <span class="comment"># 判断是否用新浪微博登录过</span></span><br><span class="line">    user=User.objects.filter(username=username).first()</span><br><span class="line">    sina_id=<span class="string">''</span></span><br><span class="line">    user_id=<span class="string">''</span></span><br><span class="line">    <span class="keyword">if</span> user:</span><br><span class="line">        <span class="comment"># 代表曾经登录过</span></span><br><span class="line">        sina_id=user.username</span><br><span class="line">        user_id=user.id</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 首次登陆</span></span><br><span class="line">        User(username=username,password=res.json()[<span class="string">'id'</span>]).save()</span><br><span class="line">        user=User.objects.filter(username=username).first()</span><br><span class="line">        sina_id=user.username</span><br><span class="line">        user_id=user.id</span><br><span class="line"></span><br><span class="line">    print(sina_id,user_id)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 重定向到主页 并传递参数</span></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">"http://localhost:8080?sina_id="</span>+str(sina_id)+<span class="string">"&amp;uid="</span>+str(user_id))</span><br><span class="line">前端解析后端传递的参数</span><br><span class="line"></span><br><span class="line">var sina_id = this.$route.query.sina_id;</span><br><span class="line">var user_id = this.$route.query.uid;</span><br><span class="line"><span class="keyword">if</span> (sina_id)&#123;</span><br><span class="line">    // 自动帮用户登录</span><br><span class="line">    localStorage.setItem(<span class="string">'username'</span>,sina_id)</span><br><span class="line">    localStorage.setItem(<span class="string">'uid'</span>,user_id)</span><br><span class="line">&#125;</span><br></pre>

<hr>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化底层</title>
    <url>/2018/10/23/%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82/</url>
    <content><![CDATA[<h3 id="DRF的核心-就是-前后端分离的核心"><a href="#DRF的核心-就是-前后端分离的核心" class="headerlink" title="DRF的核心 就是 前后端分离的核心"></a>DRF的核心 就是 前后端分离的核心</h3><h4 id="前后端分离开发的核心：-将模型转换为json-称之为-序列化-将json转换为模型-称之为-反序列化"><a href="#前后端分离开发的核心：-将模型转换为json-称之为-序列化-将json转换为模型-称之为-反序列化" class="headerlink" title="前后端分离开发的核心： 将模型转换为json 称之为 序列化 将json转换为模型 称之为 反序列化"></a>前后端分离开发的核心： 将模型转换为json 称之为 序列化 将json转换为模型 称之为 反序列化</h4><h4 id="制作序列化类"><a href="#制作序列化类" class="headerlink" title="制作序列化类"></a>制作序列化类</h4><pre class="highlight"><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> myapp.models <span class="keyword">import</span> *</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">userlSer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model=User</span><br><span class="line">        fields = <span class="string">'__all__'</span></span><br></pre>

<hr>
<h6 id="序列化底层是根据-sql语句查出的结果集在进行json格式化"><a href="#序列化底层是根据-sql语句查出的结果集在进行json格式化" class="headerlink" title="序列化底层是根据 sql语句查出的结果集在进行json格式化"></a>序列化底层是根据 sql语句查出的结果集在进行json格式化</h6><p>我们就来实现一下原理</p>
<pre class="highlight"><span class="line"><span class="comment"># 导入原生sql模块</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Search</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment"># 检索字段</span></span><br><span class="line">        text = eval(request.GET.get(<span class="string">'text'</span>,<span class="literal">None</span>))</span><br><span class="line">        <span class="comment"># 建立游标对象</span></span><br><span class="line">        cursor=connection.cursor()</span><br><span class="line">        <span class="comment"># 执行sql语句</span></span><br><span class="line">        cursor.execute(<span class="string">"select * from goods where name like '%%%s%%'"</span> %text)</span><br><span class="line">        <span class="comment"># 查询</span></span><br><span class="line">        res=dictfetch(cursor)</span><br><span class="line">        <span class="comment"># 判断长度</span></span><br><span class="line">        count=len(res)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'msg'</span>:text,<span class="string">"data"</span>:res,<span class="string">'total'</span>:count&#125;)</span><br></pre>

<h6 id="在执行查询的部分-我们调用了dictfetch-函数-因为游标查询出的数据是元祖形式-但是与前端类型不符合-函数内的逻辑就是-将查询出的数据-进行列表嵌套键值对的二次重组"><a href="#在执行查询的部分-我们调用了dictfetch-函数-因为游标查询出的数据是元祖形式-但是与前端类型不符合-函数内的逻辑就是-将查询出的数据-进行列表嵌套键值对的二次重组" class="headerlink" title="在执行查询的部分 我们调用了dictfetch 函数   因为游标查询出的数据是元祖形式 但是与前端类型不符合   函数内的逻辑就是 将查询出的数据 进行列表嵌套键值对的二次重组"></a>在执行查询的部分 我们调用了dictfetch 函数   因为游标查询出的数据是元祖形式 但是与前端类型不符合   函数内的逻辑就是 将查询出的数据 进行列表嵌套键值对的二次重组</h6><pre class="highlight"><span class="line"><span class="comment">#  格式化结果集</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dictfetch</span><span class="params">(cursor)</span>:</span></span><br><span class="line">    <span class="comment"># 声明描述符 description获取字段名</span></span><br><span class="line">    desc= cursor.description</span><br><span class="line">    <span class="comment"># 重组结果</span></span><br><span class="line">    <span class="keyword">return</span> [dict(zip([col[<span class="number">0</span>] <span class="keyword">for</span> col <span class="keyword">in</span> desc],row))</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> cursor.fetchall()</span><br><span class="line">    ]</span><br></pre>
<h3 id="zip-函数将可迭代对象作为参数，并打包成元组-之后在使用dict将tuple-转换为键值对"><a href="#zip-函数将可迭代对象作为参数，并打包成元组-之后在使用dict将tuple-转换为键值对" class="headerlink" title="zip()函数将可迭代对象作为参数，并打包成元组    之后在使用dict将tuple 转换为键值对"></a>zip()函数将可迭代对象作为参数，并打包成元组    之后在使用dict将tuple 转换为键值对</h3><pre class="highlight"><span class="line">[(<span class="string">'name'</span>, <span class="string">'2'</span>)]</span><br></pre>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>拦截器</title>
    <url>/2018/09/04/%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<h4 id="前端vue-index-js-代码示例："><a href="#前端vue-index-js-代码示例：" class="headerlink" title="前端vue(index.js)代码示例："></a>前端vue(index.js)代码示例：</h4><pre class="highlight"><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  path:<span class="string">'/myprofile'</span>,</span><br><span class="line">  name:<span class="string">'myprofile'</span>,</span><br><span class="line">  component:myprofile,</span><br><span class="line">  &lt;!-- to去哪，from来自哪，next下一步 --&gt;</span><br><span class="line">  beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(localStorage.getItem(<span class="string">'username'</span>))&#123;</span><br><span class="line">      console.log(<span class="string">'已经登录'</span>);</span><br><span class="line">      &lt;!-- 注意必须有下一步 --&gt;</span><br><span class="line">      next();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      console.log(<span class="string">'没有登录'</span>);</span><br><span class="line">      next(<span class="string">'/login'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>密码错误五次以上账号锁定功能</title>
    <url>/2018/09/10/%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF%E4%BA%94%E6%AC%A1%E4%BB%A5%E4%B8%8A%E8%B4%A6%E5%8F%B7%E9%94%81%E5%AE%9A%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h3 id="利用Redis数据进行密码输入错误锁号的功能限制操作"><a href="#利用Redis数据进行密码输入错误锁号的功能限制操作" class="headerlink" title="利用Redis数据进行密码输入错误锁号的功能限制操作"></a>利用Redis数据进行密码输入错误锁号的功能限制操作</h3><h6 id="1-构造一个计数器"><a href="#1-构造一个计数器" class="headerlink" title="1.构造一个计数器"></a>1.构造一个计数器</h6><pre class="highlight"><span class="line"></span><br><span class="line"><span class="comment"># 导包</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="comment"># 定义ip 和端口号</span></span><br><span class="line">host = <span class="string">"localhost"</span></span><br><span class="line">port = <span class="number">6379</span></span><br><span class="line"><span class="comment"># 建立链接</span></span><br><span class="line">r = redis.Redis(host=host,port=port)</span><br><span class="line"><span class="comment"># 记录插入放入次数</span></span><br><span class="line"><span class="comment"># a = r.incr(‘keys’0)</span></span><br><span class="line"><span class="comment"># print(a)</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">5</span>：</span><br><span class="line">	print(<span class="string">"你的账号被锁定了"</span>)</span><br></pre>

<hr>
<h6 id="2-通过列表类型的数组"><a href="#2-通过列表类型的数组" class="headerlink" title="2.通过列表类型的数组"></a>2.通过列表类型的数组</h6><pre class="highlight"><span class="line"><span class="comment">#导包</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义ip和端口号</span></span><br><span class="line">host = <span class="string">"127.0.0.1"</span></span><br><span class="line">port = <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#建立连接</span></span><br><span class="line">r = redis.Redis(host=host,port=port)</span><br><span class="line"><span class="comment">#用户名</span></span><br><span class="line">username = <span class="string">'laowang'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#账号密码输入错误5次后锁住账号逻辑</span></span><br><span class="line"><span class="comment">#列表操作</span></span><br><span class="line">r.lpush(username,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置过期时间,单位是秒</span></span><br><span class="line">r.expire(username,<span class="number">30</span>)</span><br><span class="line"><span class="comment">#打印过期时间</span></span><br><span class="line">print(r.ttl(username))</span><br><span class="line"><span class="comment">#打印列表长度</span></span><br><span class="line">print(r.llen(username))</span><br><span class="line"><span class="keyword">if</span> r.llen(username) &gt; <span class="number">5</span>:</span><br><span class="line">    print(<span class="string">'你的账号被锁定'</span>)</span><br></pre>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>模糊查询及关键字高亮</title>
    <url>/2018/09/17/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E5%8F%8A%E5%85%B3%E9%94%AE%E5%AD%97%E9%AB%98%E4%BA%AE/</url>
    <content><![CDATA[<h2 id="如何实现多条件模糊查询"><a href="#如何实现多条件模糊查询" class="headerlink" title="如何实现多条件模糊查询"></a>如何实现多条件模糊查询</h2><pre class="highlight"><span class="line">在我们一般使用淘宝网站的时候</span><br><span class="line">经常使用一些连词 来精准查询的结果</span><br><span class="line"></span><br><span class="line">例：使用 夏季 鞋子 男 休闲 等词语来指定查找</span><br><span class="line"></span><br><span class="line">那么如何实现该功能呢</span><br></pre>

<pre class="highlight"><span class="line">&lt;!--实现搜索框--&gt;</span><br><span class="line">&lt;input @change=<span class="string">'search'</span> v-model=<span class="string">"text"</span> &gt;</span><br></pre>

<hr>
<h3 id="text-变量就是绑定的搜索的参数-我们只需要判断该变量就可以了"><a href="#text-变量就是绑定的搜索的参数-我们只需要判断该变量就可以了" class="headerlink" title="text 变量就是绑定的搜索的参数  我们只需要判断该变量就可以了"></a>text 变量就是绑定的搜索的参数  我们只需要判断该变量就可以了</h3><pre class="highlight"><span class="line">	// 查询字符串中是否有空格</span><br><span class="line"><span class="keyword">if</span> (this.text.indexOf(<span class="string">' '</span>))&#123;</span><br><span class="line">    //由空格为间隔切片为list</span><br><span class="line">    var text = this.text.split(<span class="string">" "</span>)</span><br><span class="line">    // 生成list形式的字符串</span><br><span class="line">    text = JSON.stringify(text)</span><br><span class="line">&#125;</span><br></pre>

<hr>
<h3 id="对查询参数进行操作-生成字符串：-“value1”-”value2”-在后台接受的参数时将该字符串转换为列表"><a href="#对查询参数进行操作-生成字符串：-“value1”-”value2”-在后台接受的参数时将该字符串转换为列表" class="headerlink" title="对查询参数进行操作 生成字符串：[“value1”,”value2”]   在后台接受的参数时将该字符串转换为列表"></a>对查询参数进行操作 生成字符串：[“value1”,”value2”]   在后台接受的参数时将该字符串转换为列表</h3><pre class="highlight"><span class="line"><span class="comment"># 检索字段</span></span><br><span class="line">text = eval(request.GET.get(<span class="string">'text'</span>,<span class="literal">None</span>))</span><br></pre>

<hr>
<h3 id="模糊查询操作"><a href="#模糊查询操作" class="headerlink" title="模糊查询操作"></a>模糊查询操作</h3><h5 id="操作思路：循环查询参数-每次查询之后添加进列表"><a href="#操作思路：循环查询参数-每次查询之后添加进列表" class="headerlink" title="操作思路：循环查询参数 每次查询之后添加进列表"></a>操作思路：循环查询参数 每次查询之后添加进列表</h5><pre class="highlight"><span class="line"><span class="comment"># 是否进行模糊查询</span></span><br><span class="line"><span class="keyword">if</span> text:</span><br><span class="line">    goods=[]</span><br><span class="line">    <span class="comment"># 循环条件列表</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> text:</span><br><span class="line">        <span class="comment"># 每次循环 查询数据</span></span><br><span class="line">        good_obj=Goods.objects.filter(Q(name__contains=key)|Q(desc__contains=key)).all()</span><br><span class="line">        <span class="comment"># 向列表尾部拼接</span></span><br><span class="line">        goods.extend(good_obj)</span><br><span class="line">        <span class="comment"># 去重 防止重复 有时重复查询同一个 会出现多数据 就需要去重</span></span><br><span class="line">        goods=list(set(goods))</span><br><span class="line">        count = len(goods)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 查询所有商品个数</span></span><br><span class="line">     count = Goods.objects.count()</span><br></pre>

<hr>
<h3 id="关键字高亮Permalink"><a href="#关键字高亮Permalink" class="headerlink" title="关键字高亮Permalink"></a>关键字高亮Permalink</h3><pre class="highlight"><span class="line">在我们访问百度的时候 经常看见自己查询的关键字是红色的</span><br><span class="line"></span><br><span class="line">这是怎么做到的呢</span><br><span class="line"></span><br><span class="line">可以用过滤器来操作</span><br></pre>
<pre class="highlight"><span class="line">//过滤器</span><br><span class="line"> filters:&#123;</span><br><span class="line">	 make_text(str)&#123;</span><br><span class="line">		var mytext=str.toString()</span><br><span class="line">		var text=<span class="string">'关键字'</span></span><br><span class="line">        // new RegExp(text,<span class="string">'g'</span>) 正则模式全文检索 </span><br><span class="line">		<span class="keyword">return</span> mytext.replace(new RegExp(text,<span class="string">'g'</span>),<span class="string">'&lt;span class="highlight"&gt;'</span>+text+<span class="string">'&lt;/span&gt;'</span>)</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;,</span><br></pre>

<hr>
<h6 id="可以实现为-关键字-词语-这样我们就可以设置指定样式来输出了-使用-v-html-来输出"><a href="#可以实现为-关键字-词语-这样我们就可以设置指定样式来输出了-使用-v-html-来输出" class="headerlink" title="可以实现为 关键字 词语   这样我们就可以设置指定样式来输出了   使用 v-html 来输出"></a>可以实现为 <span class="mystyle">关键字<span> 词语   这样我们就可以设置指定样式来输出了   使用 v-html 来输出</h6><pre class="highlight"><span class="line">&lt;!--因为v-html与其他不同 需要以调用方式来使用过滤器--&gt;</span><br><span class="line">&lt;!--如果全局声明了装饰器就不需要 否则就要以$options.filters.装饰器 来使用--&gt;</span><br><span class="line">&lt;span v-html='$options.filters.make_text(item.name)'&gt;&lt;/span&gt;</span><br></pre>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>画中画</title>
    <url>/2018/08/28/%E7%94%BB%E4%B8%AD%E7%94%BB/</url>
    <content><![CDATA[<pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        视频：&lt;video id='video' :src="img_url" width="350" height="240"&gt;&lt;/video&gt;</span><br><span class="line">        &lt;Button @click="into"&gt;&#123;&#123; this.hzh&#125;&#125;&lt;/Button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            //画中画</span><br><span class="line">            hzh : <span class="string">'进入画中画'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        //画中画</span><br><span class="line">        into:function()&#123;</span><br><span class="line">            <span class="keyword">if</span>(video != document.pictureInPictureElement)&#123;</span><br><span class="line">                //尝试进入画中画</span><br><span class="line">                video.requestPictureInPicture();</span><br><span class="line">                this.hzh = <span class="string">'退出画中画'</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                //退出画中画</span><br><span class="line">                document.exitPictureInPicture();</span><br><span class="line">                this.hzh = <span class="string">'进入画中画'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;，</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre>

<hr>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/2019/09/15/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>在调用一个函数的过程中，直接或间接地调用了函数本身这个就叫递归。但为了避免出现死循环，必须要有一个结束条件</p>
<p>在函数中调用函数本身时，相当于你让程序回到函数的第一行重新走一遍而已。、</p>
<p><img src="https://v3u.cn/book/img/dd1.jpg" alt="~~~~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://v3u.cn/book/img/dd1.jpg" class="lozad post-image"></p>
<pre class="highlight"><span class="line">def foo(S, T):</span><br><span class="line">    S &#x3D; T * T - S</span><br><span class="line">    if S &gt;&#x3D; 10:</span><br><span class="line">        W &#x3D; S + T * T</span><br><span class="line">        return W</span><br><span class="line">    else:</span><br><span class="line">        foo(S, T * 2)</span><br></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>验证码设置&amp;检测</title>
    <url>/2018/10/26/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AE%BE%E7%BD%AE&amp;%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h3 id="django设置验证码"><a href="#django设置验证码" class="headerlink" title="django设置验证码"></a>django设置验证码</h3><pre class="highlight"><span class="line"><span class="comment">#导入图片库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#绘画库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageDraw</span><br><span class="line"><span class="comment">#字体库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFont</span><br><span class="line"><span class="comment">#图片库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="comment">#随机库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#文件流</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#导包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="comment">#定义ip和端口号</span></span><br><span class="line"></span><br><span class="line">host = <span class="string">'localhost'</span></span><br><span class="line">port = <span class="number">6379</span></span><br><span class="line"><span class="comment">#建立连接</span></span><br><span class="line"></span><br><span class="line">r = redis.Redis(host=host,port=port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#自定义图片验证码</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCode</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="comment">#定义rgb随机颜色获取</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_random_color</span><span class="params">(self)</span>:</span></span><br><span class="line">        R = random.randrange(<span class="number">255</span>)</span><br><span class="line">        G = random.randrange(<span class="number">255</span>)</span><br><span class="line">        B = random.randrange(<span class="number">255</span>)</span><br><span class="line">        <span class="keyword">return</span> (R,G,B)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#定义画布</span></span><br><span class="line"></span><br><span class="line">        img_size = (<span class="number">120</span>,<span class="number">50</span>)<span class="comment">#宽120px，高50px</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#定义图片对象</span></span><br><span class="line"></span><br><span class="line">        image = Image.new(<span class="string">'RGB'</span>,img_size,<span class="string">'white'</span>)<span class="comment">#RGB的颜色模式 #画布 #背景颜色为白色</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#定义画笔</span></span><br><span class="line"></span><br><span class="line">        draw = ImageDraw.Draw(image,<span class="string">'RGB'</span>)  <span class="comment">#图片对象  #参数mode：RGB颜色模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#画笔内容</span></span><br><span class="line"></span><br><span class="line">        source = <span class="string">'0123456789abcdefghijklmnopqrstuvwxyz'</span><span class="comment">#内容为数字，字母，特殊符号，增加安全性</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#接收容器</span></span><br><span class="line"></span><br><span class="line">        code_str = <span class="string">''</span></span><br><span class="line">        <span class="comment">#定义字体，在本地路径下,size字体大小</span></span><br><span class="line"></span><br><span class="line">        myfont = ImageFont.truetype(font=<span class="string">'C:\\Windows\\Fonts\\Arial.ttf'</span>,size=<span class="number">25</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            <span class="comment">#获取字母颜色</span></span><br><span class="line"></span><br><span class="line">            text_color = self.get_random_color()</span><br><span class="line">            <span class="comment">#获取随机下标</span></span><br><span class="line"></span><br><span class="line">            tmp_num = random.randrange(len(source))</span><br><span class="line">            <span class="comment">#随机验证码内容</span></span><br><span class="line"></span><br><span class="line">            random_str = source[tmp_num]</span><br><span class="line">            <span class="comment">#装入容器</span></span><br><span class="line"></span><br><span class="line">            code_str += random_str</span><br><span class="line">            <span class="comment">#绘制验证码</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 参数(横坐标，纵坐标20),#验证码内容#验证码颜色#字体</span></span><br><span class="line"></span><br><span class="line">            draw.text((<span class="number">10</span>+<span class="number">30</span>*i,<span class="number">10</span>),random_str,text_color,font=myfont)</span><br><span class="line">        <span class="comment">#获取缓冲区</span></span><br><span class="line"></span><br><span class="line">        buf = io.BytesIO()</span><br><span class="line">        <span class="comment">#将临时图片保存到缓冲区</span></span><br><span class="line"></span><br><span class="line">        image.save(buf,<span class="string">'png'</span>)</span><br><span class="line">        <span class="comment">#保存随机验证码</span></span><br><span class="line"></span><br><span class="line">        r.set(<span class="string">'code'</span>,code_str)</span><br><span class="line">        <span class="comment">#保存session到数据库中的django_session</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">'222'</span>,r.get(<span class="string">'code'</span>))</span><br><span class="line">        <span class="comment"># request.session['code'] = code_str</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#返回获取缓冲区的图片</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(buf.getvalue(),<span class="string">'image/png'</span>)</span><br></pre>

<hr>
<h3 id="vue展示验证码"><a href="#vue展示验证码" class="headerlink" title="vue展示验证码"></a>vue展示验证码</h3><pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 图片验证码 --&gt;</span><br><span class="line">    &lt;img :src="src" alt="点击刷新" @click="img_code" class="imgcode"&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">	  src:<span class="string">'http://127.0.0.1:8000/code/'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    //刷新验证码</span><br><span class="line">	img_code()&#123;</span><br><span class="line">		//给图片网址加一个随机参数，可以点击刷新验证码</span><br><span class="line">		var lsrc = <span class="string">'http://127.0.0.1:8000/code/'</span>+<span class="string">'?'</span>+Math.random()</span><br><span class="line">		this.src = lsrc</span><br><span class="line"></span><br><span class="line">		//var num = Math.ceil(Math.random()*<span class="number">10</span>)</span><br><span class="line">		// this.src = this.src + <span class="string">'?num='</span>+num</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.imgcode &#123;</span><br><span class="line">    /* 给图片点击鼠标更换小手样式 */</span><br><span class="line">	cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre>


<h4 id="Api检测验证码-百度AI"><a href="#Api检测验证码-百度AI" class="headerlink" title="Api检测验证码(百度AI)"></a>Api检测验证码(百度AI)</h4><pre class="highlight"><span class="line"></span><br><span class="line">1.创建百度账号或者登陆百度账号</span><br><span class="line">2.选择总览--&gt;人工智能--&gt;文字识别--&gt;创建一个应用</span><br><span class="line">3.输入应用名,选择不需要文字识别包名--&gt;输入描述--&gt;点击创建(会有API Key和Secret Key)</span><br><span class="line">4.在左边目录中点击技术文档--&gt;点击API文档，立即使用</span><br><span class="line">5.选择通用文字识别--&gt;通用文字识别(高精度版)--&gt;点击Access token获取</span><br><span class="line">6.获取Access token：</span><br><span class="line">    1.向授权服务地址https:&#x2F;&#x2F;aip.baidubce.com&#x2F;oauth&#x2F;2.0&#x2F;token发送请求（推荐使用POST),并在URL中带上以下参数</span><br><span class="line">        grant_type： 必须参数，固定为client_credentials；</span><br><span class="line">        client_id： 必须参数，应用的API Key；</span><br><span class="line">        client_secret： 必须参数，应用的Secret Key；</span><br><span class="line">    2.url &#x3D; https:&#x2F;&#x2F;aip.baidubce.com&#x2F;oauth&#x2F;2.0&#x2F;token?</span><br><span class="line">      grant_type&#x3D;client_credentials&amp;client_id&#x3D;百度云应用的API Key&amp;client_secret&#x3D;百度云应用的Secret Key</span><br><span class="line">    3.使用json()获取：</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;refresh_token&quot;: &quot;25.b55fe1d287227ca97aab219bb249b8ab.315360000.1798284651.282335-8574074&quot;,</span><br><span class="line">        &quot;expires_in&quot;: 2592000,  # Access Token的有效期(秒为单位，一般为1个月)</span><br><span class="line">        &quot;scope&quot;: &quot;public wise_adapt&quot;,</span><br><span class="line">        &quot;session_key&quot;: &quot;9mzdDZXu3dENdFZQurfg0Vz8slgSgvvOAUebNFzyzcpQ5EnbxbF+hfG9DQkpUVQdh4p6HbQcAiz5RmuBAja1JJGgIdJI&quot;,</span><br><span class="line">        &quot;access_token&quot;: &quot;24.6c5e1ff107f0e8bcef8c46d3424a0e78.2592000.1485516651.282335-8574074&quot;,  #要获取的Access Token</span><br><span class="line">        &quot;session_secret&quot;: &quot;dfac94a3489fe9fca7c3221cbf7525ff&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    4.关于报错信息：</span><br><span class="line">      &#123;</span><br><span class="line">        error： 错误码；关于错误码的详细信息请参考下方鉴权认证错误码。</span><br><span class="line">        error_description： 错误描述信息，帮助理解和解决发生的错误。</span><br><span class="line">      &#125;</span><br><span class="line">      &#123;</span><br><span class="line">        error(错误码)     error_description(错误描述信息)	  解释</span><br><span class="line">        invalid_client	 unknown client id	              API Key不正确</span><br><span class="line">        invalid_client	 Client authentication failed	    Secret Key不正确</span><br><span class="line">      &#125;</span><br><span class="line">7.访问url：&#39;https:&#x2F;&#x2F;aip.baidubce.com&#x2F;rest&#x2F;2.0&#x2F;ocr&#x2F;v1&#x2F;accurate_basic?access_token&#x3D;&#39; + access_token</span><br><span class="line">8.HTTP方法：POST</span><br><span class="line">9.Header参数：&#123;&#39;Content-Type&#39;:&#39;application&#x2F;x-www-form-urlencoded&#39;&#125;</span><br><span class="line">10.body必要参数：image   说明：ase64编码后进行urlencode</span><br><span class="line">11.返回结果：&#123;</span><br><span class="line">              log_id：唯一的log id，用于问题定位,</span><br><span class="line">              words_result:	识别结果数组,</span><br><span class="line">              words_result_num:	识别结果数，表示words_result的元素个数,</span><br><span class="line">              words：识别结果字符串,</span><br><span class="line">            &#125;</span><br></pre>


<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><pre class="highlight"><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"><span class="comment">#访问url</span></span><br><span class="line"></span><br><span class="line">res = requests.post(<span class="string">'https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=jHUoq7NLRtijZz4RaVUHxnZC&amp;client_secret=jqBWDRAkrWlB3mKzjkGYRoTxW8fgpW5m'</span>)</span><br><span class="line"><span class="comment">#获取access_token</span></span><br><span class="line"></span><br><span class="line">access_token = res.json()[<span class="string">'access_token'</span>]</span><br><span class="line">print(access_token)</span><br><span class="line"><span class="comment">#开始智能识图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#接口地址，访问ulr</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://aip.baidubce.com/rest/2.0/ocr/v1/accurate_basic?access_token='</span>+access_token</span><br><span class="line"><span class="comment">#定义请求头</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"Content-Type"</span>:<span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#操作图片</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#读取图片</span></span><br><span class="line"></span><br><span class="line">myimg = open(<span class="string">'../code.png'</span>,<span class="string">'rb'</span>)</span><br><span class="line">img_temp = myimg.read()</span><br><span class="line">myimg.close()</span><br><span class="line"><span class="comment">#对图片进行base64编码</span></span><br><span class="line"></span><br><span class="line">temp_data = &#123;</span><br><span class="line">    <span class="string">'image'</span>:base64.b64encode(img_temp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#对图片地址进行urlencode操作</span></span><br><span class="line"></span><br><span class="line">temp_data = urllib.parse.urlencode(temp_data)</span><br><span class="line"><span class="comment">#发起post请求</span></span><br><span class="line"></span><br><span class="line">res = requests.post(url=url,headers=headers,data=temp_data)</span><br><span class="line">res_list = res.json()</span><br><span class="line">print(res_list)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res_list[<span class="string">'words_result'</span>]:</span><br><span class="line">    code = i[<span class="string">'words'</span>].replace(<span class="string">' '</span>,<span class="string">""</span>)</span><br><span class="line">    print(code)</span><br></pre>

<hr>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>进程，线程和协程的区别</title>
    <url>/2018/09/01/%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><strong>现在多进程多线程已经是老生常谈了，协程也在最近几年流行起来。python中有协程库gevent，py web框架tornado中也用了gevent封装好的协程。本文主要介绍进程、线程和协程三者之间的区别。</strong></p>
<h1 id="一-概念"><a href="#一-概念" class="headerlink" title="一.  概念"></a>一.  概念</h1><p><strong>1. 进程</strong></p>
<p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</p>
<p><strong>2.  线程</strong></p>
<p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</p>
<p><strong>3. 协程</strong></p>
<p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<h1 id="二-区别"><a href="#二-区别" class="headerlink" title="二.  区别"></a>二.  区别</h1><p><strong>1， 进程多与线程比较</strong></p>
<p>线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:</p>
<p>1) 地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间<br>2) 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源<br>3) 线程是处理器调度的基本单位,但进程不是<br>4) 二者均可并发执行</p>
<p>5) 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</p>
<p><strong>2，协程多与线程进行比较</strong></p>
<p>1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。</p>
<p>2) 线程进程都是同步机制，而协程则是异步</p>
<p>3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</p>
<h1 id="三-进程和线程、协程在python中的使用"><a href="#三-进程和线程、协程在python中的使用" class="headerlink" title="三.  进程和线程、协程在python中的使用"></a>三.  进程和线程、协程在python中的使用</h1><ol>
<li><p>多进程一般使用multiprocessing库，来利用多核CPU，主要是用在CPU密集型的程序上，当然生产者消费者这种也可以使用。多进程的优势就是一个子进程崩溃并不会影响其他子进程和主进程的运行，但缺点就是不能一次性启动太多进程，会严重影响系统的资源调度，特别是CPU使用率和负载。使用多进程可以查看文章《python 多进程使用总结》。注：python2的进程池在类中的使用会有问题，需要把类函数定义成全局函数。具体可参考 <a href="http://bbs.chinaunix.net/thread-4111379-1-1.html" target="_blank" rel="noopener">http://bbs.chinaunix.net/thread-4111379-1-1.html</a></p>
</li>
<li><p>多线程一般是使用threading库，完成一些IO密集型并发操作。多线程的优势是切换快，资源消耗低，但一个线程挂掉则会影响到所有线程，所以不够稳定。现实中使用线程池的场景会比较多，具体可参考《python线程池实现》。</p>
</li>
<li><p>协程一般是使用gevent库，当然这个库用起来比较麻烦，所以使用的并不是很多。相反，协程在tornado的运用就多得多了，使用协程让tornado做到单线程异步，据说还能解决C10K的问题。所以协程使用的地方最多的是在web应用上。</p>
<h1 id="四-一个形象的例子解释进程和线程的区别"><a href="#四-一个形象的例子解释进程和线程的区别" class="headerlink" title="四.  一个形象的例子解释进程和线程的区别"></a>四.  一个形象的例子解释进程和线程的区别</h1><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC9hdHRhY2htZW50LzIwMTMxMC8yMy8yOTI3MDYyOF8xMzgyNTQxOTUxbkplNy5qcGc?x-oss-process=image/format,png" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC9hdHRhY2htZW50LzIwMTMxMC8yMy8yOTI3MDYyOF8xMzgyNTQxOTUxbkplNy5qcGc?x-oss-process=image/format,png" class="lozad post-image"><br>这副图是一个双向多车道的道路图，假如我们<strong>把整条道路看成是一个“进程</strong>”<strong>的话</strong>，那么图中由白色虚线分隔开来的<strong>各个车道就是进程中的各个“线程”</strong>了。</p>
</li>
</ol>
<ul>
<li><p>这些线程(车道)共享了进程(道路)的公共资源(土地资源)。</p>
</li>
<li><p>这些线程(车道)必须依赖于进程(道路)，也就是说，线程不能脱离于进程而存在(就像离开了道路，车道也就没有意义了)。</p>
</li>
<li><p>这些线程(车道)之间可以并发执行(各个车道你走你的，我走我的)，也可以互相同步(某些车道在交通灯亮时禁止继续前行或转弯，必须等待其它车道的车辆通行完毕)。</p>
</li>
<li><p>这些线程(车道)之间依靠代码逻辑(交通灯)来控制运行，一旦代码逻辑控制有误(死锁，多个线程同时竞争唯一资源)，那么线程将陷入混乱，无序之中。</p>
</li>
<li><p>这些线程(车道)之间谁先运行是未知的，只有在线程刚好被分配到CPU时间片(交通灯变化)的那一刻才能知道。</p>
</li>
</ul>
<hr>
<p><strong>总结一下就是IO密集型一般使用多线程或者多进程，CPU密集型一般使用多进程，强调非阻塞异步并发的一般都是使用协程，当然有时候也是需要多进程线程池结合的，或者是其他组合方式。</strong></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Celery在Django 项目中如何使用</title>
    <url>/2019/09/30/Celery%E5%9C%A8Django%20%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="创建目录celery-pro，并在celery-pro下创建下面两个文件"><a href="#创建目录celery-pro，并在celery-pro下创建下面两个文件" class="headerlink" title="创建目录celery_pro，并在celery_pro下创建下面两个文件"></a>创建目录celery_pro，并在celery_pro下创建下面两个文件</h3><p>celery.py</p>
<pre class="highlight"><span class="line"># celery.py</span><br><span class="line"># -*- coding:utf8 -*-</span><br><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line">#1. absolute_import 可以使导入的celery是python绝对路基的celery模块，不是当前我们创建的celery.py</span><br><span class="line">#2. unicode_literals 模块可能是python2和3兼容的，不知道</span><br><span class="line">from celery import Celery</span><br><span class="line"># from .celery import Celery        #这样才是导入当前目录下的celery</span><br><span class="line">			# 填写你的项目名</span><br><span class="line">app &#x3D; Celery(&#39;project&#39;,</span><br><span class="line">             broker&#x3D;&#39;redis:&#x2F;&#x2F;localhost&#39;,</span><br><span class="line">             backend&#x3D;&#39;redis:&#x2F;&#x2F;localhost&#39;,</span><br><span class="line">             include&#x3D;[&#39;celery_pro.tasks&#39;,</span><br><span class="line">                      &#39;celery_pro.tasks2&#39;,</span><br><span class="line">                      ])</span><br><span class="line">#celery——pro是存放celery文件的文件夹名字</span><br><span class="line"></span><br><span class="line">#实例化时可以添加下面这个属性</span><br><span class="line">app.conf.update(</span><br><span class="line">   result_expires&#x3D;3600,        #执行结果放到redis里，一个小时没人取就丢弃</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 配置定时任务：每5秒钟执行 调用一次celery_pro下tasks.py文件中的add函数</span><br><span class="line">app.conf.beat_schedule &#x3D; &#123;</span><br><span class="line">    &#39;add-every-5-seconds&#39;: &#123;</span><br><span class="line">        &#39;task&#39;: &#39;celery_pro.tasks.add&#39;,  # 寻找tasks下面的add函数</span><br><span class="line">        &#39;schedule&#39;: 5.0,</span><br><span class="line">        &#39;args&#39;: (16, 16)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">app.conf.timezone &#x3D; &#39;UTC&#39;   # 配置的时间规范</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">   app.start()</span><br></pre>
<h3 id="task-py"><a href="#task-py" class="headerlink" title="task.py"></a>task.py</h3><pre class="highlight"><span class="line"># task.py</span><br><span class="line"># -*- coding:utf8 -*-</span><br><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line">from .celery import app       #从当前目录导入app</span><br><span class="line"></span><br><span class="line">#写一个add函数</span><br><span class="line">@app.task</span><br><span class="line">def add(x, y):</span><br><span class="line">    return x + y</span><br></pre>

<h3 id="task2-py"><a href="#task2-py" class="headerlink" title="task2.py"></a>task2.py</h3><pre class="highlight"><span class="line"># task2.py</span><br><span class="line"># -*- coding:utf8 -*-</span><br><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line">from .celery import app</span><br><span class="line">import time,random</span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def randnum(start,end):</span><br><span class="line">    time.sleep(3)</span><br><span class="line">    return random.randint(start,end)</span><br><span class="line"></span><br><span class="line">tasks2.py</span><br></pre>
<p>touch <strong>init</strong>.py<br>在celery_pro目录下新建<strong>init</strong>.py文件，否则执行命令时会报错</p>
<h3 id="执行下面两条命令即可让celery定时执行任务了"><a href="#执行下面两条命令即可让celery定时执行任务了" class="headerlink" title="执行下面两条命令即可让celery定时执行任务了"></a>执行下面两条命令即可让celery定时执行任务了</h3><ol>
<li><p>启动一个worker：在celery_pro外层目录下执行<br>celery -A celery_pro worker -l info</p>
</li>
<li><p>启动任务调度器 celery beat<br>celery -A celery_pro beat -l info</p>
</li>
<li><p>执行效果<br>看到celery运行日志中每5秒回返回一次 add函数执行结果</p>
</li>
</ol>
<h3 id="启动celery的worker：每台机器可以启动8个worker"><a href="#启动celery的worker：每台机器可以启动8个worker" class="headerlink" title="启动celery的worker：每台机器可以启动8个worker"></a>启动celery的worker：每台机器可以启动8个worker</h3><ol>
<li>在pythondir目录下启动 /pythondir/celery_pro/ 目录下的worker</li>
</ol>
<p>celery -A celery_pro worker -l info</p>
<ol start="2">
<li>后台启动worker：/pythondir/celery_pro/目录下执行</li>
</ol>
<pre class="highlight"><span class="line">celery multi start w1 -A celery_pro -l info             #在后台启动w1这个worker</span><br><span class="line"></span><br><span class="line">celery multi start w1 w2 -A celery_pro -l info       #一次性启动w1,w2两个worker</span><br><span class="line"></span><br><span class="line">celery -A celery_pro status                       #查看当前有哪些worker在运行</span><br><span class="line"></span><br><span class="line">celery multi stop w1 w2 -A celery_pro                   #停止w1,w2两个worker</span><br><span class="line"></span><br><span class="line">celery multi restart w1 w2 -A celery_pro               #重启w1,w2两个worker</span><br></pre>
<h3 id="也可以手动给celery分配任务：在-pythondir-下执行"><a href="#也可以手动给celery分配任务：在-pythondir-下执行" class="headerlink" title="也可以手动给celery分配任务：在/pythondir/下执行"></a>也可以手动给celery分配任务：在/pythondir/下执行</h3><pre class="highlight"><span class="line">python3</span><br><span class="line">from celery_pro import tasks,tasks2</span><br><span class="line"></span><br><span class="line">t1 &#x3D; tasks.add.delay(34,3)</span><br><span class="line">t2 &#x3D; tasks2.randnum.delay(1,10000)             </span><br><span class="line">t1.get()</span><br><span class="line">t2.get()</span><br><span class="line"></span><br><span class="line">手动给celery分配任务：在&#x2F;pythondir&#x2F;下执行</span><br></pre>

<h3 id="celery与Django项目最佳实践"><a href="#celery与Django项目最佳实践" class="headerlink" title="celery与Django项目最佳实践"></a>celery与Django项目最佳实践</h3><pre class="highlight"><span class="line">pip3 install Django&#x3D;&#x3D;2.0.4</span><br><span class="line">pip3 install celery&#x3D;&#x3D;4.3.0</span><br><span class="line">pip3 install redis&#x3D;&#x3D;3.2.1</span><br><span class="line">pip3 install ipython&#x3D;&#x3D;7.6.1 </span><br><span class="line"></span><br><span class="line">find .&#x2F; -type f | xargs sed -i &#39;s&#x2F;\r$&#x2F;&#x2F;g&#39;     # 批量将当前文件夹下所有文件装换成unix格式</span><br><span class="line">celery  multi start celery_test -A celery_test -l debug --autoscale&#x3D;50,5        # celery并发数：最多50个，最少5个</span><br><span class="line">http:&#x2F;&#x2F;docs.celeryproject.org&#x2F;en&#x2F;latest&#x2F;reference&#x2F;celery.bin.worker.html#cmdoption-celery-worker-autoscale</span><br><span class="line">ps auxww|grep &quot;celery worker&quot;|grep -v grep|awk &#39;&#123;print $2&#125;&#39;|xargs kill -9       # 关闭所有celery进程</span><br></pre>

<h3 id="在Django中使用celery介绍（celery无法再windows下运行）"><a href="#在Django中使用celery介绍（celery无法再windows下运行）" class="headerlink" title="在Django中使用celery介绍（celery无法再windows下运行）"></a>在Django中使用celery介绍（celery无法再windows下运行）</h3><ol>
<li><p>在Django中使用celery时，celery文件必须以tasks.py</p>
</li>
<li><p>Django会自动到每个APP中找tasks.py文件</p>
</li>
</ol>
<h3 id="创建一个Django项目celery-test，和app01"><a href="#创建一个Django项目celery-test，和app01" class="headerlink" title="创建一个Django项目celery_test，和app01"></a>创建一个Django项目celery_test，和app01</h3><h3 id="在与项目同名的目录下创建celery-py"><a href="#在与项目同名的目录下创建celery-py" class="headerlink" title="在与项目同名的目录下创建celery.py"></a>在与项目同名的目录下创建celery.py</h3><pre class="highlight"><span class="line"># celery.py</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from __future__ import absolute_import</span><br><span class="line">import os</span><br><span class="line">from celery import Celery</span><br><span class="line"></span><br><span class="line"># 只要是想在自己的脚本中访问Django的数据库等文件就必须配置Django的环境变量</span><br><span class="line">os.environ.setdefault(&#39;DJANGO_SETTINGS_MODULE&#39;, &#39;celery_test.settings&#39;)</span><br><span class="line"></span><br><span class="line"># app名字</span><br><span class="line">app &#x3D; Celery(&#39;celery_test&#39;)</span><br><span class="line"></span><br><span class="line"># 配置celery</span><br><span class="line">class Config:</span><br><span class="line">    BROKER_URL &#x3D; &#39;redis:&#x2F;&#x2F;192.168.56.11:6379&#39;</span><br><span class="line">    CELERY_RESULT_BACKEND &#x3D; &#39;redis:&#x2F;&#x2F;192.168.56.11:6379&#39;</span><br><span class="line"></span><br><span class="line">app.config_from_object(Config)</span><br><span class="line"># 到各个APP里自动发现tasks.py文件</span><br><span class="line">app.autodiscover_tasks()</span><br></pre>

<h3 id="在与项目同名的目录下的-init-py-文件中添加下面内容"><a href="#在与项目同名的目录下的-init-py-文件中添加下面内容" class="headerlink" title="在与项目同名的目录下的 init.py 文件中添加下面内容"></a>在与项目同名的目录下的 init.py 文件中添加下面内容</h3><pre class="highlight"><span class="line"># __init__.py </span><br><span class="line"># -*- coding:utf8 -*-</span><br><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line"></span><br><span class="line"># 告诉Django在启动时别忘了检测我的celery文件</span><br><span class="line">from .celery import app as celery_ap</span><br><span class="line">__all__ &#x3D; [&#39;celery_app&#39;]</span><br></pre>

<h3 id="创建app01-tasks-py文件"><a href="#创建app01-tasks-py文件" class="headerlink" title="创建app01/tasks.py文件"></a>创建app01/tasks.py文件</h3><pre class="highlight"><span class="line"># tasks.py</span><br><span class="line"># -*- coding:utf8 -*-</span><br><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line">from celery import shared_task</span><br><span class="line"></span><br><span class="line"># 这里不再使用@app.task,而是用@shared_task，是指定可以在其他APP中也可以调用这个任务</span><br><span class="line">@shared_task</span><br><span class="line">def add(x, y):</span><br><span class="line">   return x + y</span><br></pre>

<h3 id="在setings-py文件指定redis服务器的配置"><a href="#在setings-py文件指定redis服务器的配置" class="headerlink" title="在setings.py文件指定redis服务器的配置"></a>在setings.py文件指定redis服务器的配置</h3><pre class="highlight"><span class="line"># settings.py</span><br><span class="line">CELERY_BROKER_URL &#x3D; &#39;redis:&#x2F;&#x2F;localhost&#39;</span><br><span class="line">CELERY_RESULT_BACKEND &#x3D; &#39;redis:&#x2F;&#x2F;localhost&#39;</span><br></pre>


<h3 id="将celery-test这个Django项目拷贝到centos7-3的django-test文件夹中"><a href="#将celery-test这个Django项目拷贝到centos7-3的django-test文件夹中" class="headerlink" title="将celery_test这个Django项目拷贝到centos7.3的django_test文件夹中"></a>将celery_test这个Django项目拷贝到centos7.3的django_test文件夹中</h3><h3 id="保证启动了redis-server"><a href="#保证启动了redis-server" class="headerlink" title="保证启动了redis-server"></a>保证启动了redis-server</h3><h3 id="启动一个celery的worker"><a href="#启动一个celery的worker" class="headerlink" title="启动一个celery的worker"></a>启动一个celery的worker</h3><pre class="highlight"><span class="line">celery -A celery_test worker -l info</span><br></pre>

<h3 id="在Linux中启动-Django项目"><a href="#在Linux中启动-Django项目" class="headerlink" title="在Linux中启动 Django项目"></a>在Linux中启动 Django项目</h3><pre class="highlight"><span class="line">python3 manage.py runserver 0.0.0.0:9000</span><br></pre>
<h3 id="访问http-1-1-1-3-9000-celery-call-获取任务id"><a href="#访问http-1-1-1-3-9000-celery-call-获取任务id" class="headerlink" title="访问http://1.1.1.3:9000/celery_call/ 获取任务id"></a>访问<a href="http://1.1.1.3:9000/celery_call/" target="_blank" rel="noopener">http://1.1.1.3:9000/celery_call/</a> 获取任务id</h3><p><img src="https://img-blog.csdnimg.cn/20200222231228719.png" alt="~~~~~~~~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200222231228719.png" class="lozad post-image"></p>
<h3 id="根据11中的任务id获取对应的值"><a href="#根据11中的任务id获取对应的值" class="headerlink" title="根据11中的任务id获取对应的值"></a>根据11中的任务id获取对应的值</h3><p><a href="http://1.1.1.3:9000/celery_result/?id=5065b65b-0c01-430a-a67f-9531fe3e8d90" target="_blank" rel="noopener">http://1.1.1.3:9000/celery_result/?id=5065b65b-0c01-430a-a67f-9531fe3e8d90</a></p>
<h3 id="基于步骤↑：在django中使用计划任务功能"><a href="#基于步骤↑：在django中使用计划任务功能" class="headerlink" title="基于步骤↑：在django中使用计划任务功能"></a>基于步骤↑：在django中使用计划任务功能</h3><h3 id="在Django中使用celery的定时任务需要安装django-celery-beat"><a href="#在Django中使用celery的定时任务需要安装django-celery-beat" class="headerlink" title="在Django中使用celery的定时任务需要安装django-celery-beat"></a>在Django中使用celery的定时任务需要安装django-celery-beat</h3><pre class="highlight"><span class="line">pip3 install django-celery-beat</span><br></pre>

<h3 id="在Django的settings中注册django-celery-beat"><a href="#在Django的settings中注册django-celery-beat" class="headerlink" title="在Django的settings中注册django_celery_beat"></a>在Django的settings中注册django_celery_beat</h3><pre class="highlight"><span class="line">INSTALLED_APPS &#x3D; (</span><br><span class="line">        ...,</span><br><span class="line">        &#39;django_celery_beat&#39;,</span><br><span class="line">    )</span><br></pre>

<h3 id="执行创建表命令"><a href="#执行创建表命令" class="headerlink" title="执行创建表命令"></a>执行创建表命令</h3><pre class="highlight"><span class="line">python3 manage.py makemigrations</span><br><span class="line"></span><br><span class="line">python3 manage.py migrate</span><br><span class="line"></span><br><span class="line">python3 manage.py startsuperuser</span><br></pre>

<h3 id="运行Django项目"><a href="#运行Django项目" class="headerlink" title="运行Django项目"></a>运行Django项目</h3><pre class="highlight"><span class="line">celery -A celery_test worker -l info</span><br><span class="line"></span><br><span class="line">python3 manage.py runserver 0.0.0.0:9000</span><br></pre>

<h3 id="登录-http-1-1-1-3-9000-admin-可以看到多了三张表"><a href="#登录-http-1-1-1-3-9000-admin-可以看到多了三张表" class="headerlink" title="登录 http://1.1.1.3:9000/admin/ 可以看到多了三张表"></a>登录 <a href="http://1.1.1.3:9000/admin/" target="_blank" rel="noopener">http://1.1.1.3:9000/admin/</a> 可以看到多了三张表</h3><p><img src="https://img-blog.csdnimg.cn/20200222231719454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="~~~~~~" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200222231719454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h3 id="在intervals表中添加一条每5秒钟执行一次的任务的时钟"><a href="#在intervals表中添加一条每5秒钟执行一次的任务的时钟" class="headerlink" title="在intervals表中添加一条每5秒钟执行一次的任务的时钟"></a>在intervals表中添加一条每5秒钟执行一次的任务的时钟</h3><p>![<del>~</del>`](<a href="https://img-blog.csdnimg.cn/20200222231733989.png" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20200222231733989.png</a>)</p>
<h3 id="在Periodic-tasks表中创建任务"><a href="#在Periodic-tasks表中创建任务" class="headerlink" title="在Periodic tasks表中创建任务"></a>在Periodic tasks表中创建任务</h3><p><img src="https://img-blog.csdnimg.cn/20200222231750136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="````````````" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200222231750136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h3 id="在-django-test-celery-test-目录下执行下面命令"><a href="#在-django-test-celery-test-目录下执行下面命令" class="headerlink" title="在/django_test/celery_test/目录下执行下面命令"></a>在/django_test/celery_test/目录下执行下面命令</h3><pre class="highlight"><span class="line">celery -A celery_test worker -l info                                                   #启动一个worker</span><br><span class="line"></span><br><span class="line">python manage.py runserver 0.0.0.0:9000                           #运行Django项目</span><br><span class="line"></span><br><span class="line">celery -A celery_test beat -l info -S django                                                   #启动心跳任务</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">运行上面命令后就可以看到在运行celery -A celery_test worker -l info         窗口中每5秒钟执行一次app01.tasks.add： 2+3&#x3D;5</span><br></pre>
<h3 id="关于添加新任务必须重启心跳问题"><a href="#关于添加新任务必须重启心跳问题" class="headerlink" title="关于添加新任务必须重启心跳问题"></a>关于添加新任务必须重启心跳问题</h3><ol>
<li><p>每次在Django表中添加一个任务就必须重启一下beat</p>
</li>
<li><p>但是Django中有一个djcelery插件可以帮助我们不必重启</p>
<h3 id="cdjango-celery-redis实现异步周期任务"><a href="#cdjango-celery-redis实现异步周期任务" class="headerlink" title="cdjango+celery+redis实现异步周期任务"></a>cdjango+celery+redis实现异步周期任务</h3><h5 id="注：python的celery模块-4-2-0版本，-刚开始安装的未4-1-1版本，但是定时任务居然不执行"><a href="#注：python的celery模块-4-2-0版本，-刚开始安装的未4-1-1版本，但是定时任务居然不执行" class="headerlink" title="注：python的celery模块 4.2.0版本， 刚开始安装的未4.1.1版本，但是定时任务居然不执行"></a>注：python的celery模块 4.2.0版本， 刚开始安装的未4.1.1版本，但是定时任务居然不执行</h5></li>
</ol>
<h3 id="在settings-py中配置celery"><a href="#在settings-py中配置celery" class="headerlink" title="在settings.py中配置celery"></a>在settings.py中配置celery</h3><pre class="highlight"><span class="line"># settings.py</span><br><span class="line">#1、如果在django中需要周期性执行，在这里需要注册 django_celery_beat 中间件</span><br><span class="line">INSTALLED_APPS &#x3D; [</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    &#39;django_celery_beat&#39;,</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TIME_ZONE &#x3D; &#39;Asia&#x2F;Shanghai&#39;  # 将默认的UTC时区给成中国时区</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#2、celery：配置celery</span><br><span class="line">BROKER_URL &#x3D; &#39;redis:&#x2F;&#x2F;localhost:6379&#39;</span><br><span class="line">CELERY_RESULT_BACKEND &#x3D; &#39;redis:&#x2F;&#x2F;localhost:6379&#39;</span><br><span class="line">CELERY_ACCEPT_CONTENT &#x3D; [&#39;application&#x2F;json&#39;]</span><br><span class="line">CELERY_TASK_SERIALIZER &#x3D; &#39;json&#39;</span><br><span class="line">CELERY_RESULT_SERIALIZER &#x3D; &#39;json&#39;</span><br><span class="line">CELERY_TASK_RESULT_EXPIRES &#x3D; 60 * 60</span><br><span class="line">CELERY_TIMEZONE &#x3D; &#39;Asia&#x2F;Shanghai&#39;</span><br><span class="line">CELERY_ENABLE_UTC&#x3D;False</span><br><span class="line">CELERY_ANNOTATIONS &#x3D; &#123;&#39;*&#39;: &#123;&#39;rate_limit&#39;: &#39;500&#x2F;s&#39;&#125;&#125;</span><br><span class="line">CELERYBEAT_SCHEDULER &#x3D; &#39;djcelery.schedulers.DatabaseScheduler&#39;</span><br></pre>

<h3 id="在与项目同名的目录下创建celery-py-1"><a href="#在与项目同名的目录下创建celery-py-1" class="headerlink" title="在与项目同名的目录下创建celery.py"></a>在与项目同名的目录下创建celery.py</h3><p>更多定时参考官网：<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html#crontab-schedules" target="_blank" rel="noopener">http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html#crontab-schedules</a></p>
<pre class="highlight"><span class="line"># # -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from __future__ import absolute_import</span><br><span class="line">import os</span><br><span class="line">from celery import Celery</span><br><span class="line">from celery.schedules import crontab</span><br><span class="line">from datetime import timedelta</span><br><span class="line">from kombu import Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># set the default Django settings module for the &#39;celery&#39; program.</span><br><span class="line">os.environ.setdefault(&#39;DJANGO_SETTINGS_MODULE&#39;, &#39;celery_test.settings&#39;)</span><br><span class="line"></span><br><span class="line">from django.conf import settings</span><br><span class="line"></span><br><span class="line">app &#x3D; Celery(&#39;celery_test&#39;)</span><br><span class="line"></span><br><span class="line"># Using a string here means the worker will not have to</span><br><span class="line"># pickle the object when using Windows.</span><br><span class="line">class Config:</span><br><span class="line">    BROKER_URL &#x3D; &#39;redis:&#x2F;&#x2F;1.1.1.3:6379&#39;</span><br><span class="line">    CELERY_RESULT_BACKEND &#x3D; &#39;redis:&#x2F;&#x2F;1.1.1.3:6379&#39;</span><br><span class="line">    CELERY_ACCEPT_CONTENT &#x3D; [&#39;application&#x2F;json&#39;]</span><br><span class="line">    CELERY_TASK_SERIALIZER &#x3D; &#39;json&#39;</span><br><span class="line">    CELERY_RESULT_SERIALIZER &#x3D; &#39;json&#39;</span><br><span class="line">    CELERY_TIMEZONE &#x3D; &#39;Asia&#x2F;Shanghai&#39;</span><br><span class="line">    ENABLE_UTC &#x3D; False</span><br><span class="line">    CELERY_TASK_RESULT_EXPIRES &#x3D; 60 * 60</span><br><span class="line">    CELERY_ANNOTATIONS &#x3D; &#123;&#39;*&#39;: &#123;&#39;rate_limit&#39;: &#39;500&#x2F;s&#39;&#125;&#125;</span><br><span class="line">    # 每次取任务的数量</span><br><span class="line">    # CELERYD_PREFETCH_MULTIPLIER &#x3D; 10</span><br><span class="line">    # 每个worker执行多少次任务之后就销毁，防止内存泄漏。相当于--maxtasksperchild参数</span><br><span class="line">    CELERYD_MAX_TASKS_PER_CHILD &#x3D; 16</span><br><span class="line">    # 防止死锁</span><br><span class="line">    # CELERYD_FORCE_EXECV &#x3D; True</span><br><span class="line">    # 任务发出后，经过一段时间还未收到acknowledge , 就将任务重新交给其他worker执行</span><br><span class="line">    # CELERY_DISABLE_RATE_LIMITS &#x3D; True</span><br><span class="line">    # CELERYBEAT_SCHEDULER &#x3D; &#39;djcelery.schedulers.DatabaseScheduler&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.config_from_object(Config)</span><br><span class="line">app.autodiscover_tasks()</span><br><span class="line"></span><br><span class="line">#crontab config</span><br><span class="line">app.conf.update(</span><br><span class="line">    CELERYBEAT_SCHEDULE &#x3D; &#123;</span><br><span class="line">        # 每隔三分钟执行一次add函数</span><br><span class="line">        &#39;every-3-min-add&#39;: &#123;</span><br><span class="line">            &#39;task&#39;: &#39;app01.tasks.add&#39;,</span><br><span class="line">            &#39;schedule&#39;: timedelta(seconds&#x3D;180)</span><br><span class="line">        &#125;,</span><br><span class="line">        # 每天下午15:420执行</span><br><span class="line">        &#39;add-every-day-morning@14:50&#39;: &#123;</span><br><span class="line">            &#39;task&#39;: &#39;app01.tasks.minus&#39;,</span><br><span class="line">            &#39;schedule&#39;: crontab(hour&#x3D;15, minute&#x3D;20, day_of_week&#x3D;&#39;*&#x2F;1&#39;),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Queue(&#39;transient&#39;, routing_key&#x3D;&#39;transient&#39;,delivery_mode&#x3D;1)</span><br><span class="line"></span><br><span class="line">celery.py</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from __future__ import absolute_import</span><br><span class="line">import os</span><br><span class="line">from celery import Celery</span><br><span class="line">from celery.schedules import crontab</span><br><span class="line">from datetime import timedelta</span><br><span class="line">from kombu import Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># set the default Django settings module for the &#39;celery&#39; program.</span><br><span class="line">os.environ.setdefault(&#39;DJANGO_SETTINGS_MODULE&#39;, &#39;celery_test.settings&#39;)</span><br><span class="line"></span><br><span class="line">from django.conf import settings</span><br><span class="line"></span><br><span class="line">app &#x3D; Celery(&#39;celery_test&#39;)</span><br><span class="line"></span><br><span class="line"># Using a string here means the worker will not have to</span><br><span class="line"># pickle the object when using Windows.</span><br><span class="line">class Config:</span><br><span class="line">    BROKER_URL &#x3D; &#39;redis:&#x2F;&#x2F;1.1.1.3:6379&#39;</span><br><span class="line">    CELERY_RESULT_BACKEND &#x3D; &#39;redis:&#x2F;&#x2F;1.1.1.3:6379&#39;</span><br><span class="line">    CELERY_ACCEPT_CONTENT &#x3D; [&#39;application&#x2F;json&#39;]</span><br><span class="line">    CELERY_TASK_SERIALIZER &#x3D; &#39;json&#39;</span><br><span class="line">    CELERY_RESULT_SERIALIZER &#x3D; &#39;json&#39;</span><br><span class="line">    CELERY_TIMEZONE &#x3D; &#39;Asia&#x2F;Shanghai&#39;</span><br><span class="line">    ENABLE_UTC &#x3D; False</span><br><span class="line">    CELERY_TASK_RESULT_EXPIRES &#x3D; 60 * 60</span><br><span class="line">    CELERY_ANNOTATIONS &#x3D; &#123;&#39;*&#39;: &#123;&#39;rate_limit&#39;: &#39;500&#x2F;s&#39;&#125;&#125;</span><br><span class="line">    # 每次取任务的数量</span><br><span class="line">    # CELERYD_PREFETCH_MULTIPLIER &#x3D; 10</span><br><span class="line">    # 每个worker执行多少次任务之后就销毁，防止内存泄漏。相当于--maxtasksperchild参数</span><br><span class="line">    CELERYD_MAX_TASKS_PER_CHILD &#x3D; 16</span><br><span class="line">    # 防止死锁</span><br><span class="line">    # CELERYD_FORCE_EXECV &#x3D; True</span><br><span class="line">    # 任务发出后，经过一段时间还未收到acknowledge , 就将任务重新交给其他worker执行</span><br><span class="line">    # CELERY_DISABLE_RATE_LIMITS &#x3D; True</span><br><span class="line">    # CELERYBEAT_SCHEDULER &#x3D; &#39;djcelery.schedulers.DatabaseScheduler&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.config_from_object(Config)</span><br><span class="line">app.autodiscover_tasks()</span><br><span class="line"></span><br><span class="line">#crontab config</span><br><span class="line">app.conf.update(</span><br><span class="line">    CELERYBEAT_SCHEDULE &#x3D; &#123;</span><br><span class="line">        # 每隔三分钟执行一次add函数</span><br><span class="line">        &#39;every-3-min-add&#39;: &#123;</span><br><span class="line">            &#39;task&#39;: &#39;app01.tasks.add&#39;,</span><br><span class="line">            &#39;schedule&#39;: timedelta(seconds&#x3D;180)</span><br><span class="line">        &#125;,</span><br><span class="line">        # 每天下午15:420执行</span><br><span class="line">        &#39;add-every-day-morning@14:50&#39;: &#123;</span><br><span class="line">            &#39;task&#39;: &#39;app01.tasks.minus&#39;,</span><br><span class="line">            &#39;schedule&#39;: crontab(hour&#x3D;15, minute&#x3D;20, day_of_week&#x3D;&#39;*&#x2F;1&#39;),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Queue(&#39;transient&#39;, routing_key&#x3D;&#39;transient&#39;,delivery_mode&#x3D;1)</span><br></pre>

<h3 id="在任意app下创建tasks-py-django会自动到各app中找到此tasks文件"><a href="#在任意app下创建tasks-py-django会自动到各app中找到此tasks文件" class="headerlink" title="在任意app下创建tasks.py (django会自动到各app中找到此tasks文件)"></a>在任意app下创建tasks.py (django会自动到各app中找到此tasks文件)</h3><pre class="highlight"><span class="line"># tasks.py</span><br><span class="line"># -*- coding:utf8 -*-</span><br><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line">from celery import shared_task</span><br><span class="line"></span><br><span class="line"># 这里不再使用@app.task,而是用@shared_task，是指定可以在其他APP中也可以调用这个任务</span><br><span class="line">@shared_task</span><br><span class="line">def add():</span><br><span class="line">   print &#39;app01.tasks.add&#39;</span><br><span class="line">   return 222 + 333</span><br><span class="line"></span><br><span class="line">@shared_task</span><br><span class="line">def minus():</span><br><span class="line">   print &#39;app01.tasks.minus&#39;</span><br><span class="line">   return 222 - 333</span><br></pre>

<h3 id="在与项目同名的目录下的-init-py-文件中添加下面内容-1"><a href="#在与项目同名的目录下的-init-py-文件中添加下面内容-1" class="headerlink" title="在与项目同名的目录下的 init.py 文件中添加下面内容"></a>在与项目同名的目录下的 init.py 文件中添加下面内容</h3><pre class="highlight"><span class="line"># __init__.py</span><br><span class="line"># -*- coding:utf8 -*-</span><br><span class="line">from __future__ import absolute_import, unicode_literals</span><br><span class="line"></span><br><span class="line"># 告诉Django在启动时别忘了检测我的celery文件</span><br><span class="line">from .celery import app as celery_ap</span><br><span class="line">__all__ &#x3D; [&#39;celery_app&#39;]</span><br></pre>

<h3 id="启动脚本（记得开启celery服务）"><a href="#启动脚本（记得开启celery服务）" class="headerlink" title="启动脚本（记得开启celery服务）"></a>启动脚本（记得开启celery服务）</h3><h3 id="启动django程序"><a href="#启动django程序" class="headerlink" title="启动django程序"></a>启动django程序</h3><pre class="highlight"><span class="line">python manage.py runserver 0.0.0.0:8000</span><br></pre>
<pre class="highlight"><span class="line"># service.sh</span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env bash</span><br><span class="line"></span><br><span class="line">source ..&#x2F;env&#x2F;bin&#x2F;activate</span><br><span class="line"></span><br><span class="line">export DJANGO_SETTINGS_MODULE&#x3D;celery_test.settings</span><br><span class="line"></span><br><span class="line">base_dir&#x3D;&#96;pwd&#96;</span><br><span class="line">mup_pid() &#123;</span><br><span class="line">echo &#96;ps -ef | grep -E &quot;(manage.py)(.*):8000&quot; | grep -v grep| awk &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line">&#125;</span><br><span class="line">start() &#123;</span><br><span class="line"> python $base_dir&#x2F;manage.py runserver 0.0.0.0:8000 &amp;&gt;&gt; $base_dir&#x2F;django.log 2&gt;&amp;1 &amp;</span><br><span class="line"> pid&#x3D;$(mup_pid)</span><br><span class="line"> echo -e &quot;\e[00;31mmup is running (pid: $pid)\e[00m&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop() &#123;</span><br><span class="line"> pid&#x3D;$(mup_pid)</span><br><span class="line"> echo -e &quot;\e[00;31mmup is stop (pid: $pid)\e[00m&quot;</span><br><span class="line"> ps -ef | grep -E &quot;(manage.py)(.*):8000&quot; | grep -v grep| awk &#39;&#123;print $2&#125;&#39; | xargs kill -9 &amp;&gt; &#x2F;dev&#x2F;null</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restart()&#123;</span><br><span class="line">    stop</span><br><span class="line">    start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># See how we were called.</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">  start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">  stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">  restart)</span><br><span class="line">        restart</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">  *)</span><br><span class="line">        echo $&quot;Usage: $0 &#123;start|stop|restart&#125;&quot;</span><br><span class="line">        exit 2</span><br><span class="line">esac</span><br></pre>

<h3 id="启动celery的worker：每台机器可以启动8个worker-1"><a href="#启动celery的worker：每台机器可以启动8个worker-1" class="headerlink" title="启动celery的worker：每台机器可以启动8个worker"></a>启动celery的worker：每台机器可以启动8个worker</h3><pre class="highlight"><span class="line">celery -A celery_test worker -l info</span><br></pre>
<pre class="highlight"><span class="line"># start-celery.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">source ..&#x2F;env&#x2F;bin&#x2F;activate</span><br><span class="line">export C_FORCE_ROOT&#x3D;&quot;true&quot;</span><br><span class="line">base_dir&#x3D;&#96;pwd&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">celery_pid() &#123;</span><br><span class="line">    echo &#96;ps -ef | grep -E &quot;celery -A celery_test worker&quot; | grep -v grep| awk &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line">&#125;</span><br><span class="line">start() &#123;</span><br><span class="line">    celery  multi start celery_test -A celery_test -l debug --autoscale&#x3D;50,5 --logfile&#x3D;$base_dir&#x2F;var&#x2F;celery-%I.log --pidfile&#x3D;celery_test.pid</span><br><span class="line">&#125;</span><br><span class="line">restart() &#123;</span><br><span class="line">    celery  multi restart celery_test -A celery_test -l debug</span><br><span class="line">&#125;</span><br><span class="line">stop() &#123;</span><br><span class="line">    celery  multi stop celery_test -A celery_test -l debug</span><br><span class="line">&#125;</span><br><span class="line">#restart()&#123;</span><br><span class="line">#    stop</span><br><span class="line">#    start</span><br><span class="line">#&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># See how we were called.</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">  start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">  restart)</span><br><span class="line">        restart</span><br><span class="line">        ;;</span><br><span class="line">  stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">  *)</span><br><span class="line">        echo $&quot;Usage: $0 &#123;start|stop|restart&#125;&quot;</span><br><span class="line">        exit 2</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">#nohup celery -A celery_test worker -l debug --concurrency&#x3D;10 --autoreload  &amp; &gt;&gt;celery.log</span><br></pre>
<h3 id="启动celery-定时任务运行"><a href="#启动celery-定时任务运行" class="headerlink" title="启动celery 定时任务运行"></a>启动celery 定时任务运行</h3><pre class="highlight"><span class="line">celery -A celery_test beat -l debug</span><br></pre>
<pre class="highlight"><span class="line"># celery-crond.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#celery 定时任务运行</span><br><span class="line">source ..&#x2F;env&#x2F;bin&#x2F;activate</span><br><span class="line">export C_FORCE_ROOT&#x3D;&quot;true&quot;</span><br><span class="line">base_dir&#x3D;&#96;pwd&#96;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">celery_pid() &#123;</span><br><span class="line">    echo &#96;ps -ef | grep -E &quot;celery -A celery_test beat&quot; | grep -v grep| awk &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line">&#125;</span><br><span class="line">start() &#123;</span><br><span class="line">    #django 调度定时任务</span><br><span class="line">    #celery -A celery_test beat -l info -S django &gt;&gt; $base_dir&#x2F;var&#x2F;celery-cron.log 2&gt;&amp;1 &amp;</span><br><span class="line">    celery -A celery_test beat -l debug &gt;&gt; $base_dir&#x2F;var&#x2F;Scheduler.log 2&gt;&amp;1 &amp;</span><br><span class="line">    sleep 3</span><br><span class="line">    pid&#x3D;$(celery_pid)</span><br><span class="line">    echo -e &quot;\e[00;31mcelery is start (pid: $pid)\e[00m&quot;</span><br><span class="line">&#125;</span><br><span class="line">restart() &#123;</span><br><span class="line">    pid&#x3D;$(celery_pid)</span><br><span class="line">    echo -e &quot;\e[00;31mcelery is restart (pid: $pid)\e[00m&quot;</span><br><span class="line">    ps auxf | grep -E &quot;celery -A celery_test beat&quot; | grep -v grep| awk &#39;&#123;print $2&#125;&#39; | xargs kill -HUP &amp;&gt; &#x2F;dev&#x2F;null</span><br><span class="line">&#125;</span><br><span class="line">stop() &#123;</span><br><span class="line">    pid&#x3D;$(celery_pid)</span><br><span class="line">    echo -e &quot;\e[00;31mcelery is stop (pid: $pid)\e[00m&quot;</span><br><span class="line">    ps -ef | grep -E &quot;celery -A celery_test beat&quot; | grep -v grep| awk &#39;&#123;print $2&#125;&#39; | xargs kill -TERM &amp;&gt; &#x2F;dev&#x2F;null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">  start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">  restart)</span><br><span class="line">        restart</span><br><span class="line">        ;;</span><br><span class="line">  stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">  *)</span><br><span class="line">        echo $&quot;Usage: $0 &#123;start|stop|restart&#125;&quot;</span><br><span class="line">        exit 2</span><br><span class="line">esac</span><br></pre>
<h3 id="windows下编写的脚本文件，放到Linux中无法识别格式"><a href="#windows下编写的脚本文件，放到Linux中无法识别格式" class="headerlink" title="windows下编写的脚本文件，放到Linux中无法识别格式"></a>windows下编写的脚本文件，放到Linux中无法识别格式</h3><p>在Linux中执行.sh脚本，异常/bin/sh^M: bad interpreter: No such file or directory</p>
<p>set ff=unix</p>
<p>dos2unix start-celery.sh<br>dos2unix celery-crond.sh</p>
<h3 id="常见报错"><a href="#常见报错" class="headerlink" title="常见报错"></a>常见报错</h3><p>Received unregistered task of type ‘XXX’ Celery报错（定时任务中无法找到对应tasks.py文件）</p>
<p>app = Celery(‘opwf’, include=[‘api_workflow.tasks’]) # api_workflow这个app中的tasks文件</p>
<p><a href="https://www.cnblogs.com/xiaonq/p/9303941.html" target="_blank" rel="noopener">博客参考地址</a></p>
]]></content>
      <categories>
        <category>celery</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 演示 脏读，不可重复读，幻读</title>
    <url>/2020/01/12/Mysql%20%E6%BC%94%E7%A4%BA%20%E8%84%8F%E8%AF%BB%EF%BC%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%8C%E5%B9%BB%E8%AF%BB/</url>
    <content><![CDATA[<p>今天要演示的是 Mysql 事务隔离性的 隔离级别。<br>简单介绍一下 事务的四大特性，之前的博客也详细的写过：<a href="http://localhost:4000/2020/01/05/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%20%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E5%85%A8%20(Mysql%EF%BC%8CRedis%EF%BC%8CMongoDB)/" target="_blank" rel="noopener">http://localhost:4000/2020/01/05/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%20%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E5%85%A8%20(Mysql%EF%BC%8CRedis%EF%BC%8CMongoDB)/</a></p>
<h4 id="InnoDB事务原理"><a href="#InnoDB事务原理" class="headerlink" title="InnoDB事务原理"></a>InnoDB事务原理</h4><ul>
<li>事务（Transaction）是数据库区别于文件系统的重要特性之一，事务会把数据库从一种一致性状态转换为另一种一致性状态。</li>
<li>在数据库提交时，可以确保要么所有修改都已保存，要么所有修改都不保存。</li>
</ul>
<h4 id="事务的（ACID）特征"><a href="#事务的（ACID）特征" class="headerlink" title="事务的（ACID）特征"></a>事务的（ACID）特征</h4><ul>
<li>原子性(Atomicity)：整个事物的所有操作要么全部提交成功，要么全部失败回滚(不会出现部分执行的情况)。</li>
<li>一致性(Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。</li>
<li>隔离性(Isolation)：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。</li>
<li>持久性(Durability): 一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>
</ul>
<h5 id="事物隔离级别"><a href="#事物隔离级别" class="headerlink" title="事物隔离级别"></a>事物隔离级别</h5><ul>
<li><p>未提交读: 脏读（READ UNCOMMITTED） 读未提交</p>
</li>
<li><p>提交读: 不可重复读（READ COMMITTED）</p>
</li>
<li><p>可重复读: 幻读（REPEATABLE READ）：<strong>这是MySQL的默认事务隔离级别</strong></p>
</li>
<li><p>可串行读（SERIALIZABLE） 序列化&amp;串行读</p>
<p>在该隔离级别下，可以解决前面出现的脏读、不可重复读和幻读问题，但也会导致大量的超时和锁竞争现象，一般不推荐使用</p>
</li>
</ul>
<p>√ 为会发生，×为不会发生</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>read uncommitted（未提交读）</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>read committed（提交读）</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>repeatable read（可重复读）</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>serializable （可串行化）</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<pre class="highlight"><span class="line">表格借鉴的Java识堂(https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_44685869&#x2F;article&#x2F;details&#x2F;104105291)</span><br></pre>

<p>此文 用到的 MySQL 的一些命令</p>
<pre class="highlight"><span class="line"><span class="comment"># 查看 MySQL 版本</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">version</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 MySQL 隔离级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @@tx_isolation</span><br><span class="line"></span><br><span class="line"><span class="comment"># MySQL在会话层面设置隔离级别</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> 隔离级别名字</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启事务</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交事务</span></span><br><span class="line"><span class="keyword">commit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回滚事务</span></span><br><span class="line"><span class="keyword">rollback</span></span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre>

<p>创建 库、表、查看。</p>
<pre class="highlight"><span class="line"><span class="comment"># 创建 demo01 数据库</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> demo01</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> demo01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建测试表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test01(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">3</span>) <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">	price <span class="built_in">int</span>(<span class="number">7</span>) <span class="keyword">default</span> <span class="number">0</span>         <span class="comment"># 这里不许有逗号</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">4</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line">1234567891011</span><br></pre>

<p>插入初始数据</p>
<pre class="highlight"><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test01(<span class="keyword">name</span>,price) <span class="keyword">values</span>(<span class="string">'张三'</span>,<span class="number">100</span>),(<span class="string">'李四'</span>,<span class="number">0</span>);</span><br><span class="line">1</span><br><span class="line">一切ok 开始干活</span><br></pre>



<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>表中的数据如下，设置隔离级别为未提交读<br><img src="https://img-blog.csdnimg.cn/20200309222854412.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200309222854412.png" class="lozad post-image"></p>
<table>
<thead>
<tr>
<th>时间</th>
<th>客户端A（Tab A）</th>
<th>客户端B（Tab B）</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>set session transaction isolation level read uncommitted; start transaction;（开启事务） update test01 set price = price + 100 where id = 1; select * from test01 where id = 1; 设置为未提交读，给张三账号+100，输出为200</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>set session transaction isolation level read uncommitted; start transaction; select * from test01 where id = 1; 查询余额输出为200</td>
</tr>
<tr>
<td>T3</td>
<td>rollback</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td>commit</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>select * from test01 where id = 1; 查询余额输出为100</td>
</tr>
</tbody></table>
<p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</p>
<p>再举一个严重的例子，证明一下危害<br>表中的数据如下<br><img src="https://img-blog.csdnimg.cn/20200309222854412.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200309222854412.png" class="lozad post-image"></p>
<table>
<thead>
<tr>
<th>时间</th>
<th>客户端A（Tab A）</th>
<th>客户端B（Tab B）</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>set session transaction isolation level read uncommitted; start transaction; update test01 set price = price - 100 where id = 1; update test01 set price = price + 100 where id = 2;</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>set session transaction isolation level read uncommitted; start transaction; select price from test01 where id = 2; update test01 set price = price - 100 where id = 2; 更新语句被阻塞</td>
</tr>
<tr>
<td>T3</td>
<td>rollback</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>commit</td>
</tr>
</tbody></table>
<p>执行完成，数据库中的数据如下<br><img src="https://img-blog.csdnimg.cn/20200309224709503.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200309224709503.png" class="lozad post-image"></p>
<table>
<thead>
<tr>
<th>时间</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>1给2转100</td>
</tr>
<tr>
<td>T2</td>
<td>2的余额够100元，购买100元的东西，更新语句被阻塞</td>
</tr>
<tr>
<td>T3</td>
<td>1回滚，1的余额变成100，2的余额变成0</td>
</tr>
<tr>
<td>T4</td>
<td>2成功扣款，余额0-100=-100</td>
</tr>
</tbody></table>
<p>现在好了，银行无缘无故损失100元。</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>表中的数据如下，设置隔离级别为提交读</p>
<p><img src="https://img-blog.csdnimg.cn/20200309222854412.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200309222854412.png" class="lozad post-image"></p>
<table>
<thead>
<tr>
<th>时间</th>
<th>客户端A（Tab A）</th>
<th>客户端B（Tab B）</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>set session transaction isolation level read committed; start transaction; select * from test01 where id = 2; 查询余额输出为0</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>set session transaction isolation level read committed; start transaction; update test01 set price = price + 100 where id = 2; select * from test01 where id = 2; commit; 查询余额输出100</td>
</tr>
<tr>
<td>T3</td>
<td>select * from test01 where id = 2; commit; 查询余额输出100</td>
<td></td>
</tr>
</tbody></table>
<p>不可重复读是指在事务1内，读取了一个数据，事务1还没有结束时，事务2也访问了这个数据，修改了这个数据，并提交。紧接着，事务1又读这个数据。由于事务2的修改，那么事务1两次读到的的数据可能是不一样的，因此称为是不可重复读。</p>
<p>当然你可以在T2时间段客户端B修改完id=2的账户余额但没有commit的时候，在客户端A查询id=2的账户余额，发现账户余额为0，可以证明提交读这个隔离级别不会发生脏读。</p>
<h3 id="可重复读级别"><a href="#可重复读级别" class="headerlink" title="可重复读级别"></a>可重复读级别</h3><p>看一下可重复读是个什么过程？<br>表中的数据如下，设置隔离级别为可重复读<br><img src="https://img-blog.csdnimg.cn/20200309222854412.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200309222854412.png" class="lozad post-image"></p>
<table>
<thead>
<tr>
<th>时间</th>
<th>客户端A（Tab A）</th>
<th>客户端B（Tab B）</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>set session transaction isolation level repeatable read; start transaction; select * from test01 where id = 2; 查询余额输出为0</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>set session transaction isolation level repeatable read; start transaction; update test01 where set price = price + 100 where id = 2; select * from test01 where where id = 2; commit; 查询余额输出100</td>
</tr>
<tr>
<td>T3</td>
<td>select * from test01 where where id = 2; commit; 查询余额输出0</td>
<td></td>
</tr>
</tbody></table>
<p>当我们将当前会话的隔离级别设置为可重复读的时候，当前会话可以重复读，就是每次读取的结果集都相同，而不管其他事务有没有提交。</p>
<p>但是在可重复读的隔离级别上，会产生幻读的问题。</p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>设置隔离级别为可重复读</p>
<p><img src="https://img-blog.csdnimg.cn/20200309233027370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200309233027370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<p>所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB存储引擎通过多版本并发控制（MVCC）解决了幻读的问题。</p>
<p>用大白话解释一下，就是事务1查询id&lt;10的记录时，返回了2条记录，接着事务2插入了一条id为3的记录，并提交。接着事务1查询id&lt;10的记录时，返回了3条记录，说好的可重复读呢？结果却多了一条数据。</p>
<p>演示如何解决的幻读，表中的数据如下<br><img src="https://img-blog.csdnimg.cn/20200309222854412.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200309222854412.png" class="lozad post-image"><br>MySQL通过 MVCC 解决了这种情况下的幻读<br>MVCC 在我理解 就是类似于乐观锁</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>客户端A（Tab A）</th>
<th>客户端B（Tab B）</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>set session transaction isolation level repeatable read; start transaction; select count(*) from test01 where id &lt;= 10; 输出2</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>set session transaction isolation level repeatable read; start transaction; insert into test01 (id, name, price) values (3, “王五”, 0); select count(*) from test01 where id &lt;= 10; commit; 输出3</td>
</tr>
<tr>
<td>T3</td>
<td>select count(*) from test01 where id &lt;= 10; commit; 输出2</td>
<td></td>
</tr>
</tbody></table>
<p>这种情况下的幻读被解决了，我再举一个例子</p>
<p>表中的数据如下</p>
<p><img src="https://img-blog.csdnimg.cn/20200309222854412.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200309222854412.png" class="lozad post-image"></p>
<table>
<thead>
<tr>
<th>时间</th>
<th>客户端A（Tab A）</th>
<th>客户端B（Tab B）</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>set session transaction isolation level repeatable read; start transaction; select count(*) from account where id = 3; 输出为0</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>set session transaction isolation level repeatable read; start transaction; insert into account (id, name, balance) values (3, “王五”, 0); commit;</td>
</tr>
<tr>
<td>T3</td>
<td>insert into account (id, name, balance) values (3, “王五”, 0); 主键重复，插入失败</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td>select count(*) from account where id = 3; 输出为0</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td>rollback;</td>
<td></td>
</tr>
</tbody></table>
<p>select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，这个就有问题了。</p>
<p>很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。</p>
<p>总的来说幻读就是事务A对数据进行操作，事务B还是可以用insert插入数据的，因为使用的是行锁，这样导致的各种奇葩问题就是幻读，表现形式很多，就不列举了。</p>
<p>当隔离级别设置为可串行化，强制事务串行执行，避免了前面说的幻读的问题。</p>
<p><a href="https://blog.csdn.net/zzti_erlie/article/details/88080822" target="_blank" rel="noopener">参考原址：https://blog.csdn.net/zzti_erlie/article/details/88080822</a></p>
<hr>
<p>数据库使用锁是为了支持更好的并发，提供数据的完整性和一致性。<br>InnoDB是一个支持行锁的存储引擎，锁的类型有：</p>
<ul>
<li>共享锁（S）</li>
<li>排他锁（X）</li>
<li>意向共享（IS）</li>
<li>意向排他（IX）</li>
</ul>
<p>为了提供更好的并发，InnoDB提供了非锁定读：不需要等待访问行上的锁释放，读取行的一个快照。该方法是通过InnoDB的一个特性：MVCC来实现的。</p>
<h4 id="InnoDB有三种行锁的算法："><a href="#InnoDB有三种行锁的算法：" class="headerlink" title="InnoDB有三种行锁的算法："></a>InnoDB有三种行锁的算法：</h4><ol>
<li>Record Lock：单个行记录上的锁。</li>
<li>Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。</li>
<li>Next-Key Lock：1+2，锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 介绍</title>
    <url>/2020/04/20/Python%20%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200419130337195.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200419130337195.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" class="lozad post-image"><br>Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言。</p>
<p>Python 由 Guido van Rossum (吉多·范 罗苏姆，龟叔) 于 1989 年底发明，第一个公开发行版发行于 1991 年。</p>
<p>像 Perl 语言一样, Python 源代码同样遵循 GPL(GNU General Public License) 协议。</p>
<p>官方宣布，2020 年 1 月 1 日， 停止 Python 2 的更新。</p>
<p>Python 2.7 被确定为最后一个 Python 2.x 版本。</p>
<h4 id="Python-成长史"><a href="#Python-成长史" class="headerlink" title="Python 成长史"></a>Python 成长史</h4><h5 id="可爱的他-诞生："><a href="#可爱的他-诞生：" class="headerlink" title="可爱的他 -诞生："></a>可爱的他 -诞生：</h5><p>1989年，为了打发圣诞节假期，龟叔开始写Python语言的编译器。Python这个名字，来自龟叔所挚爱的电视剧Monty Python’s Flying Circus（巨蟒剧团的飞行的马戏团）。</p>
<p>他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，功能全面，易学易用，可拓展的语言。龟叔作为一个语言设计爱好者，已经有过设计语言的尝试。这一次，也不过是一次纯粹的即兴行为。</p>
<h5 id="他的-成长经历："><a href="#他的-成长经历：" class="headerlink" title="他的 -成长经历："></a>他的 -成长经历：</h5><p>最初的Python完全由龟叔本人开发。Python得到龟叔同事的欢迎。他们迅速的反馈使用意见，并参与到Python的改进。</p>
<p>龟叔和一些同事构成Python的核心团队。他们将自己大部分的业余时间用于改进 Python。<br>随后，Python拓 展到研究所之外。</p>
<p>Python将许多机器层面上的细节隐藏，交给编译器处理，并凸显出逻辑层面的编程思考。Python程序员可以花更多的时间用于思考程序的逻辑，而不是具体的实现细节。这一特征吸引了广大的程序员。Python开始流行。</p>
<p>随着计算机硬件越来越强大，Python又容易使用，所以许多人开始转向Python。龟叔维护了一个mail list，Python用户就通过邮件进行交流。 Python用户来自许多领域，有不同的背景，对Python也有不同的需求。Python相当的开放又容易拓展，所以当用户不满足于现有功能，很容易对Python进行拓展或改造。</p>
<p>随后这些用户将改动发给龟叔，并由龟叔决定是否将新的特征加入到Python或者标准库中。如果代码能被纳入Python自身或者标准库，这将极大的荣誉。由于龟叔至高无上的决定权，他因此被称为“仁慈的独裁者”</p>
<h5 id="他的-成就"><a href="#他的-成就" class="headerlink" title="他的 -成就"></a>他的 -成就</h5><p>Python以及其标准库的功能强大。这些是整个社区的贡献。Python的开发者来自不同领域，他们将不同领域的优点带给Python。</p>
<p>比如Python标准库中的正则表达是参考Perl，而lambda, map, filter, reduce等函数参考了Lisp。<br>Python本身的一些功能以及大部分的标准库来自于社区。Python的社 区不断扩大，进而拥有了自己的网站以及基金。</p>
<p>从Python 2.0开始，Python也从mail list的开发方式，转为完全开源的开发方式。社区气氛已经形成，工作被整个社区分担，于此同时，Python也获得了更加高速的发展。</p>
<p>到今天，Python的框架已经确立。Python语言以对象为核心组织代码，支持多种编程范式，采用动态类型，自动进行内存回收。Python支持解释运行，并能调用C库进行拓展。</p>
<p>Python有强大的标准库。由于标准库的体系已经稳定，所以Python的生态系统开始拓展到第三方包。<br>这些包，如Django、Flask、numpy、matplotlib、PIL，将Python升级成了物种丰富的‘热带雨林’。</p>
<h4 id="Python-国内发展史"><a href="#Python-国内发展史" class="headerlink" title="Python 国内发展史"></a>Python 国内发展史</h4><p>Python在被设计之后，一直是不温不火的状态。龟叔 在2005年加入了 google阵营，2012年离开。在 google带了7年，导致了一个结果。</p>
<ul>
<li>google 的人大量的使用python。正是因为 这个原因，带动了一些其他的公司开始使用Python，大海在时代开启。</li>
</ul>
<h4 id="2005年"><a href="#2005年" class="headerlink" title="2005年"></a>2005年</h4><p>国内建立了一个影响中国影坛的公司，至今 很多人都依靠 他对电影的评分来作为基础，来对电影进行初步的认识 打分和评价。没错这就是 <code>豆瓣</code>，豆瓣 的网站正好也是大量的使用 Python来开发的，不能说他是国内第一个使用的公司，但的确是 python融入国内的 里程碑。</p>
<h4 id="2012年"><a href="#2012年" class="headerlink" title="2012年"></a>2012年</h4><p>云计算兴起，毕竟那个时候 如果你想搞个网站起码 10W +，不干别的 就买服务器 要做双机热备 负载均衡，还要预留维护资金，等等等… 所以云计算 也站在了风口上。</p>
<p>比如：</p>
<ul>
<li>阿里云， Amazon 这些公有云</li>
<li>虚拟机 为代表的私有云</li>
</ul>
<p>随着云计算的兴起，一个开源的云计算管理平台项目加入到了人们的视角 –&gt; OpenStack</p>
<pre class="highlight"><span class="line">OpenStack为私有云和公有云提供可扩展的弹性的云计算服务。项目目标是提供实施简单、可大规模扩展、丰富、标准统一的云计算管理平台。</span><br><span class="line">1</span><br></pre>

<p>这个 OpenStack 就是用 Python语言开发的，这样呢 Python就又火了一下。</p>
<h4 id="2014年"><a href="#2014年" class="headerlink" title="2014年"></a>2014年</h4><p>Artificial Intelligence 人工智能的兴起，Python 又一次的火了一波，为什么AI兴起 Python火大家都知道吧。<a href="https://blog.csdn.net/qq_44929388/article/details/89421247" target="_blank" rel="noopener">不知道这里: https://blog.csdn.net/qq_44929388/article/details/89421247</a></p>
<p>说白了还是代码少(开玩笑啊，这只是一方面)，大家都知道 AI的基础是靠什么？算法 + 数据。<br>Python虽然是脚本语言，但是因为容易学，迅速成为科学家的工具（MATLAB也能搞科学计算，但是软件要钱，且很贵），从而积累了大量的工具库、架构，人工智能涉及大量的数据计算，用Python是很自然的，简单高效。Python有非常多优秀的深度学习库可用，现在大部分深度学习框架都支持Python。</p>
<h4 id="2017年"><a href="#2017年" class="headerlink" title="2017年"></a>2017年</h4><p>在这个时候 Python就已经可以说是 大众视野了，虽然用的人没有 特别多，但是 说出来 Python，程序员都知道。<code>我也就是在这个时候 接触了 她，学习了她 一直用到了现在</code>。你不知道你就是 lowB，你可以不知道区块链 但是你得知道 Python，为什么？因为BTB 在国内倒台了。</p>
<h4 id="主要领域"><a href="#主要领域" class="headerlink" title="主要领域"></a>主要领域</h4><ul>
<li>Python-Web<br>公司代表 知乎</li>
<li>网络编程</li>
<li>爬虫</li>
<li>云计算<br>代表：OpenStack</li>
<li>AI</li>
<li>自动化运维</li>
<li>科学运算<br>97年开始 NASA就开始用 Python大量的进行科学运算<br>代表作：引力波的发现程序</li>
<li>游戏开发<br>代表作：文明</li>
</ul>
<p>正因为 Python能够接触这么多的领域，所以 Python大家都叫他 万能语言。</p>
<h4 id="那些大厂都在使用Python"><a href="#那些大厂都在使用Python" class="headerlink" title="那些大厂都在使用Python"></a>那些大厂都在使用Python</h4><ul>
<li>Google</li>
<li>CIA</li>
<li>NASA</li>
<li>YouTube</li>
<li>Dropbox</li>
<li>Instagram</li>
<li>Facebook</li>
<li>Redhat</li>
<li>豆瓣</li>
<li>知乎</li>
<li>春雨医生</li>
<li>搜狐</li>
<li>金山</li>
<li>腾讯</li>
<li>盛大</li>
<li>网易</li>
<li>百度</li>
<li>阿里</li>
<li>淘宝</li>
<li>土豆</li>
<li>新浪</li>
<li>果壳</li>
</ul>
<h4 id="各个版本"><a href="#各个版本" class="headerlink" title="各个版本"></a>各个版本</h4><p>1999年诞生了第一个 Python-Web 框架 Zope</p>
<ul>
<li>Python 1.0 - 1994.1 增加了 lambda, map, filter, reduce</li>
<li>Python 2.0 - 2000.10 加入内存回收机制，构成了现在 Python语言框架的基础</li>
<li>Python 2.4 - 2004.11 同年 Django诞生</li>
<li>Python 2.5 - 2006.19</li>
<li>Python 2.6 - 2008.10</li>
<li>Python 2.7 - 2010.7</li>
</ul>
<p>在这里大家看到，Python3.0 是在 Python 2.7之前发布的，这里没有写错啊。</p>
<p>因为 当时Python是由 龟叔 + 社区工作者 + 广大用户 一起来维护的，但是慢慢地龟叔发现 Python 越来越像C系 或 Java类型了，但由于植入的功能讷河模块特别多，也不方便整改，所以 龟叔 选择了推出 Python 3.x。</p>
<p>但因为 Python 2.x (2.7以下) 和Python3互不兼容，你 Py2的代码，用Py3运行不了，导致了 大量的人反对，而且 Python 3.x的支持率也急剧下降。迫于无奈两年后 2010年，龟叔推出了 Python 2.7 来缓和和过度 让大家慢慢地接受Python 3.x。他和 Python 3.x 是可以兼容的 并且龟叔发出声明 2020.1 将不再对 Python 2.7进行更新和维护。</p>
<ul>
<li>Python 3.0 - 2008.12</li>
<li>Python 3.1 - 2009.6</li>
<li>Python 3.2 - 2011.2</li>
<li>Python 3.3 - 2012.9</li>
<li>Python 3.4 - 2014.3</li>
<li>Python 3.5 - 2015.9</li>
<li>Python 3.6 - 2016.12</li>
<li>Python 3.7 - 2018.2</li>
<li>Python 3.8 - 2019.1</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 配置文件</title>
    <url>/2020/08/23/Nginx%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200302114623831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200302114623831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" class="lozad post-image"></p>
<p><strong>Nginx 配置</strong></p>
<h5 id="nginx配置文件注释"><a href="#nginx配置文件注释" class="headerlink" title="nginx配置文件注释"></a>nginx配置文件注释</h5><pre class="highlight"><span class="line"><span class="meta">#</span><span class="bash">运行用户</span></span><br><span class="line">user nobody;</span><br><span class="line"><span class="meta">#</span><span class="bash">启动进程,通常设置成和cpu的数量相等</span></span><br><span class="line">worker_processes  1;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">全局错误日志及PID文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  info;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">pid        logs/nginx.pid;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">工作模式及连接数上限</span></span><br><span class="line">events &#123;</span><br><span class="line">    #epoll是多路复用IO(I/O Multiplexing)中的一种方式,</span><br><span class="line">    #仅用于linux2.6以上内核,可以大大提高nginx的性能</span><br><span class="line">    use   epoll; </span><br><span class="line"> </span><br><span class="line">    #单个后台worker process进程的最大并发链接数    </span><br><span class="line">    worker_connections  1024;</span><br><span class="line"> </span><br><span class="line">    # 并发总数是 worker_processes 和 worker_connections 的乘积</span><br><span class="line">    # 即 max_clients = worker_processes * worker_connections</span><br><span class="line">    # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4  为什么</span><br><span class="line">    # 为什么上面反向代理要除以4，应该说是一个经验值</span><br><span class="line">    # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000</span><br><span class="line">    # worker_connections 值的设置跟物理内存大小有关</span><br><span class="line">    # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数</span><br><span class="line">    # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右</span><br><span class="line">    # 我们来看看360M内存的VPS可以打开的文件句柄数是多少：</span><br><span class="line">    # $ cat /proc/sys/fs/file-max</span><br><span class="line">    # 输出 34336</span><br><span class="line">    # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内</span><br><span class="line">    # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置</span><br><span class="line">    # 使得并发总数小于操作系统可以打开的最大文件数目</span><br><span class="line">    # 其实质也就是根据主机的物理CPU和内存进行配置</span><br><span class="line">    # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。</span><br><span class="line">    # ulimit -SHn 65535</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">http &#123;</span><br><span class="line">    #设定mime类型,类型由mime.type文件定义</span><br><span class="line">    include    mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    #设定日志格式</span><br><span class="line">    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">                      '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">                      '"$http_user_agent" "$http_x_forwarded_for"';</span><br><span class="line"> </span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line"> </span><br><span class="line">    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，</span><br><span class="line">    #对于普通应用，必须设为 on,</span><br><span class="line">    #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，</span><br><span class="line">    #以平衡磁盘与网络I/O处理速度，降低系统的uptime.</span><br><span class="line">    sendfile     on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"> </span><br><span class="line">    #连接超时时间</span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    tcp_nodelay     on;</span><br><span class="line"> </span><br><span class="line">    #开启gzip压缩</span><br><span class="line">    gzip  on;</span><br><span class="line">    gzip_disable "MSIE [1-6].";</span><br><span class="line"> </span><br><span class="line">    #设定请求缓冲</span><br><span class="line">    client_header_buffer_size    128k;</span><br><span class="line">    large_client_header_buffers  4 128k;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    #设定虚拟主机配置</span><br><span class="line">    server &#123;</span><br><span class="line">        #侦听80端口</span><br><span class="line">        listen    80;</span><br><span class="line">        #定义使用 www.nginx.cn访问</span><br><span class="line">        server_name  www.nginx.cn;</span><br><span class="line"> </span><br><span class="line">        #定义服务器的默认网站根目录位置</span><br><span class="line">        root html;</span><br><span class="line"> </span><br><span class="line">        #设定本虚拟主机的访问日志</span><br><span class="line">        access_log  logs/nginx.access.log  main;</span><br><span class="line"> </span><br><span class="line">        #默认请求</span><br><span class="line">        location / &#123;</span><br><span class="line">            </span><br><span class="line">            #定义首页索引文件的名称</span><br><span class="line">            index index.php index.html index.htm;   </span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        # 定义错误提示页面</span><br><span class="line">        error_page   500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        #静态文件，nginx自己处理</span><br><span class="line">        location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123;</span><br><span class="line">            </span><br><span class="line">            #过期30天，静态文件不怎么更新，过期可以设大一点，</span><br><span class="line">            #如果频繁更新，则可以设置得小一点。</span><br><span class="line">            expires 30d;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.</span><br><span class="line">        location ~ .php$ &#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">            include fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        #禁止访问 .htxxx 文件</span><br><span class="line">            location ~ /.ht &#123;</span><br><span class="line">            deny all;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>



<h5 id="nginx配置举例"><a href="#nginx配置举例" class="headerlink" title="nginx配置举例"></a>nginx配置举例</h5><pre class="highlight"><span class="line">user  work;</span><br><span class="line">worker_processes 8;</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line">error_log  logs/error.log warn;</span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line">pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  65535;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> load modules compiled as Dynamic Shared Object (DSO)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">dso &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    load ngx_http_fastcgi_module.so;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    load ngx_http_rewrite_module.so;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">&#125;</span></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    server_names_hash_bucket_size 128;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nopush      on;</span><br><span class="line">    tcp_nodelay     on;</span><br><span class="line"></span><br><span class="line">    fastcgi_connect_timeout 5;</span><br><span class="line">    fastcgi_send_timeout 10;</span><br><span class="line">    fastcgi_read_timeout 10;</span><br><span class="line">    fastcgi_buffer_size 64k;</span><br><span class="line">    fastcgi_buffers 4 64k;</span><br><span class="line">    fastcgi_busy_buffers_size 128k;</span><br><span class="line">    fastcgi_temp_file_write_size 128k;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  60;</span><br><span class="line">    keepalive_requests 1024;</span><br><span class="line">    client_header_buffer_size 4k;</span><br><span class="line">    large_client_header_buffers 4 32k;</span><br><span class="line">    client_max_body_size 10m;</span><br><span class="line"></span><br><span class="line">    client_body_buffer_size 512k;</span><br><span class="line">    client_body_timeout 600;</span><br><span class="line">    client_header_timeout 600;</span><br><span class="line">    send_timeout 600;</span><br><span class="line"></span><br><span class="line">    proxy_connect_timeout   1000ms;</span><br><span class="line">    proxy_send_timeout      2000000ms;</span><br><span class="line">    proxy_read_timeout      2000000ms;</span><br><span class="line">    proxy_buffers           64 8k;</span><br><span class="line">    proxy_busy_buffers_size    128k;</span><br><span class="line">    proxy_temp_file_write_size 64k;</span><br><span class="line">    proxy_redirect off;</span><br><span class="line">    #proxy_next_upstream off ;</span><br><span class="line"></span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line">    gzip_buffers 4 16k;</span><br><span class="line">    gzip_http_version 1.0;</span><br><span class="line">    gzip_comp_level 2;</span><br><span class="line">    gzip_types text/plain application/x-javascript text/css application/xml;</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    add_header X-Frame-Options "ALLOW-FROM  http://cloud.njsig.cn";</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Real-Port $remote_port;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">        '$status $body_bytes_sent "$http_referer" "$http_cookie" "$http_user_agent" '</span><br><span class="line">        '$request_time $remote_addr $server_addr $upstream_addr $host '</span><br><span class="line">        '"$http_x_forwarded_for" $upstream_response_time';</span><br><span class="line"></span><br><span class="line">    set_real_ip_from 10.0.0.0/8;</span><br><span class="line">    real_ip_header X-Real-IP;</span><br><span class="line"></span><br><span class="line">    #example</span><br><span class="line"><span class="meta">#</span><span class="bash">     server &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        listen 8000;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        server_name www;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        access_log logs/access.log  main;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        location / &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            proxy_pass http://127.0.0.1:8001;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        &#125;</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">      &#125;</span></span><br><span class="line">    include vhosts/*.conf;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####</span></span></span><br></pre>



<h5 id="nginx-conf-vhosts-opwf-conf-django项目简单配置"><a href="#nginx-conf-vhosts-opwf-conf-django项目简单配置" class="headerlink" title="nginx/conf/vhosts/opwf.conf django项目简单配置"></a>nginx/conf/vhosts/opwf.conf django项目简单配置</h5><pre class="highlight"><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name aaa.test.com bbb.test.com;</span><br><span class="line">        access_log  /home/work/nginx/logs/opwf_access.log main;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:8001;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre>



<h5 id="nginx-conf-vhosts-opwf-conf-django项目简单配置-1"><a href="#nginx-conf-vhosts-opwf-conf-django项目简单配置-1" class="headerlink" title="nginx/conf/vhosts/opwf.conf django项目简单配置"></a>nginx/conf/vhosts/opwf.conf django项目简单配置</h5><pre class="highlight"><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name ccc.test.com;</span><br><span class="line">        access_log  /home/work/nginx/logs/nj1_access.log main;</span><br><span class="line">        root /home/work/project/frontopwf/dist;</span><br><span class="line">        location / &#123;</span><br><span class="line">                try_files $uri $uri/ @router;</span><br><span class="line">        &#125;</span><br><span class="line">        location @router &#123;</span><br><span class="line">                rewrite ^.*$ /index.html last;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre>]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python Django 支付宝 扫码支付</title>
    <url>/2020/08/12/Python%20Django%20%E6%94%AF%E4%BB%98%E5%AE%9D%20%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98/</url>
    <content><![CDATA[<p><strong>*\</strong>*安装python-alipay-sdk**<em>**</em></p>
<pre class="highlight"><span class="line">pip install python-alipay-sdk --upgrade</span><br></pre>



<p><strong><em>\</em>原理介绍：**</strong></p>
<p>　　1.进行秘钥配置，因为传输的数据必须要进行签名加密，ubuntu内置命令openssl可以生成私钥，根据私钥生成公钥</p>
<pre class="highlight"><span class="line">　　openssl</span><br><span class="line">　　OpenSSL&gt; genrsa -out app_private_key.pem   2048  # 私钥 2048对应的是rsa加密时候的复杂程度，即rsa2</span><br><span class="line">　　OpenSSL&gt; rsa -in app_private_key.pem -pubout -out app_public_key.pem # 导出公钥</span><br><span class="line">　　OpenSSL&gt; exit</span><br></pre>

<p>　　2.cat app_publict_key.pem 查看公钥的内容</p>
<p>　　将—–BEGIN PUBLIC KEY—–和—–END PUBLIC KEY—–中间的内容保存在支付宝的用户配置中（沙箱或者正式）</p>
<p>​    <a href="https://openhome.alipay.com/platform/appDaily.htm?tab=info" target="_blank" rel="noopener">https://openhome.alipay.com/platform/appDaily.htm?tab=info</a></p>
<p>　　3.配置好公钥后，支付宝会生成公钥，将公钥的内容复制保存到一个文本文件中(alipay_pubilc_key.pem)，注意需要在文本的首尾添加标记位(—–BEGIN 　　PUBLIC KEY—–和—–END PUBLIC KEY—–) </p>
<p>　　4.将刚刚生成的私钥app_private_key.pem和支付宝公钥alipay_public_key.pem放到我们的项目目录中</p>
<p>　　5.使用支付宝 python包的初始化</p>
<p>　　6.调用支付接口</p>
<p>　　<a href="https://docs.open.alipay.com/270/alipay.trade.page.pay/" target="_blank" rel="noopener">https://docs.open.alipay.com/270/alipay.trade.page.pay/</a></p>
<p>　　7.获取支付结果接口</p>
<p>　　<a href="https://docs.open.alipay.com/api_1/alipay.trade.query" target="_blank" rel="noopener">https://docs.open.alipay.com/api_1/alipay.trade.query</a></p>
<p><strong><em>\</em>代码部分：**</strong></p>
<p>1.整个项目架构</p>
<p><img src="https://images2017.cnblogs.com/blog/1265917/201801/1265917-20180106213627440-1895798970.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://images2017.cnblogs.com/blog/1265917/201801/1265917-20180106213627440-1895798970.png" class="lozad post-image"></p>
<p>index.html代码</p>
<pre class="highlight"><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;static&#x2F;js&#x2F;jquery-1.4.2.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            $(&#39;#btn&#39;).click(function () &#123;</span><br><span class="line">                var order_id &#x3D; &quot;20180105002&quot;;</span><br><span class="line">                var req_data &#x3D; &#123;</span><br><span class="line">                    order_id: order_id,</span><br><span class="line">                    csrfmiddlewaretoken: &quot;&#123;&#123; csrf_token &#125;&#125;&quot;</span><br><span class="line">                &#125;;</span><br><span class="line">                $.post(&quot;&#x2F;pay&#x2F;&quot;, req_data, function (data) &#123;</span><br><span class="line">                    window.open(data.url)</span><br><span class="line">                &#125;);</span><br><span class="line">                $.get(&quot;&#x2F;check_pay&#x2F;?order_id&#x3D;&quot; + order_id, function (data) &#123;</span><br><span class="line">                    if (0 &#x3D;&#x3D; data.code) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 支付成功</span><br><span class="line">                        alert(&quot;支付成功&quot;);</span><br><span class="line">                        location.reload();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        alert(data.message)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btn&quot; value&#x3D;&quot;支付&quot;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre>

<p>2.AppTest.views.py代码</p>
<pre class="highlight"><span class="line">#coding:utf-8</span><br><span class="line">from django.shortcuts import render</span><br><span class="line"></span><br><span class="line">from django.shortcuts import render</span><br><span class="line">from django.http import JsonResponse</span><br><span class="line">from alipay import AliPay</span><br><span class="line">import os</span><br><span class="line">from django.conf import settings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    return render(request, &quot;index.html&quot;,locals())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pay(request):</span><br><span class="line">    order_id &#x3D; request.POST.get(&quot;order_id&quot;)</span><br><span class="line">    # 创建用于进行支付宝支付的工具对象</span><br><span class="line">    alipay &#x3D; AliPay(</span><br><span class="line">        appid&#x3D;settings.ALIPAY_APPID,</span><br><span class="line">        app_notify_url&#x3D;None,  # 默认回调url</span><br><span class="line">        app_private_key_path&#x3D;os.path.join(settings.BASE_DIR, &quot;AppTest&#x2F;app_private_key.pem&quot;),</span><br><span class="line">        alipay_public_key_path&#x3D;os.path.join(settings.BASE_DIR, &quot;AppTest&#x2F;alipay_public_key.pem&quot;),</span><br><span class="line">        # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,</span><br><span class="line">        sign_type&#x3D;&quot;RSA2&quot;,  # RSA 或者 RSA2</span><br><span class="line">        debug&#x3D;True  # 默认False  配合沙箱模式使用</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # 电脑网站支付，需要跳转到https:&#x2F;&#x2F;openapi.alipay.com&#x2F;gateway.do? + order_string</span><br><span class="line">    order_string &#x3D; alipay.api_alipay_trade_page_pay(</span><br><span class="line">        out_trade_no&#x3D;order_id,</span><br><span class="line">        total_amount&#x3D;str(0.01),  # 将Decimal类型转换为字符串交给支付宝</span><br><span class="line">        subject&#x3D;&quot;测试订单&quot;,</span><br><span class="line">        return_url&#x3D;&quot;https:&#x2F;&#x2F;example.com&quot;,</span><br><span class="line">        notify_url&#x3D;&quot;https:&#x2F;&#x2F;example.com&#x2F;notify&quot;  # 可选, 不填则使用默认notify url</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # 让用户进行支付的支付宝页面网址</span><br><span class="line">    url &#x3D; settings.ALIPAY_URL + &quot;?&quot; + order_string</span><br><span class="line"></span><br><span class="line">    return JsonResponse(&#123;&quot;code&quot;: 0, &quot;message&quot;: &quot;请求支付成功&quot;, &quot;url&quot;: url&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def check_pay(request):</span><br><span class="line">    # 创建用于进行支付宝支付的工具对象</span><br><span class="line">    order_id &#x3D; request.GET.get(&quot;order_id&quot;)</span><br><span class="line">    alipay &#x3D; AliPay(</span><br><span class="line">        appid&#x3D;settings.ALIPAY_APPID,</span><br><span class="line">        app_notify_url&#x3D;None,  # 默认回调url</span><br><span class="line">        app_private_key_path&#x3D;os.path.join(settings.BASE_DIR, &quot;AppTest&#x2F;app_private_key.pem&quot;),</span><br><span class="line">        alipay_public_key_path&#x3D;os.path.join(settings.BASE_DIR, &quot;AppTest&#x2F;alipay_public_key.pem&quot;),</span><br><span class="line">        # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,</span><br><span class="line">        sign_type&#x3D;&quot;RSA2&quot;,  # RSA2,官方推荐，配置公钥的时候能看到</span><br><span class="line">        debug&#x3D;True  # 默认False  配合沙箱模式使用</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        # 调用alipay工具查询支付结果</span><br><span class="line">        response &#x3D; alipay.api_alipay_trade_query(order_id)  # response是一个字典</span><br><span class="line">        # 判断支付结果</span><br><span class="line">        code &#x3D; response.get(&quot;code&quot;)  # 支付宝接口调用成功或者错误的标志</span><br><span class="line">        trade_status &#x3D; response.get(&quot;trade_status&quot;)  # 用户支付的情况</span><br><span class="line"></span><br><span class="line">        if code &#x3D;&#x3D; &quot;10000&quot; and trade_status &#x3D;&#x3D; &quot;TRADE_SUCCESS&quot;:</span><br><span class="line">            # 表示用户支付成功</span><br><span class="line">            # 返回前端json，通知支付成功</span><br><span class="line">            return JsonResponse(&#123;&quot;code&quot;: 0, &quot;message&quot;: &quot;支付成功&quot;&#125;)</span><br><span class="line"></span><br><span class="line">        elif code &#x3D;&#x3D; &quot;40004&quot; or (code &#x3D;&#x3D; &quot;10000&quot; and trade_status &#x3D;&#x3D; &quot;WAIT_BUYER_PAY&quot;):</span><br><span class="line">            # 表示支付宝接口调用暂时失败，（支付宝的支付订单还未生成） 后者 等待用户支付</span><br><span class="line">            # 继续查询</span><br><span class="line">            print(code)</span><br><span class="line">            print(trade_status)</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">            # 支付失败</span><br><span class="line">            # 返回支付失败的通知</span><br><span class="line">            return JsonResponse(&#123;&quot;code&quot;: 1, &quot;message&quot;: &quot;支付失败&quot;&#125;)</span><br><span class="line"># Create your views here.</span><br></pre>

<p>3.主urls.py</p>
<pre class="highlight"><span class="line">from django.conf.urls import include, url</span><br><span class="line">from django.contrib import admin</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^admin&#x2F;&#39;, include(admin.site.urls)),</span><br><span class="line">    url(r&#39;^&#39;, include(&#39;AppTest.urls&#39;)),</span><br><span class="line">]</span><br></pre>

<p>4.AppTest urls.py</p>
<pre class="highlight"><span class="line">from django.conf.urls import include, url</span><br><span class="line">from views import *</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&quot;^$&quot;, index),</span><br><span class="line">    url(r&quot;^pay&#x2F;$&quot;, pay),</span><br><span class="line">    url(r&quot;^check_pay&#x2F;$&quot;, check_pay),</span><br><span class="line">]</span><br></pre>

<p>5.setttings.py中设置</p>
<p>修改templates部分</p>
<pre class="highlight"><span class="line">TEMPLATES &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,</span><br><span class="line">        &#39;DIRS&#39;: [</span><br><span class="line">            os.path.join(BASE_DIR,&quot;template&quot;).replace(&quot;\\&quot;,&quot;&#x2F;&quot;)</span><br><span class="line">        ],</span><br><span class="line">        &#39;APP_DIRS&#39;: True,</span><br><span class="line">        &#39;OPTIONS&#39;: &#123;</span><br><span class="line">            &#39;context_processors&#39;: [</span><br><span class="line">                &#39;django.template.context_processors.debug&#39;,</span><br><span class="line">                &#39;django.template.context_processors.request&#39;,</span><br><span class="line">                &#39;django.contrib.auth.context_processors.auth&#39;,</span><br><span class="line">                &#39;django.contrib.messages.context_processors.messages&#39;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre>

<p>末尾加入</p>
<pre class="highlight"><span class="line">STATIC_URL &#x3D; &#39;&#x2F;static&#x2F;&#39;</span><br><span class="line">STATICFILES_DIRS &#x3D; [os.path.join(BASE_DIR, &quot;static&quot;)]</span><br><span class="line"></span><br><span class="line"># 支付宝配置参数</span><br><span class="line">ALIPAY_APPID &#x3D; &quot;2017072407880788&quot;</span><br><span class="line">ALIPAY_URL &#x3D; &quot;https:&#x2F;&#x2F;openapi.alipay.com&#x2F;gateway.do&quot;</span><br></pre>





<p><strong>测试效果：</strong></p>
<p><strong><img src="https://images2017.cnblogs.com/blog/1265917/201801/1265917-20180106214211659-814207984.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://images2017.cnblogs.com/blog/1265917/201801/1265917-20180106214211659-814207984.png" class="lozad post-image"></strong></p>
<p><strong><img src="https://images2017.cnblogs.com/blog/1265917/201801/1265917-20180106214152831-470859591.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://images2017.cnblogs.com/blog/1265917/201801/1265917-20180106214152831-470859591.png" class="lozad post-image"></strong></p>
<p>返回结果</p>
<p><a href="https://example.com/?total_amount=0.01&amp;timestamp=2018-01-06+21%3A28%3A38&amp;sign=fg19hD85DPPuN1aaI%2B%2BskuomKUxaDGE%2FdvyttEyV3vubVkVvBDXVziZaGybXqZs5o4bXYojx587qNBb8e%2FjAJOBCwKwYZxd7qR3AKlVabkPDzEOlzvEaSW7HTQpsWsVeX6BW%2ByEO8pWQ8c%2BS8B8tS8a8AFtQxeW92as4hdNjQU2YBZ2SVxtKSohWbFWpny1gDWXinQ3y2HNo4t5lmA8fRknB0MaUPwR1SzWa0k%2BylYjpWEnzC6OihP0Er21Ad8fiUwtSxZqH4xIAhnbofAy%2BHYZZVsv5lYg%2Brb87eM6Yz7xwUe5v5dDEoz%2FOLjsuB0GDRTdvhHqs39cGIoMXFfEpbw%3D%3D&amp;trade_no=2018010621001004260217512776&amp;sign_type=RSA2&amp;auth_app_id=2017072407880788&amp;charset=utf-8&amp;seller_id=2088221936946848&amp;method=alipay.trade.page.pay.return&amp;app_id=2017072407880788&amp;out_trade_no=20180105002&amp;version=1.0" target="_blank" rel="noopener">https://example.com/?total_amount=0.01&amp;timestamp=2018-01-06+21%3A28%3A38&amp;sign=fg19hD85DPPuN1aaI%2B%2BskuomKUxaDGE%2FdvyttEyV3vubVkVvBDXVziZaGybXqZs5o4bXYojx587qNBb8e%2FjAJOBCwKwYZxd7qR3AKlVabkPDzEOlzvEaSW7HTQpsWsVeX6BW%2ByEO8pWQ8c%2BS8B8tS8a8AFtQxeW92as4hdNjQU2YBZ2SVxtKSohWbFWpny1gDWXinQ3y2HNo4t5lmA8fRknB0MaUPwR1SzWa0k%2BylYjpWEnzC6OihP0Er21Ad8fiUwtSxZqH4xIAhnbofAy%2BHYZZVsv5lYg%2Brb87eM6Yz7xwUe5v5dDEoz%2FOLjsuB0GDRTdvhHqs39cGIoMXFfEpbw%3D%3D&amp;trade_no=2018010621001004260217512776&amp;sign_type=RSA2&amp;auth_app_id=2017072407880788&amp;charset=utf-8&amp;seller_id=2088221936946848&amp;method=alipay.trade.page.pay.return&amp;app_id=2017072407880788&amp;out_trade_no=20180105002&amp;version=1.0</a></p>
]]></content>
      <categories>
        <category>支付宝扫码</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 单元测试</title>
    <url>/2020/05/10/Python%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>Python 中有一个经常使用的测试框架 <code>unitest</code></p>
<h4 id="什么是unittest"><a href="#什么是unittest" class="headerlink" title="什么是unittest"></a>什么是unittest</h4><p>unittest是Python单元测试框架，Java也有个类似的 叫 JUnit。</p>
<h4 id="unitest主要功能模块介绍"><a href="#unitest主要功能模块介绍" class="headerlink" title="unitest主要功能模块介绍"></a>unitest主要功能模块介绍</h4><p>unitest主要包含TestCase、TestSuite、TestLoader、TextTestRunner、TextTestResult这几个功能模块。</p>
<ul>
<li>TestCase：一个 <code>TestCase</code> 实例就是一个测试用例，一个测试用例就是一个完整的测试流程，包括测试前环境的搭建，测试代码的执行，以及测试后环境的还原或者销毁。元测试的本质也就在这里，一个测试用例是一个完整的测试单元，可以对某一具体问题进行检查验证。</li>
<li>TestSuite：多个测试用例集合在一起就是 <code>TestSuite</code>，<code>TestSuite</code> 也可以嵌套<code>TestSuite</code>。</li>
<li>TestLoader：<code>TestLoader</code> 的作用是将 <code>Testcase</code> 加载到 <code>TestSuite</code> 中。</li>
<li>TextTestRunner：<code>TextTestRunner</code> 是用来执行测试用例的，其中的run(test)会执行 <code>TestSuite/TestCase</code> 中的 <code>run(result)</code> 方法。</li>
<li>TextTestResult：<code>TextTestResult</code> 用来保存测试结果，其中包括运行了多少测试用例，成功了多少，失败了多少等信息。</li>
</ul>
<p>整个流程为：写好 TestCase，然后由 TestLoader 加载 TestCase 到 TestSuite，然后由 TextTestRunner 来运行 TestSuite，运行的结果保存在 TextTestResult 中。</p>
<h4 id="实例介绍"><a href="#实例介绍" class="headerlink" title="实例介绍"></a>实例介绍</h4><ul>
<li>首先准备几个待测的方法，写在 test_func.py中。</li>
</ul>
<pre class="highlight"><span class="line"><span class="comment"># test_func.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multi</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lower_str</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> string.lower()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre>

<ul>
<li>准备好几个待测的方法之后，为这些方法写一个测试用例,写入 our_testcase.py中。</li>
</ul>
<pre class="highlight"><span class="line"><span class="comment"># our_testcase.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> test_func <span class="keyword">import</span> *   <span class="comment"># 测试使用，所以可以 *</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestFunc</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""Test test_func.py"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Test func add"""</span></span><br><span class="line">        self.assertEqual(<span class="number">3</span>, add(<span class="number">1</span>, <span class="number">2</span>))      <span class="comment"># 1 + 2 = 3</span></span><br><span class="line">        self.assertNotEqual(<span class="number">3</span>, add(<span class="number">1</span>, <span class="number">3</span>))    <span class="comment"># 1 + 3 != 3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_multi</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Test func multi"""</span></span><br><span class="line">        self.assertEqual(<span class="number">6</span>, multi(<span class="number">2</span>, <span class="number">3</span>))      <span class="comment"># 2 * 3 = 6</span></span><br><span class="line">        self.assertNotEqual(<span class="number">8</span>, multi(<span class="number">3</span>, <span class="number">3</span>))      <span class="comment"># 3 * 3 != 8</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_lower_str</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Test func lower_str"""</span></span><br><span class="line">        self.assertEqual(<span class="string">"abc"</span>, lower_str(<span class="string">"ABC"</span>))     <span class="comment"># ABC 小写后是 abc</span></span><br><span class="line">        self.assertNotEqual(<span class="string">"Dce"</span>, lower_str(<span class="string">"DCE"</span>))      <span class="comment"># DCE 小写不是 Dce</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_square</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Test func square"""</span></span><br><span class="line">        self.assertEqual(<span class="number">17</span>, square(<span class="number">4</span>))  <span class="comment"># 这里故意设计一个会出错的用例，测试4的平方等于17，实际上并不等于。</span></span><br><span class="line">        self.assertNotEqual(<span class="number">35</span>, square(<span class="number">6</span>))     <span class="comment"># 6的2次方不是 35</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132</span></span><br></pre>

<p>这里写好之后，进入命令行终端，执行python our_testcase.py，执行结果如下。</p>
<pre class="highlight"><span class="line">...F</span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_square (__main__.TestFunc)</span><br><span class="line">Test func square</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"our_testcase.py"</span>, line <span class="number">27</span>, <span class="keyword">in</span> test_square</span><br><span class="line">    self.assertEqual(<span class="number">17</span>, square(<span class="number">4</span>))</span><br><span class="line">AssertionError: <span class="number">17</span> != <span class="number">16</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">4</span> tests <span class="keyword">in</span> <span class="number">0.000</span>s</span><br><span class="line"></span><br><span class="line">FAILED (failures=<span class="number">1</span>)</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre>

<p>这里分析一下这个执行结果。首先能够看到一共运行了4个测试用例，失败了1个，并且给出了失败原因，AssertionError: 17 != 16，这是我们故意留下的错误漏洞，被测试用例测试出来了。</p>
<p>第一行…F中，一个点.代表测试成功，F代表失败，我们的测试结果中，前三个成功了，第四个失败了，总共是四个测试，其余的符号中E代表出错，S代表跳过。</p>
<pre class="highlight"><span class="line">特别说明的一点是，测试的执行顺序跟方法的顺序没有关系，四个测试是随机先后执行的。</span><br></pre>

<p>每个测试方法编写的时候，都要以 <code>test开头，比如test_square，否则是不被unitest识别的。</code></p>
<h4 id="进阶，查看程序"><a href="#进阶，查看程序" class="headerlink" title="进阶，查看程序"></a>进阶，查看程序</h4><p>在unitest.main()中加上verbosity参数可以控制输出的错误报告的详细程序，默认是1，如果设为0，则不输出每一用例的执行结果，即上面的第一行的执行结果内容。如果设为2，则输出详细的执行结果。</p>
<ul>
<li>修改our_testcase.py中主函数。</li>
</ul>
<pre class="highlight"><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main(verbosity=<span class="number">2</span>)</span><br><span class="line"><span class="number">12</span></span><br></pre>

<ul>
<li>执行结果如下。</li>
</ul>
<pre class="highlight"><span class="line">test_add (__main__.TestFunc)</span><br><span class="line">Test func add ... ok</span><br><span class="line">test_lower_str (__main__.TestFunc)</span><br><span class="line">Test func lower_str ... ok</span><br><span class="line">test_multi (__main__.TestFunc)</span><br><span class="line">Test func multi ... ok</span><br><span class="line">test_square (__main__.TestFunc)</span><br><span class="line">Test func square ... FAIL</span><br><span class="line"></span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_square (__main__.TestFunc)</span><br><span class="line">Test func square</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"our_testcase.py"</span>, line <span class="number">27</span>, <span class="keyword">in</span> test_square</span><br><span class="line">    self.assertEqual(<span class="number">17</span>, square(<span class="number">4</span>))</span><br><span class="line">AssertionError: <span class="number">17</span> != <span class="number">16</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">4</span> tests <span class="keyword">in</span> <span class="number">0.000</span>s</span><br><span class="line"></span><br><span class="line">FAILED (failures=<span class="number">1</span>)</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre>

<p>可以看到，每一个用例的详细执行情况以及用例名，用例描述均被输出了出来，在测试方法下加代码示例中的 Doc String，在用例执行时，会将该字符串作为此用例的描述，加合适的注释能够使输出的测试报告更加便于阅读。</p>
<h4 id="一、组织TestSuite-顺序执行"><a href="#一、组织TestSuite-顺序执行" class="headerlink" title="一、组织TestSuite 顺序执行"></a>一、组织TestSuite 顺序执行</h4><p>按照上面的测试方法，我们无法控制用例执行的顺序，这样显然是不合理的，因为在一些测试过程中，我们肯定需要控制先测试某些用例，再测试某些用例，这些用例有先后的因果关系。在这里，我们就需要用到TestSuite。我们添加到TestSuite中的case是会按照添加的顺序执行的。</p>
<p>还有一个问题是，我们现在只有一个测试文件，我们直接执行该文件即可，但如果有多个测试文件，怎么进行组织，总不能一个个文件执行吧，答案也在TestSuite中。</p>
<ul>
<li>新建一个文件，test_suite.py。</li>
</ul>
<pre class="highlight"><span class="line"><span class="comment"># test_suite.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> our_testcase <span class="keyword">import</span> TestFunc</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    suite = unittest.TestSuite()</span><br><span class="line">    tests = [TestFunc(<span class="string">"test_square"</span>), TestFunc(<span class="string">"test_lower_str"</span>), TestFunc(<span class="string">"test_multi"</span>)]</span><br><span class="line">    suite.addTests(tests)</span><br><span class="line">    runner = unittest.TextTestRunner(verbosity=<span class="number">2</span>)</span><br><span class="line">    runner.run(suite)</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre>

<p>执行结果如下。</p>
<pre class="highlight"><span class="line">test_square (our_testcase.TestFunc)</span><br><span class="line">Test func square ... FAIL</span><br><span class="line">test_lower_str (our_testcase.TestFunc)</span><br><span class="line">Test func lower_str ... ok</span><br><span class="line">test_multi (our_testcase.TestFunc)</span><br><span class="line">Test func multi ... ok</span><br><span class="line"></span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_square (our_testcase.TestFunc)</span><br><span class="line">Test func square</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/luyuze/projects/test/our_testcase.py"</span>, line <span class="number">27</span>, <span class="keyword">in</span> test_square</span><br><span class="line">    self.assertEqual(<span class="number">17</span>, square(<span class="number">4</span>))</span><br><span class="line">AssertionError: <span class="number">17</span> != <span class="number">16</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">3</span> tests <span class="keyword">in</span> <span class="number">0.000</span>s</span><br><span class="line"></span><br><span class="line">FAILED (failures=<span class="number">1</span>)</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre>

<p>这样，用例执行的顺序就是按照我们添加进去的顺序来执行的了。</p>
<p>上面使用的是TestSuite的addTests()方法，并直接传入TestCase列表，也有一些其他的方法可以向TestSuite中添加用例。</p>
<pre class="highlight"><span class="line"><span class="comment"># 直接用addTest方法添加单个TestCase</span></span><br><span class="line">suite.addTest(TestMathFunc(<span class="string">"test_multi"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用loadTestFromName,传入模块名.TestCase名，下面俩方法效果相同</span></span><br><span class="line">suite.addTests(unittest.TestLoader().loadTestsFromName(<span class="string">'our_testcase.TestFunc'</span>))</span><br><span class="line">suite.addTests(unittest.TestLoader().loadTestsFromNames([<span class="string">'our_testcase.TestFunc'</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># loadTestsFromTestCase()，传入TestCase</span></span><br><span class="line">suite.addTests(unittest.TestLoader().loadTestsFromTestCase(TestFunc))</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre>

<p>用TestLoader的方法是无法对case进行排序的，同时，suite中也可以套suite。</p>
<h4 id="二、输出到文件"><a href="#二、输出到文件" class="headerlink" title="二、输出到文件"></a>二、输出到文件</h4><p>用例组织好了，但是结果只能输出到控制台，这样没办法查看之前的执行记录，我们想将结果输出到文件。</p>
<ul>
<li>修改test_suite.py。</li>
</ul>
<pre class="highlight"><span class="line"><span class="comment"># test_suite.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> our_testcase <span class="keyword">import</span> TestFunc</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    suite = unittest.TestSuite()</span><br><span class="line">    tests = [TestFunc(<span class="string">"test_square"</span>), TestFunc(<span class="string">"test_lower_str"</span>), TestFunc(<span class="string">"test_multi"</span>)]</span><br><span class="line">    suite.addTests(tests)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'UnitestTextReport.txt'</span>, <span class="string">'a'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        runner = unittest.TextTestRunner(stream=f, verbosity=<span class="number">2</span>)</span><br><span class="line">        runner.run(suite)</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre>

<h4 id="三、测试前后的处理"><a href="#三、测试前后的处理" class="headerlink" title="三、测试前后的处理"></a>三、测试前后的处理</h4><p>在之前的测试中，可能会存在这样的问题：如果要在测试之前准备环境，测试完成之后做一些清理怎么办？这里需要用到的是setUp()和tearDown()。</p>
<ul>
<li>修改our_testcase.py。</li>
</ul>
<pre class="highlight"><span class="line"><span class="comment"># our_testcase.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> test_func <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestFunc</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""Test test_func.py"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"do something before testcase"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Test func add"""</span></span><br><span class="line">        self.assertEqual(<span class="number">3</span>, add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">        self.assertNotEqual(<span class="number">3</span>, add(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_multi</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Test func multi"""</span></span><br><span class="line">        self.assertEqual(<span class="number">6</span>, multi(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">        self.assertNotEqual(<span class="number">8</span>, multi(<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_lower_str</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Test func lower_str"""</span></span><br><span class="line">        self.assertEqual(<span class="string">"abc"</span>, lower_str(<span class="string">"ABC"</span>))</span><br><span class="line">        self.assertNotEqual(<span class="string">"Dce"</span>, lower_str(<span class="string">"DCE"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_square</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Test func square"""</span></span><br><span class="line">        self.assertEqual(<span class="number">17</span>, square(<span class="number">4</span>))</span><br><span class="line">        self.assertNotEqual(<span class="number">35</span>, square(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDownClass</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"do something after testcase"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main(verbosity=<span class="number">2</span>)</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738</span></span><br></pre>

<ul>
<li>执行结果：</li>
</ul>
<pre class="highlight"><span class="line">test_add (__main__.TestFunc)</span><br><span class="line">Test func add ... do something before testcase</span><br><span class="line">do something after testcase</span><br><span class="line">ok</span><br><span class="line">test_lower_str (__main__.TestFunc)</span><br><span class="line">Test func lower_str ... do something before testcase</span><br><span class="line">do something after testcase</span><br><span class="line">ok</span><br><span class="line">test_multi (__main__.TestFunc)</span><br><span class="line">Test func multi ... do something before testcase</span><br><span class="line">do something after testcase</span><br><span class="line">ok</span><br><span class="line">test_square (__main__.TestFunc)</span><br><span class="line">Test func square ... do something before testcase</span><br><span class="line">do something after testcase</span><br><span class="line">FAIL</span><br><span class="line"></span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_square (__main__.TestFunc)</span><br><span class="line">Test func square</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"our_testcase.py"</span>, line <span class="number">30</span>, <span class="keyword">in</span> test_square</span><br><span class="line">    self.assertEqual(<span class="number">17</span>, square(<span class="number">4</span>))</span><br><span class="line">AssertionError: <span class="number">17</span> != <span class="number">16</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">4</span> tests <span class="keyword">in</span> <span class="number">0.001</span>s</span><br><span class="line"></span><br><span class="line">FAILED (failures=<span class="number">1</span>)</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930</span></span><br></pre>

<p>可以发现 <code>setUp()</code> 和 <code>tearDown()</code> 在每个 <code>case</code> 前后都执行了一次。如果要在所有 <code>case</code> 执行之前和所有 <code>case</code> 执行之后准备和清理环境，我们可以使用 <code>setUpClass()</code> 与 <code>tearDownClass()</code>。</p>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestFunc</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""Test test_func.py"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUpClass</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"This setUpClass() method only called once."</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDownClass</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"This tearDownClass() method only called once too."</span></span><br><span class="line"><span class="number">12345678910</span></span><br></pre>

<h4 id="四、跳过case"><a href="#四、跳过case" class="headerlink" title="四、跳过case"></a>四、跳过case</h4><p>如果我们临时想要跳过某个 <code>case</code> 不执行，<code>unitest</code> 也有相应的方法。</p>
<ul>
<li>1、skip装饰器</li>
</ul>
<pre class="highlight"><span class="line"><span class="comment"># our_testcase.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> test_func <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestFunc</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""Test test_func.py"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @unittest.skip('do not run this case')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Test func add"""</span></span><br><span class="line">        self.assertEqual(<span class="number">3</span>, add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">        self.assertNotEqual(<span class="number">3</span>, add(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_multi</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Test func multi"""</span></span><br><span class="line">        self.assertEqual(<span class="number">6</span>, multi(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">        self.assertNotEqual(<span class="number">8</span>, multi(<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_lower_str</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Test func lower_str"""</span></span><br><span class="line">        self.assertEqual(<span class="string">"abc"</span>, lower_str(<span class="string">"ABC"</span>))</span><br><span class="line">        self.assertNotEqual(<span class="string">"Dce"</span>, lower_str(<span class="string">"DCE"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_square</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Test func square"""</span></span><br><span class="line">        self.assertEqual(<span class="number">17</span>, square(<span class="number">4</span>))</span><br><span class="line">        self.assertNotEqual(<span class="number">35</span>, square(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main(verbosity=<span class="number">2</span>)</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233</span></span><br></pre>

<p>执行结果：</p>
<pre class="highlight"><span class="line">test_add (__main__.TestFunc)</span><br><span class="line">Test func add ... skipped <span class="string">'do not run this case'</span></span><br><span class="line">test_lower_str (__main__.TestFunc)</span><br><span class="line">Test func lower_str ... ok</span><br><span class="line">test_multi (__main__.TestFunc)</span><br><span class="line">Test func multi ... ok</span><br><span class="line">test_square (__main__.TestFunc)</span><br><span class="line">Test func square ... FAIL</span><br><span class="line"></span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_square (__main__.TestFunc)</span><br><span class="line">Test func square</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"our_testcase.py"</span>, line <span class="number">28</span>, <span class="keyword">in</span> test_square</span><br><span class="line">    self.assertEqual(<span class="number">17</span>, square(<span class="number">4</span>))</span><br><span class="line">AssertionError: <span class="number">17</span> != <span class="number">16</span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran <span class="number">4</span> tests <span class="keyword">in</span> <span class="number">0.000</span>s</span><br><span class="line"></span><br><span class="line">FAILED (failures=<span class="number">1</span>, skipped=<span class="number">1</span>)</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre>

<p>结果显示为，总共执行4个测试，1个失败，1个被跳过。</p>
<p>skip装饰器一共有三个:</p>
<ol>
<li>unittest.skip(reason)</li>
<li>unittest.skipIf(condition, reason)</li>
<li>unittest.skipUnless(condition, reason)</li>
</ol>
<p>skip无条件跳过，skipIf 当 condition 为 True 时跳过，skipUnless当condition 为 False 时跳过。</p>
<ul>
<li>2、TestCase.skipTest()方法</li>
</ul>
<pre class="highlight"><span class="line"><span class="comment"># our_testcase.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestFunc</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="string">"""Test test_func.py"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Test func add"""</span></span><br><span class="line">        self.skipTest(<span class="string">"do not run this case"</span>)</span><br><span class="line">        self.assertEqual(<span class="number">3</span>, add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">        self.assertNotEqual(<span class="number">3</span>, add(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line"><span class="number">12345678910</span></span><br></pre>

<p>效果与第一种是一样的。</p>
<p>参考地址：<a href="https://zhuanlan.zhihu.com/p/95687793" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/95687793</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据操作</title>
    <url>/2019/05/01/Redis%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><ul>
<li>redis是key-value的数据结构，每条数据都是⼀个键值对</li>
<li>键的类型是字符串</li>
<li>注意：键不能重复</li>
</ul>
<p><strong>数据结构</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTYxODQwMS8yMDE5MDkvMTYxODQwMS0yMDE5MDkwMTIwNTQxOTIyMy0xODA4MDM4ODM3LnBuZw?x-oss-process=image/format,png" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTYxODQwMS8yMDE5MDkvMTYxODQwMS0yMDE5MDkwMTIwNTQxOTIyMy0xODA4MDM4ODM3LnBuZw?x-oss-process=image/format,png" class="lozad post-image"></p>
<p><strong>值的类型</strong>分为五种：</p>
<ul>
<li>字符串string</li>
<li>哈希hash</li>
<li>列表list</li>
<li>集合set</li>
<li>有序集合zset</li>
</ul>
<p><strong>数据操作行为</strong></p>
<ul>
<li>保存</li>
<li>修改</li>
<li>获取</li>
<li>删除<br>中⽂官⽹查看命令⽂档 <a href="http://redis.cn/commands.html" target="_blank" rel="noopener">http://redis.cn/commands.html</a><h1 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h1></li>
</ul>
<p>字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。</p>
<p><strong>保存</strong><br>如果设置的键不存在则为添加，如果设置的键已经存在则修改</p>
<p><strong>设置键值</strong><br>set key value<br>例1：设置键为name值为itcast的数据</p>
<pre class="highlight"><span class="line">set name yifchan</span><br></pre>



<p><strong>设置键值及过期时间</strong>，以秒为单位</p>
<pre class="highlight"><span class="line">setex key seconds value</span><br></pre>

<p>例2：设置键为aa值为aa过期时间为3秒的数据</p>
<pre class="highlight"><span class="line">setex aa 3 aa</span><br></pre>

<p><strong>设置多个键值</strong></p>
<pre class="highlight"><span class="line">mset key1 value1 key2 value2 ...</span><br></pre>

<p>例3：设置键为’a1’值为’python’、键为’a2’值为’java’、键为’a3’值为’c’</p>
<pre class="highlight"><span class="line">mset a1 python a2 java a3 c</span><br></pre>


<p><strong>追加值</strong></p>
<pre class="highlight"><span class="line">append key value</span><br></pre>

<p>例4：向键为a1中追加值’ haha’</p>
<pre class="highlight"><span class="line">append &#39;a1&#39; &#39;haha&#39;</span><br></pre>



<p><strong>获取</strong><br>获取：<strong>根据键获取值</strong>，如果不存在此键则返回nil</p>
<pre class="highlight"><span class="line">get key</span><br></pre>
<p>例5：获取键’name’的值</p>
<pre class="highlight"><span class="line">get &#39;name&#39;</span><br></pre>


<p>根据多个键获取多个值</p>
<pre class="highlight"><span class="line">mget key1 key2 ...</span><br></pre>

<p>例6：获取键a1、a2、a3’的值</p>
<pre class="highlight"><span class="line">mget a1 a2 a3</span><br></pre>


<p><strong>删除</strong><br>详⻅下节键的操作，删除键时会将值删除</p>
<p><strong>键命令</strong><br>查找键，参数⽀持正则表达式</p>
<pre class="highlight"><span class="line">keys pattern</span><br></pre>

<p>例1：查看所有键</p>
<pre class="highlight"><span class="line">keys *</span><br></pre>

<p>例2：查看名称中包含a的键</p>
<pre class="highlight"><span class="line">keys &#39;a*&#39;</span><br></pre>



<p><strong>判断键是否存在</strong>，如果存在返回1，不存在返回0</p>
<pre class="highlight"><span class="line">exists key1</span><br></pre>

<p>例3：判断键a1是否存在</p>
<pre class="highlight"><span class="line">exists a1</span><br></pre>


<p><strong>查看键对应的value的类型</strong></p>
<pre class="highlight"><span class="line">type key</span><br></pre>

<p>例4：查看键a1的值类型，为redis⽀持的五种类型中的⼀种</p>
<pre class="highlight"><span class="line">type a1</span><br></pre>



<p><strong>删除键及对应的值</strong></p>
<pre class="highlight"><span class="line">del key1 key2 ...</span><br></pre>

<p>例5：删除键a2、a3</p>
<pre class="highlight"><span class="line">del a2 a3</span><br></pre>



<p><strong>设置过期时间</strong>，以秒为单位</p>
<p>如果没有指定过期时间则⼀直存在，直到使⽤DEL移除</p>
<pre class="highlight"><span class="line">expire key seconds</span><br></pre>

<p>例6：设置键’a1’的过期时间为3秒</p>
<pre class="highlight"><span class="line">expire &#39;a1&#39; 3</span><br></pre>



<p><strong>查看有效时间</strong>，以秒为单位</p>
<pre class="highlight"><span class="line">ttl key</span><br></pre>
<p>例7：查看键’bb’的有效时间</p>
<pre class="highlight"><span class="line">ttl bb</span><br></pre>
<h1 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h1><ul>
<li>hash⽤于存储对象，对象的结构为属性、值</li>
<li>值的类型为string</li>
<li><strong>增加、修改</strong></li>
</ul>
<p><strong>设置单个属性</strong></p>
<pre class="highlight"><span class="line">hset key field value</span><br></pre>

<p>例1：设置键 user的属性name为itheima</p>
<pre class="highlight"><span class="line">hset user name itheima</span><br></pre>
<p>可能报错</p>
<pre class="highlight"><span class="line">MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error.</span><br></pre>
<p>Redis被配置为保存数据库快照，但它目前不能持久化到硬盘。用来修改集合数据的命令不能用</p>
<p>原因：</p>
<p>强制关闭Redis快照导致不能持久化。 解决方案：</p>
<p>运行 config set stop-writes-on-bgsave-error no 命令后，关闭配置项stop-writes-on-bgsave-error解决该问题。<br><strong>设置多个属性</strong></p>
<p>hmset key field1 value1 field2 value2 …<br>例2：设置键u2的属性name为itcast、属性age为11</p>
<p>hmset u2 name itcast age 11</p>
<p><strong>获取<br>获取指定键所有的属性</strong></p>
<pre class="highlight"><span class="line">hkeys key</span><br></pre>

<p>例3：获取键u2的所有属性</p>
<pre class="highlight"><span class="line">hkeys u2</span><br></pre>


<p><strong>获取⼀个属性的值</strong></p>
<pre class="highlight"><span class="line">hget key field</span><br></pre>

<p>例4：获取键u2属性’name’的值</p>
<pre class="highlight"><span class="line">hget u2 &#39;name&#39;</span><br></pre>

<p><strong>获取多个属性的值</strong></p>
<pre class="highlight"><span class="line">hmget key field1 field2 ...</span><br></pre>

<p>例5：获取键u2属性’name’、’age的值</p>
<pre class="highlight"><span class="line">hmget u2 name age</span><br></pre>


<p>获取所有属性的值</p>
<pre class="highlight"><span class="line">hvals key</span><br></pre>

<p>例6：获取键’u2’所有属性的值</p>
<pre class="highlight"><span class="line">hvals u2</span><br></pre>



<p><strong>删除</strong><br>删除整个hash键及值，使⽤del命令<br>删除属性，属性对应的值会被⼀起删除</p>
<pre class="highlight"><span class="line">hdel key field1 field2 ...</span><br></pre>

<p>例7：删除键’u2’的属性’age’</p>
<pre class="highlight"><span class="line">hdel u2 age</span><br></pre>




<h1 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h1><ul>
<li>列表的元素类型为string</li>
<li>按照插⼊顺序排序</li>
</ul>
<p><strong>增加<br>在左侧插⼊数据</strong></p>
<pre class="highlight"><span class="line">lpush key value1 value2 ...</span><br></pre>

<p>例1：从键为’a1’的列表左侧加⼊数据a 、 b 、c</p>
<pre class="highlight"><span class="line">lpush a1 a b c</span><br></pre>



<p><strong>在右侧插⼊数据</strong></p>
<pre class="highlight"><span class="line">rpush key value1 value2 ...</span><br></pre>

<p>例2：从键为’a1’的列表右侧加⼊数据0 1</p>
<pre class="highlight"><span class="line">rpush a1 0 1</span><br></pre>



<p><strong>在指定元素的前或后插⼊新元素</strong></p>
<pre class="highlight"><span class="line">linsert key before或after 现有元素 新元素</span><br></pre>

<p>例3：在键为’a1’的列表中元素’b’前加⼊’3’</p>
<pre class="highlight"><span class="line">linsert a1 before b 3</span><br></pre>


<p><strong>获取<br>返回列表⾥指定范围内的元素</strong></p>
<ul>
<li>start、stop为元素的下标索引</li>
<li>索引从左侧开始，第⼀个元素为0</li>
<li>索引可以是负数，表示从尾部开始计数，如-1表示最后⼀个元素<br>lrange key start stop<br>例4：获取键为’a1’的列表所有元素<pre class="highlight"><span class="line">lrange a1 0 -1</span><br></pre>


</li>
</ul>
<p><strong>设置指定索引位置的元素值</strong><br>索引从左侧开始，第⼀个元素为0<br>索引可以是负数，表示尾部开始计数，如-1表示最后⼀个元素</p>
<pre class="highlight"><span class="line">lset key index value</span><br></pre>
<p>例5：修改键为’a1’的列表中下标为1的元素值为’z’</p>
<pre class="highlight"><span class="line">lset a 1 z</span><br></pre>

<p><strong>删除<br>删除指定元素</strong></p>
<p>将列表中前count次出现的值为value的元素移除</p>
<ul>
<li>count &gt; 0: 从头往尾移除</li>
<li>count &lt; 0: 从尾往头移除</li>
<li>count = 0: 移除所有<pre class="highlight"><span class="line">lrem key count value</span><br></pre>

</li>
</ul>
<p>例6.1：向列表’a2’中加⼊元素’a’、’b’、’a’、’b’、’a’、’b’</p>
<pre class="highlight"><span class="line">lpush a2 a b a b a b</span><br></pre>

<p>例6.2：从’a2’列表右侧开始删除2个’b’</p>
<pre class="highlight"><span class="line">lrem a2 -2 b</span><br></pre>

<p>例6.3：查看列表’py12’的所有元素</p>
<pre class="highlight"><span class="line">lrange a2 0 -1</span><br></pre>


<h1 id="set类型"><a href="#set类型" class="headerlink" title="set类型"></a>set类型</h1><ul>
<li>⽆序集合</li>
<li>元素为string类型</li>
<li>元素具有唯⼀性，不重复</li>
<li>说明：对于集合没有修改操作</li>
</ul>
<p><strong>增加<br>添加元素</strong></p>
<pre class="highlight"><span class="line">sadd key member1 member2 ...</span><br></pre>
<p>例1：向键’a3’的集合中添加元素’zhangsan’、’lisi’、’wangwu’</p>
<pre class="highlight"><span class="line">sadd a3 zhangsan sili wangwu</span><br></pre>

<p><strong>获取<br>返回所有的元素</strong></p>
<pre class="highlight"><span class="line">smembers key</span><br></pre>
<p>例2：获取键’a3’的集合中所有元素</p>
<pre class="highlight"><span class="line">smembers a3</span><br></pre>


<p><strong>删除<br>删除指定元素</strong></p>
<pre class="highlight"><span class="line">srem key</span><br></pre>
<p>例3：删除键’a3’的集合中元素’wangwu’</p>
<pre class="highlight"><span class="line">srem a3 wangwu</span><br></pre>


<h1 id="zset类型"><a href="#zset类型" class="headerlink" title="zset类型"></a>zset类型</h1><ul>
<li>sorted set，有序集合</li>
<li>元素为string类型</li>
<li>元素具有唯⼀性，不重复</li>
<li>每个元素都会关联⼀个double类型的score，表示权重，通过权重将元素从⼩到⼤排序</li>
<li>说明：没有修改操作</li>
</ul>
<p><strong>增加<br>添加</strong></p>
<pre class="highlight"><span class="line">zadd key score1 member1 score2 member2 ...</span><br></pre>

<p>例1：向键’a4’的集合中添加元素’lisi’、’wangwu’、’zhaoliu’、’zhangsan’，权重分别为4、5、6、3</p>
<pre class="highlight"><span class="line">zadd a4 4 lisi 5 wangwu 6 zhaoliu 3 zhangsan</span><br></pre>


<p><strong>获取<br>返回指定范围内的元素</strong></p>
<ul>
<li>start、stop为元素的下标索引</li>
<li>索引从左侧开始，第⼀个元素为0</li>
<li>索引可以是负数，表示从尾部开始计数，如-1表示最后⼀个元素<pre class="highlight"><span class="line">zrange key start stop</span><br></pre>

</li>
</ul>
<p>例2：获取键’a4’的集合中所有元素</p>
<pre class="highlight"><span class="line">zrange a4 0 -1</span><br></pre>



<p><strong>返回score值在min和max之间的成员</strong></p>
<pre class="highlight"><span class="line">zrangebyscore key min max</span><br></pre>
<p>例3：获取键’a4’的集合中权限值在5和6之间的成员</p>
<pre class="highlight"><span class="line">zrangebyscore a4 5 6</span><br></pre>

<p><strong>返回成员member的score值</strong></p>
<pre class="highlight"><span class="line">zscore key member</span><br></pre>

<p>例4：获取键’a4’的集合中元素’zhangsan’的权重</p>
<pre class="highlight"><span class="line">zscore a4 zhangsan</span><br></pre>

<p><strong>删除<br>删除指定元素</strong></p>
<pre class="highlight"><span class="line">zrem key member1 member2 ...</span><br></pre>

<p>例5：删除集合’a4’中元素’zhangsan’</p>
<pre class="highlight"><span class="line">zrem a4 zhangsan</span><br></pre>


<p><strong>删除权重在指定范围的元素</strong></p>
<pre class="highlight"><span class="line">zremrangebyscore key min max</span><br></pre>
<p>例6：删除集合’a4’中权限在5、6之间的元素</p>
<pre class="highlight"><span class="line">zremrangebyscore a4 5 6</span><br></pre>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js的基本语法</title>
    <url>/2019/10/31/Vue.js%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>Vue是一个 MVVM 的框架，数据驱动和 组件化是Vue的核心思想。</p>
<p>简单的讲MVVM框架就是：我们只需要在数据层做数据操作，显示层会检测到我们每次的数据变化，然后做出相应的改变，监测数据这个工作就是中间的ViewModel。通<br>过这种模式，我们就可以不用再直接操作DOM节点来进行数据的改变。</p>
<h4 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h4><p>在模板里可以实现data数据的展示，如果data数据改变，展示的数据也会响应式的改变。响应式的改变意味着我们不需要强制刷新页面就可以实现数据的变化。这种语法为请输入代码Mustache语法</p>
<pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;</span><br><span class="line">         &lt;h3&gt;这里是title的值：&#123;&#123;title&#125;&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">    name:'phonerisk',</span></span><br><span class="line"><span class="regexp">    data()&#123;</span></span><br><span class="line"><span class="regexp">        return&#123;</span></span><br><span class="line"><span class="regexp">            title:'testTitle'</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">1234567891011121314</span></span><br></pre>

<h4 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h4><p>v-html可以将一段HTML的代码字符串输出成HTML片段而不是普通的文本</p>
<pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;</span><br><span class="line">        &lt;p &gt;这里是&lt;span v-html=<span class="string">'html'</span>&gt;&lt;<span class="regexp">/span&gt;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name:<span class="string">'phonerisk'</span>,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            html:<span class="string">'&lt;span style="color:blue;font-size:23px;"&gt;v-if&lt;/span&gt;'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre>

<h3 id="方法事件"><a href="#方法事件" class="headerlink" title="方法事件"></a>方法事件</h3><h4 id="v-bind-在事件里绑定方法"><a href="#v-bind-在事件里绑定方法" class="headerlink" title="v-bind 在事件里绑定方法"></a>v-bind 在事件里绑定方法</h4><p>Mustache·语法不能用于HTML上，所以我们需要绑定一些属之类的需要使用v-bind。v-bind就是将data里面的数据绑定到HTML上面，从而实现属性的变化。</p>
<pre class="highlight"><span class="line"><span class="string">"v-bind:"</span> 缩写--&gt; <span class="string">":"</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;</span><br><span class="line">        &lt;img :src=<span class="string">"imgUrl"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name:<span class="string">'phonerisk'</span>,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">             imgUrl:<span class="string">"../../static/img/KFC.e66b2f8e.png"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre>

<h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><p>v-model是用于表单输入的数据双向绑定。所谓双向绑定就是视图层的数据变化会引起数据层数据的改变，相反的，数据层的变化也会导致视图层展示数据的变化。</p>
<pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"text"</span> v-model=<span class="string">"name"</span>&gt;</span><br><span class="line">        &#123;&#123;name&#125;&#125;</span><br><span class="line">        &lt;button @click=<span class="string">'changeName'</span>&gt;改变名字&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">    name:'phonerisk',</span></span><br><span class="line"><span class="regexp">    data()&#123;</span></span><br><span class="line"><span class="regexp">        return&#123;</span></span><br><span class="line"><span class="regexp">            name:'小明'</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    methods:&#123;</span></span><br><span class="line"><span class="regexp">        changeName()&#123;</span></span><br><span class="line"><span class="regexp">            this.name = "小花";</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">123456789101112131415161718192021</span></span><br></pre>

<h4 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h4><p>v-on 用于监听DOM事件，如按钮的点击事件、双击事件等。v-on 的简写为 @,如下面的 @click 就等价为 v-on:click。</p>
<pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button @click=<span class="string">'yes'</span>&gt;你敢点我吗？&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">    name:'phonerisk',</span></span><br><span class="line"><span class="regexp">    data()&#123;</span></span><br><span class="line"><span class="regexp">        return&#123;</span></span><br><span class="line"><span class="regexp">            name:''</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">	methods:&#123;</span></span><br><span class="line"><span class="regexp">        yes()&#123;</span></span><br><span class="line"><span class="regexp">            alert("我有啥不敢的！！！");   /</span><span class="regexp">/ alert 是弹出的小窗口</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">1234567891011121314151617181920</span></span><br></pre>

<h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        </span><br><span class="line">       &lt;form action=<span class="string">""</span> @submit.prevent=<span class="string">'yzbd'</span>&gt;</span><br><span class="line">           &lt;input type=<span class="string">"text"</span> name=<span class="string">'name'</span> v-model=<span class="string">'user'</span>&gt;</span><br><span class="line">           &lt;input type=<span class="string">"password"</span> name=<span class="string">'pwd'</span> v-model=<span class="string">'pwd'</span>&gt;</span><br><span class="line">           &lt;button&gt;登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        &lt;/</span>form&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> vm =<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#app"</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        user:<span class="string">''</span>,</span><br><span class="line">        pwd:<span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        yzbd:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.user==<span class="string">''</span>)&#123;</span><br><span class="line">                  alert(<span class="string">'你不要拿空的表单来骗人，不输用户不叫你进来'</span>);                  </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.user==<span class="string">'zhangsan'</span> &amp;&amp; <span class="keyword">this</span>.pwd==<span class="string">'12345'</span>)&#123;</span><br><span class="line">                    alert(<span class="string">'欢迎你回来，zhangsan'</span>)</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        alert(<span class="string">'请输入正确的用户名或密码'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">1234567891011121314151617181920212223242526272829303132333435</span></span><br></pre>

<p>其他事件修饰符举例</p>
<pre class="highlight"><span class="line">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="line">&lt;a v-on:click.stop=<span class="string">"doThis"</span>&gt;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/</span>form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent=<span class="string">"doThat"</span>&gt;&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;form v-on:submit.prevent&gt;&lt;/</span>form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span><br><span class="line">&lt;div v-on:click.capture=<span class="string">"doThis"</span>&gt;...&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="regexp">&lt;div v-on:click.self="doThat"&gt;...&lt;/</span>div&gt;</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre>

<h4 id="按键码"><a href="#按键码" class="headerlink" title="按键码"></a>按键码</h4><pre class="highlight"><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        </span><br><span class="line">       &lt;form action=<span class="string">""</span> @submit.prevent=<span class="string">'yzbd'</span>&gt;</span><br><span class="line">            &lt;input type=<span class="string">"text"</span> v-on:keyup.enter=<span class="string">'yzbd'</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">var vm =new Vue(&#123;</span></span><br><span class="line"><span class="regexp">    el:"#app",</span></span><br><span class="line"><span class="regexp">    data:&#123;</span></span><br><span class="line"><span class="regexp">        user:'',</span></span><br><span class="line"><span class="regexp">        pwd:''</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    methods: &#123;</span></span><br><span class="line"><span class="regexp">        yzbd:function()&#123;</span></span><br><span class="line"><span class="regexp">            alert('你按回车了');</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre>

<p>其它按键码：</p>
<pre class="highlight"><span class="line">.enter</span><br><span class="line">.tab</span><br><span class="line">.delete</span><br><span class="line">.esc</span><br><span class="line">.space</span><br><span class="line">.up</span><br><span class="line">.down</span><br><span class="line">.left</span><br><span class="line">.right</span><br><span class="line"><span class="number">123456789</span></span><br></pre>



<h4 id="v-if-条件渲染"><a href="#v-if-条件渲染" class="headerlink" title="v-if 条件渲染"></a>v-if 条件渲染</h4><p>v-if用于做条件化的渲染，当组件的判断条件发生改变，这个组件会被销毁并重建。</p>
<pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;</span><br><span class="line">    &lt;span v-<span class="keyword">if</span>=<span class="string">"display"</span>&gt;我叫<span class="number">001</span>&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span v-if="!display"&gt;我叫002&lt;/</span>span&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"changeShow"</span>&gt;切换&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">javascript</span></span><br><span class="line"><span class="regexp">    data()&#123;</span></span><br><span class="line"><span class="regexp">        return&#123;</span></span><br><span class="line"><span class="regexp">            display:true</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    methods:&#123;</span></span><br><span class="line"><span class="regexp">        changeShow()&#123;</span></span><br><span class="line"><span class="regexp">          this.display = !this.display;</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">12345678910111213141516171819</span></span><br></pre>

<h4 id="v-if-v-else"><a href="#v-if-v-else" class="headerlink" title="v-if v-else"></a>v-if v-else</h4><pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">	    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">	        &lt;div v-<span class="keyword">if</span>=<span class="string">'Math.random()&gt;0.5'</span>&gt;</span><br><span class="line">	            you can see me!</span><br><span class="line">	        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">	        &lt;div v-else&gt;</span></span><br><span class="line"><span class="regexp">	            now,you can't see me!</span></span><br><span class="line"><span class="regexp">	        &lt;/</span>div&gt;</span><br><span class="line">	    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    var vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">        el: '#app',</span></span><br><span class="line"><span class="regexp">        data: &#123;</span></span><br><span class="line"><span class="regexp">         ok:true</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">    &#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre>

<h4 id="v-if-v-else-if-v-else"><a href="#v-if-v-else-if-v-else" class="headerlink" title="v-if v-else-if v-else"></a>v-if v-else-if v-else</h4><pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;div v-<span class="keyword">if</span>=<span class="string">'name=="XXX"'</span>&gt;</span><br><span class="line">            XXX</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div v-else-if='name=="XXX"'&gt;</span></span><br><span class="line"><span class="regexp">            XXX</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        &lt;div v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">'name=="XXX"'</span>&gt;</span><br><span class="line">           XXX</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div v-else&gt;</span></span><br><span class="line"><span class="regexp">            木有！！！</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    var vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">        el: '#app',</span></span><br><span class="line"><span class="regexp">        data: &#123;</span></span><br><span class="line"><span class="regexp">            name:'XXX'</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">    &#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526</span></span><br></pre>

<h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .tabcss &#123;</span><br><span class="line">            width: <span class="number">100</span>%;</span><br><span class="line">        &#125;</span><br><span class="line">        .tabstyle &#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">        &#125;</span><br><span class="line">        .cur &#123;</span><br><span class="line">            background: cornsilk;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">       &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">'tabcss'</span>&gt;</span><br><span class="line">            &lt;div id=<span class="string">"tab1"</span> @click=<span class="string">'tabid=0'</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">'tabstyle'</span> v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123;'cur':tabid==0&#125;"</span>&gt;标签<span class="number">1</span>&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div id="tab2"@click='tabid=1'  class='tabstyle' v-bind:class="&#123;'cur':tabid==1&#125;"&gt;标签2&lt;/</span>div&gt;</span><br><span class="line">       &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">       &lt;div class='box'&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div v-show='tabid==0'&gt;</span></span><br><span class="line"><span class="regexp">                标签1里的内容</span></span><br><span class="line"><span class="regexp">                Lorem, ipsum dolor sit amet consectetur adipisicing elit. Sunt eius quo ab, quasi, dolorem asperiores ratione odit placeat iusto nostrum deleniti non. Quis, tenetur! Quam nisi voluptatum ipsa. Dolor, qui!</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">            &lt;div v-show=<span class="string">"tabid==1"</span>&gt;</span><br><span class="line">                    标签<span class="number">2</span>里的内容</span><br><span class="line">                Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dolor eligendi dolorum cum sapiente sed quae accusamus odit! Deleniti ducimus perferendis temporibus sint, consequatur ipsa commodi! Possimus, nobis. Cumque, unde placeat?</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    var vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">        el: '#app',</span></span><br><span class="line"><span class="regexp">        data: &#123;</span></span><br><span class="line"><span class="regexp">            tabid:0,</span></span><br><span class="line"><span class="regexp">            ok:true,</span></span><br><span class="line"><span class="regexp">            name:'XXX'</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">    &#125;);</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 安装 及简单使用，详细介绍</title>
    <url>/2019/10/26/Vue.js%20%E5%AE%89%E8%A3%85%20%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>准备 Vue.js 之前要先有 node.js。</p>
<ul>
<li><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node.js 安装网址：https://nodejs.org/en/download/。</a></li>
<li>具体安装步骤参考：<a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-install-setup.html</a></li>
</ul>
<h5 id="vue-js-有著名的全家桶系列"><a href="#vue-js-有著名的全家桶系列" class="headerlink" title="vue.js 有著名的全家桶系列"></a>vue.js 有著名的全家桶系列</h5><pre class="highlight"><span class="line">包含了vue-router，vuex， vue-resource，</span><br><span class="line">再加上构建工具vue-cli，就是一个完整的vue项目的核心构成。</span><br><span class="line"><span class="number">12</span></span><br></pre>

<p>安装好后，就要</p>
<h4 id="安装-Vue-js了。"><a href="#安装-Vue-js了。" class="headerlink" title="安装 Vue.js了。"></a>安装 Vue.js了。</h4><ol>
<li><p>安装node.js，安装完node.js之后，npm也会自动安装</p>
<p>查询是否安装成功的命令：</p>
<pre class="highlight"><span class="line">node -v</span><br><span class="line"></span><br><span class="line">npm -v</span><br><span class="line"><span class="number">123</span></span><br></pre>

<p><img src="https://img-blog.csdnimg.cn/20200411235915961.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200411235915961.png" class="lozad post-image"></p>
</li>
<li><p>全局安装脚手架工具vue-cli，命令如下：</p>
<pre class="highlight"><span class="line">npm install --global vue-cli</span><br><span class="line"><span class="number">1</span></span><br></pre>

<p><img src="https://img-blog.csdnimg.cn/20200411235949844.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200411235949844.png" class="lozad post-image"></p>
</li>
<li><p>vue项目初始化命令如下，若没有安装webpack，则先安装webpack</p>
<pre class="highlight"><span class="line">npm install -g webpack   <span class="comment">// 安装 webpack</span></span><br><span class="line">npm cache clean --force    <span class="comment">// 清除 npm 缓存</span></span><br><span class="line"><span class="number">12</span></span><br></pre>

<p>项目</p>
<pre class="highlight"><span class="line">vue init webpack myVue <span class="comment">// myVue 项目名称</span></span><br><span class="line"></span><br><span class="line">project name（项目名称）  按回车</span><br><span class="line"></span><br><span class="line">project description（项目描述） 按回车</span><br><span class="line"></span><br><span class="line">author（作者） 按回车</span><br><span class="line"></span><br><span class="line">vue build（解释器） 按回车</span><br><span class="line"></span><br><span class="line">Install vue-router(路由) 按y按回车</span><br><span class="line"></span><br><span class="line">use aslantto lint your code(代码检查) 按n按回车</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> up unit tests(测试模块) 按n按回车</span><br><span class="line"></span><br><span class="line">setup e2e tests with night watch(是否安装e2e) 按n按回车</span><br><span class="line"></span><br><span class="line">should we run ’npm install’(是否选择npm方式)选第一个，按回车</span><br><span class="line">12345678910111213141516171819</span><br></pre>
</li>
</ol>
<ul>
<li>初始化完成后的vue项目目录如下：<br><img src="https://img-blog.csdnimg.cn/20200412000103875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200412000103875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></li>
</ul>
<ol>
<li><p>进入到myVue目录下，使用npm install 安装package.json包中的依赖</p>
<p>命令如下：</p>
<pre class="highlight"><span class="line">cd myVue</span><br><span class="line"></span><br><span class="line">npm install</span><br><span class="line"><span class="number">123</span></span><br></pre>

<p><img src="https://img-blog.csdnimg.cn/20200412000138705.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200412000138705.png" class="lozad post-image"></p>
</li>
<li><p>运行项目：</p>
<pre class="highlight"><span class="line">npm run dev</span><br><span class="line"><span class="number">1</span></span><br></pre>

<p><img src="https://img-blog.csdnimg.cn/20200412000238169.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200412000238169.png" class="lozad post-image"><br><img src="https://img-blog.csdnimg.cn/202004120002437.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/202004120002437.png" class="lozad post-image"><br>在浏览器上输入：localhost:8080，将会出现下面的vue初始页面：</p>
<p><img src="https://img-blog.csdnimg.cn/20200412000307779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200412000307779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
<li><p>结束项目运行：</p>
<p>ctrl+c，选择Y即可停止项目的运行</p>
<p><img src="https://img-blog.csdnimg.cn/20200412000340614.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200412000340614.png" class="lozad post-image"></p>
</li>
</ol>
<h4 id="二、vue项目目录说明"><a href="#二、vue项目目录说明" class="headerlink" title="二、vue项目目录说明"></a>二、vue项目目录说明</h4><p><img src="https://img-blog.csdnimg.cn/20200412000449449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200412000449449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>build</td>
<td>项目构建(webpack)相关代码</td>
</tr>
<tr>
<td>config</td>
<td>配置目录，包括端口号等</td>
</tr>
<tr>
<td>node_modules</td>
<td>npm加载的项目依赖块</td>
</tr>
<tr>
<td>src</td>
<td>这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：</td>
</tr>
<tr>
<td>assets</td>
<td>放置一些图片，如logo等</td>
</tr>
<tr>
<td>components</td>
<td>该目录里存放的我们的开发文件组件，主要的开发文件都存放在这里了</td>
</tr>
<tr>
<td>App.vue</td>
<td>项目入口文件</td>
</tr>
<tr>
<td>main.js</td>
<td>项目的核心文件</td>
</tr>
<tr>
<td>router</td>
<td>路由配置目录</td>
</tr>
<tr>
<td>static</td>
<td>放置一些静态资源文件</td>
</tr>
<tr>
<td>test</td>
<td>初始测试目录，可删除</td>
</tr>
<tr>
<td>.xxxx文件</td>
<td>这些是一些配置文件，包括语法配置，git配置等</td>
</tr>
<tr>
<td>index.html</td>
<td>首页入口文件</td>
</tr>
<tr>
<td>package.json</td>
<td>项目配置文件</td>
</tr>
<tr>
<td>README.md</td>
<td>项目的说明文档，markdown 格式</td>
</tr>
</tbody></table>
<h4 id="三、vue项目启动流程"><a href="#三、vue项目启动流程" class="headerlink" title="三、vue项目启动流程"></a>三、vue项目启动流程</h4><ol>
<li><p>在执行npm run dev的时候，会去在当前文件夹下的项目中找package.json文件,启动开发服务器，默认端口是8080；</p>
<p><img src="https://img-blog.csdnimg.cn/2020041200065713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/2020041200065713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
<li><p>找到src的main.js文件，在该文件中new Vue的实例，要加载的模板内容App；</p>
<p><img src="https://img-blog.csdnimg.cn/20200412000711982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200412000711982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
<li><p>App是src目录下的App.vue结尾的文件；</p>
<p><img src="https://img-blog.csdnimg.cn/20200412000733581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200412000733581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
<li><p>在App.vue所对应的模板当中，有一个router-view在src目录下有一个router文件夹，该文件夹有个index.js文件，该文件是配置路由词典，指定了路由地址是空，加载HelloWorld组件</p>
<p><img src="https://img-blog.csdnimg.cn/20200412000749870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200412000749870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
</ol>
<pre class="highlight"><span class="line">注：刚才也说过了，vue运行是基于node环境的，所以 构建vue框架之前，一定要确保node环境安装成功</span><br></pre>

<h4 id="四、Vue的组件的使用"><a href="#四、Vue的组件的使用" class="headerlink" title="四、Vue的组件的使用"></a>四、Vue的组件的使用</h4><ol>
<li><p>在<code>components</code>文件夹下创建.vue结尾的文件</p>
<p>例如在：<code>src/components/public/</code> 目录下新建 <code>header.vue</code> 文件</p>
<p><img src="https://img-blog.csdnimg.cn/20200412000900707.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200412000900707.png" class="lozad post-image"></p>
<p>header.vue文件内容如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200412000915989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200412000915989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
<li><p>在路由配置文件src/router/index.js中引入组件并配置组件路由</p>
</li>
</ol>
<ul>
<li><p>引入组件</p>
<pre class="highlight"><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'@/components/public/header'</span></span><br><span class="line"><span class="number">1</span></span><br></pre>
</li>
<li><p>配置组件路由</p>
<pre class="highlight"><span class="line">&#123;</span><br><span class="line">	path: <span class="string">'/header'</span>,</span><br><span class="line">	name: <span class="string">'header'</span>,</span><br><span class="line">	component: Header</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre>

<p><img src="https://img-blog.csdnimg.cn/20200412001213759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200412001213759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
</ul>
<ol>
<li><p>运行项目：<code>npm run dev</code></p>
</li>
<li><p>在浏览器中输入：localhost:8080/header ,显示如下页面：</p>
<p><img src="https://img-blog.csdnimg.cn/20200412001242987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200412001242987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
</li>
</ol>
<h3 id="附：vue生命周期示意图"><a href="#附：vue生命周期示意图" class="headerlink" title="附：vue生命周期示意图"></a>附：vue生命周期示意图</h3><p><img src="https://img-blog.csdnimg.cn/20200412001255711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200412001255711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>首页轮播图展示</title>
    <url>/2020/05/09/lbt/</url>
    <content><![CDATA[<p>需求：如果您是超级管理员可以修改轮播图权限，如果你是普通用户则浏览，没有权限，我们将轮播图作为动态浏览，通过前后端分离实现，等一些增删改查操作。</p>
<h4 id="首先我们做添加前端表单提交"><a href="#首先我们做添加前端表单提交" class="headerlink" title="首先我们做添加前端表单提交"></a>首先我们做添加前端表单提交</h4><pre class="highlight"><span class="line">标题：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;title&quot;&gt;</span><br><span class="line">连接：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;link&quot;&gt;</span><br><span class="line">上传图片：&lt;input type&#x3D;&quot;file&quot; @change&#x3D;&quot;addpc&quot;&gt;</span><br></pre>

<h4 id="双向绑定数据"><a href="#双向绑定数据" class="headerlink" title="双向绑定数据"></a>双向绑定数据</h4><pre class="highlight"><span class="line">data()&#123;</span><br><span class="line">	return&#123;</span><br><span class="line">		   &#x2F;&#x2F; 创建展示列表</span><br><span class="line">            carousel_list : [</span><br><span class="line">                &#123;   </span><br><span class="line">                    title:&#39;&#39;,</span><br><span class="line">                    link:&#39;&#39;,</span><br><span class="line">                    image:&#39;&#39;,</span><br><span class="line">                &#125;</span><br><span class="line">            &#x2F;&#x2F; 定义轮播图变量</span><br><span class="line">            title:&#39;&#39;,</span><br><span class="line">            link:&#39;&#39;,</span><br><span class="line">            image:&#39;&#39;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre>

<h4 id="写change方法向后端发起请求"><a href="#写change方法向后端发起请求" class="headerlink" title="写change方法向后端发起请求"></a>写change方法向后端发起请求</h4><pre class="highlight"><span class="line">&#x2F;&#x2F; 向后端发起请求</span><br><span class="line">      addpc:function(e)&#123;</span><br><span class="line">          let data &#x3D; new FormData()</span><br><span class="line">          data.append(&#39;title&#39;,this.title)</span><br><span class="line">          data.append(&#39;link&#39;,this.link)</span><br><span class="line">          data.append(&#39;image&#39;,e.target.files[0])</span><br><span class="line">          &#x2F;&#x2F; 声明上传头部</span><br><span class="line">          let config&#x3D;&#123;</span><br><span class="line">              &#39;Content-Type&#39;:&#39;multipart&#x2F;form-data&#39;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; 发起请求</span><br><span class="line">          this.axios.post(&#39;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;addcarousel&#x2F;&#39;,data,config).then((res&#x3D;&gt;&#123;</span><br><span class="line">              console.log(res)</span><br><span class="line">              this.$Message(res.data.msg)</span><br><span class="line">              &#x2F;&#x2F; 刷新页面</span><br><span class="line">              this.$router.go(0)</span><br><span class="line">          &#125;))</span><br><span class="line">      &#125;</span><br></pre>

<h4 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h4><pre class="highlight"><span class="line">第一步：</span><br><span class="line">&#x2F;&#x2F; 导入</span><br><span class="line">import carouselin from &#39;@&#x2F;components&#x2F;carouselin&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;配置路由</span><br><span class="line">      &#123;</span><br><span class="line">        path:&#39;&#x2F;carouselin&#39;,</span><br><span class="line">        name:&#39;carouselin&#39;,</span><br><span class="line">        component:carouselin,</span><br><span class="line">        beforeEnter:(to,from,next) &#x3D;&gt;&#123;</span><br><span class="line">          if (localStorage.getItem(&#39;type&#39;) &#x3D;&#x3D; 1)&#123;</span><br><span class="line">            console.log(&#39;欢迎超级管理员&#39;)</span><br><span class="line">            next();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          console.log(&#39;普通用户&#39;)</span><br><span class="line">          next(&#39;&#x2F;&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path:&#39;&#x2F;upcarousel&#39;,</span><br><span class="line">        name:&#39;upcarousel&#39;,</span><br><span class="line">        component:upcarousel,</span><br><span class="line">        beforeEnter:(to,from,next) &#x3D;&gt;&#123;</span><br><span class="line">          if (localStorage.getItem(&#39;type&#39;) &#x3D;&#x3D; 1)&#123;</span><br><span class="line">            console.log(&#39;您有修改权限&#39;)</span><br><span class="line">            next();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">          console.log(&#39;普您没有修改权限&#39;)</span><br><span class="line">          next(&#39;&#x2F;&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br></pre>

<p>注：在这里我们使用拦截器方法实现您不是超级管理员则没有权限操作跳转到轮播图修改，这个操作也很简单在您login页面登陆成功之后，将用户类型存入localstorage中，访问后台接口，前端获取他的类型存入localstorage，之后我们可以判断用户类型。</p>
<p>1 首先判断myheader头部，如果是超级管理，我们则给您跳转轮播图修改页面，普通用户则没有。</p>
<pre class="highlight"><span class="line">&#x2F;&#x2F; 在您的methods方法中</span><br><span class="line">	data()&#123;</span><br><span class="line">		return&#123;</span><br><span class="line">			guanliyuan:0 &#x2F;&#x2F;默认是普通用户</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		&#x2F;&#x2F; 判断管理员</span><br><span class="line">		ifget:function()&#123;</span><br><span class="line">			&#x2F;&#x2F; 首先判断用户是否注册管理员 如果没有则默认普通用户</span><br><span class="line">			var guanliyuan &#x3D; localStorage.getItem(&quot;type&quot;)</span><br><span class="line">			if (guanliyuan &#x3D;&#x3D; &#39;&#39;)&#123;</span><br><span class="line">				this.guanliyuan.locale &#x3D; 0</span><br><span class="line">				this.guanliyuan &#x3D; 0</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				if(guanliyuan &#x3D;&#x3D; 1)&#123;</span><br><span class="line">					this.guanliyuan &#x3D; 1</span><br><span class="line">				&#125;else&#123;</span><br><span class="line">					this.guanliyuan &#x3D; 0</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre>

<p>2 在template中判断</p>
<pre class="highlight"><span class="line">&lt;div v-if&#x3D;&quot;guanliyuan &#x3D;&#x3D; 1&quot;&gt;</span><br><span class="line">	&lt;Button&gt;</span><br><span class="line">	&lt;router-link to&#x3D;&#39;carouselin&#39;&gt;跳转操作轮播图&lt;&#x2F;router-link&gt;</span><br><span class="line">	&lt;&#x2F;Button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre>

<p>这样就OK了！</p>
<h4 id="下来后端我们创建个轮播图库"><a href="#下来后端我们创建个轮播图库" class="headerlink" title="下来后端我们创建个轮播图库"></a>下来后端我们创建个轮播图库</h4><pre class="highlight"><span class="line"><span class="comment"># 轮播图 Base基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Carousel</span><span class="params">(Base)</span>:</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    link = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    image = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">	<span class="comment"># 声明表名</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'carousel'</span></span><br></pre>

<h4 id="创建OK之后我们写类视图添加方法"><a href="#创建OK之后我们写类视图添加方法" class="headerlink" title="创建OK之后我们写类视图添加方法"></a>创建OK之后我们写类视图添加方法</h4><pre class="highlight"><span class="line"><span class="comment"># 添加轮播图接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACarousel</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment"># 获取数据</span></span><br><span class="line">        title = request.POST.get(<span class="string">'title'</span>,<span class="literal">None</span>)</span><br><span class="line">        link = request.POST.get(<span class="string">'link'</span>,<span class="literal">None</span>)</span><br><span class="line">        image = request.FILES.get(<span class="string">'image'</span>)</span><br><span class="line">        print(title)</span><br><span class="line">        <span class="comment"># 排重</span></span><br><span class="line">        carousel = Carousel.objects.filter(title=title).first()</span><br><span class="line">        <span class="keyword">if</span> carousel:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">"code"</span>:<span class="number">404</span>,<span class="string">'msg'</span>:<span class="string">'轮播图已存在'</span>&#125;)</span><br><span class="line">        carousel = Carousel(title=title,link=link,image=<span class="string">'http://localhost:8000/static/upload/'</span>+ image.name)</span><br><span class="line">        carousel.save()</span><br><span class="line">        <span class="comment"># 建立文件流 存入本地</span></span><br><span class="line">        <span class="keyword">with</span> open(os.path.join(UPLOAD_ROOT,<span class="string">''</span>,image.name),<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> chunk <span class="keyword">in</span> image.chunks():</span><br><span class="line">                f.write(chunk)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>:<span class="number">200</span>,<span class="string">'msg'</span>:<span class="string">'成功'</span>&#125;)</span><br></pre>

<p>注：获取数据名，一定和前端传来的数据温和，否则为None。</p>
<h4 id="urls配置路由"><a href="#urls配置路由" class="headerlink" title="urls配置路由"></a>urls配置路由</h4><pre class="highlight"><span class="line">// 首先导入类视图</span><br><span class="line">	// 之后配置路由</span><br><span class="line">    path(<span class="string">'getcarousel/'</span>,GetCarousel.as_view()), // 展示</span><br><span class="line">    path(<span class="string">'addcarousel/'</span>,ACarousel.as_view()),  // 添加</span><br><span class="line">    path(<span class="string">'delcarousel/'</span>,DelCarousel.as_view()), // 删除</span><br><span class="line">    path(<span class="string">'upcarousel/'</span>,Upcarousel.as_view())  // 修改</span><br></pre>

<h4 id="展示操作"><a href="#展示操作" class="headerlink" title="展示操作"></a>展示操作</h4><p>下面我们做的是展示，在做删除修改操作，首先我们想到的是将用户的id传到后台进行删改操作，所以我们在前端从数据库中获取数据展示轮播图。</p>
<p>1.请求后台轮播图接口</p>
<pre class="highlight"><span class="line">&#x2F;&#x2F; 请求轮播图接口</span><br><span class="line">      get_carousel:function()&#123;</span><br><span class="line">          this.axios.get(&#39;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;getcarousel&#x2F;&#39;).then((res&#x3D;&gt;&#123;</span><br><span class="line">              &#x2F;&#x2F; console.log(res)</span><br><span class="line">              &#x2F;&#x2F; 创建容器</span><br><span class="line">              var mylist&#x3D;[]</span><br><span class="line">              &#x2F;&#x2F; 遍历轮播图数组</span><br><span class="line">              for(let i&#x3D;0;i&lt;res.data.length;i++)&#123;</span><br><span class="line">                  console.log(res.data[i])</span><br><span class="line">                  &#x2F;&#x2F; 进行赋值</span><br><span class="line">                  mylist.push(&#123;title:res.data[i].title,link:res.data[i].link,image:res.data[i].image&#125;)</span><br><span class="line">                  this.carousel_list &#x3D; mylist</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;))</span><br><span class="line">      &#125;</span><br></pre>

<p>2 后台类视图函数</p>
<pre class="highlight"><span class="line"><span class="comment"># 轮播图后台接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetCarousel</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment"># 读库</span></span><br><span class="line">        carousels = Carousel.objects.all()</span><br><span class="line">        <span class="comment"># 序列化操作</span></span><br><span class="line">        carousels_ser = CarouseSer(carousels,many=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Response(carousels_ser.data)</span><br></pre>

<p>3 回到前段进行展示</p>
<pre class="highlight"><span class="line">&#x2F;&#x2F; 再上门面我们已经定义，接收轮播图列表 carousel_list[]</span><br><span class="line">       &lt;table&gt;</span><br><span class="line">           &lt;tr&gt;</span><br><span class="line">               &lt;td&gt;标题&lt;&#x2F;td&gt;</span><br><span class="line">               &lt;td&gt;超链接&lt;&#x2F;td&gt;</span><br><span class="line">               &lt;td&gt;照片&lt;&#x2F;td&gt;</span><br><span class="line">               &lt;td&gt;操作&lt;&#x2F;td&gt;</span><br><span class="line">           &lt;&#x2F;tr&gt;</span><br><span class="line">           &lt;tr v-for&#x3D;&quot;(item,index) in carousel_list&quot;&gt;</span><br><span class="line">               &lt;td&gt;&#123;&#123;index+1&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">               &lt;td&gt;&#123;&#123;item.title&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">               &lt;td&gt;&#123;&#123;item.link&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">               &lt;td&gt;&lt;img :src&#x3D;&quot;item.image&quot; alt&#x3D;&quot;&quot; width&#x3D;&quot;100px&quot; height&#x3D;&quot;100px&quot;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">               &lt;td&gt;</span><br><span class="line">                   &lt;Button @click&#x3D;&quot;delcarousel(item.id)&quot;&gt;删除&lt;&#x2F;Button&gt;</span><br><span class="line">                   &lt;Button @click&#x3D;&quot;upcarousel(item.id)&quot;&gt;修改&lt;&#x2F;Button&gt;</span><br><span class="line">               &lt;&#x2F;td&gt;</span><br><span class="line">           &lt;&#x2F;tr&gt;</span><br><span class="line">       &lt;&#x2F;table&gt;</span><br></pre>

<h4 id="删除轮播图"><a href="#删除轮播图" class="headerlink" title="删除轮播图"></a>删除轮播图</h4><p>1 我们将获取用户id传到方法函数中，将他传给后台进行删除操作</p>
<pre class="highlight"><span class="line">&#x2F;&#x2F; 删除轮播图</span><br><span class="line">       delcarousel:function(uid)&#123;</span><br><span class="line">           &#x2F;&#x2F;请求接口</span><br><span class="line">           this.axios.get(&#39;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;delcarousel&#x2F;&#39;,&#123;params:&#123;id:uid&#125;&#125;).then((res)&#x3D;&gt;&#123;</span><br><span class="line">               </span><br><span class="line">               console.log(uid)</span><br><span class="line"></span><br><span class="line">               this.$Message(res.data.msg)</span><br><span class="line">               &#x2F;&#x2F;刷新页面</span><br><span class="line">               this.$router.go(0)</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;</span><br></pre>

<p>2 后台类视图删除函数</p>
<pre class="highlight"><span class="line"><span class="comment"># 删除轮播图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelCarousel</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#获取id</span></span><br><span class="line">        aid = request.GET.get(<span class="string">"id"</span>,<span class="literal">None</span>)</span><br><span class="line">        print(aid)</span><br><span class="line">        <span class="comment"># 进行删除</span></span><br><span class="line">        carousel = Carousel.objects.filter(id=aid).delete()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> carousel:</span><br><span class="line">                <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>:<span class="number">200</span>,<span class="string">'msg'</span>:<span class="string">'删除成功'</span>&#125;)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>:<span class="number">200</span>,<span class="string">'msg'</span>:e&#125;)</span><br></pre>

<h4 id="修改轮播图"><a href="#修改轮播图" class="headerlink" title="修改轮播图"></a>修改轮播图</h4><p>1 我们给它一个跳转页面，跳转的同时带的您的用户id，也就是带参跳转。</p>
<pre class="highlight"><span class="line">&#x2F;&#x2F;跳转修改页面</span><br><span class="line">     upcarousel:function(id)&#123;</span><br><span class="line">         this.$router.push(&#123;&#39;path&#39;:&#39;&#x2F;upcarousel&#39;,query:&#123;id:id&#125;&#125;)</span><br><span class="line">     &#125;</span><br></pre>

<p>2 我们创建upcarousel修页面</p>
<pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;myheader&gt;&lt;&#x2F;myheader&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">          标题：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;title&quot;&gt;</span><br><span class="line">          连接：&lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;link&quot;&gt;</span><br><span class="line">          上传图片：&lt;input type&#x3D;&quot;file&quot; @change&#x3D;&quot;addpc&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">import myheader from &#39;.&#x2F;myheader&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">        &#x2F;&#x2F; 定义轮播图变量</span><br><span class="line">        title:&#39;&#39;,</span><br><span class="line">        link:&#39;&#39;,</span><br><span class="line">        image:&#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    &#x2F;&#x2F; 注册组件标签</span><br><span class="line">    components:&#123;</span><br><span class="line">        &#39;myheader&#39;:myheader</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted:function()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123; </span><br><span class="line">        &#x2F;&#x2F; 向后端发起请求</span><br><span class="line">        addpc:function(e)&#123;</span><br><span class="line">            let data &#x3D; new FormData()</span><br><span class="line">            &#x2F;&#x2F; 接收id</span><br><span class="line">            data.append(&#39;id&#39;,this.$route.query.id)</span><br><span class="line">            data.append(&#39;title&#39;,this.title)</span><br><span class="line">            data.append(&#39;link&#39;,this.link)</span><br><span class="line">            data.append(&#39;image&#39;,e.target.files[0])</span><br><span class="line">            &#x2F;&#x2F; 声明上传头部</span><br><span class="line">            let config&#x3D;&#123;</span><br><span class="line">                &#39;Content-Type&#39;:&#39;multipart&#x2F;form-data&#39;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 发起请求</span><br><span class="line">            this.axios.post(&#39;http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;upcarousel&#x2F;&#39;,data,config).then((res&#x3D;&gt;&#123;</span><br><span class="line">                console.log(this.$route.query.id)</span><br><span class="line">                this.$Message(res.data.msg)</span><br><span class="line">                &#x2F;&#x2F; 刷新页面</span><br><span class="line">                this.$router.go(0)</span><br><span class="line">            &#125;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre>

<p>注：逻辑跟您添加页面一致，只不过传个id给后台</p>
<p>3 后台创建类视图修改函数</p>
<pre class="highlight"><span class="line"><span class="comment">#修改轮播图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Upcarousel</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#接收参数</span></span><br><span class="line">        aid = request.POST.get(<span class="string">'id'</span>,<span class="literal">None</span>)</span><br><span class="line">        print(aid)</span><br><span class="line">        title = request.POST.get(<span class="string">'title'</span>,<span class="literal">None</span>)</span><br><span class="line">        link = request.POST.get(<span class="string">'link'</span>,<span class="literal">None</span>)</span><br><span class="line">        image = request.FILES.get(<span class="string">'image'</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#过滤查询</span></span><br><span class="line">        carousel = Carousel.objects.filter(id=aid).first()</span><br><span class="line">        <span class="keyword">if</span> carousel:</span><br><span class="line">            <span class="comment"># 建立文件流 存入本地</span></span><br><span class="line">            <span class="keyword">with</span> open(os.path.join(UPLOAD_ROOT,<span class="string">''</span>,image.name),<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="keyword">for</span> chunk <span class="keyword">in</span> image.chunks():</span><br><span class="line">                    f.write(chunk)</span><br><span class="line">            <span class="comment">#重新入库</span></span><br><span class="line">            carousel.title = title</span><br><span class="line">            carousel.link = link</span><br><span class="line">            carousel.image = <span class="string">'http://localhost:8000/static/upload/'</span>+image.name</span><br><span class="line">            carousel.save()</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>:<span class="number">200</span>,<span class="string">'msg'</span>:<span class="string">'修改成功'</span>&#125;)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>:<span class="number">400</span>,<span class="string">'msg'</span>:<span class="string">'修改失败'</span>&#125;)</span><br></pre>

<h4 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h4>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>scrapy框架（1）</title>
    <url>/2019/06/12/scrapy%E6%A1%86%E6%9E%B6%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1-scrapy安装与环境依赖"><a href="#1-scrapy安装与环境依赖" class="headerlink" title="1.scrapy安装与环境依赖"></a>1.scrapy安装与环境依赖</h2><p>在安装scrapy前需要安装好相应的依赖库, 再安装scrapy, 具体安装步骤如下:</p>
<h4 id="1-安装lxml库"><a href="#1-安装lxml库" class="headerlink" title="(1).安装lxml库"></a>(1).安装lxml库</h4><pre class="highlight"><span class="line">pip install lxml</span><br></pre>
<h4 id="2-安装wheel"><a href="#2-安装wheel" class="headerlink" title="(2).安装wheel"></a>(2).安装wheel</h4><pre class="highlight"><span class="line">pip install wheel</span><br></pre>
<h4 id="3-安装twisted"><a href="#3-安装twisted" class="headerlink" title="(3).安装twisted"></a>(3).安装twisted</h4><pre class="highlight"><span class="line">pip install twisted文件路径</span><br></pre>
<pre class="highlight"><span class="line">(twisted需下载后本地安装,下载地址:http:&#x2F;&#x2F;www.lfd.uci.edu&#x2F;~gohlke&#x2F;pythonlibs&#x2F;#twisted)</span><br><span class="line">    (版本选择如下图,版本后面有解释,请根据自己实际选择)</span><br></pre>
<p><img src="/hugoblog/twisted.png" alt="twisted" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/twisted.png" class="lozad post-image"></p>
<h4 id="4-安装pywin32"><a href="#4-安装pywin32" class="headerlink" title="(4).安装pywin32"></a>(4).安装pywin32</h4><pre class="highlight"><span class="line">pip install pywin32</span><br></pre>
<h4 id="5-安装scrapy"><a href="#5-安装scrapy" class="headerlink" title="(5).安装scrapy"></a>(5).安装scrapy</h4><pre class="highlight"><span class="line">pip install scrapy</span><br></pre>
<h4 id="6-成功验证"><a href="#6-成功验证" class="headerlink" title="(6).成功验证"></a>(6).成功验证</h4><pre class="highlight"><span class="line">在cmd命令行输入scrapy,显示Scrapy1.6.0-no active project,证明安装成功</span><br></pre>
<hr>
<h2 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2.创建项目"></a>2.创建项目</h2><pre class="highlight"><span class="line">1.手动创建一个目录test</span><br><span class="line">2.在test文件夹下创建爬虫项目为spiderpro: scrapy startproject spiderpro</span><br><span class="line">3.进入项目文件夹: cd spiderpro</span><br><span class="line">4.创建爬虫文件: scrapy genspider 爬虫名 域名</span><br></pre>
<hr>
<h2 id="3-项目目录介绍"><a href="#3-项目目录介绍" class="headerlink" title="3.项目目录介绍"></a>3.项目目录介绍</h2><pre class="highlight"><span class="line">spiderpro</span><br><span class="line">　　spiderpro # 项目目录</span><br><span class="line">　　　　__init__</span><br><span class="line">　　　　spiders:爬虫文件目录</span><br><span class="line">　　　　　　__init__</span><br><span class="line">　　　　　　tests.py:爬虫文件</span><br><span class="line">　　　　items.py:定义爬取数据持久化的数据结构</span><br><span class="line">　　　　middlewares.py:定义中间件</span><br><span class="line">　　　　pipelines.py:管道,持久化存储相关</span><br><span class="line">　　　　settings.py:配置文件</span><br><span class="line">　　venv:虚拟环境目录</span><br><span class="line">　 scrapy.cfg: scrapy项目配置文件</span><br></pre>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre class="highlight"><span class="line">(1).spiders:其内包含一个个Spider的实现, 每个Spider是一个单独的文件</span><br><span class="line">　　(2).items.py:它定义了Item数据结构, 爬取到的数据存储为哪些字段</span><br><span class="line">　　(3).pipelines.py:它定义Item Pipeline的实现</span><br><span class="line">　　(4).settings.py:项目的全局配置</span><br><span class="line">　　(5).middlewares.py:定义中间件, 包括爬虫中间件和下载中间件</span><br><span class="line">　　(6).scrapy.cfg:它是scrapy项目的配置文件, 其内定义了项目的配置路径, 部署相关的信息等</span><br></pre>
<hr>
<h2 id="4-scrapy框架介绍-5大核心组件与数据流向"><a href="#4-scrapy框架介绍-5大核心组件与数据流向" class="headerlink" title="4.scrapy框架介绍: 5大核心组件与数据流向"></a>4.scrapy框架介绍: 5大核心组件与数据流向</h2><p><img src="/hugoblog/scrapy.png" alt="scrapy" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/scrapy.png" class="lozad post-image"></p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构:"></a>架构:</h3><pre class="highlight"><span class="line">Scrapy Engine: 这是引擎，负责Spiders、ItemPipeline,Downloader、Scheduler中间的通讯，信号、数据传递等等!</span><br><span class="line"></span><br><span class="line">　　Scheduler(调度器): 它负责接受引擎发送过来的requests请求，并按照一定的方式进行整理排列，入队、并等待Scrapy Engine(引擎)来请求时，交给引擎。</span><br><span class="line"></span><br><span class="line">　　Downloader（下载器)：负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spiders来处理，</span><br><span class="line"></span><br><span class="line">　　Spiders：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器)，</span><br><span class="line"></span><br><span class="line">　　Item Pipeline：它负责处理Spiders中获取到的Item，并进行处理，比如去重，持久化存储（存数据库，写入文件，总之就是保存数据用的）</span><br><span class="line"></span><br><span class="line">　　Downloader Middlewares(下载中间件)：你可以当作是一个可以自定义扩展下载功能的组件</span><br><span class="line"></span><br><span class="line">　　Spider Middlewares(Spider中间件)：你可以理解为是一个可以自定扩展和操作引擎和Spiders中间‘通信‘的功能组件（比如进入Spiders的Responses;和从Spiders出去的Requests）</span><br></pre>
<hr>
<h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流:"></a>工作流:</h3><pre class="highlight"><span class="line">1.spider将请求发送给引擎, 引擎将request发送给调度器进行请求调度</span><br><span class="line"></span><br><span class="line">　　2.调度器把接下来要请求的request发送给引擎, 引擎传递给下载器, 中间会途径下载中间件</span><br><span class="line"></span><br><span class="line">　　3.下载携带request访问服务器, 并将爬取内容response返回给引擎, 引擎将response返回给spider</span><br><span class="line"></span><br><span class="line">　　4.spider将response传递给自己的parse进行数据解析处理及构建item一系列的工作, 最后将item返回给引擎, 引擎传递个pipeline</span><br><span class="line"></span><br><span class="line">　　5.pipe获取到item后进行数据持久化</span><br><span class="line"></span><br><span class="line">　　6.以上过程不断循环直至爬虫程序终止</span><br></pre>
<hr>
<h2 id="5-使用scrapy框架爬取糗百"><a href="#5-使用scrapy框架爬取糗百" class="headerlink" title="5.使用scrapy框架爬取糗百"></a>5.使用scrapy框架爬取糗百</h2><h4 id="需求-爬取糗事百科热门板块-每一条的标题-好笑-评论条数及作者信息-解析爬取的信息数据-定制item数据存储结构-最终将数据存储于MongoDB数据库中"><a href="#需求-爬取糗事百科热门板块-每一条的标题-好笑-评论条数及作者信息-解析爬取的信息数据-定制item数据存储结构-最终将数据存储于MongoDB数据库中" class="headerlink" title="需求: 爬取糗事百科热门板块,每一条的标题,好笑,评论条数及作者信息,解析爬取的信息数据,定制item数据存储结构,最终将数据存储于MongoDB数据库中."></a>需求: 爬取糗事百科热门板块,每一条的标题,好笑,评论条数及作者信息,解析爬取的信息数据,定制item数据存储结构,最终将数据存储于MongoDB数据库中.</h4><pre class="highlight"><span class="line"># 创建项目:</span><br><span class="line">scrapy startproject qsbk # 创建项目</span><br><span class="line">cd qsbk # 切换到项目目录</span><br><span class="line">scrapy genspider qsbk_hot www.qiushibaike.com # 创建爬虫文件, qsbk_hot为爬虫名, www...com为爬取范围</span><br></pre>
<hr>
<pre class="highlight"><span class="line"># item文件定义数据存储的字段:</span><br><span class="line">import scrapy</span><br><span class="line">class QsbkItem(scrapy.Item):</span><br><span class="line">    title &#x3D; scrapy.Field()  # 标题</span><br><span class="line">    lau &#x3D; scrapy.Field()  # 好笑数</span><br><span class="line">    comment &#x3D; scrapy.Field()  # 评论数</span><br><span class="line">    auth &#x3D; scrapy.Field()  # 作者</span><br></pre>
<pre class="highlight"><span class="line"># spider文件中定义解析数据的方法</span><br><span class="line">class QsbkHotSpider(scrapy.Spider):</span><br><span class="line">    name &#x3D;&#39;qsbk_hot&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.qiushibaike.com&#39;] # 无用, 可注释掉</span><br><span class="line">    start_urls &#x3D;[&#39;http:&#x2F;&#x2F;www.qiushibaike.com&#x2F;&#39;]</span><br><span class="line"></span><br><span class="line">    # 思路:一条热点数据在前端中对应一个li标签, 将一页中的所有li标签取出, 再进一步操作</span><br><span class="line">    def parse(self, response):</span><br><span class="line"></span><br><span class="line">        li_list &#x3D; response.selector.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;recommend-article&quot;]&#x2F;ul&#x2F;li&#39;)</span><br><span class="line"></span><br><span class="line">        # 循环li标签组成的列表, 先实例化item, 再取需要的字段, 并该item对象的相应属性赋值</span><br><span class="line">        for li in li_list:</span><br><span class="line"></span><br><span class="line">            # 实例化item对象</span><br><span class="line">            item &#x3D;QsbkItem()</span><br><span class="line"></span><br><span class="line">            # 解析获取title(标题), lau(好笑数), comment(评论数), auth(作者)等信息</span><br><span class="line">            title &#x3D; li.xpath(&#39;.&#x2F;div[@class&#x3D;&quot;recmd-right&quot;]&#x2F;a&#x2F;text()&#39;).extract_first()</span><br><span class="line">            lau &#x3D; li.xpath(&#39;.&#x2F;div[@class&#x3D;&quot;recmd-right&quot;]&#x2F;div[@class&#x3D;&quot;recmd-detail clearfix&quot;]&#x2F;div&#x2F;span[1]&#x2F;text()&#39;).extract_first()</span><br><span class="line">            comment &#x3D; li.xpath(&#39;.&#x2F;div[@class&#x3D;&quot;recmd-right&quot;]&#x2F;div[@class&#x3D;&quot;recmd-detail clearfix&quot;]&#x2F;div&#x2F;span[4]&#x2F;text()&#39;).extract_first()</span><br><span class="line">            auth &#x3D; li.xpath(&#39;.&#x2F;div[@class&#x3D;&quot;recmd-right&quot;]&#x2F;div[@class&#x3D;&quot;recmd-detail clearfix&quot;]&#x2F;a&#x2F;span&#x2F;text()&#39;).extract_first()</span><br><span class="line"></span><br><span class="line">            # 因为部分热点数据还没有评论和好笑数, 所以需对数据进行处理</span><br><span class="line">            if not lau:</span><br><span class="line">                lau &#x3D;None</span><br><span class="line">            if not comment:</span><br><span class="line">                comment &#x3D;None</span><br><span class="line"></span><br><span class="line">            # 将字段的值存储在item的属性中</span><br><span class="line">            item[&quot;title&quot;]&#x3D; title</span><br><span class="line">            item[&quot;lau&quot;]&#x3D; lau</span><br><span class="line">            item[&quot;comment&quot;]&#x3D; comment</span><br><span class="line">            item[&quot;auth&quot;]&#x3D; auth</span><br><span class="line"></span><br><span class="line">            # 返回item, 框架会自动将item传送至pipeline中的指定类</span><br><span class="line">            yield item</span><br></pre>

<pre class="highlight"><span class="line"># 在pipeline中定义管道类进行数据的存储</span><br><span class="line">import pymongo</span><br><span class="line"></span><br><span class="line">classQsbkPipeline(object):</span><br><span class="line">　　# 连接MongoDB数据库</span><br><span class="line">	conn &#x3D; pymongo.MongoClient(&quot;localhost&quot;, 27017)</span><br><span class="line">	db &#x3D; conn.qiubai  #(数据库名)</span><br><span class="line">	table &#x3D; db.qb_hot  #(表名)</span><br><span class="line"></span><br><span class="line">　　def process_item(self, item, spider):</span><br><span class="line">　　　　# 向数据库中出入数据</span><br><span class="line">　　　　self.table.insert(dict(item))</span><br><span class="line"></span><br><span class="line">　　　　# 此处return item是为了下一个管道类能够接收到item进行存储</span><br><span class="line">　　　　return item</span><br><span class="line"></span><br><span class="line">　　def close_spider(self):</span><br><span class="line">　　　　# 关闭数据库连接</span><br><span class="line">　　　　self.conn.close()</span><br></pre>

<pre class="highlight"><span class="line"># 此示例中配置文件中的配置的项, 注意是不是全部的配置, 是针对该项目增加或修改的配置项</span><br><span class="line"></span><br><span class="line"># 忽略robots协议</span><br><span class="line">ROBOTSTXT_OBEY &#x3D;False</span><br><span class="line"></span><br><span class="line"># UA伪装</span><br><span class="line">USER_AGENT &#x3D; &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;76.0.3809.87 Safari&#x2F;537.36&#39;</span><br><span class="line"></span><br><span class="line"># 管道类的注册配置</span><br><span class="line">ITEM_PIPELINES &#x3D;&#123;</span><br><span class="line">&#39;qsbk.pipelines.QsbkPipeline&#39;:300,</span><br><span class="line">&#125;</span><br></pre>
<hr>
<h2 id="6-scrapy爬取校花网人名与图片下载链接"><a href="#6-scrapy爬取校花网人名与图片下载链接" class="headerlink" title="6.scrapy爬取校花网人名与图片下载链接"></a>6.scrapy爬取校花网人名与图片下载链接</h2><h4 id="需求-爬取校花网大学校花的默认的第一页的所有图片src和人名-并通过管道存入mongodb数据库"><a href="#需求-爬取校花网大学校花的默认的第一页的所有图片src和人名-并通过管道存入mongodb数据库" class="headerlink" title="需求: 爬取校花网大学校花的默认的第一页的所有图片src和人名, 并通过管道存入mongodb数据库"></a>需求: 爬取校花网大学校花的默认的第一页的所有图片src和人名, 并通过管道存入mongodb数据库</h4><pre class="highlight"><span class="line"># 创建项目:</span><br><span class="line">scrapy startproject xiaohuaspider # 创建项目</span><br><span class="line">cd xiaohuaspider # 切换到项目目录</span><br><span class="line">scrapy genspider hua www.baidu.com # 创建爬虫文件, hua为爬虫名, www.baidu.com为爬取范围</span><br></pre>

<hr>
<pre class="highlight"><span class="line"># 创建item类, 用于存储解析出的数据</span><br><span class="line">import scrapy</span><br><span class="line">class XiaohuaspiderItem(scrapy.Item):</span><br><span class="line">    name &#x3D; scrapy.Field()</span><br><span class="line">    src &#x3D; scrapy.Field()</span><br></pre>
<hr>
<pre class="highlight"><span class="line"># spider中定义爬取的行为与解析数据的操作</span><br><span class="line">import scrapy</span><br><span class="line">from ..items import XiaohuaspiderItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HuaSpider(scrapy.Spider):</span><br><span class="line">    name &#x3D; &#39;hua&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;http:&#x2F;&#x2F;www.xiaohuar.com&#x2F;hua&#x2F;&#39;]</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        div_list &#x3D; response.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;img&quot;]&#39;)</span><br><span class="line">        for div in div_list:</span><br><span class="line">            item &#x3D; XiaohuaspiderItem()</span><br><span class="line">            name &#x3D; div.xpath(&#39;.&#x2F;&#x2F;span&#x2F;text()&#39;).extract_first()</span><br><span class="line">            src &#x3D; div.xpath(&#39;.&#x2F;a&#x2F;img&#x2F;@src&#39;).extract_first()</span><br><span class="line">            item[&quot;name&quot;] &#x3D; name</span><br><span class="line">            item[&quot;src&quot;] &#x3D; src</span><br><span class="line">            yield item</span><br></pre>
<hr>
<pre class="highlight"><span class="line"># itemPipeline编码, 持久化数据到本地</span><br><span class="line">import pymongo</span><br><span class="line"></span><br><span class="line">class XiaohuaspiderPipeline(object):</span><br><span class="line">    conn &#x3D; pymongo.MongoClient(&#39;localhost&#39;, 27017)</span><br><span class="line">    db &#x3D; conn.xiaohua</span><br><span class="line">    table &#x3D; db.hua</span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        self.table.insert(dict(item))</span><br><span class="line">        return item</span><br><span class="line">    def close_spider(self, spider):</span><br><span class="line">        self.conn.close()</span><br></pre>
<hr>
<pre class="highlight"><span class="line"># 配置项:</span><br><span class="line"># UA伪装:</span><br><span class="line">USER_AGENT &#x3D; &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;76.0.3809.87 Safari&#x2F;537.36&#39;</span><br><span class="line"></span><br><span class="line"># 忽略robots协议:</span><br><span class="line">ROBOTSTXT_OBEY &#x3D; False</span><br><span class="line"></span><br><span class="line"># 开启管道类</span><br><span class="line">ITEM_PIPELINES &#x3D; &#123;</span><br><span class="line">   &#39;xiaohuaspider.pipelines.XiaohuaspiderPipeline&#39;: 300,</span><br><span class="line">&#125;</span><br></pre>
<hr>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>requests模块初级用法&amp;高级用法</title>
    <url>/2018/07/17/requests%E6%A8%A1%E5%9D%97%E5%88%9D%E7%BA%A7%E7%94%A8%E6%B3%95&amp;%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1-requests模块初级用法"><a href="#1-requests模块初级用法" class="headerlink" title="1.requests模块初级用法"></a>1.requests模块初级用法</h2><h3 id="requests库的安装"><a href="#requests库的安装" class="headerlink" title="requests库的安装"></a>requests库的安装</h3><pre class="highlight"><span class="line">pip install requests</span><br></pre>
<hr>
<h3 id="get请求"><a href="#get请求" class="headerlink" title="get请求:"></a>get请求:</h3><ul>
<li>不携带参数的get请求</li>
<li>不携带参数的get请求 + headers</li>
<li>携带参数的get请求 + headers</li>
</ul>
<h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求:"></a>post请求:</h3><ul>
<li>构建参数的post请求</li>
</ul>
<h3 id="响应数据的获取与属性"><a href="#响应数据的获取与属性" class="headerlink" title="响应数据的获取与属性"></a>响应数据的获取与属性</h3><pre><code>(1).响应数据的获取:
        res.text: 文本数据
        res.json(): json数据
        res.content: 流
(2).响应的其他属性:
        res.status_code: 获取响应状态码
        res.headers: 响应头
        res.cookie: cookie信息</code></pre><hr>
<h3 id="requests模块的get请求"><a href="#requests模块的get请求" class="headerlink" title="requests模块的get请求"></a>requests模块的get请求</h3><h4 id="1-不携带参数的get请求-爬取搜狗主页"><a href="#1-不携带参数的get请求-爬取搜狗主页" class="headerlink" title="1.不携带参数的get请求: 爬取搜狗主页"></a>1.不携带参数的get请求: 爬取搜狗主页</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;www.sogou.com&#x2F;&#39;</span><br><span class="line">res &#x3D; requests.get(url&#x3D;url)</span><br><span class="line">print(res)</span><br><span class="line">print(res.text)</span><br><span class="line"></span><br><span class="line">with open(&#39;sougou.html&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">    f.write(res.text)</span><br></pre>
<hr>
<h4 id="2-不携带参数的get请求-headers-爬取知乎的发现页"><a href="#2-不携带参数的get请求-headers-爬取知乎的发现页" class="headerlink" title="2.不携带参数的get请求  +  headers: 爬取知乎的发现页"></a>2.不携带参数的get请求  +  headers: 爬取知乎的发现页</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;www.zhihu.com&#x2F;explore&#39;</span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line">with open(&#39;zhihu.html&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">    f.write(res.text)</span><br></pre>
<hr>
<h4 id="3-携带参数的get请求-headers-知乎的发现栏中搜索Python"><a href="#3-携带参数的get请求-headers-知乎的发现栏中搜索Python" class="headerlink" title="3.携带参数的get请求  +  headers: 知乎的发现栏中搜索Python"></a>3.携带参数的get请求  +  headers: 知乎的发现栏中搜索Python</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">url&#x3D; &#39;https:&#x2F;&#x2F;www.zhihu.com&#x2F;search?&#39;</span><br><span class="line">params &#x3D; &#123;</span><br><span class="line">    &#39;type&#39;:&#39;content&#39;,</span><br><span class="line">    &#39;q&#39;:&#39;python&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers, params&#x3D;params)</span><br><span class="line">print(res)</span><br><span class="line">print(res.text)</span><br><span class="line">with open(&#39;python.html&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">    f.write(res.text)</span><br></pre>
<hr>
<h3 id="4-requests模块的post请求"><a href="#4-requests模块的post请求" class="headerlink" title="4.requests模块的post请求:"></a>4.requests模块的post请求:</h3><h4 id="以post方式请求httpbin-org-post时会返回提交的请求信息"><a href="#以post方式请求httpbin-org-post时会返回提交的请求信息" class="headerlink" title="以post方式请求httpbin.org/post时会返回提交的请求信息"></a>以post方式请求httpbin.org/post时会返回提交的请求信息</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">     &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;</span><br><span class="line">data &#x3D; &#123;</span><br><span class="line">    &#39;name&#39;: &#39;spiderman&#39;,</span><br><span class="line">    &#39;age&#39;: 8</span><br><span class="line">&#125;</span><br><span class="line">res &#x3D; requests.post(url&#x3D;url, headers&#x3D;headers, data&#x3D;data)</span><br><span class="line">print(res.text)</span><br></pre>
<h4 id="以post方式请求百度翻译返回请求信息"><a href="#以post方式请求百度翻译返回请求信息" class="headerlink" title="以post方式请求百度翻译返回请求信息"></a>以post方式请求百度翻译返回请求信息</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line"></span><br><span class="line">#  确定url,发送请求，响应数据</span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;fanyi.baidu.com&#x2F;sug&#39;</span><br><span class="line">while 1:</span><br><span class="line">    kw &#x3D; input(&#39;请输入需要查询的单词：&#39;)</span><br><span class="line">    if kw &#x3D;&#x3D; &#39;q&#39;:</span><br><span class="line">        break</span><br><span class="line">    params &#x3D; &#123;</span><br><span class="line">        &#39;kw&#39;:kw</span><br><span class="line">    &#125;</span><br><span class="line">    headers &#x3D; &#123;</span><br><span class="line">        &#39;User-agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;80.0.3987.106 Safari&#x2F;537.36&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    res &#x3D; requests.post(url &#x3D; url,headers &#x3D; headers,params &#x3D; params).json()</span><br><span class="line">    # print(res)</span><br><span class="line">    kdata &#x3D; res[&#39;data&#39;][0][&#39;v&#39;]</span><br><span class="line">    print(kdata)</span><br></pre>
<hr>
<h3 id="json形式与流形式的响应数据示例"><a href="#json形式与流形式的响应数据示例" class="headerlink" title="json形式与流形式的响应数据示例"></a>json形式与流形式的响应数据示例</h3><h4 id="1-json形式响应数据示例-bilibili的Python视频教程-目录列表"><a href="#1-json形式响应数据示例-bilibili的Python视频教程-目录列表" class="headerlink" title="1.json形式响应数据示例: bilibili的Python视频教程, 目录列表"></a>1.json形式响应数据示例: bilibili的Python视频教程, 目录列表</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">     &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;api.bilibili.com&#x2F;x&#x2F;web-interface&#x2F;view?aid&#x3D;14184325&amp;cid&#x3D;23153678&#39;</span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line">print(res)</span><br><span class="line">print(res.status_code)</span><br><span class="line">print(res.headers)</span><br><span class="line">print(&#39;~~~~~~&#39;)</span><br><span class="line">print(res.json())</span><br></pre>
<hr>
<h4 id="2-流形式响应数据示例-站长素材的简历模板"><a href="#2-流形式响应数据示例-站长素材的简历模板" class="headerlink" title="2.流形式响应数据示例: 站长素材的简历模板"></a>2.流形式响应数据示例: 站长素材的简历模板</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">     &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;fjdx.sc.chinaz.net&#x2F;Files&#x2F;DownLoad&#x2F;jianli&#x2F;201907&#x2F;jianli10810.rar&#39;</span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line">print(res.content)</span><br><span class="line">with open(&#39;janli.rar&#39;, &#39;wb&#39;) as f:</span><br><span class="line">    f.write(res.content)</span><br></pre>

<hr>
<h2 id="2-requests模块高级用法"><a href="#2-requests模块高级用法" class="headerlink" title="2.requests模块高级用法"></a>2.requests模块高级用法</h2><h3 id="文件上传功能"><a href="#文件上传功能" class="headerlink" title="文件上传功能"></a>文件上传功能</h3><pre class="highlight"><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># 定义上传文件数据, 键为file, 值为文件句柄</span><br><span class="line">files &#x3D; &#123;</span><br><span class="line">&#39;file&#39;: open(&#39;favicon.ico&#39;, &#39;rb&#39;)</span><br><span class="line">&#125;</span><br><span class="line">r &#x3D; requests.post(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;, files&#x3D;files)</span><br><span class="line">print(res.text)</span><br></pre>
<hr>
<h3 id="cookie处理方法"><a href="#cookie处理方法" class="headerlink" title="cookie处理方法"></a>cookie处理方法</h3><ol>
<li>headers添加cookie键值对</li>
<li>RequestsCookieJar对象</li>
</ol>
<hr>
<h4 id="headers内添加cookie键值对处理cookie"><a href="#headers内添加cookie键值对处理cookie" class="headerlink" title="headers内添加cookie键值对处理cookie"></a>headers内添加cookie键值对处理cookie</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;,</span><br><span class="line">    &#39;Cookies&#39;:&#39;BAIDUID&#x3D;79A570F8D90B2C45E42D40A3666ADC46:FG&#x3D;1; BIDUPSID&#x3D;79A570F8D90B2C45E42D40A3666ADC46; PSTM&#x3D;1551074009; BD_UPN&#x3D;12314753; sugstore&#x3D;0; BDORZ&#x3D;FFFB88E999055A3F8A630C64834BD6D0; yjs_js_security_passport&#x3D;10c9ca61409abe70ac5c03db796f78648e697d8f_1563711806_js; COOKIE_SESSION&#x3D;2860_2_2_7_3_5_0_0_2_4_106_0_3778_177561_116_109_1563714759_1563714752_1563714643%7C9%23177557_14_1563714643%7C7; delPer&#x3D;0; BD_HOME&#x3D;0; H_PS_PSSID&#x3D;1452_21117_29522_29521_28519_29099_28831_29221&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line">res.encoding &#x3D; &#39;utf-8&#39;</span><br><span class="line">with open(&#39;baidu_cookie.html&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">    f.write(res.text)</span><br></pre>
<hr>
<h4 id="RequestsCookieJar对象处理cookie-用cookie维持百度登陆"><a href="#RequestsCookieJar对象处理cookie-用cookie维持百度登陆" class="headerlink" title="RequestsCookieJar对象处理cookie: 用cookie维持百度登陆"></a>RequestsCookieJar对象处理cookie: 用cookie维持百度登陆</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">cookies &#x3D; &#39;BAIDUID&#x3D;79A570F8D90B2C45E42D40A3666ADC46:FG&#x3D;1; BIDUPSID&#x3D;79A570F8D90B2C45E42D40A3666ADC46; PSTM&#x3D;1551074009; BD_UPN&#x3D;12314753; sugstore&#x3D;0; BDORZ&#x3D;FFFB88E999055A3F8A630C64834BD6D0; yjs_js_security_passport&#x3D;10c9ca61409abe70ac5c03db796f78648e697d8f_1563711806_js; COOKIE_SESSION&#x3D;2860_2_2_7_3_5_0_0_2_4_106_0_3778_177561_116_109_1563714759_1563714752_1563714643%7C9%23177557_14_1563714643%7C7; delPer&#x3D;0; BD_HOME&#x3D;0; H_PS_PSSID&#x3D;1452_21117_29522_29521_28519_29099_28831_29221; BDUSS&#x3D;lSVnBVVkRVNFpNZ2ZJZ2ZpNFpjblFFSX5EaW9DNzBpcnNkaDZIQVdRd2Z1bHhkRVFBQUFBJCQAAAAAAAAAAAEAAABwfMtW09rQodPjMDgyMGZyZWUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8tNV0fLTVdYX&#39;</span><br><span class="line">jar &#x3D; requests.cookies.RequestsCookieJar()</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &#39;User-Agetn&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">for cookie in cookies.split(&#39;;&#39;):</span><br><span class="line">    key, value &#x3D; cookie.split(&#39;&#x3D;&#39;, 1)</span><br><span class="line">    jar.set(key, value)</span><br><span class="line">    </span><br><span class="line">res &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.baidu.com&#39;, cookies&#x3D;jar, headers&#x3D;headers)</span><br><span class="line">print(res.text)  # 响应数据中包含用户名信息, 说明cookie生效</span><br></pre>
<hr>
<h3 id="会话维持"><a href="#会话维持" class="headerlink" title="会话维持"></a>会话维持</h3><h4 id="HTTP无状态"><a href="#HTTP无状态" class="headerlink" title="HTTP无状态:"></a>HTTP无状态:</h4><p>使用requests模块中的get()和post()方法请求网页时, 每一次请求都是独立的, 没有连续请求之间的状态保持. 假象, 如果你登陆了淘宝后向查看订单, 那么如果没有状态的维持就无法实现.</p>
<hr>
<h3 id="会话的维持-Session对象"><a href="#会话的维持-Session对象" class="headerlink" title="会话的维持: Session对象"></a>会话的维持: Session对象</h3><pre class="highlight"><span class="line">from requests import Session</span><br><span class="line">s &#x3D; Session()</span><br><span class="line">res &#x3D; s.get(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;)</span><br></pre>
<hr>
<h3 id="SSL证书验证"><a href="#SSL证书验证" class="headerlink" title="SSL证书验证"></a>SSL证书验证</h3><h4 id="1-SSL证书验证"><a href="#1-SSL证书验证" class="headerlink" title="1.SSL证书验证"></a>1.SSL证书验证</h4><p>requests提供了证书验证的功能. 当发起HTTP请求时, 模块会检查SSL证书. 但检查的行为可以用verify参数来控制.</p>
<pre class="highlight"><span class="line">verify &#x3D; False  # 不检查SSL证书</span><br><span class="line">verify &#x3D; True  # 检查SSL证书</span><br></pre>

<h4 id="2-异常"><a href="#2-异常" class="headerlink" title="2.异常"></a>2.异常</h4><p>如果使用requests模块的SSL验证, 验证不通过会抛出异常, 此时可以将verify参数设置为False</p>
<h4 id="3-www-12306-cn的证书验证"><a href="#3-www-12306-cn的证书验证" class="headerlink" title="3.www.12306.cn的证书验证:"></a>3.<a href="http://www.12306.cn的证书验证" target="_blank" rel="noopener">www.12306.cn的证书验证</a>:</h4><h5 id="会抛出异常"><a href="#会抛出异常" class="headerlink" title="会抛出异常"></a>会抛出异常</h5><pre class="highlight"><span class="line">import requests</span><br><span class="line">response &#x3D; requests.get(&#39;https:&#x2F;&#x2F;www.12306.cn&#39;)</span><br><span class="line">print(response.status_code)</span><br></pre>

<h5 id="不抛异常-但会出现警告"><a href="#不抛异常-但会出现警告" class="headerlink" title="不抛异常, 但会出现警告"></a>不抛异常, 但会出现警告</h5><pre class="highlight"><span class="line">import requests</span><br><span class="line">response &#x3D; requests.get(&#39;https:&#x2F;&#x2F;www.12306.cn&#39;, verify&#x3D;False)</span><br><span class="line">print(response.status_code)</span><br></pre>

<h5 id="禁止警告"><a href="#禁止警告" class="headerlink" title="禁止警告"></a>禁止警告</h5><pre class="highlight"><span class="line">import requests</span><br><span class="line">from requests.packages import urllib3</span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line">response &#x3D; requests.get(url&#x3D;&#39;https:&#x2F;&#x2F;www.12306.cn&#39;, verify&#x3D;False)</span><br><span class="line">print(response.status_code)</span><br></pre>

<hr>
<h3 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h3><h5 id="代理-代理即代理ip"><a href="#代理-代理即代理ip" class="headerlink" title="代理: 代理即代理ip"></a>代理: 代理即代理ip</h5><p>代理ip是指在请求的过程中使用非本机ip进行请求, 避免大数据量频繁请求的过程中出现ip封禁, 限制数据的爬取.</p>
<hr>
<h5 id="代理ip分类"><a href="#代理ip分类" class="headerlink" title="代理ip分类:"></a>代理ip分类:</h5><ol>
<li>透明代理ip: 请求时, 服务器知道请求的真实ip, 知道请求使用了代理</li>
<li>匿名代理ip: 请求时, 服务器知道请求使用了代理, 但不知道请求的真实ip</li>
<li>高匿代理ip: 请求时, 服务器不知道请求使用了代理, 也不知道请求的真实ip</li>
</ol>
<hr>
<h4 id="requests模块使用代理ip"><a href="#requests模块使用代理ip" class="headerlink" title="requests模块使用代理ip"></a>requests模块使用代理ip</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.httpbin.org&#39;</span><br><span class="line">proxies &#x3D; &#123;</span><br><span class="line">    &#39;http&#39;: &#39;http:&#x2F;&#x2F;61.183.176.122:57210&#39;</span><br><span class="line">&#125;</span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, proxies&#x3D;proxies)</span><br><span class="line">print(res.text)</span><br></pre>

<hr>
<h3 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h3><p>由于网络状况的不同, 服务器配置差异以及服务器处理并发的能力不同, 有时会出现服务器的响应时间过长, 甚至无法获取响应而抛出异常. requests模块发送请求可以设置超时时间, 在超时时间内未得到响应, 便会抛出异常.<br>一方面, 减少了请求的阻塞时间, 一方面, 可以进行异常处理, 执行相应的操作.</p>
<pre class="highlight"><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers, timeout&#x3D;0.001)  # 在0.001秒为得到响应, 抛出requests.exceptions.ConnectTimeout异常</span><br><span class="line">print(res.text)</span><br></pre>

<hr>
<h3 id="构建Request对象"><a href="#构建Request对象" class="headerlink" title="构建Request对象"></a>构建Request对象</h3><pre class="highlight"><span class="line"># 1.Prepared Request</span><br><span class="line">利用 Prepared Request 数据结构构件Request对象. 其构建及使用步骤如下:</span><br><span class="line">from requests import Request, Session</span><br><span class="line"></span><br><span class="line"># 构建Request对象</span><br><span class="line">url &#x3D; &#39;...&#39;</span><br><span class="line">data &#x3D; &#123;...&#125;</span><br><span class="line">params &#x3D; &#123;...&#125;</span><br><span class="line">headers &#x3D; &#123;...&#125;</span><br><span class="line">session &#x3D; Session()</span><br><span class="line"></span><br><span class="line"># 构建post请求:</span><br><span class="line">req_post &#x3D; Request(method&#x3D;&#39;POST&#39;, url&#x3D;url, headers&#x3D;headers, data&#x3D;data)</span><br><span class="line">req_obj_post &#x3D; session.prepare_request(req_post)</span><br><span class="line"></span><br><span class="line"># 构建get请求:</span><br><span class="line">req_get &#x3D; Request(method&#x3D;&#39;GET&#39;, url&#x3D;url, headers&#x3D;headers, params&#x3D;params)</span><br><span class="line">req_obj_get &#x3D; session.prepare_request(req_get)</span><br><span class="line"></span><br><span class="line"># 利用构建的请求对象, 向服务器发送请求</span><br><span class="line">res &#x3D; session.send(req_obj_post)</span><br><span class="line">res &#x3D; session.send(req_obj_get)</span><br><span class="line"></span><br><span class="line"># 应用:</span><br><span class="line">通过此方法, 我们可以构建一个独立的request对象, 当需要请求的url很多时, 我们可以为每一个url构建一个request对象, 将所有request对象置于队列中, 便于调度.</span><br></pre>

<hr>
<h5 id="构建Request对象-请求糗事百科获取页面"><a href="#构建Request对象-请求糗事百科获取页面" class="headerlink" title="构建Request对象, 请求糗事百科获取页面"></a>构建Request对象, 请求糗事百科获取页面</h5><pre class="highlight"><span class="line">from requests import Request, Session</span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;www.qiushibaike.com&#x2F;&#39;</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">session &#x3D; Session()</span><br><span class="line">req_get &#x3D; Request(url&#x3D;url, headers&#x3D;headers, method&#x3D;&#39;GET&#39;)</span><br><span class="line">req_get_obj &#x3D; session.prepare_request(req_get)</span><br><span class="line">res &#x3D; session.send(req_get_obj)</span><br><span class="line">res.encoding &#x3D; &#39;utf-8&#39;</span><br><span class="line">with open(&#39;qb_reqobj.html&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">    f.write(res.text)</span><br></pre>
<hr>
<h3 id="urllib简单介绍"><a href="#urllib简单介绍" class="headerlink" title="urllib简单介绍"></a>urllib简单介绍</h3><h5 id="urllib简介"><a href="#urllib简介" class="headerlink" title="urllib简介:"></a>urllib简介:</h5><ul>
<li>urllib模块是Python的一个请求模块</li>
<li>Python2中是urllib和urllib2相结合实现请求的发送. Python3中同一为urllib库</li>
<li>urllib是Python内置的请求库, 其包含4个模块:<ul>
<li>request模块: 模拟发送请求</li>
<li>error模块: 异常处理模块</li>
<li>parse模块: 工具模块, 提供关于URL的处理方法, 如拆分, 解析, 合并等</li>
<li>robotparser模块: 识别robots协议</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础数据类型的操作</title>
    <url>/2019/03/28/python%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="列表和元组"><a href="#列表和元组" class="headerlink" title="列表和元组"></a>列表和元组</h1><h2 id="1-列表基本操作"><a href="#1-列表基本操作" class="headerlink" title="1.列表基本操作"></a>1.列表基本操作</h2><h3 id="1-1-列表赋值"><a href="#1-1-列表赋值" class="headerlink" title="1.1  列表赋值　"></a>1.1  列表赋值　</h3><pre class="highlight"><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">100</span>        <span class="comment">#the result ： [100, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre>
<h3 id="1-2-元素删除"><a href="#1-2-元素删除" class="headerlink" title="1.2 元素删除"></a>1.2 元素删除</h3><pre class="highlight"><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="keyword">del</span> a[<span class="number">0</span>]　　                <span class="comment">#the result ： [2, 3, 4, 5, 6, 7, 8]</span></span><br></pre>
<h3 id="1-3-分片赋值"><a href="#1-3-分片赋值" class="headerlink" title="1.3 分片赋值"></a>1.3 分片赋值</h3><pre class="highlight"><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">a[::<span class="number">2</span>]                  <span class="comment"># [1, 3, 5, 7]</span></span><br><span class="line">a[<span class="number">-2</span>:]                  <span class="comment"># [7, 8]</span></span><br><span class="line">a[<span class="number">1</span>:<span class="number">1</span>] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]             <span class="comment"># the result : [1, 0, 0, 0, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre>
<h3 id="1-4-使用-for-i-in-range-10-1-1-生成列表"><a href="#1-4-使用-for-i-in-range-10-1-1-生成列表" class="headerlink" title="1.4 使用 for i in range(10,-1,-1) 生成列表"></a>1.4 使用 for i in range(10,-1,-1) 生成列表</h3><pre class="highlight"><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>,<span class="number">-1</span>,<span class="number">-1</span>): </span><br><span class="line"><span class="comment"># 开始位置（10），结束位置（-1）， 步长（-1）		</span></span><br><span class="line">	<span class="keyword">print</span> i,</span><br><span class="line"><span class="comment"># 打印结果：10 9 8 7 6 5 4 3 2 1 0</span></span><br><span class="line"><span class="comment"># 从10开始，每次向后取一个值，直到遇到结束位置 -1</span></span><br></pre>
<h2 id="2-列表方法"><a href="#2-列表方法" class="headerlink" title="2.列表方法"></a>2.列表方法</h2><h3 id="2-1-append"><a href="#2-1-append" class="headerlink" title="2.1 append"></a>2.1 append</h3><p>作用：append用于在列表末尾追加新的对象</p>
<pre class="highlight"><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.append(<span class="number">4</span>)          　　　　　　　<span class="comment">#the result ： [1, 2, 3, 4]</span></span><br></pre>
<h3 id="2-2-count"><a href="#2-2-count" class="headerlink" title="2.2  count"></a>2.2  count</h3><p>作用：count方法统计某个元素在列表中出现的次数</p>
<pre class="highlight"><span class="line">a =[<span class="string">'aa'</span>,<span class="string">'bb'</span>,<span class="string">'cc'</span>,<span class="string">'aa'</span>,<span class="string">'aa'</span>]print(a.count(<span class="string">'aa'</span>))                  <span class="comment">#the result ： 3</span></span><br></pre>
<h3 id="2-3-extend"><a href="#2-3-extend" class="headerlink" title="2.3   extend"></a>2.3   extend</h3><p>作用：extend方法可以在列表的末尾一次性追加另一个序列中的多个值</p>
<pre class="highlight"><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">a.extend(b)       <span class="comment">#the result ：[1, 2, 3, 4, 5, 6]</span></span><br></pre>
<h3 id="2-4-index"><a href="#2-4-index" class="headerlink" title="2.4  index"></a>2.4  index</h3><p>作用：index函数用于从列表中找出某个值第一个匹配项的索引位置</p>
<pre class="highlight"><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]``print(a.index(<span class="number">1</span>))                  <span class="comment">#the result ： 0`</span></span><br></pre>
<h3 id="2-5-insert"><a href="#2-5-insert" class="headerlink" title="2.5  insert"></a>2.5  insert</h3><p>作用： insert方法用于将对象插入到列表中</p>
<pre class="highlight"><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]``a.insert(<span class="number">0</span>,``<span class="string">'aa'</span>``)      <span class="comment">#the result : [``'aa'``, 1, 2, 3]`</span></span><br></pre>
<h3 id="2-6-pop"><a href="#2-6-pop" class="headerlink" title="2.6  pop"></a>2.6  pop</h3><p>作用：pop方法会移除列表中的一个元素（默认是最后一个），并且返回该元素的值</p>
<pre class="highlight"><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]``a.pop()                         <span class="comment">#the result ： [1, 2]``a.pop(0)`</span></span><br></pre>
<h3 id="2-7-remove"><a href="#2-7-remove" class="headerlink" title="2.7   remove"></a>2.7   remove</h3><p>作用：remove方法用于移除列表中某个值的第一个匹配项</p>
<pre class="highlight"><span class="line">a = [<span class="string">'aa'</span>,<span class="string">'bb'</span>,<span class="string">'cc'</span>,<span class="string">'aa'</span>]</span><br><span class="line">a.remove(<span class="string">'aa'</span>)            <span class="comment">#the result ： ['bb', 'cc', 'aa']</span></span><br></pre>
<h3 id="2-8-reverse"><a href="#2-8-reverse" class="headerlink" title="2.8  reverse"></a>2.8  reverse</h3><p>作用：reverse方法将列表中的元素反向存放</p>
<pre class="highlight"><span class="line">a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]a.reverse()         <span class="comment">#the result ： ['c', 'b', 'a']</span></span><br></pre>
<h3 id="2-9-sort"><a href="#2-9-sort" class="headerlink" title="2.9  sort"></a>2.9  sort</h3><p>　　作用：sort方法用于在原位置对列表进行排序，意味着改变原来的列表，让其中的元素按一定顺序排列</p>
<pre class="highlight"><span class="line">a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.sort()            <span class="comment">#the result ：[1, 2, 3, 'a', 'b', 'c']</span></span><br></pre>
<h3 id="2-10-enumrate"><a href="#2-10-enumrate" class="headerlink" title="2.10  enumrate"></a>2.10  enumrate</h3><pre class="highlight"><span class="line">li = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>]</span><br><span class="line"><span class="keyword">for</span>  k,v  <span class="keyword">in</span> enumerate(li, <span class="number">1</span>):</span><br><span class="line">print(k,v)</span><br></pre>

<h3 id="2-11-range和xrange-指定范围，生成指定的数字"><a href="#2-11-range和xrange-指定范围，生成指定的数字" class="headerlink" title="2.11 range和xrange 指定范围，生成指定的数字"></a>2.11 range和xrange 指定范围，生成指定的数字</h3><p>注：python3中的range类似python2中的xrange，比如a = range(1,4) : a返回的不是列表对象而是一个可迭代对象（&lt;class ‘range’&gt;）</p>
<pre class="highlight"><span class="line"><span class="comment">#1、range根据start与stop指定的范围以及step设定的步长，生成一个序列：range([start,] stop[, step])``#2、xrange 用法与 range 完全相同，所不同的是生成的不是一个list对象，而是一个生成器for i in range(1,10,2):</span></span><br><span class="line">print(i)`</span><br></pre>
<h3 id="2-12-列表去空"><a href="#2-12-列表去空" class="headerlink" title="2.12  列表去空"></a>2.12  列表去空</h3><pre class="highlight"><span class="line"><span class="comment">#方法1：</span></span><br><span class="line">filter(<span class="literal">None</span>, your_list)</span><br><span class="line"><span class="comment">#方法2：</span></span><br><span class="line"><span class="keyword">while</span> <span class="string">''</span> <span class="keyword">in</span> your_list:</span><br><span class="line">	your_list.remove(<span class="string">''</span>)</span><br><span class="line"><span class="comment">#方法3：</span></span><br><span class="line">your_list = [x  <span class="keyword">for</span> x  <span class="keyword">in</span> your_list  <span class="keyword">if</span> x != <span class="string">''</span>]</span><br></pre>

<h2 id="3-元组定义：元组和列表一样，也是一种序列，唯一的不同是元组不能修改。"><a href="#3-元组定义：元组和列表一样，也是一种序列，唯一的不同是元组不能修改。" class="headerlink" title="3.元组定义：元组和列表一样，也是一种序列，唯一的不同是元组不能修改。"></a>3.元组定义：元组和列表一样，也是一种序列，唯一的不同是元组不能修改。</h2><h3 id="3-1-创建元组举例"><a href="#3-1-创建元组举例" class="headerlink" title="3.1  创建元组举例"></a>3.1  创建元组举例</h3><pre class="highlight"><span class="line"><span class="comment">#1. 创建元组</span></span><br><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="comment">#2. 将列表转换成元组</span></span><br><span class="line">tuple([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])                  <span class="comment">#the result ： (1, 2, 3, 4)</span></span><br></pre>
<h2 id="4-列表和元组常用函数"><a href="#4-列表和元组常用函数" class="headerlink" title="4.列表和元组常用函数"></a>4.列表和元组常用函数</h2><p>com(x,y) 比较两个值<br>len(seq) 返回序列的长度<br>list(seq) 把序列转换成列表<br>max(args) 返回序列或者参数集合中得最大值<br>min(args) 返回序列或者参数集合中的最小值<br>reversed(seq) 对序列进行反向迭代<br>sorted(seq) 返回已经排列的包含seq 所有元素的列表<br>tuple(seq) 把序列转换成元组</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="1-字符串格式化"><a href="#1-字符串格式化" class="headerlink" title="1.字符串格式化"></a>1.字符串格式化</h2><h3 id="1-1-使用百分号（-）字符串格式化"><a href="#1-1-使用百分号（-）字符串格式化" class="headerlink" title="1.1 使用百分号（%）字符串格式化"></a>1.1 使用百分号（%）字符串格式化</h3><pre class="highlight"><span class="line">num = <span class="number">100</span></span><br><span class="line">print(<span class="string">"%d to hex is %x"</span>%(num, num))    <span class="comment">#100 to hex is 64 </span></span><br><span class="line">print(<span class="string">"%d to hex is %#x"</span>%(num, num))    <span class="comment">#100 to hex is 0x64</span></span><br></pre>

<h3 id="1-2-使用format字符串格式化"><a href="#1-2-使用format字符串格式化" class="headerlink" title="1.2  使用format字符串格式化"></a>1.2  使用format字符串格式化</h3><pre class="highlight"><span class="line"><span class="comment">#1. 位置参数</span></span><br><span class="line">print(<span class="string">"&#123;0&#125; is &#123;1&#125; years old"</span></span><br><span class="line">.format(<span class="string">"tom"</span>, <span class="number">28</span>))     </span><br><span class="line"> <span class="comment">#tom ``is` `28 years old``print(``"&#123;&#125; is &#123;&#125; years old"``.format(``"tom"``, 28))       #tom ``is` `28 years old``print(``"Hi, &#123;0&#125;! &#123;0&#125; is &#123;1&#125; years old"``.format(``"tom"``, 28)) #Hi, tom! tom ``is` `28 years old` `#2. 关键字参数``print(``"&#123;name&#125; is &#123;age&#125; years old"``.format(name = ``"tom"``, age = 28))  #tom ``is` `28 years old` `#3. 下标参数``li = [``"tom"``, 28]``print(``"&#123;0[0]&#125; is &#123;0[1]&#125; years old"``.format(li))     #tom ``is` `28 years old`</span></span><br></pre>
<h2 id="2-字符串方法"><a href="#2-字符串方法" class="headerlink" title="2.字符串方法"></a>2.字符串方法</h2><h3 id="2-1-find方法"><a href="#2-1-find方法" class="headerlink" title="2.1  find方法"></a>2.1  find方法</h3><p>作用：find方法可以在一个较长的字符串中查找子串，他返回子串所在位置的最左端索引，如果没有找到则返回-1</p>
<pre class="highlight"><span class="line">a=<span class="string">'abcdefghijk'</span></span><br><span class="line">print(a.find(<span class="string">'abc'</span>))             </span><br><span class="line"><span class="comment">#the result ： 0</span></span><br><span class="line">print(a.find(<span class="string">'abc'</span>,<span class="number">10</span>,<span class="number">100</span>))          <span class="comment">#the result ： 11 指定查找的起始和结束查找位置</span></span><br></pre>
<h3 id="2-2-join方法"><a href="#2-2-join方法" class="headerlink" title="2.2  join方法"></a>2.2  join方法</h3><p>作用：join方法是非常重要的字符串方法，他是split方法的逆方法，用来连接序列中的元素，并且需要被连接的元素都必须是字符串。</p>
<pre class="highlight"><span class="line">a = [``<span class="string">'1'</span>``,``<span class="string">'2'</span>``,``<span class="string">'3'</span>``]``print(``<span class="string">'+'</span>``.``join``(a))                  <span class="comment">#the result ： 1+2+3</span></span><br></pre>
<h3 id="2-3-split方法"><a href="#2-3-split方法" class="headerlink" title="2.3  split方法"></a>2.3  split方法</h3><p>作用：这是一个非常重要的字符串，它是join的逆方法，用来将字符串分割成序列</p>
<pre class="highlight"><span class="line">print(&#96;&#96;&#39;1+2+3+4&#39;&#96;&#96;.split(&#96;&#96;&#39;+&#39;&#96;&#96;))              #the result ： [&#96;&#96;&#39;1&#39;&#96;&#96;, &#96;&#96;&#39;2&#39;&#96;&#96;, &#96;&#96;&#39;3&#39;&#96;&#96;, &#96;&#96;&#39;4&#39;&#96;&#96;]</span><br></pre>
<h3 id="2-4-strip"><a href="#2-4-strip" class="headerlink" title="2.4  strip"></a>2.4  strip</h3><p>作用：strip 方法返回去除首位空格（不包括内部）的字符串</p>
<pre class="highlight"><span class="line">print(``<span class="string">"  test  test  "</span>``.strip())        </span><br><span class="line"><span class="comment">#the result ：“test  test”</span></span><br></pre>

<h3 id="2-5-replace"><a href="#2-5-replace" class="headerlink" title="2.5 replace"></a>2.5 replace</h3><p>作用：replace方法返回某字符串所有匹配项均被替换之后得到字符串</p>
<pre class="highlight"><span class="line">print(``<span class="string">"This is a test"</span>``.replace(``<span class="string">'is'</span>``,``<span class="string">'is_test'</span>``))   </span><br><span class="line"><span class="comment">#the result ： This_test is_test a test</span></span><br></pre>
<h3 id="2-6-首字母大写"><a href="#2-6-首字母大写" class="headerlink" title="2.6 首字母大写"></a>2.6 首字母大写</h3><pre class="highlight"><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = ``<span class="string">'aBdkndfkFFD'</span>``&gt;&gt;&gt; s.capitalize()``<span class="string">'Abdkndfkffd'</span>`</span><br></pre>

<h3 id="2-7-Pinyin-模块，将汉字转换成拼音"><a href="#2-7-Pinyin-模块，将汉字转换成拼音" class="headerlink" title="2.7 Pinyin 模块，将汉字转换成拼音"></a>2.7 Pinyin 模块，将汉字转换成拼音</h3><pre class="highlight"><span class="line"><span class="keyword">from</span> xpinyin <span class="keyword">import</span> Pinyin </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">p = Pinyin()  </span><br><span class="line">fullname =raw_input(<span class="string">'name：'</span>).strip()  fullname = fullname.decode(<span class="string">'utf8'</span>)  </span><br><span class="line">print(fullname)  </span><br><span class="line">xin = fullname[<span class="number">0</span>]  </span><br><span class="line">ming = fullname[<span class="number">1</span>:]  </span><br><span class="line">name = ming + ``<span class="string">'.'</span>` `+ xin</span><br><span class="line">username = p.get_pinyin(name, <span class="string">''</span>)  </span><br><span class="line"><span class="keyword">print</span> username</span><br><span class="line"><span class="keyword">print</span> username + <span class="string">'@yiducloud.cn</span></span><br></pre>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="1-字典基本使用"><a href="#1-字典基本使用" class="headerlink" title="1.字典基本使用"></a>1.字典基本使用</h2><h3 id="1-1-键类型：字典的键不一定为整形数据，键可以是任意的不可变类型，比如浮点型（实行），字符串或者元组。-1-2-自动添加：即使键起初在字典中不存在，也可以为他赋值，这样字典就会建立新的项。而（在不适用append方法或者其他类似操作的情况下）不能将值关联到列表之外的索引上。"><a href="#1-1-键类型：字典的键不一定为整形数据，键可以是任意的不可变类型，比如浮点型（实行），字符串或者元组。-1-2-自动添加：即使键起初在字典中不存在，也可以为他赋值，这样字典就会建立新的项。而（在不适用append方法或者其他类似操作的情况下）不能将值关联到列表之外的索引上。" class="headerlink" title="1.1 键类型：字典的键不一定为整形数据，键可以是任意的不可变类型，比如浮点型（实行），字符串或者元组。 ### 1.2 自动添加：即使键起初在字典中不存在，也可以为他赋值，这样字典就会建立新的项。而（在不适用append方法或者其他类似操作的情况下）不能将值关联到列表之外的索引上。"></a>1.1 键类型：字典的键不一定为整形数据，键可以是任意的不可变类型，比如浮点型（实行），字符串或者元组。 ### 1.2 自动添加：即使键起初在字典中不存在，也可以为他赋值，这样字典就会建立新的项。而（在不适用append方法或者其他类似操作的情况下）不能将值关联到列表之外的索引上。</h3><pre class="highlight"><span class="line">phonebook = &#123;``<span class="string">'Tom'</span>``:<span class="number">8777</span>,``<span class="string">'Jack'</span>``:<span class="number">9999</span>,``<span class="string">'Fly'</span>``:<span class="number">6666</span>&#125;</span><br><span class="line">print(``<span class="string">"Tom's Phonenumber is %(Tom)s"</span>` `% phonebook)    </span><br><span class="line"><span class="comment">#Tom's Phonenumber ``is` `8777`</span></span><br></pre>
<h2 id="2-字典常用方法"><a href="#2-字典常用方法" class="headerlink" title="2.字典常用方法"></a>2.字典常用方法</h2><h3 id="2-1-clear"><a href="#2-1-clear" class="headerlink" title="2.1 clear"></a>2.1 clear</h3><p>作用：clear方法清除字典中所有的项，这是一个原地操作，所以无返回值（或则说返回None）</p>
<pre class="highlight"><span class="line">d = &#123;&#125;``d[``<span class="string">'Tom'</span>``]=<span class="number">8777</span>``d[``<span class="string">'Jack'</span>``]=<span class="number">9999</span>``</span><br><span class="line">print(d)                </span><br><span class="line"><span class="comment">#the result : &#123;``'Jack'``: 9999, ``'</span></span><br><span class="line">Tom<span class="string">'``: 8777&#125;``</span></span><br><span class="line"><span class="string">d.clear()``print(d)                </span></span><br><span class="line"><span class="string">#the result : &#123;&#125;`</span></span><br></pre>
<h3 id="2-2-copy"><a href="#2-2-copy" class="headerlink" title="2.2 copy"></a>2.2 copy</h3><p>作用：copy方法返回一个具有相同 ”键-值” 对的新字典，而不是副本</p>
<pre class="highlight"><span class="line">d = &#123;<span class="string">'Tom'</span>:<span class="number">8777</span>,<span class="string">'Fly'</span>:<span class="number">6666</span>&#125;</span><br><span class="line">a = d.copy()</span><br><span class="line">a[<span class="string">'Tom'</span>] = <span class="string">'改变后的值'</span></span><br><span class="line">print(d)           </span><br><span class="line"><span class="comment">#&#123;``'Fly'``: 6666, ``'Tom'``: 8777&#125;</span></span><br><span class="line">print(a)           </span><br><span class="line"><span class="comment">#&#123;``'Fly'``: 6666, ``'Tom': '改变后的值'&#125;</span></span><br></pre>

<h3 id="2-3-fromkeys"><a href="#2-3-fromkeys" class="headerlink" title="2.3 fromkeys"></a>2.3 fromkeys</h3><p>作用：fromkeys方法使用给定的键建立新的字典，每个键都对应一个默认的值None。</p>
<p>　　首先建造一个空字典，然后调用它的fromkeys方法，建立另一个字典</p>
<pre class="highlight"><span class="line">print(&#123;&#125;.fromkeys([<span class="string">'name'</span>,<span class="string">'age'</span>]))    </span><br><span class="line"> <span class="comment">#the result　：　&#123;``'age'``: None, ``'name'``: None&#125;`</span></span><br><span class="line"><span class="comment">### 2.4  get</span></span><br><span class="line">作用：get方法是个更宽松的访问字典项的方法，如果试图访问字典中不存在的项时不会报错仅会 返回：<span class="literal">None</span></span><br><span class="line">```python</span><br><span class="line">d = &#123;``<span class="string">'Tom'</span>``:<span class="number">8777</span>,``<span class="string">'Jack'</span>``:<span class="number">8888</span>,``<span class="string">'Fly'</span>``:<span class="number">6666</span>&#125;</span><br><span class="line">print(d.``get``(``<span class="string">'Tom'</span>``))               </span><br><span class="line"> <span class="comment">#the result ：  8777``</span></span><br><span class="line"> print(d.``get``(``<span class="string">'not_exist'</span>``))             </span><br><span class="line"> <span class="comment">#the result ：   None`</span></span><br></pre>

<h3 id="2-5-for循环字典的三种方法"><a href="#2-5-for循环字典的三种方法" class="headerlink" title="2.5. for循环字典的三种方法"></a>2.5. for循环字典的三种方法</h3><pre class="highlight"><span class="line">d = &#123;`Tom<span class="string">':8777,'</span>Jack<span class="string">':8888,'</span>Fly<span class="string">':6666&#125;</span></span><br><span class="line"><span class="string">for` k,v  in d.items():</span></span><br><span class="line"><span class="string">	print(k,v)</span></span><br><span class="line"><span class="string">for` k  in d.values():  </span></span><br><span class="line"><span class="string">	print(k) </span></span><br><span class="line"><span class="string">for` k  in d.keys():  </span></span><br><span class="line"><span class="string">print(k)</span></span><br></pre>

<h3 id="2-6-pop-1"><a href="#2-6-pop-1" class="headerlink" title="2.6  pop"></a>2.6  pop</h3><p>作用：pop方法用于获得对应与给定键的值，然后将这个”键-值”对从字典中移除</p>
<pre class="highlight"><span class="line">d = &#123;<span class="string">'Tom'</span>:<span class="number">8777</span>,<span class="string">'Jack'</span>:<span class="number">8888</span>,<span class="string">'Fly'</span>:<span class="number">6666</span>&#125;</span><br><span class="line">v = d.pop(<span class="string">'Tom'</span>)</span><br><span class="line">print(v)          </span><br><span class="line"><span class="comment">#8777</span></span><br></pre>

<h3 id="2-7-popitem"><a href="#2-7-popitem" class="headerlink" title="2.7  popitem"></a>2.7  popitem</h3><p>① popitem方法类似于list.pop，list.pop会弹出列表的最后一个元素，但是popitem仅仅会弹出随机的项，因为字典没有”最后的元素”或则其他有关顺序的概念 　　<br>② 所以想一个接一个的移除并处理字典中的项，popitem是非常有效的（因为不用获取键的列表） 　　<br>③ 尽管popitem和列表的pop方法很类似，但是字典中没有与append等价的方法，因为字典是无序的，类似于append得方法是没有任何意义的</p>
<pre class="highlight"><span class="line">d = &#123;<span class="string">'Tom'</span>:<span class="number">8777</span>,<span class="string">'Jack'</span>:<span class="number">8888</span>,<span class="string">'Fly'</span>:<span class="number">6666</span>&#125;</span><br><span class="line">d.popitem()</span><br></pre>
<h3 id="2-8-setdefault"><a href="#2-8-setdefault" class="headerlink" title="2.8  setdefault"></a>2.8  setdefault</h3><p>作用：setdefault方法在某种程度上类似于get方法，能够获得与给定键相关联的值，除此之外，setdefault还能在字典中不含有给定键的情况下设定相应的键值</p>
<pre class="highlight"><span class="line">d = &#123;<span class="string">'Tom'</span>:<span class="number">8777</span>,<span class="string">'Jack'</span>:<span class="number">8888</span>,<span class="string">'Fly'</span>:<span class="number">6666</span>&#125;</span><br><span class="line">d.setdefault(``<span class="string">'Tom'</span>``)              </span><br><span class="line"><span class="comment">#the result ： 8777</span></span><br><span class="line">print(d.setdefault(<span class="string">'Test'</span>))          </span><br><span class="line"><span class="comment">#the result ： None</span></span><br><span class="line">print(d)                  </span><br><span class="line"><span class="comment">#&#123;'Fly': 6666, 'Jack': 8888, 'Tom': 8777, 'Test': None&#125;</span></span><br></pre>

<h3 id="2-9-update"><a href="#2-9-update" class="headerlink" title="2.9  update"></a>2.9  update</h3><p>作用：update方法可以利用一个字典项更新另一个字典，提供的字典中的项会被添加到旧的字典中，如有相同的键则会被覆盖</p>
<pre class="highlight"><span class="line">d = &#123;<span class="string">'Tom'</span>:<span class="number">8777</span>,<span class="string">'Jack'</span>:<span class="number">8888</span>,<span class="string">'Fly'</span>:<span class="number">6666</span>&#125;``</span><br><span class="line">a = &#123;<span class="string">'Tom'</span>:<span class="number">110</span>,<span class="string">'Test'</span>:<span class="number">119</span>&#125;</span><br><span class="line">d.update(a)</span><br><span class="line">prin t(d)            </span><br><span class="line"><span class="comment">#the result ：&#123;'Fly': 6666, 'Test': 119, 'Jack': 8888, 'Tom': 110&#125;</span></span><br></pre>
<h3 id="2-10-将两个列表组合成字典"><a href="#2-10-将两个列表组合成字典" class="headerlink" title="2.10 将两个列表组合成字典"></a>2.10 将两个列表组合成字典</h3><pre class="highlight"><span class="line">keys = [<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line">values = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment">#1、zip生成字典print(dict(zip(keys,values)))                   # &#123;'a': 1, 'b': 2&#125;</span></span><br><span class="line"><span class="comment">#2、for循环推倒字典</span></span><br><span class="line">print(&#123;keys[i]: values[i] </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(keys))&#125;)       </span><br><span class="line"><span class="comment"># &#123;'a': 1, 'b': 2&#125;</span></span><br></pre>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="1-集合作用"><a href="#1-集合作用" class="headerlink" title="1.集合作用　"></a>1.集合作用　</h2><p>1.1  去重 　　<br>1.2 取两个列表的交集 　<br>1.3 取两个列表的并集</p>
<pre class="highlight"><span class="line">list_1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#1、去重(去除list_1中重复元素1,2)</span></span><br><span class="line">list_1 = set(list_1)                  </span><br><span class="line"></span><br><span class="line"><span class="comment">#去重： &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line">print(list_1)</span><br><span class="line">list_2 = set([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、交集（在list_1和list_2中都有的元素4,5）</span></span><br><span class="line">print(list_1.intersection(list_2))           </span><br><span class="line"></span><br><span class="line"><span class="comment">#交集： &#123;4, 5&#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3、并集（在list_1和list_2中的元素全部打印出来，重复元素仅打印一次）</span></span><br><span class="line">print(list_1.union(list_2))               </span><br><span class="line"></span><br><span class="line"><span class="comment">#并集： &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4、差集</span></span><br><span class="line">print(list_1.difference(list_2))            </span><br><span class="line"><span class="comment">#差集：在list_1中有在list_2中没有：  &#123;1, 2, 3&#125;</span></span><br><span class="line">print(list_2.difference(list_1))            </span><br><span class="line"></span><br><span class="line"><span class="comment">#差集：在list_1中有在list_2中没有：  &#123;8, 6, 7&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5、子集</span></span><br><span class="line">print(list_1.issubset(list_2))             </span><br><span class="line"></span><br><span class="line"><span class="comment">#子集：  False  List_1中的元素是否全部在list2中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#6、父集</span></span><br><span class="line">print(list_1.issuperset(list_2))            </span><br><span class="line"></span><br><span class="line"><span class="comment">#父集：  False  List_1中是否包含list_2中的所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#7、交集</span></span><br><span class="line">print(list_1 &amp; list_2)                 </span><br><span class="line"></span><br><span class="line"><span class="comment">#交集  &#123;4, 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#8、union并集</span></span><br><span class="line">print(list_1 | list_2)                 </span><br><span class="line"></span><br><span class="line"><span class="comment">#并集： &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#9、difference差集</span></span><br><span class="line">print(list_1 - list_2)                 <span class="comment">#差集：  &#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#10、在集合中添加一个元素999</span></span><br><span class="line">list_1.add(<span class="number">999</span>)</span><br><span class="line">print(list_1)                      </span><br><span class="line"></span><br><span class="line"><span class="comment">#Add()方法：     </span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">999</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#11、删除集合中任意一个元素不会打印删除的值</span></span><br><span class="line">list_1.pop()                      </span><br><span class="line"></span><br><span class="line"><span class="comment">#Pop()方法：      </span></span><br><span class="line">无返回值</span><br><span class="line"></span><br><span class="line"><span class="comment">#12、discard删除集合中的指定元素，如过没有则返回None</span></span><br><span class="line">print(list_1.discard(<span class="string">"ddd"</span>))       </span><br><span class="line"></span><br><span class="line"><span class="comment">#Discard()方法：  删除指定的值，没有返回None</span></span><br></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>一次完整的HTTP请求过程</title>
    <url>/2018/11/20/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="问题：当我们在web浏览器的地址栏中输入：www-baidu-com，具体发生了什么？"><a href="#问题：当我们在web浏览器的地址栏中输入：www-baidu-com，具体发生了什么？" class="headerlink" title="问题：当我们在web浏览器的地址栏中输入：www.baidu.com，具体发生了什么？"></a>问题：当我们在web浏览器的地址栏中输入：<a href="www.baidu.com">www.baidu.com</a>，具体发生了什么？</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>对<a href="www.baidu.com">www.baidu.com</a>这个网址进行DNS域名解析，得到对应的IP地址</li>
<li>根据这个IP，找到对应的服务器，发起TCP的三次握手</li>
<li>建立TCP连接后发起HTTP请求</li>
<li>服务器响应HTTP请求，浏览器得到html代码</li>
<li>浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）（先得到html代码，才能去找这些资源）</li>
<li>浏览器对页面进行渲染呈现给用户</li>
<li>服务器关闭关闭TCP连接</li>
</ol>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><h5 id="1-DNS怎么找到域名的？"><a href="#1-DNS怎么找到域名的？" class="headerlink" title="1.DNS怎么找到域名的？"></a>1.DNS怎么找到域名的？</h5><pre class="highlight"><span class="line">DNS域名解析采用的是递归查询的方式，过程是，先去找DNS缓存-&gt;缓存找不到就去找根域名服务器-&gt;根域名又会去找下一级，这样递归查找之后，找到了，给我们的web浏览器</span><br></pre>
<h5 id="2-为什么HTTP协议要基于TCP来实现？"><a href="#2-为什么HTTP协议要基于TCP来实现？" class="headerlink" title="2.为什么HTTP协议要基于TCP来实现？"></a>2.为什么HTTP协议要基于TCP来实现？</h5><pre class="highlight"><span class="line">TCP是一个端到端的可靠的面相连接的协议，HTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，会重传）</span><br></pre>

<h5 id="3-最后一步浏览器是如何对页面进行渲染的？"><a href="#3-最后一步浏览器是如何对页面进行渲染的？" class="headerlink" title="3.最后一步浏览器是如何对页面进行渲染的？"></a>3.最后一步浏览器是如何对页面进行渲染的？</h5><pre class="highlight"><span class="line">a)  解析html文件构成 DOM树</span><br><span class="line">b）解析CSS文件构成渲染树</span><br><span class="line">c）边解析，边渲染</span><br><span class="line">d）JS 单线程运行，JS有可能修改DOM结构，意味着JS执行完成前，后续所有资源的下载是没有必要的，所以JS是单线程，会阻塞后续资源下载</span><br></pre>

<h2 id="各个步骤具体细节"><a href="#各个步骤具体细节" class="headerlink" title="各个步骤具体细节"></a>各个步骤具体细节</h2><h5 id="DNS解析（域名解析服务器）"><a href="#DNS解析（域名解析服务器）" class="headerlink" title="DNS解析（域名解析服务器）"></a>DNS解析（域名解析服务器）</h5><p>a）首先会搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存）</p>
<p>b）如果浏览器自身的缓存里面没有找到，那么浏览器会搜索系统自身的DNS缓存</p>
<p>c）如果还没有找到，那么尝试从 hosts文件里面去找</p>
<p>d）在前面三个过程都没获取到的情况下，就递归地去域名服务器去查找，具体过程如下<br><img src="https://img-blog.csdnimg.cn/20200707212544343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU4Nzg2NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200707212544343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU4Nzg2NA==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h6 id="DNS优化两个方面：DNS缓存、DNS负载均衡"><a href="#DNS优化两个方面：DNS缓存、DNS负载均衡" class="headerlink" title="DNS优化两个方面：DNS缓存、DNS负载均衡"></a>DNS优化两个方面：DNS缓存、DNS负载均衡</h6><h2 id="TCP连接建立（三次握手）"><a href="#TCP连接建立（三次握手）" class="headerlink" title="TCP连接建立（三次握手）"></a>TCP连接建立（三次握手）</h2><p>　　拿到域名对应的IP地址之后，User-Agent（一般指浏览器）会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd，nginx）等的80端口。这个连接请求（原始的http请求经过TCP/IP4层模型的层层封包）到达服务器端后（这中间有各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终达到WEB程序，最终建立了TCP/IP的连接</p>
<h2 id="发起HTTP请求-建立连接后"><a href="#发起HTTP请求-建立连接后" class="headerlink" title="发起HTTP请求(建立连接后)"></a>发起HTTP请求(建立连接后)</h2><p>HTTP请求报文由三部分组成：请求行，请求头、空格、请求正文</p>
<p>请求行：用于描述客户端的请求方式（GET/POST等），请求的资源名称(URL)以及使用的HTTP协议的版本号</p>
<p>请求头：用于描述客户端请求哪台主机及其端口，以及客户端的一些环境信息等</p>
<p>空行：空行就是\r\n (POST请求时候有)</p>
<p>请求正文：当使用POST等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中（GET方式是保存在url地址后面，不会放到这里）</p>
<h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><p>下面是浏览器对 <a href="http://localhost:8081/test?name=XXG&amp;age=23的GET" target="_blank" rel="noopener">http://localhost:8081/test?name=XXG&amp;age=23的GET</a> 请求时发送给服务器的数据：<br><img src="https://img-blog.csdnimg.cn/2020070721290553.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/2020070721290553.png" class="lozad post-image"></p>
<p>可以看出请求包含请求行和请求头两部分。其中请求行中包含 method（例如 GET、POST）、URI（通一资源标志符）和协议版本三部分，三个部分之间以空格分开。请求行和每个请求头各占一行，以换行符 CRLF（即 \r\n）分割。</p>
<h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><p>下面是浏览器对 <a href="http://localhost:8081/test" target="_blank" rel="noopener">http://localhost:8081/test</a> 的 POST 请求时发送给服务器的数据，消息体中带上参数 name=XXG&amp;age=23<br><img src="https://img-blog.csdnimg.cn/20200707213226601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU4Nzg2NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200707213226601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU4Nzg2NA==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>可以看出，上面的请求包含三个部分：请求行、请求头、空格、消息体，比之前的 GET 请求多了一个请求消息，其中 请求头和消息体之间用一个空行分割。POST 请求的参数不在 URL 中，而是在消息体中，请求头中多了一项 Content-Length 用于表示消息体的字节数，这样服务器才能知道请求是否发送结束。这也就是 GET 请求和 POST 请求的主要区别。</p>
<p>那么<strong>起始行中的请求方法</strong>有哪些种呢？</p>
<pre class="highlight"><span class="line">GET: 完整请求一个资源 （常用）</span><br><span class="line">  HEAD: 仅请求响应首部</span><br><span class="line">  POST：提交表单  （常用）</span><br><span class="line">  PUT: (webdav) 上传文件（但是浏览器不支持该方法）</span><br><span class="line">  DELETE：(webdav) 删除</span><br><span class="line">  OPTIONS：返回请求的资源所支持的方法的方法</span><br><span class="line">  TRACE: 追求一个资源请求中间所经过的代理（该方法不能由浏览器发出）</span><br></pre>
<p>那什么是URL、URI、URN？</p>
<pre class="highlight"><span class="line">URI  Uniform Resource Identifier 统一资源标识符</span><br><span class="line">URL  Uniform Resource Locator 统一资源定位符</span><br><span class="line">URN  Uniform Resource Name 统一资源名称</span><br></pre>
<p>URL和URN 都属于 URI，为了方便就把URL和URI暂时都通指一个东西</p>
<h3 id="服务器响应http请求，浏览器得到html代码"><a href="#服务器响应http请求，浏览器得到html代码" class="headerlink" title="服务器响应http请求，浏览器得到html代码"></a>服务器响应http请求，浏览器得到html代码</h3><p>HTTP响应也由三部分组成：状态行，响应头，空格，消息体</p>
<p>状态行包括：协议版本、状态码、状态码描述</p>
<p><strong>状态码</strong>：状态码用于表示服务器对请求的处理结果</p>
<pre class="highlight"><span class="line">1xx：指示信息——表示请求已经接受，继续处理</span><br><span class="line">2xx：成功——表示请求已经被成功接收、理解、接受。</span><br><span class="line">3xx：重定向——要完成请求必须进行更进一步的操作</span><br><span class="line">4xx：客户端错误——请求有语法错误或请求无法实现</span><br><span class="line">5xx：服务器端错误——服务器未能实现合法的请求。</span><br></pre>
<p>列举几种常见的：</p>
<pre class="highlight"><span class="line">200（没有问题） </span><br><span class="line">302（要你去找别人） </span><br><span class="line">304（要你去拿缓存） </span><br><span class="line">307（要你去拿缓存） </span><br><span class="line">403（有这个资源，但是没有访问权限） </span><br><span class="line">404（服务器没有这个资源） </span><br><span class="line">500（服务器这边有问题）</span><br></pre>

<p><strong>响应头</strong>：响应头用于描述服务器的基本信息，以及客户端如何处理数据</p>
<p><strong>空格</strong>：CRLF（即 \r\n）分割</p>
<p><strong>消息体</strong>：服务器返回给客户端的数据</p>
<p>响应格式如下图<br><img src="https://img-blog.csdnimg.cn/20200707213625670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU4Nzg2NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200707213625670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzU4Nzg2NA==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>上面的 HTTP 响应中，响应头中的 Content-Length 同样用于表示消息体的字节数。Content-Type 表示消息体的类型，通常浏览网页其类型是HTML，当然还会有其他类型，比如图片、视频等。</p>
<h3 id="浏览器解析html代码，并请求html代码中的资源"><a href="#浏览器解析html代码，并请求html代码中的资源" class="headerlink" title="浏览器解析html代码，并请求html代码中的资源"></a>浏览器解析html代码，并请求html代码中的资源</h3><p>浏览器拿到html文件后，就开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这是时候就用上 keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里面的顺序，但是由于每个资源大小不一样，而浏览器又是多线程请求请求资源，所以这里显示的顺序并不一定是代码里面的顺序。</p>
<h3 id="浏览器对页面进行渲染呈现给用户"><a href="#浏览器对页面进行渲染呈现给用户" class="headerlink" title="浏览器对页面进行渲染呈现给用户"></a>浏览器对页面进行渲染呈现给用户</h3><p>最后，浏览器利用自己内部的工作机制，把请求的静态资源和html代码进行渲染，渲染之后呈现给用户，浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，JS有可能修改DOM结构，意味着JS执行完成前，后续所有资源的下载是没有必要的，所以JS是单线程，会阻塞后续资源下载。</p>
<h3 id="服务器关闭关闭TCP连接"><a href="#服务器关闭关闭TCP连接" class="headerlink" title="服务器关闭关闭TCP连接"></a>服务器关闭关闭TCP连接</h3><p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：</p>
<pre class="highlight"><span class="line">Connection:keep-alive</span><br></pre>
<p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>
<h2 id="自此一次完整的HTTP事务宣告完成"><a href="#自此一次完整的HTTP事务宣告完成" class="headerlink" title="自此一次完整的HTTP事务宣告完成."></a>自此一次完整的HTTP事务宣告完成.</h2><h6 id="转载于：https-www-cnblogs-com-WindSun-p-11489356-html"><a href="#转载于：https-www-cnblogs-com-WindSun-p-11489356-html" class="headerlink" title="转载于：https://www.cnblogs.com/WindSun/p/11489356.html"></a>转载于：<a href="https://www.cnblogs.com/WindSun/p/11489356.html" target="_blank" rel="noopener">https://www.cnblogs.com/WindSun/p/11489356.html</a></h6>]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程爬虫</title>
    <url>/2018/08/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h2 id="1-整体思路"><a href="#1-整体思路" class="headerlink" title="1.整体思路"></a>1.整体思路</h2><pre class="highlight"><span class="line">&gt; 队列保存变化的参数，即之前构建的类似页码的东西。</span><br><span class="line"></span><br><span class="line">&gt; 一个类实现：三个线程进行数据采集，依次从队列中获取参数，拼接url，请求到的网	页源码保存到新队列。</span><br><span class="line"></span><br><span class="line">&gt; 一个类实现 ：1.  三个线程进行数据处理，依次从队列中获取源码，xpath定位元素	取出文本，构建字典。2. 定义函数数据入库，pymongon数据插入数据即可</span><br><span class="line"></span><br><span class="line">主程序 mian 分为 两 部分</span><br><span class="line"></span><br><span class="line">- 实例化队列，我们有两组线程在工作，初始队列一个，线程间通信需要一个，一共两个</span><br><span class="line"></span><br><span class="line">- 实例化线程，通过遍历实例化线程类，创建俩组三线程。</span><br><span class="line"></span><br><span class="line">调用主程序</span><br></pre>
<hr>
<h2 id="2-具体部署"><a href="#2-具体部署" class="headerlink" title="2.具体部署"></a>2.具体部署</h2><pre class="highlight"><span class="line">定义第一个类：</span><br><span class="line"></span><br><span class="line">  定义类：需要继承threading.Thread父类</span><br><span class="line"></span><br><span class="line">  类属性：想清楚传那些熟悉</span><br><span class="line"></span><br><span class="line">   1. 参数队列要传进来</span><br><span class="line"></span><br><span class="line">   2. 子类重写初始化属性</span><br><span class="line"></span><br><span class="line">      先继承父类属性----&gt;然后写自己要加的属性</span><br><span class="line"></span><br><span class="line">  定义方法：</span><br><span class="line"></span><br><span class="line">   重写run方法</span><br><span class="line"></span><br><span class="line">   ​	通过无限循环获取队列中的参数，实现请求多页面，</span><br><span class="line"></span><br><span class="line">   ​	这个队列是被三个线程去访问的。</span><br><span class="line"></span><br><span class="line">定义第二个类：</span><br><span class="line"></span><br><span class="line"> ​	需要考虑的和第一个类思路是一样的，这里有一个互斥锁的加入</span><br><span class="line"></span><br><span class="line"> ​	就是在处理数据的时候加入，因为写入数据库的字段都一样，避免数据量过大</span><br><span class="line"></span><br><span class="line"> ​	出错，导致数据错乱。</span><br><span class="line"></span><br><span class="line">主程序代码</span><br><span class="line"></span><br><span class="line">  实例队列对象</span><br><span class="line"></span><br><span class="line">   page_Queue &#x3D; Queue() 构建参数</span><br><span class="line"></span><br><span class="line">   data_Queue &#x3D; Queue() 负责两个主线程间的通信</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  实例互斥锁对象</span><br><span class="line"></span><br><span class="line">   lock &#x3D; Lock()</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  构建两个主线程，一个线程负责采集数据，一个线程处理数据并入库</span><br><span class="line"></span><br><span class="line">  当然都是用for循环来构建的，记得线程类需要传入那些属性</span><br><span class="line"></span><br><span class="line">调用主程序</span><br></pre>
<hr>
<h4 id="重写父类同名方法需要注意"><a href="#重写父类同名方法需要注意" class="headerlink" title="重写父类同名方法需要注意:"></a>重写父类同名方法需要注意:</h4><pre class="highlight"><span class="line">class ParseTread(threading.Thread):</span><br><span class="line">    def __init__(self, threadName, dataQueue, lock):</span><br><span class="line">        # 先把父类的方法继承下来</span><br><span class="line">        super(ParseTread, self).__init__()</span><br><span class="line">        # 然后定义自己的方法</span><br><span class="line">        self.threadName &#x3D; threadName</span><br><span class="line">        self.dataQueue &#x3D; dataQueue</span><br><span class="line">        self.lock &#x3D; lock</span><br></pre>
<hr>
<h4 id="首先明白什么是进程什么是线程，线程和进程的区别？"><a href="#首先明白什么是进程什么是线程，线程和进程的区别？" class="headerlink" title="首先明白什么是进程什么是线程，线程和进程的区别？"></a>首先明白什么是进程什么是线程，线程和进程的区别？</h4><pre class="highlight"><span class="line"> 线程（有时候称为轻量级进程）与进程类似，不过它们是在同一个进程下执行的，并共享相同的上下文。可以将它们认为是在一个主进程或“主线程”中并行运行的一些“迷你进程”。 </span><br><span class="line"></span><br><span class="line"> 这里讲的很清楚&lt;https:&#x2F;&#x2F;www.cnblogs.com&#x2F;chbo&#x2F;p&#x2F;7043660.html&gt; </span><br><span class="line"></span><br><span class="line">我们的子线程为什么要设置join()，其实设置了守护线程才是join()出现的时机</span><br><span class="line"></span><br><span class="line"> 如果是为了避免数据的恶性竞争的话，互斥锁是接这个的小能手。</span><br><span class="line"></span><br><span class="line">为什么要设置守护线程</span><br><span class="line"></span><br><span class="line"> 如果给线程设置守护线程，那么后台线程执行完毕就会杀死这些线程。大致的作用就是当你退出进程，后台线程关闭那么这些子线程也要同时关闭。</span><br><span class="line"></span><br><span class="line">join()的作用，和其存在的意义</span><br><span class="line"></span><br><span class="line"> join()的功能是设置阻塞，之所以要设置join()就是有选择的设置守护线程，因为我们有的线程需要同步主线程结束而结束，而有的线程需要执行完毕菜行。设置了守护线程的子线程都会随着主线的结束而结束。</span><br><span class="line"></span><br><span class="line"> 我们这里设置的join()是没有意义的，因为并没有设置守护线程，因此没必要设置阻塞。</span><br></pre>
<hr>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">from urllib import request</span><br><span class="line">from chaojiying import Chaojiying_Client</span><br><span class="line">from lxml import etree</span><br><span class="line">import re, threading</span><br><span class="line">from threading import Lock</span><br><span class="line">from queue import Queue</span><br><span class="line">import pymongo</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CrawlThread(threading.Thread):</span><br><span class="line">    def __init__(self, threadName, page_Queue, data_Queue):</span><br><span class="line">        super(CrawlThread, self).__init__()</span><br><span class="line">        self.threadName &#x3D; threadName</span><br><span class="line">        self.pageQueue &#x3D; page_Queue</span><br><span class="line">        self.dataQueue &#x3D; data_Queue</span><br><span class="line">        self.headers &#x3D; &#123;&quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;74.0.3729.169 Safari&#x2F;537.36&quot;,&#125;</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        url1 &#x3D; &#39;http:&#x2F;&#x2F;www.ziroom.com&#x2F;z&#x2F;nl&#x2F;z3.html?p&#x3D;%s&#39;</span><br><span class="line">        while True:</span><br><span class="line">            try:</span><br><span class="line">                # 如果队列为空 block 为 True 那么进入阻塞状态</span><br><span class="line">                # 如果队列为控 block 为 false 那么会抛出异常</span><br><span class="line">                p &#x3D; self.pageQueue.get(block&#x3D;False)</span><br><span class="line">                print(&#39;%s开始工作...&#39; % self.threadName)</span><br><span class="line">                response &#x3D; requests.get(url&#x3D;url1 % p, headers&#x3D;self.headers)</span><br><span class="line">                content &#x3D; response.text</span><br><span class="line">                self.dataQueue.put(content)</span><br><span class="line">                # print(self.dataQueue.qsize())</span><br><span class="line">                print(&#39;%s工作结束...&#39; % self.threadName)</span><br><span class="line">            except:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">class ParseTread(threading.Thread):</span><br><span class="line">    def __init__(self, threadName, dataQueue, lock):</span><br><span class="line">        super(ParseTread, self).__init__()</span><br><span class="line">        self.threadName &#x3D; threadName</span><br><span class="line">        self.dataQueue &#x3D; dataQueue</span><br><span class="line">        self.lock &#x3D; lock</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        while True:</span><br><span class="line">            try:</span><br><span class="line">                html &#x3D; self.dataQueue.get(block&#x3D;False)</span><br><span class="line">                print(&#39;%s开始处理数据........&#39; % self.threadName)</span><br><span class="line">                self.get_price_list(html)</span><br><span class="line">                print(&#39;%s数据处理完毕........&#39; % self.threadName)</span><br><span class="line">            except Exception as e:</span><br><span class="line">                print(e)</span><br><span class="line">                # print(&#39;出错了&#39;)</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">    def get_price_list(self, html):</span><br><span class="line">        # 正则匹配图片地址，超级鹰打码，获取列表两个参数 code 下标列表</span><br><span class="line">        price_image &#x3D; re.findall(r&#39;&quot;image&quot;:&quot;(.*?)&quot;&#39;, html)[0]</span><br><span class="line">        index_list &#x3D; re.findall(r&#39;&quot;offset&quot;:(.*?)&#125;;&#39;, html)[0]</span><br><span class="line">        index_list &#x3D; eval(index_list)</span><br><span class="line">        # print(index_list)</span><br><span class="line">        price_image_link &#x3D; &#39;http:&#39; + price_image</span><br><span class="line">        # print(price_image_link)</span><br><span class="line">        request.urlretrieve(price_image_link, &#39;.&#x2F;im.jpg&#39;)</span><br><span class="line">        # 超级鹰打码，获取到图片中的数字</span><br><span class="line">        chaojiying &#x3D; Chaojiying_Client(&#39;ipython&#39;, &#39;123456789&#39;, &#39;96001&#39;)</span><br><span class="line">        im &#x3D; open(&#39;im.jpg&#39;, &#39;rb&#39;).read()</span><br><span class="line">        code &#x3D; chaojiying.PostPic(im, 4111)[&#39;pic_str&#39;]</span><br><span class="line">        price_list &#x3D; []</span><br><span class="line">        for j in index_list:</span><br><span class="line">            # print(j)</span><br><span class="line">            str1 &#x3D; &#39;&#39;</span><br><span class="line">            for i in j:</span><br><span class="line">                str1 +&#x3D; code[int(i)]</span><br><span class="line">            # print(code)</span><br><span class="line">            # print(str1)</span><br><span class="line">            price_list.append(int(str1))</span><br><span class="line">        self.get_detail_list(html, price_list)</span><br><span class="line"></span><br><span class="line">    def get_detail_list(self, html, price_list):</span><br><span class="line">        html &#x3D; etree.HTML(html)</span><br><span class="line">        data_list &#x3D; html.xpath(&#39;&#x2F;&#x2F;ul[@id&#x3D;&quot;houseList&quot;]&#x2F;li&#39;)</span><br><span class="line">        a &#x3D; 0</span><br><span class="line">        for i in data_list:</span><br><span class="line">            item &#x3D; &#123;&#125;</span><br><span class="line">            title &#x3D; i.xpath(&#39;.&#x2F;&#x2F;h3&#x2F;a[@class&#x3D;&quot;t1&quot;]&#x2F;text()&#39;)[0]</span><br><span class="line">            size_detail &#x3D; i.xpath(&#39;.&#x2F;&#x2F;div[@class&#x3D;&quot;detail&quot;]&#x2F;p&#39;)[0].xpath(&#39;.&#x2F;&#x2F;span&#x2F;text()&#39;)</span><br><span class="line">            position &#x3D; i.xpath(&#39;.&#x2F;&#x2F;div[@class&#x3D;&quot;detail&quot;]&#x2F;p&#39;)[1].xpath(&#39;.&#x2F;&#x2F;span&#x2F;text()&#39;)[0]</span><br><span class="line">            item &#x3D; &#123;&#39;标题&#39;: title, &#39;面积&#39;: size_detail, &#39;位置&#39;: position, &#39;价格&#39;: price_list[a]&#125;</span><br><span class="line">            a +&#x3D; 1</span><br><span class="line">            with self.lock:</span><br><span class="line">                self.save(item)</span><br><span class="line"></span><br><span class="line">    def save(self, item):</span><br><span class="line">        conn &#x3D; pymongo.MongoClient(&quot;localhost&quot;,27017)</span><br><span class="line">        db &#x3D; conn.qiubai</span><br><span class="line">        table &#x3D; db.qiubai</span><br><span class="line">        table.insert(item)</span><br><span class="line">       </span><br><span class="line">def main(n):</span><br><span class="line">    page_Queue &#x3D; Queue()</span><br><span class="line">    data_Queue &#x3D; Queue()</span><br><span class="line">    lock &#x3D; Lock()</span><br><span class="line">    for i in range(1,n+1):</span><br><span class="line">        page_Queue.put(i)</span><br><span class="line"></span><br><span class="line">    crawlList &#x3D; &#123;&#39;长征1号&#39;, &#39;长征2号&#39;, &#39;长征3号&#39;&#125;</span><br><span class="line">    TreadCrawl &#x3D; []</span><br><span class="line">    for var in crawlList:</span><br><span class="line">        c &#x3D; CrawlThread(var, page_Queue, data_Queue)</span><br><span class="line">        c.start()</span><br><span class="line">        TreadCrawl.append(c)</span><br><span class="line">    for var in TreadCrawl:</span><br><span class="line">        var.join()</span><br><span class="line">    parseList &#x3D; [&#39;嫦娥1号&#39;, &#39;嫦娥2号&#39;, &#39;嫦娥3号&#39;]</span><br><span class="line">    TreadParse &#x3D; []</span><br><span class="line">    for var in parseList:</span><br><span class="line">        p &#x3D; ParseTread(var, data_Queue, lock)</span><br><span class="line">        p.start()</span><br><span class="line">        TreadParse.append(p)</span><br><span class="line">    for var in TreadParse:</span><br><span class="line">        var.join()</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main(10)</span><br></pre>
<hr>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>增量式与分布式</title>
    <url>/2018/08/09/%E5%A2%9E%E9%87%8F%E5%BC%8F%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="基于crawlSpider的全站数据爬取"><a href="#基于crawlSpider的全站数据爬取" class="headerlink" title="基于crawlSpider的全站数据爬取"></a>基于crawlSpider的全站数据爬取</h3><pre class="highlight"><span class="line"># 项目的创建</span><br><span class="line">scrapy startproject projectname</span><br><span class="line">scrapy genspider -t crawl spidername www.baidu.com</span><br></pre>
<pre class="highlight"><span class="line"># crawlspider全站数据爬取:</span><br><span class="line">- CrawlSpider是一个爬虫类, 是scrapy.spider的子类, 功能比spider更强大.</span><br><span class="line">- CrawlSpider的机制:</span><br><span class="line">    - 连接提取器: 可以根据指定的规则进行连接的提取</span><br><span class="line">    - 规则解析器: 更具指定的规则对响应数据进行解析</span><br></pre>
<h4 id="案例-基于CrawlSpider对笑话网进行全站深度数据爬取-抓取笑话标题与内容-并存储于MongoDB中"><a href="#案例-基于CrawlSpider对笑话网进行全站深度数据爬取-抓取笑话标题与内容-并存储于MongoDB中" class="headerlink" title="案例: 基于CrawlSpider对笑话网进行全站深度数据爬取, 抓取笑话标题与内容, 并存储于MongoDB中"></a>案例: 基于CrawlSpider对笑话网进行全站深度数据爬取, 抓取笑话标题与内容, 并存储于MongoDB中</h4><pre class="highlight"><span class="line"># item编码:</span><br><span class="line">import scrapy</span><br><span class="line">class JokeItem(scrapy.Item):</span><br><span class="line">    title &#x3D; scrapy.Field()</span><br><span class="line">    content &#x3D; scrapy.Field()</span><br></pre>

<pre class="highlight"><span class="line"># spider编码:</span><br><span class="line">import scrapy</span><br><span class="line">from scrapy.linkextractors import LinkExtractor</span><br><span class="line">from scrapy.spiders import CrawlSpider, Rule</span><br><span class="line">from..items import JokeItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ZSpider(CrawlSpider):</span><br><span class="line">    name &#x3D; &#39;z&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;http:&#x2F;&#x2F;xiaohua.zol.com.cn&#x2F;lengxiaohua&#x2F;&#39;]</span><br><span class="line">    link &#x3D; LinkExtractor(allow&#x3D;r&#39;&#x2F;lengxiaohua&#x2F;\d+.html&#39;)</span><br><span class="line">    link_detail &#x3D; LinkExtractor(allow&#x3D;r&#39;.*?\d+\.html&#39;)</span><br><span class="line">    rules &#x3D; (</span><br><span class="line">        Rule(link, callback&#x3D;&#39;parse_item&#39;, follow&#x3D;True),</span><br><span class="line">        Rule(link_detail, callback&#x3D;&#39;parse_detail&#39;),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    def parse_item(self, response):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def parse_detail(self, response):</span><br><span class="line">        title &#x3D; response.xpath(&#39;&#x2F;&#x2F;h1[@class&#x3D;&quot;article-title&quot;]&#x2F;text()&#39;).extract_first()</span><br><span class="line">        content &#x3D; response.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;article-text&quot;]&#x2F;&#x2F;text()&#39;).extract()</span><br><span class="line">        content &#x3D; &#39;&#39;.join(content)</span><br><span class="line"></span><br><span class="line">        if title and content:</span><br><span class="line">            item &#x3D; JokeItem()</span><br><span class="line">            item[&quot;title&quot;] &#x3D; title</span><br><span class="line">            item[&quot;content&quot;] &#x3D; content</span><br><span class="line">            print(dict(item))</span><br><span class="line">            yield item</span><br></pre>

<pre class="highlight"><span class="line"># pipeline编码:</span><br><span class="line">class JokePipeline(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, mongo_uri, mongo_db):</span><br><span class="line">        self.mongo_uri &#x3D; mongo_uri</span><br><span class="line">        self.mongo_db &#x3D; mongo_db</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_crawler(cls, crawler):</span><br><span class="line">        return cls(</span><br><span class="line">            mongo_uri&#x3D;crawler.settings.get(&#39;MONGO_URI&#39;),</span><br><span class="line">            mongo_db&#x3D;crawler.settings.get(&#39;MONGO_DB&#39;)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def open_spider(self, spider):</span><br><span class="line">        self.client &#x3D; pymongo.MongoClient(self.mongo_uri)</span><br><span class="line">        self.db &#x3D; self.client[self.mongo_db]</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        self.db[&quot;joke&quot;].insert(dict(item))</span><br><span class="line">        return item</span><br><span class="line"></span><br><span class="line">    def close(self, spider):</span><br><span class="line">        self.client.close()</span><br></pre>

<h4 id="电影天堂-全站深度抓取电影名与下载链接"><a href="#电影天堂-全站深度抓取电影名与下载链接" class="headerlink" title="电影天堂: 全站深度抓取电影名与下载链接:"></a>电影天堂: 全站深度抓取电影名与下载链接:</h4><pre class="highlight"><span class="line"># item定义存储字段:</span><br><span class="line">import scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BossItem(scrapy.Item):</span><br><span class="line">    title &#x3D; scrapy.Field()</span><br><span class="line">    downloadlink &#x3D; scrapy.Field()</span><br></pre>

<pre class="highlight"><span class="line"># spider编码:</span><br><span class="line">import scrapy</span><br><span class="line">from scrapy.linkextractors import LinkExtractor</span><br><span class="line">from scrapy.spiders import CrawlSpider, Rule</span><br><span class="line">from ..items import MvItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BSpider(CrawlSpider):</span><br><span class="line">    name &#x3D; &#39;mv&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;https:&#x2F;&#x2F;www.ygdy8.net&#x2F;html&#x2F;gndy&#x2F;oumei&#x2F;index.html&#39;]</span><br><span class="line">    link &#x3D; LinkExtractor(allow&#x3D;r&#39;list.*?html&#39;)</span><br><span class="line">    link_detail &#x3D; LinkExtractor(allow&#x3D;r&#39;.*?&#x2F;\d+\.html&#39;)</span><br><span class="line">    rules &#x3D; (</span><br><span class="line">        Rule(link, callback&#x3D;&#39;parse_item&#39;, follow&#x3D;True,),</span><br><span class="line">        Rule(link_detail, callback&#x3D;&#39;parse_detail&#39;, follow&#x3D;True,),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    def parse_item(self, response):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def parse_detail(self, response):</span><br><span class="line">        title &#x3D; response.xpath(&#39;&#x2F;&#x2F;h1&#x2F;&#x2F;text()&#39;).extract_first()</span><br><span class="line">        downloadlink &#x3D; response.xpath(&#39;&#x2F;&#x2F;tbody&#x2F;tr&#x2F;td&#x2F;a&#x2F;text()&#39;).extract_first()</span><br><span class="line">        if title and downloadlink and &#39;ftp&#39; in downloadlink:</span><br><span class="line">            item &#x3D; BossItem()</span><br><span class="line">            item[&#39;title&#39;] &#x3D; title</span><br><span class="line">            item[&#39;downloadlink&#39;] &#x3D; downloadlink</span><br><span class="line">            yield item</span><br></pre>

<pre class="highlight"><span class="line"># piplines编码:</span><br><span class="line">class MvPipeline(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, mongo_uri, mongo_db):</span><br><span class="line">        self.mongo_uri &#x3D; mongo_uri</span><br><span class="line">        self.mongo_db &#x3D; mongo_db</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_crawler(cls, crawler):</span><br><span class="line">        return cls(</span><br><span class="line">            mongo_uri&#x3D;crawler.settings.get(&#39;MONGO_URI&#39;),</span><br><span class="line">            mongo_db&#x3D;crawler.settings.get(&#39;MONGO_DB&#39;)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    def open_spider(self, spider):</span><br><span class="line">        self.client &#x3D; pymongo.MongoClient(self.mongo_uri)</span><br><span class="line">        self.db &#x3D; self.client[self.mongo_db]</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        self.db[&quot;mv&quot;].insert(dict(item))</span><br><span class="line">        return item</span><br><span class="line"></span><br><span class="line">    def close(self, spider):</span><br><span class="line">        self.client.close()</span><br></pre>
<hr>
<h2 id="1-分布式"><a href="#1-分布式" class="headerlink" title="1.分布式"></a>1.分布式</h2><pre class="highlight"><span class="line"># 分布式概念:</span><br><span class="line">使用多台机器组成一个分布式的机群，在机群中运行同一组程序，进行联合数据的爬取。</span><br><span class="line"></span><br><span class="line"># 原生scrapy无法实现分布式原因:</span><br><span class="line">	- 原生的scrapy中的调度器不可以被共享</span><br><span class="line">	- 原生的scrapy的管道不可以被共享</span><br><span class="line"></span><br><span class="line"># 使用scrapy实现分布式思路:</span><br><span class="line">- 为原生的scrapy框架提供共享的管道和调度器</span><br><span class="line">- pip install scrapy_redis</span><br></pre>

<hr>
<pre class="highlight"><span class="line">- 1. 创建工程: scrapy startproject projectname</span><br><span class="line">- 2. 爬虫文件: scrapy genspider -t crawl spidername www.baidu.com</span><br><span class="line">- 3. 修改爬虫文件：</span><br><span class="line">	- 3.1 导包：from scrapy_redis.spiders import RedisCrawlSpider</span><br><span class="line">	- 3.2 将当前爬虫类的父类进行修改RedisCrawlSpider</span><br><span class="line">	- 3.3 allowed_domains，start_url注释掉，添加一个新属性redis_key&#x3D;&#39;qn&#39;(调度器队列的名称)</span><br><span class="line">	- 3.4 指定redis_key &#x3D; &#39;xxx&#39; , 即共享调度器队列名字</span><br><span class="line">	- 3.4 数据解析，将解析的数据封装到item中然后向管道提交</span><br><span class="line">- 4. 配置文件的编写：</span><br><span class="line">	- 4.1 指定管道：</span><br><span class="line">		ITEM_PIPELINES &#x3D; &#123;</span><br><span class="line">			&#39;scrapy_redis.pipelines.RedisPipeline&#39;: 400</span><br><span class="line">		&#125;</span><br><span class="line">	- 4.2 指定调度器：</span><br><span class="line">		# 增加了一个去重容器类的配置, 作用使用Redis的set集合来存储请求的指纹数据, 从而实现请求去重的持久化</span><br><span class="line">		DUPEFILTER_CLASS &#x3D; &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span><br><span class="line">		# 使用scrapy-redis组件自己的调度器</span><br><span class="line">		SCHEDULER &#x3D; &quot;scrapy_redis.scheduler.Scheduler&quot;</span><br><span class="line">		# 配置调度器是否要持久化, 也就是当爬虫结束了, 要不要清空Redis中请求队列和去重指纹的set。如果是True, 就表示要持久化存储, 就不清空数据, 否则清空数据</span><br><span class="line">		SCHEDULER_PERSIST &#x3D; True</span><br><span class="line">	- 4.3 指定具体的redis：</span><br><span class="line">		REDIS_HOST &#x3D; &#39;redis服务的ip地址&#39;</span><br><span class="line">		REDIS_PORT &#x3D; 6379</span><br><span class="line">- 5. 修改Redis配置并指定配置启动：</span><br><span class="line">	- #bind 127.0.0.1</span><br><span class="line">	- protected-mode no</span><br><span class="line">	- 开启redis服务(携带redis的配置文件：redis-server .&#x2F;redis.windows.conf),和客户端(redis-cli)：</span><br><span class="line"></span><br><span class="line">- 6. 启动程序：scrapy runspider xxx.py(需要进入spider文件夹)</span><br><span class="line">- 7. 向调度器队列中扔入一个起始的url（redis的客户端）：lpush xxx www.xxx.com</span><br><span class="line">	(xxx表示的就是redis_key的值)</span><br></pre>

<h4 id="案例-阳光热线问政平台投诉信息爬取–-gt-网址-http-wz-sun0769-com-index-php-question-questionType-type-4"><a href="#案例-阳光热线问政平台投诉信息爬取–-gt-网址-http-wz-sun0769-com-index-php-question-questionType-type-4" class="headerlink" title="案例: 阳光热线问政平台投诉信息爬取–&gt;网址: http://wz.sun0769.com/index.php/question/questionType?type=4"></a>案例: 阳光热线问政平台投诉信息爬取–&gt;网址: <a href="http://wz.sun0769.com/index.php/question/questionType?type=4" target="_blank" rel="noopener">http://wz.sun0769.com/index.php/question/questionType?type=4</a></h4><pre class="highlight"><span class="line"># items编码:</span><br><span class="line">import scrapy</span><br><span class="line">class FbsproItem(scrapy.Item):</span><br><span class="line">    # define the fields for your item here like:</span><br><span class="line">    title &#x3D; scrapy.Field()</span><br></pre>

<pre class="highlight"><span class="line"># spider编码:</span><br><span class="line">import scrapy</span><br><span class="line">from scrapy.linkextractors import LinkExtractor</span><br><span class="line">from scrapy.spiders import CrawlSpider, Rule</span><br><span class="line">from scrapy_redis.spiders import RedisCrawlSpider</span><br><span class="line">from fbspro.items import FbsproItem  </span><br><span class="line">class TestSpider(RedisCrawlSpider):</span><br><span class="line">    name &#x3D; &#39;test&#39;  </span><br><span class="line">    # allowed_domains &#x3D; [&#39;ww.baidu.com&#39;]</span><br><span class="line">    # start_urls &#x3D; [&#39;http:&#x2F;&#x2F;ww.baidu.com&#x2F;&#39;]</span><br><span class="line">    redis_key &#x3D; &#39;urlscheduler&#39;</span><br><span class="line">    link &#x3D; LinkExtractor(allow&#x3D;r&#39;.*?&amp;page&#x3D;\d+&#39;)</span><br><span class="line">    rules &#x3D; (</span><br><span class="line">        Rule(link, callback&#x3D;&#39;parse_item&#39;, follow&#x3D;True),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    def parse_item(self, response):</span><br><span class="line">        a_lst &#x3D; response.xpath(&#39;&#x2F;&#x2F;a[@class&#x3D;&quot;news14&quot;]&#39;)</span><br><span class="line">        for a in a_lst:</span><br><span class="line">            title &#x3D; a.xpath(&#39;.&#x2F;text()&#39;).extract_first()</span><br><span class="line">            # print(title)</span><br><span class="line">            item &#x3D; FbsproItem()</span><br><span class="line">            item[&#39;title&#39;] &#x3D; title</span><br><span class="line">            yield item</span><br></pre>

<pre class="highlight"><span class="line"># settings配置编码:</span><br><span class="line">USER_AGENT &#x3D; &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;76.0.3809.100 Safari&#x2F;537.36&#39;</span><br><span class="line">ROBOTSTXT_OBEY &#x3D; False</span><br><span class="line">CONCURRENT_REQUESTS &#x3D; 3</span><br><span class="line">ITEM_PIPELINES &#x3D; &#123;</span><br><span class="line">   # &#39;fbspro.pipelines.FbsproPipeline&#39;: 300,</span><br><span class="line">    &#39;scrapy_redis.pipelines.RedisPipeline&#39;: 400</span><br><span class="line">&#125;</span><br><span class="line"># 增加了一个去重容器类的配置, 作用使用Redis的set集合来存储请求的指纹数据, 从而实现请求去重的持久化</span><br><span class="line">DUPEFILTER_CLASS &#x3D; &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span><br><span class="line"># 使用scrapy-redis组件自己的调度器</span><br><span class="line">SCHEDULER &#x3D; &quot;scrapy_redis.scheduler.Scheduler&quot;</span><br><span class="line"># 配置调度器是否要持久化, 也就是当爬虫结束了, 要不要清空Redis中请求队列和去重指纹的set。如果是True, 就表示要持久化存储, 就不清空数据, 否则清空数据</span><br><span class="line">SCHEDULER_PERSIST &#x3D; True</span><br><span class="line"></span><br><span class="line"># redis配置</span><br><span class="line">REDIS_HOST &#x3D; &#39;192.168.12.198&#39;</span><br><span class="line">REDIS_PORT &#x3D; 6379</span><br></pre>

<hr>
<h2 id="2-增量式"><a href="#2-增量式" class="headerlink" title="2.增量式"></a>2.增量式</h2><pre class="highlight"><span class="line"># 概念:</span><br><span class="line">	- 检测网站数据更新, 只爬取更新的内容</span><br><span class="line">	- 核心: 去重</span><br><span class="line">        - url</span><br><span class="line">        - 数据指纹</span><br></pre>

<h4 id="增量式爬虫-电影名称与电影类型的爬取–-gt-url-https-www-4567tv-co-list-index1-html"><a href="#增量式爬虫-电影名称与电影类型的爬取–-gt-url-https-www-4567tv-co-list-index1-html" class="headerlink" title="增量式爬虫: 电影名称与电影类型的爬取–&gt;url: https://www.4567tv.co/list/index1.html"></a>增量式爬虫: 电影名称与电影类型的爬取–&gt;url: <a href="https://www.4567tv.co/list/index1.html" target="_blank" rel="noopener">https://www.4567tv.co/list/index1.html</a></h4><pre class="highlight"><span class="line"># items编码:</span><br><span class="line">import scrapy</span><br><span class="line">class MvproItem(scrapy.Item):</span><br><span class="line">    title &#x3D; scrapy.Field()</span><br><span class="line">    position &#x3D; scrapy.Field()</span><br></pre>
<pre class="highlight"><span class="line"># spider编码:</span><br><span class="line">import scrapy</span><br><span class="line">from scrapy.linkextractors import LinkExtractor</span><br><span class="line">from scrapy.spiders import CrawlSpider, Rule</span><br><span class="line">from redis import Redis</span><br><span class="line">from mvpro.items import MvproItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MoveSpider(CrawlSpider):</span><br><span class="line">    conn &#x3D; Redis(&#39;127.0.0.1&#39;, 6379)</span><br><span class="line">    name &#x3D; &#39;move&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;https:&#x2F;&#x2F;www.4567tv.co&#x2F;list&#x2F;index1.html&#39;]</span><br><span class="line">    link &#x3D; LinkExtractor(allow&#x3D;r&#39;&#x2F;list&#x2F;index1-\d+\.html&#39;)</span><br><span class="line">    rules &#x3D; (</span><br><span class="line">        Rule(link, callback&#x3D;&#39;parse_item&#39;, follow&#x3D;True),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    def parse_item(self, response):</span><br><span class="line">        li_list &#x3D; response.xpath(&#39;&#x2F;&#x2F;div[contains(@class, &quot;index-area&quot;)]&#x2F;ul&#x2F;li&#39;)</span><br><span class="line">        for li in li_list:</span><br><span class="line">            mv_link &#x3D; &#39;https:&#x2F;&#x2F;www.4567tv.co&#39; + li.xpath(&#39;.&#x2F;a&#x2F;@href&#39;).extract_first()</span><br><span class="line">            ex &#x3D; self.conn.sadd(&#39;mv_link&#39;, mv_link)</span><br><span class="line">            if ex:</span><br><span class="line">                print(&#39;有新数据可以爬取..........................&#39;)</span><br><span class="line">                yield scrapy.Request(url&#x3D;mv_link, callback&#x3D;self.parse_detail)</span><br><span class="line">            else:</span><br><span class="line">                print(&#39;没有新数据可以爬取!!!!!!!!!!!!!!!!!!!!!!!!!&#39;)</span><br><span class="line"></span><br><span class="line">    def parse_detail(self, response):</span><br><span class="line">        title &#x3D; response.xpath(&#39;&#x2F;&#x2F;dt[@class&#x3D;&quot;name&quot;]&#x2F;text()&#39;).extract_first()</span><br><span class="line">        pro &#x3D; response.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;ee&quot;]&#x2F;text()&#39;).extract_first()</span><br><span class="line">        item &#x3D; MvproItem()</span><br><span class="line">        item[&#39;title&#39;] &#x3D; title</span><br><span class="line">        item[&#39;position&#39;] &#x3D; pro</span><br><span class="line">        yield item</span><br></pre>
<hr>
<h4 id="需求-基于数据指纹的增量式爬虫-爬取糗百文字"><a href="#需求-基于数据指纹的增量式爬虫-爬取糗百文字" class="headerlink" title="需求: 基于数据指纹的增量式爬虫, 爬取糗百文字"></a>需求: 基于数据指纹的增量式爬虫, 爬取糗百文字</h4><pre class="highlight"><span class="line"># spider编码:</span><br><span class="line">import scrapy</span><br><span class="line">from qiubai.items import QiubaiItem</span><br><span class="line">import hashlib</span><br><span class="line">from redis import Redis</span><br><span class="line"></span><br><span class="line">class QbSpider(scrapy.Spider):</span><br><span class="line">    conn &#x3D; Redis(&#39;127.0.0.1&#39;, 6379)</span><br><span class="line">    name &#x3D; &#39;qb&#39;</span><br><span class="line">    # allowed_domains &#x3D; [&#39;www.baidu.com&#39;]</span><br><span class="line">    start_urls &#x3D; [&#39;https:&#x2F;&#x2F;www.qiushibaike.com&#x2F;text&#x2F;&#39;]</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        div_list &#x3D; response.xpath(&#39;&#x2F;&#x2F;div[@id&#x3D;&quot;content-left&quot;]&#x2F;div&#39;)</span><br><span class="line"></span><br><span class="line">        for div in div_list:</span><br><span class="line">            content &#x3D; div.xpath(&#39;.&#x2F;a[1]&#x2F;div[@class&#x3D;&quot;content&quot;]&#x2F;span[1]&#x2F;text()&#39;).extract_first()</span><br><span class="line">            fp &#x3D; hashlib.md5(content.encode(&#39;utf-8&#39;)).hexdigest()</span><br><span class="line">            ex &#x3D; self.conn.sadd(&#39;fp&#39;, fp)</span><br><span class="line">            if ex:</span><br><span class="line">                print(&#39;有更新数据需要爬取........................&#39;)</span><br><span class="line">                item &#x3D; QiubaiItem()</span><br><span class="line">                item[&#39;content&#39;] &#x3D; content</span><br><span class="line">                yield item</span><br><span class="line">            else:</span><br><span class="line">                print(&#39;没有数据更新~~~&#39;)</span><br></pre>
<h2 id="3-scrapy提高数据爬取效率"><a href="#3-scrapy提高数据爬取效率" class="headerlink" title="3.scrapy提高数据爬取效率"></a>3.scrapy提高数据爬取效率</h2><pre class="highlight"><span class="line">1.增加并发：</span><br><span class="line">默认scrapy开启的并发线程为32个，可以适当进行增加。在settings配置文件中修改CONCURRENT_REQUESTS &#x3D; 100值为100,并发设置成了为100。</span><br><span class="line"></span><br><span class="line">2.降低日志级别：</span><br><span class="line">    在运行scrapy时，会有大量日志信息的输出，为了减少CPU的使用率。可以设置log输出信息为INFO或者ERROR即可。在配置文件中编写：LOG_LEVEL &#x3D; ‘INFO’</span><br><span class="line"></span><br><span class="line">3.禁止cookie：</span><br><span class="line">    如果不是真的需要cookie，则在scrapy爬取数据时可以禁止cookie从而减少CPU的使用率，提升爬取效率。在配置文件中编写：COOKIES_ENABLED &#x3D; False</span><br><span class="line"></span><br><span class="line">4.禁止重试：</span><br><span class="line">    对失败的HTTP进行重新请求（重试）会减慢爬取速度，因此可以禁止重试。在配置文件中编写：RETRY_ENABLED &#x3D; False</span><br><span class="line"></span><br><span class="line">5.减少下载超时：</span><br><span class="line">    如果对一个非常慢的链接进行爬取，减少下载超时可以能让卡住的链接快速被放弃，从而提升效率。在配置文件中进行编写：DOWNLOAD_TIMEOUT &#x3D; 10 超时时间为10s</span><br></pre>
<hr>
<h2 id="4-虚拟环境"><a href="#4-虚拟环境" class="headerlink" title="4.虚拟环境"></a>4.虚拟环境</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h4><pre class="highlight"><span class="line">pip install virtualenvwrapper-win</span><br></pre>

<pre class="highlight"><span class="line"># 常用命令:mkvirtualenv envname  # 创建虚拟环境并自动切换到该环境下workon envname  # 切换到某虚拟环境下pip list rmvirtualenv envname  # 删除虚拟环境deactivate  # 退出虚拟环境lsvirtualenv  # 列出所有常见的虚拟环境mkvirtualenv --python&#x3D;&#x3D;C:\...\python.exe envname  # 指定Python解释器创建虚拟环境</span><br></pre>]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化的使用</title>
    <url>/2018/10/13/%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="rest-framework的下载"><a href="#rest-framework的下载" class="headerlink" title="rest_framework的下载"></a>rest_framework的下载</h2><pre class="highlight"><span class="line">pip install djangorestframework</span><br></pre>
<hr>
<h3 id="在settings中注册rest-framework"><a href="#在settings中注册rest-framework" class="headerlink" title="在settings中注册rest_framework"></a>在settings中注册rest_framework</h3><pre class="highlight"><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">    <span class="string">'corsheaders'</span>,    <span class="comment">#后端跨域</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'rest_framework'</span>,   <span class="comment">#rest_framework框架</span></span><br><span class="line"></span><br><span class="line">    <span class="string">'myapp'</span>,</span><br><span class="line">    <span class="string">'dwebsocket'</span></span><br><span class="line">]</span><br></pre>

<hr>
<h3 id="在django的app中创建一个serializers-py文件"><a href="#在django的app中创建一个serializers-py文件" class="headerlink" title="在django的app中创建一个serializers.py文件"></a>在django的app中创建一个serializers.py文件</h3><pre class="highlight"><span class="line"><span class="comment">#导包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入需要序列化的表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> myapp.models <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#建立序列化类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarouselSer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="comment">#针对表进行序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Carousel <span class="comment">#表名</span></span><br><span class="line"></span><br><span class="line">        fields = <span class="string">'__all__'</span>    <span class="comment">#所有字段</span></span><br></pre>

<hr>
<h3 id="在views视图中"><a href="#在views视图中" class="headerlink" title="在views视图中"></a>在views视图中</h3><pre class="highlight"><span class="line"><span class="keyword">from</span> myapp.myser <span class="keyword">import</span> *  <span class="comment">#导入序列器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetCarousel</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#读库</span></span><br><span class="line"></span><br><span class="line">        carousels = Carousel.objects.all()</span><br><span class="line">        <span class="comment">#序列化操作</span></span><br><span class="line"></span><br><span class="line">        carousels_ser = CarouselSer(carousels,many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(carousels_ser.data)</span><br></pre>

<hr>
<h3 id="使用序列化的增删改查操作"><a href="#使用序列化的增删改查操作" class="headerlink" title="使用序列化的增删改查操作"></a>使用序列化的增删改查操作</h3><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetCarousel</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="comment">#查询操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment">#读库</span></span><br><span class="line"></span><br><span class="line">        carousels = Carousel.objects.all()</span><br><span class="line">        <span class="comment">#序列化操作</span></span><br><span class="line"></span><br><span class="line">        carousels_ser = CarouselSer(carousels,many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'data'</span>:carousels_ser.data&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#添加操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        name = request.data.get(<span class="string">'name'</span>,<span class="literal">None</span>)</span><br><span class="line">        src = request.data.get(<span class="string">'link'</span>,<span class="literal">None</span>)</span><br><span class="line">        img = request.data.get(<span class="string">'imgs'</span>,<span class="literal">None</span>)</span><br><span class="line">        ser = Carousel.objects.filter(name=name).first()</span><br><span class="line">        <span class="keyword">if</span> ser:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'msg'</span>:<span class="string">'幻灯片已存在'</span>&#125;)</span><br><span class="line">        carousel = Carousel(name=name,src=src,img=img)</span><br><span class="line">        carousel.save() <span class="comment">#保存入库</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>: <span class="number">200</span>, <span class="string">'msg'</span>: <span class="string">'添加成功'</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#删除操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        id = request.GET.get(<span class="string">'id'</span>,<span class="literal">None</span>)</span><br><span class="line">        Carousel.objects.filter(id=id).delete()</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>: <span class="number">200</span>, <span class="string">'msg'</span>: <span class="string">'删除成功'</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#修改操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        id = request.data.get(<span class="string">'id'</span>,<span class="literal">None</span>)</span><br><span class="line">        name = request.data.get(<span class="string">'name'</span>,<span class="literal">None</span>)</span><br><span class="line">        src = request.data.get(<span class="string">'link'</span>,<span class="literal">None</span>)</span><br><span class="line">        img = request.data.get(<span class="string">'imgs'</span>,<span class="literal">None</span>)</span><br><span class="line">        car = Carousel.objects.filter(id=id).first()</span><br><span class="line">        car.name = name</span><br><span class="line">        car.src = src</span><br><span class="line">        car.img = img</span><br><span class="line">        car.save()</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'code'</span>:<span class="number">200</span>, <span class="string">'msg'</span>: <span class="string">'修改成功'</span>&#125;)</span><br></pre>
<h2 id="rest-framework自带增删改查四种方法"><a href="#rest-framework自带增删改查四种方法" class="headerlink" title="rest_framework自带增删改查四种方法"></a>rest_framework自带增删改查四种方法</h2><pre class="highlight"><span class="line">查询：get：Carousel.objects.all() ---&gt;method:&#39;GET&#39;</span><br><span class="line">增加：post：carousel.save()       ---&gt;method:&#39;POST(data)&#39;,request.data.get()</span><br><span class="line">删除：delete：Carousel.objects.filter(id&#x3D;id).delete() ---&gt;method:&#39;DELETE(params)&#39;,request.GET.get()</span><br><span class="line">修改：put：carousel.save()        ---&gt;method:&#39;PUT(data)&#39;,request.data.get()</span><br></pre>

<hr>
<h3 id="vue代码"><a href="#vue代码" class="headerlink" title="vue代码"></a>vue代码</h3><pre class="highlight"><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;center&gt;</span><br><span class="line">            &lt;table border=<span class="string">"1"</span> style=<span class="string">"text-align: center;"</span>&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        名称</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        链接</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        图片</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        添加</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        修改</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        删除</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">                &lt;tr v-<span class="keyword">for</span>=<span class="string">"(item,index) in lunbo_list"</span> :key=<span class="string">"index"</span>&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        &amp;emsp;&amp;emsp;            &#123;&#123;item.name&#125;&#125;           &amp;emsp;&amp;emsp;</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        &amp;emsp;&amp;emsp;        &lt;a :href="item.src" target="_black"&gt;&#123;&#123;item.src&#125;&#125;&lt;/a&gt;        &amp;emsp;&amp;emsp;</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        &amp;emsp;&amp;emsp;        &lt;img :src=<span class="string">"item.img"</span> alt=<span class="string">""</span>&gt;        &amp;emsp;&amp;emsp;</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        &amp;emsp;&amp;emsp;        &lt;Button color="green" @click="put_lunbo(item.id)"&gt;修改&lt;/Button&gt;     &amp;emsp;&amp;emsp;</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        &amp;emsp;&amp;emsp;        &lt;Button color="red" @click="del_lunbo(item.id)"&gt;删除&lt;/Button&gt;       &amp;emsp;&amp;emsp;</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;table&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    name：&lt;input type=<span class="string">"text"</span> v-model=<span class="string">"name"</span>&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    img：&lt;input type=<span class="string">"text"</span> v-model=<span class="string">"imgs"</span>&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    src：&lt;input type=<span class="string">"text"</span> v-model=<span class="string">"link"</span>&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;br&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                    &amp;emsp;&amp;emsp;        &lt;Button color="blue" @click="add_lunbo"&gt;添加&lt;/Button&gt;      &amp;emsp;&amp;emsp;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                name：&lt;input type=<span class="string">"text"</span> v-model=<span class="string">"name"</span>&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                img：&lt;input type=<span class="string">"text"</span> v-model=<span class="string">"imgs"</span>&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                src：&lt;input type=<span class="string">"text"</span> v-model=<span class="string">"link"</span>&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">                &amp;emsp;&amp;emsp;        &lt;Button color="blue" @click="put_lunbo1"&gt;修改&lt;/Button&gt;      &amp;emsp;&amp;emsp;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">    &lt;/center&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            lunbo_list:[],</span><br><span class="line">            name:<span class="string">""</span>,</span><br><span class="line">            link:<span class="string">""</span>,</span><br><span class="line">            imgs:<span class="string">""</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        this.lunbo();</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        lunbo()&#123;</span><br><span class="line">            this.axios(&#123;</span><br><span class="line">                url:<span class="string">'http://localhost:8000/getcarousel/'</span>,</span><br><span class="line">                method:<span class="string">'GET'</span>,</span><br><span class="line">            &#125;).then(resp=&gt;&#123;</span><br><span class="line">                console.log(resp)</span><br><span class="line">                this.lunbo_list = resp.data.data</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        //增加</span><br><span class="line">        add_lunbo()&#123; </span><br><span class="line">            this.axios(&#123;</span><br><span class="line">                url:<span class="string">'http://127.0.0.1:8000/getcarousel/'</span>,</span><br><span class="line">                method:<span class="string">'POST'</span>,</span><br><span class="line">                data:&#123;</span><br><span class="line">                    name:this.name,</span><br><span class="line">                    link:this.link,</span><br><span class="line">                    imgs:this.imgs,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).then(resp=&gt;&#123;</span><br><span class="line">                console.log(resp)              </span><br><span class="line">                this.$router.go(<span class="number">0</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        //删除</span><br><span class="line">        del_lunbo(id)&#123;</span><br><span class="line">            this.axios(&#123;</span><br><span class="line">                url:<span class="string">'http://127.0.0.1:8000/getcarousel/'</span>,</span><br><span class="line">                method:<span class="string">'DELETE'</span>,</span><br><span class="line">                params:&#123;</span><br><span class="line">                    id:id</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).then(resp=&gt;&#123;</span><br><span class="line">                console.log(resp)</span><br><span class="line">                alert(resp.data.msg)</span><br><span class="line">                this.$router.go(<span class="number">0</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        //修改跳转</span><br><span class="line">        put_lunbo(id)&#123;</span><br><span class="line">            //网页跳转传递id</span><br><span class="line">            this.$router.push(&#123;<span class="string">'path'</span>:<span class="string">'/my_lunbo'</span>,query:&#123;<span class="string">'aid'</span>:id&#125;&#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        //修改</span><br><span class="line">        put_lunbo1()&#123;</span><br><span class="line">            this.axios(&#123;</span><br><span class="line">                url:<span class="string">'http://127.0.0.1:8000/getcarousel/'</span>,</span><br><span class="line">                method:<span class="string">'PUT'</span>,//指定修改方法</span><br><span class="line">                data:&#123;</span><br><span class="line">                    id:this.$route.query.aid,</span><br><span class="line">                    name:this.name,</span><br><span class="line">                    link:this.link,</span><br><span class="line">                    imgs:this.imgs,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).then(resp=&gt;&#123;</span><br><span class="line">                console.log(resp)</span><br><span class="line">                alert(resp.data.msg)</span><br><span class="line">                this.$router.go(<span class="number">0</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">img&#123;</span><br><span class="line">    width: <span class="number">100</span>px;</span><br><span class="line">    height: <span class="number">100</span>px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre>
]]></content>
      <categories>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据解析之正则&amp;BS4&amp;xpath</title>
    <url>/2018/07/25/%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E4%B9%8B%E6%AD%A3%E5%88%99&amp;BS4&amp;xpath/</url>
    <content><![CDATA[<h1 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h1><hr>
<h6 id="数据解析就是应用一定的技术手段在响应数据中获取目标数据"><a href="#数据解析就是应用一定的技术手段在响应数据中获取目标数据" class="headerlink" title="数据解析就是应用一定的技术手段在响应数据中获取目标数据"></a>数据解析就是应用一定的技术手段在响应数据中获取目标数据</h6><hr>
<h5 id="常用数据解析方式"><a href="#常用数据解析方式" class="headerlink" title="常用数据解析方式:"></a>常用数据解析方式:</h5><ul>
<li>正则: 匹配高效, 但正则表达式书写有难度</li>
<li>BS4: 解析数据速度慢, 但使用简单</li>
<li>xpath: 解析速度快, 使用简单</li>
</ul>
<hr>
<h5 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置:"></a>环境配置:</h5><ul>
<li><p>正则: </p>
<pre class="highlight"><span class="line">pip install re</span><br></pre></li>
<li><p>BS4:</p>
<pre class="highlight"><span class="line">pip install lxml</span><br><span class="line">pip install BeautifulSoup4</span><br></pre>
</li>
<li><p>xpath:</p>
<pre class="highlight"><span class="line">pip install lxml</span><br></pre>
</li>
</ul>
<hr>
<h2 id="1-正则"><a href="#1-正则" class="headerlink" title="1.正则"></a>1.正则</h2><h3 id="元字符匹配"><a href="#元字符匹配" class="headerlink" title="元字符匹配"></a>元字符匹配</h3><pre class="highlight"><span class="line"> .     匹配任意字符，除了换行符</span><br><span class="line"></span><br><span class="line">[]    用来表示一组字符,单独列出：[abc] 匹配 &#39;a&#39;，&#39;b&#39;或&#39;c&#39;</span><br><span class="line"></span><br><span class="line">[^...]	匹配除了字符组中字符的所有字符</span><br><span class="line"></span><br><span class="line">\d    匹配任意数字，等价于 [0-9].</span><br><span class="line"></span><br><span class="line">\D    匹配任意非数字</span><br><span class="line"></span><br><span class="line">\w    匹配字母数字及下划线</span><br><span class="line"></span><br><span class="line">\W    匹配非字母数字及下划线</span><br><span class="line"></span><br><span class="line">\s    匹配任意空白字符，等价于 [\t\n\r\f].</span><br><span class="line"></span><br><span class="line">\S    匹配任意非空字符</span><br></pre>
<hr>
<h3 id="字符组：要求在一个位置匹配的字符可能出现很多种情况-各种情况组成一个组"><a href="#字符组：要求在一个位置匹配的字符可能出现很多种情况-各种情况组成一个组" class="headerlink" title="字符组：要求在一个位置匹配的字符可能出现很多种情况, 各种情况组成一个组"></a>字符组：要求在一个位置匹配的字符可能出现很多种情况, 各种情况组成一个组</h3><pre class="highlight"><span class="line">[0123456789]: 匹配0到9任意字符</span><br><span class="line">[0-9]: 同上</span><br><span class="line">[a-z]: 匹配a到z的任意小写字母</span><br><span class="line">[A-Z]: 匹配A到Z的任意大写字母</span><br><span class="line">[0-9a-fA-F]: 以上三种的组合, 匹配0-9任意数组或a到f之间任意字母, 不区分大小写</span><br><span class="line">自定义字符组:[a3h5]  ---&gt;  代表匹配a, 3, h, 5等字符</span><br></pre>
<hr>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词:"></a>量词:</h3><pre class="highlight"><span class="line">*  	重复零次或更多次</span><br><span class="line">+	重复一次或更多次</span><br><span class="line">?	重复零次或一次</span><br><span class="line">&#123;n&#125;	重复n次</span><br><span class="line">&#123;n,&#125;	重复n次或更多次</span><br><span class="line">&#123;n,m&#125;	重复n到m次</span><br></pre>

<hr>
<h3 id="边界修饰符"><a href="#边界修饰符" class="headerlink" title="边界修饰符"></a>边界修饰符</h3><pre class="highlight"><span class="line">^	匹配开始</span><br><span class="line">$	匹配结尾</span><br></pre>
<hr>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><pre class="highlight"><span class="line">在正则表达式中添加(), 就形成了一个分组, 在re模块中优先匹配显示分组内容</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line">s &#x3D; &quot;&lt;a href&#x3D;&#39;www.baidu.com&#39;&gt;正则匹配实验&lt;&#x2F;a&gt;&quot;</span><br><span class="line">res &#x3D; re.findall(&quot;href&#x3D;&#39;(.*)&#39;&gt;&quot;, s)</span><br><span class="line">print(res)</span><br></pre>
<hr>
<h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><pre class="highlight"><span class="line">re.S  单行模式</span><br><span class="line">re.M  多行模式	</span><br><span class="line">re.I 忽略大小写</span><br></pre>
<hr>
<h3 id="贪婪匹配与非贪婪匹配"><a href="#贪婪匹配与非贪婪匹配" class="headerlink" title="贪婪匹配与非贪婪匹配"></a>贪婪匹配与非贪婪匹配</h3><pre class="highlight"><span class="line">贪婪匹配是指: 在使用量词:  * ,  +  等时, 尽可能的匹配内容</span><br><span class="line"></span><br><span class="line">非贪婪匹配是指: 使用?对正则表达式进行修饰, 使量词的匹配尽可能少, 如+代表匹配1次或多次, 在?的修饰下, 只匹配1次.</span><br></pre>
<hr>
<h3 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h3><ul>
<li>re.findall(‘正则表达式’, ‘待匹配字符串’): 返回所有满足匹配条件的结果, 以列表形式返回</li>
<li>re.search(‘正则表达式’, ‘带匹配字符串’): 匹配到第一个就返回一个对象, 该对象使用group()进行取值, 如果为匹配到则返回None</li>
<li>re.match(‘正则表达式’, ‘待匹配字符串’): 只从字符串开始进行匹配, 如果匹配成功返回一个对象,同样使用group()进行取值, 匹配不成功返回None</li>
<li>re.compile(‘正则表达式’): 将正则表达式编译为对象, 但需要按该正则表达式匹配是可以在直接使用该对象调用以上方法即可.</li>
</ul>
<h4 id="re模块示例"><a href="#re模块示例" class="headerlink" title="re模块示例:"></a>re模块示例:</h4><pre class="highlight"><span class="line">s &#x3D; &quot;abcabc你好&quot;</span><br><span class="line"></span><br><span class="line"># findall方法演示</span><br><span class="line">res_findall &#x3D; re.findall(&#39;a&#39;, s)</span><br><span class="line">print(&#39;findall匹配结果:&#39;, res_findall)</span><br><span class="line"></span><br><span class="line"># search方法演示, 不确定是否能匹配出结果, 不可直接使用group进行取值, 需要判断或进行异常处理</span><br><span class="line">res_search &#x3D; re.search(&quot;你&quot;, s)</span><br><span class="line">if res:</span><br><span class="line">    print(&#39;search匹配结果&#39;, res.group())</span><br><span class="line">else:</span><br><span class="line">    print(&#39;None&#39;)</span><br><span class="line">    </span><br><span class="line"># match方法演示:</span><br><span class="line">res_match_1 &#x3D; re.match(&#39;abc&#39;, s)</span><br><span class="line">res_match_2 &#x3D; re.match(&#39;bc&#39;, s)</span><br><span class="line">print(&#39;res_match_1结果:&#39;, res_match_1)</span><br><span class="line">print(&#39;res_match_2结果:&#39;, res_match_2)</span><br><span class="line"></span><br><span class="line"># compile方法演示:</span><br><span class="line">re_obj &#x3D; re.compile(&#39;ab&#39;)</span><br><span class="line">res &#x3D; re_obj.findall(s)</span><br><span class="line">print(res)</span><br></pre>
<hr>
<h3 id="利用正则表达式抓取校花网图片"><a href="#利用正则表达式抓取校花网图片" class="headerlink" title="利用正则表达式抓取校花网图片"></a>利用正则表达式抓取校花网图片</h3><pre class="highlight"><span class="line">import re</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># 请求url, 抓取页面</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.xiaohuar.com&#x2F;hua&#x2F;&#39;</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line">html &#x3D; res.text</span><br><span class="line"></span><br><span class="line"># 利用正则匹配页面中的img标签, 获取其src属性值</span><br><span class="line">all_src &#x3D; re.findall(&#39;&lt;img.*src&#x3D;&quot;(.*jpg)&quot;&#39;, html, re.M)</span><br><span class="line"></span><br><span class="line"># 遍历获取到的图片连接, 处理连接为完整的url, 再次请求抓取图片二进制流数据, 写入文件</span><br><span class="line">for num, url in enumerate(all_src):</span><br><span class="line">    url &#x3D; &#39;http:&#x2F;&#x2F;www.xiaohuar.com&#39; + url</span><br><span class="line">    image &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line">    with open(&#39;%s.jpg&#39; % num, &#39;wb&#39;) as f:</span><br><span class="line">        f.write(image.content)</span><br></pre>

<hr>
<h2 id="2-BS4"><a href="#2-BS4" class="headerlink" title="2.BS4"></a>2.BS4</h2><h3 id="BS4解析库解析数据原理"><a href="#BS4解析库解析数据原理" class="headerlink" title="BS4解析库解析数据原理:"></a>BS4解析库解析数据原理:</h3><p>定位标签节点  —&gt;  提取标签节点内容或属性值</p>
<hr>
<h3 id="BS4基本使用步骤"><a href="#BS4基本使用步骤" class="headerlink" title="BS4基本使用步骤:"></a>BS4基本使用步骤:</h3><pre class="highlight"><span class="line">from BS4 import BeautifulSoup</span><br><span class="line"># 网络文件实例化对象</span><br><span class="line">soup &#x3D; BeautifulSoup(text, &#39;lxml&#39;)  </span><br><span class="line">soup &#x3D; BeautifulSoup(open(&#39;filename&#39;, &#39;lxml&#39;)</span><br><span class="line">tag_element_or_attribute &#x3D; soup.选择器</span><br></pre>
<hr>
<h3 id="BS4可用选择器"><a href="#BS4可用选择器" class="headerlink" title="BS4可用选择器:"></a>BS4可用选择器:</h3><h4 id="节点选择器"><a href="#节点选择器" class="headerlink" title="节点选择器:"></a>节点选择器:</h4><pre class="highlight"><span class="line">- 节点名单选: soup.div</span><br><span class="line">- 嵌套选择: soup.div.span</span><br><span class="line">- 关联选择: </span><br><span class="line">    - 子节点:contents返回字节子节点, 包含换行符, 返回类型是一个列表</span><br><span class="line">            children效果相同, 但返回一个生成器</span><br><span class="line">    - 子孙节点:descendants, 返回生成器遍历取值</span><br><span class="line">        1).深度选择, 从第一个子节点开始, 直至第一个子节点内的所有孙节点全部选择到</span><br><span class="line">        2).如果两个标签在两行上, 匹配第一个节点的所有深度后选择换行符.</span><br><span class="line">        3).如果标签中的文本是换行的, 则不单独匹配换行符, 换行符包含在文本内</span><br><span class="line">    - 父节点:parent</span><br><span class="line">    - 祖先节点:parents</span><br><span class="line">    - 兄弟节点:</span><br><span class="line">            next_sibling: 当前节点的下一个兄弟节点</span><br><span class="line">            previous_sibling: 当前节点的上一个兄弟节点</span><br></pre>

<hr>
<h4 id="方法选择器"><a href="#方法选择器" class="headerlink" title="方法选择器:"></a>方法选择器:</h4><pre class="highlight"><span class="line">1).find_all(name, attrs, recursive, text, **kwargs)</span><br><span class="line">    </span><br><span class="line">    - 标签名选择:soup.find_all(name&#x3D;&#39;ul&#39;)   # 选择所有ul标签</span><br><span class="line">    </span><br><span class="line">    - 嵌套选择:</span><br><span class="line">        for ul in soup.find_all(name&#x3D;&#39;ul&#39;):   </span><br><span class="line">            ul.find_all(name&#x3D;&#39;li&#39;)  # 循环ul列表, 选择每个ul中的li标签</span><br><span class="line"></span><br><span class="line">    - 属性值选择:soup.find_all(attrs&#x3D;&#123;&#39;class&#39;: &#39;element&#39;&#125;), # 根据属性选择节点,等效:soup.find_all(class&#x3D;&#39;element&#39;)</span><br><span class="line">    </span><br><span class="line">    - 文本正则选择:soup.find_all(text&#x3D;re.compile(&#39;link&#39;))  # 返回所有标签中包含link字符的文字的对象</span><br><span class="line"></span><br><span class="line">2).find():返回一个对象</span><br></pre>
<hr>
<h4 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器:"></a>css选择器:</h4><pre class="highlight"><span class="line">css选择器需要调用select方法, 改方法返回一个列表</span><br><span class="line"></span><br><span class="line">1).选择:</span><br><span class="line">        soup.select(&#39;ul li&#39;)  # 选择ul下的li所有标签</span><br><span class="line">        soup.select(&#39;.panel&#39;)  # 选择class的值为panel的标签</span><br><span class="line">        soup.select(&#39;#item1&#39;)  # 选择id为item1的标签</span><br><span class="line">2).嵌套选择:</span><br><span class="line">    for ul in soup.select(&#39;ul&#39;):</span><br><span class="line">        ul.select(&#39;li&#39;)</span><br><span class="line">3).获取文本与属性:</span><br><span class="line">    获取属性:</span><br><span class="line">        for li in soup.select(&#39;ul li&#39;):</span><br><span class="line">            print(li.attrs[&#39;id&#39;])</span><br><span class="line">            print(li[&#39;id&#39;])   # 上下两种形式效果一致</span><br><span class="line">    获取文本:</span><br><span class="line">        for li in soup.select(&#39;ul li&#39;):</span><br><span class="line">            print(li.get_text())</span><br><span class="line">            print(li.string)</span><br></pre>
<hr>
<h4 id="节点文本或属性的获取"><a href="#节点文本或属性的获取" class="headerlink" title="节点文本或属性的获取"></a>节点文本或属性的获取</h4><pre class="highlight"><span class="line">tag_element.name  # 获取节点名称</span><br><span class="line">tag_element.attrs  # 获取节点所有属性, 结果为字典形式</span><br><span class="line">tag_element.attrs[&#39;name&#39;]  # 获取节点的单个属性值, 等效: tag_element[&#39;name&#39;], 属性多值是返回列表</span><br><span class="line">tag_element.string   # 获取节点的文本内容</span><br><span class="line">如果使用关联选择, 且结果为生成器可以先转为列表再索引定位元素后在调用上面的获取元素方法, 如:</span><br><span class="line">list(p.parents)[0].attrs[&#39;name&#39;]</span><br></pre>
<hr>
<h4 id="练习示例"><a href="#练习示例" class="headerlink" title="练习示例"></a>练习示例</h4><pre class="highlight"><span class="line">html &#x3D; &#39;&#39;&#39;</span><br><span class="line">    &lt;div class&#x3D;&quot;panel&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;panel-heading&quot;&gt;</span><br><span class="line">            &lt;h4&gt;BeautifulSoup练习&lt;&#x2F;h4&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;panel-body&quot;&gt;</span><br><span class="line">            &lt;ul class&#x3D;&quot;list&quot; id&#x3D;&quot;list-1&quot;&gt;</span><br><span class="line">                &lt;li class&#x3D;&quot;element&quot;&gt;第一个li标签&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li class&#x3D;&quot;element&quot;&gt;第二个li标签&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li class&#x3D;&quot;element&quot;&gt;第三个li标签&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">            &lt;ul class&#x3D;&quot;list list-small&quot;&gt;</span><br><span class="line">                &lt;li class&#x3D;&quot;element&quot;&gt;one&lt;&#x2F;li&gt;</span><br><span class="line">                &lt;li class&#x3D;&quot;element&quot;&gt;two&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;&#x2F;ul&gt;</span><br><span class="line">            &lt;li class&#x3D;&quot;element&quot;&gt;测试多层级选择器&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">soup &#x3D; BeautifulSoup(html, &#39;lxml&#39;)</span><br><span class="line"># 1.根据节点名定位节点, 获取其文本</span><br><span class="line">h4 &#x3D; soup.select(&#39;h4&#39;)   # 标签选择器</span><br><span class="line">print(h4[0].get_text())</span><br><span class="line"></span><br><span class="line"># 2.根据class属性定位节点</span><br><span class="line">panel &#x3D; soup.select(&#39;.panel-heading&#39;)</span><br><span class="line">print(panel)</span><br><span class="line"></span><br><span class="line"># 3.根据id属性定位节点</span><br><span class="line">ul &#x3D; soup.select(&#39;#list-1&#39;)</span><br><span class="line">print(ul)</span><br><span class="line"></span><br><span class="line"># 4.嵌套选择</span><br><span class="line">ul_list &#x3D; soup.select(&#39;ul&#39;)</span><br><span class="line">for ul in ul_list:</span><br><span class="line">    li &#x3D; ul.select(&#39;li&#39;)</span><br><span class="line">    print(li)</span><br><span class="line">    </span><br><span class="line"># 5.单层级选择器与多层级选择器</span><br><span class="line">li_list_single &#x3D; soup.select(&quot;.panel-body &gt; ul &gt; li&quot;)</span><br><span class="line">li_list_multi &#x3D; soup.select(&quot;.panel-body li&quot;)</span><br></pre>
<hr>
<h4 id="爬取整部三国演义销售-写入txt文件"><a href="#爬取整部三国演义销售-写入txt文件" class="headerlink" title="爬取整部三国演义销售, 写入txt文件:"></a>爬取整部三国演义销售, 写入txt文件:</h4><pre class="highlight"><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;www.shicimingju.com&#x2F;book&#x2F;sanguoyanyi.html&#39;</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line">soup &#x3D; BeautifulSoup(res.text, &#39;lxml&#39;)</span><br><span class="line">a_list &#x3D; soup.select(&quot;.book-mulu ul li a&quot;)</span><br><span class="line">for item in a_list:</span><br><span class="line">    name &#x3D; item.string</span><br><span class="line">    href &#x3D; item[&quot;href&quot;]</span><br><span class="line">    # print(href)</span><br><span class="line">    full_url &#x3D; &#39;http:&#x2F;&#x2F;www.shicimingju.com&#39; + href</span><br><span class="line">    detail_page &#x3D; requests.get(url&#x3D;full_url, headers&#x3D;headers).text</span><br><span class="line">    soup_detail &#x3D; BeautifulSoup(detail_page, &#39;lxml&#39;)</span><br><span class="line">    div &#x3D; soup_detail.select(&quot;.chapter_content&quot;)[0]</span><br><span class="line">    print(type(div.get_text()))</span><br><span class="line">    with open(&#39;%s.txt&#39; % name, &#39;w&#39;, encoding&#x3D;&quot;utf-8&quot;) as f:</span><br><span class="line">        f.write(div.get_text())</span><br></pre>
<hr>
<h2 id="3-xpath"><a href="#3-xpath" class="headerlink" title="3.xpath"></a>3.xpath</h2><h3 id="xpath解析库的介绍"><a href="#xpath解析库的介绍" class="headerlink" title="xpath解析库的介绍"></a>xpath解析库的介绍</h3><p>数据解析的过程中使用过正则表达式, 但正则表达式想要进准匹配难度较高, 一旦正则表达式书写错误, 匹配的数据也会出错.<br>网页由三部分组成: HTML, Css, JavaScript, HTML页面标签存在层级关系, 即DOM树, 在获取目标数据时可以根据网页层次关系定位标签, 在获取标签的文本或属性.</p>
<hr>
<h3 id="xpath解析库解析数据原理"><a href="#xpath解析库解析数据原理" class="headerlink" title="xpath解析库解析数据原理:"></a>xpath解析库解析数据原理:</h3><ol>
<li>根据网页DOM树定位节点标签</li>
<li>获取节点标签的正文文本或属性值</li>
</ol>
<hr>
<h3 id="xpath安装"><a href="#xpath安装" class="headerlink" title="xpath安装"></a>xpath安装</h3><pre class="highlight"><span class="line">pip install lxml</span><br></pre>
<hr>
<h3 id="requests模块爬取糗事百科热门的标题"><a href="#requests模块爬取糗事百科热门的标题" class="headerlink" title="requests模块爬取糗事百科热门的标题:"></a>requests模块爬取糗事百科热门的标题:</h3><pre class="highlight"><span class="line">import requests</span><br><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;www.qiushibaike.com&#x2F;&#39;</span><br><span class="line">headers &#x3D; &#123;</span><br><span class="line">    &quot;User-Agent&quot;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;75.0.3770.142 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res &#x3D; requests.get(url&#x3D;url, headers&#x3D;headers)</span><br><span class="line"></span><br><span class="line">tree &#x3D; etree.HTML(res.text)</span><br><span class="line">title_lst &#x3D; tree.xpath(&#39;&#x2F;&#x2F;ul&#x2F;li&#x2F;div&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">for item in title_lst:</span><br><span class="line">    print(item)</span><br></pre>
<hr>
<h3 id="xpath使用步骤"><a href="#xpath使用步骤" class="headerlink" title="xpath使用步骤"></a>xpath使用步骤</h3><pre class="highlight"><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">tree &#x3D; etree.HTML(res.text)</span><br><span class="line">tree &#x3D; etree.parse(res.html, etree.HTMLParse())  # 示例如下, 了解内容</span><br><span class="line"></span><br><span class="line">tag_or_attr &#x3D; tree.xpath(&#39;xpath表达式&#39;)</span><br></pre>
<hr>
<h3 id="xpath语法"><a href="#xpath语法" class="headerlink" title="xpath语法:"></a>xpath语法:</h3><pre class="highlight"><span class="line">1.常用规则:</span><br><span class="line">      1.  nodename:		  节点名定位</span><br><span class="line">      2.  &#x2F;&#x2F;:			  从当前节点选取子孙节点</span><br><span class="line">      3.  &#x2F;:			  从当前节点选取直接子节点</span><br><span class="line">      4.  nodename[@attribute&#x3D;&quot;...&quot;]  根据属性定位标签</span><br><span class="line">      5.  @attributename:  获取属性 </span><br><span class="line">      6.  text():		   获取文本</span><br><span class="line">   </span><br><span class="line">2.属性匹配两种情况: 多属性匹配 &amp;  单属性多值匹配  </span><br><span class="line">    2.1 单属性多值匹配</span><br><span class="line">    示例: tree.xpath(&#39;&#x2F;&#x2F;div[contains(@class, &quot;dc&quot;)]&#x2F;text()&#39;)</span><br><span class="line"></span><br><span class="line">    2.2 多属性匹配</span><br><span class="line">    示例: tree.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;item&quot; and @name&#x3D;&quot;test&quot;]&#x2F;text()&#39;) 	</span><br><span class="line">    </span><br><span class="line">3.按序选择:</span><br><span class="line">    3.1 索引定位: 从1开始</span><br><span class="line">    3.2 last()函数</span><br><span class="line">    3.3 position()函数</span><br></pre>
<hr>
<h3 id="获取响应数据内容"><a href="#获取响应数据内容" class="headerlink" title="获取响应数据内容:"></a>获取响应数据内容:</h3><pre><code>res.text        获取HTML文本
res.content        获取二进制流
res.json()        获取json数据</code></pre><hr>
<h3 id="解析示例-示例解析的是本地文件"><a href="#解析示例-示例解析的是本地文件" class="headerlink" title="解析示例: 示例解析的是本地文件"></a>解析示例: 示例解析的是本地文件</h3><h5 id="本地文件"><a href="#本地文件" class="headerlink" title="本地文件"></a>本地文件</h5><pre class="highlight"><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Xpath练习文件&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;007&quot;&gt;</span><br><span class="line">    &quot;我是div标签的文字内容, 和下面的p标签还有div标签是同级的哦&quot;</span><br><span class="line">    &lt;p&gt;这是p标签内的文字内容&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;div&gt;这是p标签同级的div标签&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;divtag&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;第1个li标签&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;第2个li标签&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;第3个li标签&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;第4个li标签&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;第5个li标签&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&quot;&gt;这是百度的跳转连接&lt;&#x2F;a&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;c1&quot; name&#x3D;&quot;laoda&quot;&gt;老大在此&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;c1 c3&quot; name&#x3D;&quot;laoer&quot;&gt;老二任性, class有两个值&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;c1&quot; name&#x3D;&quot;laosan&quot;&gt;我是老三&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre>
<h5 id="解析本地文件"><a href="#解析本地文件" class="headerlink" title="解析本地文件"></a>解析本地文件</h5><pre class="highlight"><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">tree &#x3D; etree.parse(&#39;.&#x2F;x.html&#39;, etree.HTMLParser())</span><br><span class="line"></span><br><span class="line"># 1.根据节点名, 即nodename定位title标签, 获取标签内文字</span><br><span class="line">title_text &#x3D; tree.xpath(&#39;&#x2F;&#x2F;title&#x2F;text()&#39;)</span><br><span class="line">print(title_text)</span><br><span class="line"></span><br><span class="line"># 2.根据节点属性定位: 定位id为007的div标签</span><br><span class="line">div_007 &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@id&#x3D;&quot;007&quot;]&#39;)</span><br><span class="line">print(div_007)</span><br><span class="line"></span><br><span class="line"># 3.示例直接子节点与子孙节点:&#x2F;, &#x2F;&#x2F;</span><br><span class="line">div_007_one &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@id&#x3D;&quot;007&quot;]&#x2F;text()&#39;)</span><br><span class="line">print(div_007_one)</span><br><span class="line">div_007_two &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@id&#x3D;&quot;007&quot;]&#x2F;&#x2F;text()&#39;)</span><br><span class="line">print(div_007_two)</span><br><span class="line"></span><br><span class="line"># 4.获取a标签的href属性</span><br><span class="line">a_href &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;divtag&quot;]&#x2F;a&#x2F;@href&#39;)</span><br><span class="line">print(a_href)</span><br><span class="line"></span><br><span class="line"># 4.多属性定位: 根据class属性和name属性定位div标签</span><br><span class="line">div_two_attr &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;c1&quot; and @name&#x3D;&quot;laoda&quot;]&#x2F;text()&#39;)</span><br><span class="line">print(div_two_attr)</span><br><span class="line"></span><br><span class="line"># 5.属性多值定位: 定位所有class中有c1的div标签</span><br><span class="line">div_c1 &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[contains(@class, &quot;c1&quot;)]&#39;)</span><br><span class="line"></span><br><span class="line"># 6.按序定位</span><br><span class="line">li_first &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;divtag&quot;]&#x2F;ul&#x2F;li[1]&#x2F;text()&#39;)  # 定位第一个li标签, 获取其文本</span><br><span class="line">print(li_first)</span><br><span class="line"></span><br><span class="line">li_last &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;divtag&quot;]&#x2F;ul&#x2F;li[last()]&#x2F;text()&#39;)  # 定位最后一个li标签</span><br><span class="line">print(li_last)</span><br><span class="line"></span><br><span class="line">li_daotwo &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;divtag&quot;]&#x2F;ul&#x2F;li[last()-1]&#x2F;text()&#39;)  # 定位倒数第二个li标签</span><br><span class="line">print(li_daotwo)</span><br><span class="line"></span><br><span class="line">li_qianthree &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;divtag&quot;]&#x2F;ul&#x2F;li[position()&lt;4]&#x2F;text()&#39;)  # 定位前三个li标签</span><br><span class="line">print(li_qianthree)</span><br></pre>]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫概述&amp;协议&amp;请求</title>
    <url>/2018/07/11/%E7%88%AC%E8%99%AB%E6%A6%82%E8%BF%B0&amp;%E5%8D%8F%E8%AE%AE&amp;%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h2 id="1-爬虫概念"><a href="#1-爬虫概念" class="headerlink" title="1.爬虫概念"></a>1.爬虫概念</h2><p>爬虫, 又称网页蜘蛛或网络机器人，爬虫是 模拟人操作客户端(浏览器, APP) 向服务器发起网络请求 抓取数据的自动化程序或脚本.</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><ul>
<li>模拟: 用爬虫程序伪装出人的行为, 避免被服务识别为爬虫程序</li>
<li>客户端: 浏览器, APP都可以实现人与服务器之间的交互行为, 应用客户端从服务器获取数据</li>
<li>自动化: 数据量较小时可以人工获取数据, 但往往在公司中爬取的数据量在百万条, 千万条级别的, 所以要程序自动化获取数据.</li>
</ul>
<hr>
<h2 id="2-爬虫语言"><a href="#2-爬虫语言" class="headerlink" title="2.爬虫语言"></a>2.爬虫语言</h2><h3 id="爬虫语言："><a href="#爬虫语言：" class="headerlink" title="爬虫语言："></a>爬虫语言：</h3><pre class="highlight"><span class="line">PHP, C&#x2F;C++, Java, Python</span><br></pre>
<h3 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h3><ol>
<li>PHP: 并发能力差, 对多进程和多线程支持不好, 数据量较大时爬虫效率较低</li>
<li>C/C++: 语言效率高, 但学习成本高, 对程序员的技术能力要求较高,  所以目前还停留在研究层面, 市场需求量很小</li>
<li>Java: Python爬虫的主要竞争对手, 由于Java语言的特点, 代码臃肿, 代码量大, 维护成本重构成本高, 开发效率低. 但目前市场上岗位需求比较旺盛.</li>
<li>Python:语法简单, 学习成本较低, 对新手比较友好. Python语言良好的生态, 大量库和框架的支持是的Python爬虫目前处于爬虫圈的主导地位.</li>
</ol>
<hr>
<h2 id="3-爬虫分类"><a href="#3-爬虫分类" class="headerlink" title="3.爬虫分类"></a>3.爬虫分类</h2><p> a. 通用爬虫</p>
<p> b. 聚焦爬虫</p>
<h3 id="通用爬虫"><a href="#通用爬虫" class="headerlink" title="通用爬虫"></a>通用爬虫</h3><ul>
<li><p>通用爬虫：约定哪些内容允许哪些爬虫抓取—&gt;搜索引擎</p>
</li>
<li><p>实例: 百度, 搜狗, Google的搜索引擎</p>
</li>
<li><p>功能: 访问网页 -&gt; 抓取数据 -&gt; 数据处理 -&gt; 提供检索服务</p>
</li>
<li><p>工作流:</p>
<ol>
<li>给定一个起始URL, 存于爬取队列中</li>
<li>爬虫程序从队列中取出url, 爬取数据</li>
<li>解析爬取数据, 获取网页内的所有url, 放入爬取队列</li>
<li>重复第二个步骤</li>
</ol>
</li>
<li><p>使搜索引擎获取网站链接:</p>
<ol>
<li>主动将url提交各搜索引擎</li>
<li>在其他热门网站设置友情了解</li>
<li>百度和DNS服务商合作, 收录新网站</li>
</ol>
</li>
<li><p>网站排名(SEO):</p>
<ol>
<li>根据PageRank值进行排名(流量, 点击率)</li>
<li>百度竞价排名, 钱多就靠前排</li>
</ol>
</li>
<li><p>缺点:</p>
<ol>
<li>抓取的内容多数无用</li>
<li>无法精确获取数据</li>
</ol>
</li>
</ul>
<p>协议: 无需遵守robots协议</p>
<ul>
<li>查看方法：网站url/robots.txt, 如<a href="https://www.baidu.com/robots.txt" target="_blank" rel="noopener">https://www.baidu.com/robots.txt</a></li>
</ul>
<hr>
<h3 id="聚焦爬虫"><a href="#聚焦爬虫" class="headerlink" title="聚焦爬虫"></a>聚焦爬虫</h3><ul>
<li>概念：聚焦爬虫指针对某一领域根据特定要求实现的爬虫程序, 抓取需要的数据(垂直领域爬取)</li>
<li>设计思路：<ol>
<li>确定爬取的url, 模拟浏览器请服务器发送请求:requests,urllib,aiohttp</li>
<li>获取响应数据并进行数据解析:xpath,bs4,pyquery,正则</li>
<li>将目标数据持久化：文件，关系型数据库，非关系型数据库</li>
</ol>
</li>
</ul>
<pre class="highlight"><span class="line"># 需求: 爬取百度首页, 并写入文件中, 最后用浏览器打开文件查看效果</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># 1.确定url, 向服务器发送请求</span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;www.baidu.com&#39;</span><br><span class="line">res &#x3D; resquests.get(url&#x3D;url)</span><br><span class="line"></span><br><span class="line"># 2.操作响应数据, 获取目标数据</span><br><span class="line">res.encoding &#x3D; &#39;utf-8&#39;</span><br><span class="line"></span><br><span class="line"># 3.将目标数据持久化到本地: 写入文件</span><br><span class="line">with open(&#39;baidu.html&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">    f.write(res.text)</span><br></pre>

<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/hugoblog/jujiao.png" alt="集聚爬虫设计思路" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/jujiao.png" class="lozad post-image"></h2><hr>
<h2 id="4-爬虫反爬机制与反反爬策略"><a href="#4-爬虫反爬机制与反反爬策略" class="headerlink" title="4.爬虫反爬机制与反反爬策略"></a>4.爬虫反爬机制与反反爬策略</h2><ul>
<li>UA检测</li>
<li>robot协议</li>
<li>动态数据加载: JS动态数据加载, Ajax数据加载</li>
<li>IP封禁</li>
<li>账号封禁</li>
<li>验证码</li>
<li>数据加密</li>
<li>隐藏参数</li>
<li>图片懒加载</li>
</ul>
<hr>
<h2 id="5-协议"><a href="#5-协议" class="headerlink" title="5.协议"></a>5.协议</h2><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><ul>
<li>HTTP协议: 明文传输, 端口80</li>
<li>Http协议, 全称为Hyper Text Transfer Protocol, 即超文本传输协议.</li>
<li>HTTP协议是用于从网络传输超文本数据到本地浏览器的传送协议, 它能保证高效而准确地传送超文本文档.</li>
<li>目前广泛使用的是HTTP 1.1版本<h3 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h3></li>
<li>HTTPS协议: 加密传输, 端口443</li>
<li>HTTPS全称是Hyper Text Transfer Protocol over Secure Socket Layer, 是以安全为目标的HTTP通道. HTTPS协议实质是HTTP的安全版, 即HTTP下加入SSL层, 简称HTTPS.</li>
<li>HTTPS的安全体现在SSL的加密行为, 即通过HTTPS协议传输的数据都是经过SSL加密的</li>
<li>HTTPS的作用:<ol>
<li>建立一个信息安全的通道来保证数据传输的安全</li>
<li>确认网站的真实性, 凡是使用了HTTPS的网站, 都可以通过点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息, 也可以通过CA机构颁发的安全签章来查询</li>
</ol>
</li>
</ul>
<hr>
<h2 id="6-服务器常见端口"><a href="#6-服务器常见端口" class="headerlink" title="6.服务器常见端口"></a>6.服务器常见端口</h2><ol>
<li>ftp：File Transfer Protocol的缩写, 即文件传输协议. 端口：21</li>
<li>ssh：Secure Shell的缩写, 用于远程登录会话. 端口：22</li>
<li>MySQL：关系型数据库, 端口：3306</li>
<li>MongoDB：非关系型数据库, 端口：27017</li>
<li>Redis：非关系型数据库, 端口：6379</li>
</ol>
<hr>
<h2 id="7-开发准备"><a href="#7-开发准备" class="headerlink" title="7.开发准备"></a>7.开发准备</h2><h3 id="web端"><a href="#web端" class="headerlink" title="web端"></a>web端</h3><pre class="highlight"><span class="line">Python3.6</span><br><span class="line">Pycharm</span><br><span class="line">Google Chrome</span><br></pre>
<h3 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h3><pre class="highlight"><span class="line">fiddler抓包工具</span><br><span class="line">Charles抓包工具</span><br><span class="line">Appium自动化测试工具</span><br></pre>
<hr>
<h2 id="8-请求过程与网页基础"><a href="#8-请求过程与网页基础" class="headerlink" title="8.请求过程与网页基础"></a>8.请求过程与网页基础</h2><h3 id="URL介绍"><a href="#URL介绍" class="headerlink" title="URL介绍"></a>URL介绍</h3><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="/hugoblog/url.png" alt="url" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/url.png" class="lozad post-image"></h2><h3 id="HTTP请求过程"><a href="#HTTP请求过程" class="headerlink" title="HTTP请求过程"></a>HTTP请求过程</h3><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="/hugoblog/qingqiu.png" alt="请求" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/hugoblog/qingqiu.png" class="lozad post-image"></h2><h3 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程:"></a>请求过程:</h3><p>客户端, 通常指web浏览器或APP向服务器发起请求, 服务器接收到请求进行处理, 并向客户端发起响应.</p>
<hr>
<h2 id="9-请求"><a href="#9-请求" class="headerlink" title="9.请求"></a>9.请求</h2><p>由客户端向服务器发出的,可以分为四部分内容:  </p>
<ol>
<li>请求方法(Request Method) </li>
<li>请求网址(Request URL)</li>
<li>请求头(Request Headers)</li>
<li>请求体(Request Body)</li>
</ol>
<hr>
<h3 id="请求方法-常见有8种"><a href="#请求方法-常见有8种" class="headerlink" title="请求方法:常见有8种"></a>请求方法:常见有8种</h3><pre class="highlight"><span class="line">- GET：请求页面, 并返回页面内容 </span><br><span class="line">- POST：用于提交表单数据或上传文件, 数据包含在请求体中  </span><br><span class="line">- PUT：从客户端向服务器传送的数据取代指定文档中的内容</span><br><span class="line">- DELETE：请求服务器删除指定的页面</span><br><span class="line">- HEAD：类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</span><br><span class="line">- CONNECT：把服务器当作跳板，让服务器代替客户端访问其他网页</span><br><span class="line">- OPTIONS：允许客户端查看服务器的性能</span><br><span class="line">- TRACE：回显服务器收到的请求，主要用于测试或诊断</span><br></pre>
<hr>
<h3 id="重点掌握GET-amp-POST的区别"><a href="#重点掌握GET-amp-POST的区别" class="headerlink" title="重点掌握GET &amp; POST的区别:"></a>重点掌握GET &amp; POST的区别:</h3><ol>
<li>GET请求中的参数包含在URL里面, 数据可以在URL中看到, 而POST请求的URL不会包含这些数据, POST的数据都是通过表单形式传输的, 会包含在请求体中</li>
<li>GET请求提交的数据最多只有1024字节, 而POST方式没有限制</li>
</ol>
<hr>
<h3 id="请求网址"><a href="#请求网址" class="headerlink" title="请求网址:"></a>请求网址:</h3><p>请求的网址，即统一资源定位符URL，它可以唯一确定我们想请求的资源</p>
<hr>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头:"></a>请求头:</h3><p>请求头:用来说明服务器要使用的附加信息. 重点: Accept, Cookie, Referer, User-Agent</p>
<ol>
<li>Accept：请求报头域，用于指定客户端可接受哪些类型的信息。 </li>
<li>Cookie：也常用复数形式 Cookies，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的主要功能是维持当前访问会话。例如，我们输入用户名和密码成功登录某个网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是Cookies的功劳。Cookies里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上Cookies并将其发送给服务器，服务器通过Cookies识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。  </li>
<li>Referer：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如作来源统计、防盗链处理等。  </li>
<li>User-Agent：简称UA，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出为爬虫  </li>
<li>x-requested-with :XMLHttpRequest   # 代表ajax请求</li>
<li>Accept-Language：指定客户端可接受的语言类型。</li>
<li>Accept-Encoding：指定客户端可接受的内容编码</li>
<li>Content-Type：也叫互联网媒体类型（Internet Media Type）或者MIME类型，在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息。例如，text/html代表HTML格式，image/gif代表GIF图片，application/json代表JSON类型</li>
</ol>
<hr>
<h3 id="请求体："><a href="#请求体：" class="headerlink" title="请求体："></a>请求体：</h3><p>请求体一般承载的内容是POST请求中的表单数据，而对于GET请求，请求体则为空</p>
<hr>
<h2 id="10-响应"><a href="#10-响应" class="headerlink" title="10.响应"></a>10.响应</h2><p>由服务端返回给客户端的, 可以分为三部分: </p>
<ol>
<li>响应状态码(response status code)</li>
<li>响应头(response headers)</li>
<li>响应体(response body)</li>
</ol>
<hr>
<h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码:"></a>响应状态码:</h3><p>用于判断请求后的响应状态, 如200代表请求成功, 404代表页面页面找不到, 500代表服务器错误</p>
<hr>
<h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码:"></a>常见的状态码:</h3><h5 id="200系列"><a href="#200系列" class="headerlink" title="200系列:"></a>200系列:</h5><pre class="highlight"><span class="line">200系列:</span><br><span class="line">	200   成功         服务器已成功处理了请求  (**)</span><br><span class="line"></span><br><span class="line">300系列:</span><br><span class="line">    301    永久移动     请求的网页已永久移动到新位置，即永久重定向  (**)</span><br><span class="line">    302    临时移动     请求的网页暂时跳转到其他页面，即暂时重定向  (**)</span><br><span class="line"></span><br><span class="line">400系列:</span><br><span class="line">    400    错误请求     服务器无法解析该请求  (**)</span><br><span class="line">    401    未授权       请求没有进行身份验证或验证未通过</span><br><span class="line">    403    禁止访问     服务器拒绝此请求  (**)</span><br><span class="line">    404    未找到       服务器找不到请求的网页</span><br><span class="line"></span><br><span class="line">500系列</span><br><span class="line">    500    服务器内部错误   服务器遇到错误，无法完成请求  (**)</span><br><span class="line">    501    未实现       服务器不具备完成请求的功能</span><br><span class="line">    502    错误网关     服务器作为网关或代理，从上游服务器收到无效响应</span><br><span class="line">    504    网关超时     服务器作为网关或代理，但是没有及时从上游服务器收到请求</span><br><span class="line">    505    HTTP版本不支持   服务器不支持请求中所用的HTTP协议版本</span><br></pre>
<hr>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>状态码不能完全代表响应状态, 部分网站的状态码是自定义的, 一切以响应的数据为准</p>
<hr>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头:"></a>响应头:</h3><p>响应头包含了服务器对请求的应答信息</p>
<ul>
<li>Date：标识响应产生的时间。</li>
<li>Content-Encoding：指定响应内容的编码。</li>
<li>Server：包含服务器的信息，比如名称、版本号等。</li>
<li>Content-Type：文档类型，指定返回的数据类型是什么，如text/html代表返回HTML文档，application/x-javascript则代表返回JavaScript文件，image/jpeg则代表返回图片。</li>
<li>Set-Cookie：设置Cookies。响应头中的Set-Cookie告诉浏览器需要将此内容放在Cookies中，下次请求携带Cookies请求。</li>
<li>Expires：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。</li>
</ul>
<hr>
<h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体:"></a>响应体:</h3><p>最重要的当属响应体的内容了。响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的HTML代码；请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体.</p>
<hr>
<h2 id="11-网页基础"><a href="#11-网页基础" class="headerlink" title="11.网页基础"></a>11.网页基础</h2><p>网页可以分为三部分, HTML, CSS, JavaScript</p>
<ul>
<li>HTML: 其全称叫作Hyper Text Markup Language，即超文本标记语言，定义了网页的骨架    </li>
<li>CSS: 全称叫作Cascading Style Sheets，即层叠样式表，定义了网页的样式</li>
<li>JavaScript: 简称JS，是一种脚本语言定义了网页与用户的交互行为, 如下载进度条, 提示框, 播图 </li>
</ul>
<hr>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Django--ORM操作</title>
    <url>/2020/04/18/d_m/</url>
    <content><![CDATA[<h3 id="Django模型之ORM操作"><a href="#Django模型之ORM操作" class="headerlink" title="Django模型之ORM操作"></a>Django模型之ORM操作</h3><h4 id="ORM介绍"><a href="#ORM介绍" class="headerlink" title="ORM介绍"></a>ORM介绍</h4><ul>
<li><p><strong>什么是ORM</strong><br>ORM 全拼Object-Relation Mapping.</p>
<p>中文意为 对象-关系映射.</p>
<p>在MVC/MVT设计模式中的Model模块中都包括ORM</p>
</li>
<li><p><strong>ORM优势</strong></p>
<ul>
<li><p>只需要面向对象编程, 不需要面向数据库编写代码.</p>
<p>对数据库的操作都转化成对类属性和方法的操作.<br>不用编写各种数据库的sql语句.</p>
</li>
<li><p>实现了数据模型与数据库的解耦, 屏蔽了不同数据库操作上的差异.</p>
<p>不在关注用的是mysql、oracle…等.<br>通过简单的配置就可以轻松更换数据库, 而不需要修改代码.</p>
</li>
</ul>
</li>
<li><p><strong>ORM劣势</strong><br>相比较直接使用SQL语句操作数据库,有性能损失.<br>根据对象的操作转换成SQL语句,根据查询的结果转化成对象, 在映射过程中有性能损失.</p>
</li>
<li><p><strong>ORM和数据库关系：</strong><br>在Django中model是你数据的单一、明确的信息来源。它包含了你存储的数据的重要字段和行为。通常，一个模型（model）映射到一个数据库表.</p>
<p>基本情况：</p>
<p>每个模型都是一个Python类，它是django.db.models.Model的子类。</p>
<p>模型的每个属性都代表一个数据库字段。</p>
</li>
</ul>
<h4 id="ORM操作"><a href="#ORM操作" class="headerlink" title="ORM操作"></a>ORM操作</h4><p><strong>增加操作</strong></p>
<pre class="highlight"><span class="line"><span class="comment"># 通过python manage.py shell 进入到shell下</span></span><br><span class="line"><span class="comment"># 进入shell环境以后，首先导入模型</span></span><br><span class="line"><span class="keyword">from</span> polls.models <span class="keyword">import</span> * 			<span class="comment"># 导入全部模型</span></span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone   <span class="comment"># 导入时间模块</span></span><br><span class="line"><span class="comment"># 创建方法一：</span></span><br><span class="line">q = Question(question_text=<span class="string">"什么地方的菜最有特色？"</span>, pub_date=timezone.now())</span><br><span class="line">q.save()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关联创建，用问题关联创建选项</span></span><br><span class="line">q.choice_set.create(choice_text=<span class="string">"湖南"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建方法二：</span></span><br><span class="line">q = Question()          <span class="comment"># 创建实例对象</span></span><br><span class="line">q.question_text = <span class="string">"什么地方的菜最有特色？"</span></span><br><span class="line">q.pub_date = timeaone.now()</span><br><span class="line">q.save()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建方法三：</span></span><br><span class="line">Question.objects.create(question_text=<span class="string">"什么地方的菜最有特色？"</span>, </span><br><span class="line">                        pub_date=timezone.now())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量创建，可以提高性能，减少对数据库的访问写入次数</span></span><br><span class="line">bulk_create()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量添加，需要传入的参数是一个列表</span></span><br><span class="line">Question.objects.bulk_create(</span><br><span class="line">    [</span><br><span class="line">        Question(question_text=<span class="string">"什么地方的菜最有特色？"</span>, pub_date=timezone.now()),</span><br><span class="line">        Question(question_text=<span class="string">"什么地方的景色最美？"</span>, pub_date=timezone.now())，</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre>

<h4 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h4><pre class="highlight"><span class="line"><span class="comment"># 修改方法1：</span></span><br><span class="line">Question.objects.filter(pk=<span class="number">1</span>).update(question_text = <span class="string">"什么地方最好玩？"</span>)</span><br></pre>

<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><pre class="highlight"><span class="line"><span class="comment"># 删除：(先查询到某个queryset对象，然后用删除命令)</span></span><br><span class="line">q = Question.objects.get(id=<span class="number">1</span>)</span><br><span class="line">q.delete()</span><br></pre>

<h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><p><strong>必会的方法</strong></p>
<pre class="highlight"><span class="line"><span class="comment"># 1、 all():                 查询所有结果</span></span><br><span class="line">question_list = Question.objects.all()  <span class="comment"># 返回一个queryset集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、 filter(**kwargs):      它包含了与所给筛选条件相匹配的对象</span></span><br><span class="line">question_list = Question.objects.filter(pk=<span class="number">1</span>)  <span class="comment"># 返回一个queryset集合,如果没有查询到，返回一个空集合,不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、 get(**kwargs):         返回与所给筛选条件相匹配的对象，返回结果有且只有一个，如果符合筛选条件的							  对象超过一个或者没有都会抛出错误。</span></span><br><span class="line">question = Question.objects.get(pk=<span class="number">1</span>)  <span class="comment"># 返回一个queryset对象，并且只会得到一个数据，如果没有查询到，会报DoesNotExist的错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、 exclude(**kwargs):     它包含了与所给筛选条件不匹配的对象</span></span><br><span class="line">question = Question.objects.exclude(id__in=<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>])  <span class="comment"># 筛选id除了11，22，33外的，其它的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、 values(*field):        返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列                              model的实例化对象，而是一个可迭代的字典序列</span></span><br><span class="line">question = Question.objects.values()</span><br><span class="line"><span class="comment"># 返回结果：[&#123;"id": 1, "question_name": "xxxxxxx"&#125;, &#123;"id": 2, "question_name": "xxxxxxx"&#125;, ...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6、 values_list(*field):   它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序							   列</span></span><br><span class="line">question = Question.objects.values_list()</span><br><span class="line"><span class="comment"># 返回结果：[(1, "xxxxxxx"), (2, "xxxxxxx"), ....]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7、 order_by(*field):      对查询结果排序</span></span><br><span class="line">user_list = User.objects.order_by(<span class="string">"-id"</span>)  <span class="comment"># “-” 按id降序排列</span></span><br><span class="line">user_list = User.objects.order_by()  <span class="comment"># 按id升序排列（默认）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 8、 reverse():             对查询结果反向排序，请注意reverse()通常只能在具有已定义顺序的QuerySet								上调用(在model类的Meta中指定ordering或调用order_by()方法)。</span></span><br><span class="line">user = User.objects.all().reverse()  <span class="comment"># 把查询的结果进行反转</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 9、 distinct():            从返回结果中剔除重复纪录(如果你查询跨越多个表，可能在计算QuerySet时得到							 重复的结果。此时可以使用distinct()，注意只有在PostgreSQL中支持按字段							  去重。)</span></span><br><span class="line">Question.objects.all().distinct()  <span class="comment"># 把结果中重复的记录剔除</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 10、 count():              返回数据库中匹配查询(QuerySet)的对象数量。</span></span><br><span class="line">user_count = User.objects.count()  <span class="comment"># 返回user表中的用户数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 11、 first():              返回第一条记录</span></span><br><span class="line">User.objects.first()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 12、 last():               返回最后一条记录</span></span><br><span class="line">User.objects.last()    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 13、 exists():             如果QuerySet包含数据，就返回True，否则返回False</span></span><br><span class="line">user = User.objects.filter(pk=<span class="number">1</span>).exists()  <span class="comment"># 返回True 或者False</span></span><br><span class="line"><span class="keyword">if</span> user:</span><br><span class="line">    print(<span class="string">"OK"</span>)</span><br></pre>



<h3 id="查询条件"><a href="#查询条件" class="headerlink" title="查询条件"></a>查询条件</h3><p><strong>在 ORM 层面，这些查询条件都是使用 field + __ + condition 的方式来使用</strong></p>
<pre class="highlight"><span class="line"><span class="comment"># 精确的 等于,如果提供一个None,SQL解析为Null</span></span><br><span class="line">article = Article.objects.get(id__exact=<span class="number">14</span>)</span><br><span class="line">article = Article.objects.get(id__exact=<span class="literal">None</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">对应sql</span></span><br><span class="line"><span class="string">select ... from article where id=14;</span></span><br><span class="line"><span class="string">select ... from article where id IS NULL;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># iexact 使用like查询</span></span><br><span class="line">article = Article.objects.filter(title__iexact=<span class="string">'hello world'</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">等价于 select ... from article where title like 'hello world'</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 包含:contains,区分大小写</span></span><br><span class="line">articles = Article.objects.filter(title__contains=<span class="string">'hello'</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">等价于select ... where title like binary '%hello%';</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># icontains 忽略大小写</span></span><br><span class="line">articles = Article.objects.filter(title__icontains=<span class="string">'hello'</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">等价于 select ... where title like '%hello%';</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># in 提取那些给定的field的值是否在给定的容器中。容器可以为list、tuple或者任何一个可以迭代的对</span></span><br><span class="line">象，<span class="comment"># 包括QuerySet对象</span></span><br><span class="line">articles = Article.objects.filter(id__in=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">等价于 select ... where id in (1,3,4)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 当然也可以传递一个QuerySet对象进去。示例代码如下：</span></span><br><span class="line">inner_qs = Article.objects.filter(title__contains=<span class="string">'hello'</span>)</span><br><span class="line">categories = Category.objects.filter(article__in=inner_qs)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">等价于:以上代码的意思是获取那些文章标题包含hello的所有分类。</span></span><br><span class="line"><span class="string">select ...from category where article.id in (select id from article where title</span></span><br><span class="line"><span class="string">like '%hello%');</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># gt 大于</span></span><br><span class="line">articles = Article.objects.filter(id__gt=<span class="number">4</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">等价于 select ... where id &gt; 4;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># gte 大于等于</span></span><br><span class="line"><span class="comment"># lt 小于</span></span><br><span class="line"><span class="comment"># lte 小于等于</span></span><br><span class="line"><span class="comment"># startswidth 开始,大小写敏感</span></span><br><span class="line">articles = Article.objects.filter(title__startswith=<span class="string">'hello'</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">等价于: select ... where title like 'hello%'</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># istartswidth 大小写不敏感</span></span><br><span class="line"><span class="comment"># endswidth 以**结尾,大小写敏感</span></span><br><span class="line">articles = Article.objects.filter(title__endswith=<span class="string">'world'</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">等价于:select ... where title like '%world';</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># iendswidht 以**结尾,忽略大小写</span></span><br><span class="line"><span class="comment"># range 判断某个field的值是否在给定的区间中, 两个范围之间</span></span><br><span class="line"><span class="keyword">from</span> django.utils.timezone <span class="keyword">import</span> make_aware</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">start_date = make_aware(datetime(year=<span class="number">2018</span>,month=<span class="number">1</span>,day=<span class="number">1</span>))</span><br><span class="line">end_date = make_aware(datetime(year=<span class="number">2018</span>,month=<span class="number">3</span>,day=<span class="number">29</span>,hour=<span class="number">16</span>))</span><br><span class="line">articles = Article.objects.filter(pub_date__range=(start_date,end_date))</span><br><span class="line"><span class="comment"># isnull</span></span><br><span class="line">articles = Article.objects.filter(pub_date__isnull=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># regex和iregex： 正则</span></span><br><span class="line">articles = Article.objects.filter(title__regex=<span class="string">r'^hello'</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">等价:select ... where title regexp binary '^hello';</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">以上代码的意思是提取所有发布时间在2018/1/1到2018/12/12之间的文章。</span></span><br><span class="line"><span class="string">将翻译成以下的SQL语句：</span></span><br><span class="line"><span class="string">select ... from article where pub_time between '2018-01-01' and '2018-12-12'。</span></span><br><span class="line"><span class="string">需要注意的是，以上提取数据，不会包含最后一个值。也就是不会包含2018/12/12的文章。</span></span><br><span class="line"><span class="string">而且另外一个重点，因为我们在settings.py中指定了USE_TZ=True，并且设置了</span></span><br><span class="line"><span class="string">TIME_ZONE='Asia/Shanghai'，因此我们在提取数据的时候要使用django.utils.timezone.make_aware</span></span><br><span class="line"><span class="string">先将datetime.datetime从navie时间转换为aware时间。make_aware会将指定的时间转换为TIME_ZONE中</span></span><br><span class="line"><span class="string">指定的时区的时间。</span></span><br><span class="line"><span class="string">'''</span></span><br></pre>



<h3 id="根据关联的表查"><a href="#根据关联的表查" class="headerlink" title="根据关联的表查"></a>根据关联的表查</h3><p><strong>假如现在有两个 ORM 模型，一个是 Article ，一个是 Category 。代码如下：</strong></p>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Category</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">  <span class="string">"""文章分类表"""</span></span><br><span class="line">  name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">  <span class="string">"""文章表"""</span></span><br><span class="line">  title = models.CharField(max_length=<span class="number">100</span>,null=<span class="literal">True</span>)</span><br><span class="line">  category = models.ForeignKey(<span class="string">"Category"</span>,on_delete=models.CASCADE)</span><br></pre>

<p><strong>比如想要获取文章标题中包含”hello”的所有的分类。那么可以通过以下代码来实现：</strong></p>
<pre class="highlight"><span class="line">categories = Category.object.filter(article__title__contains(<span class="string">"hello"</span>))</span><br></pre>



<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p><strong>聚合函数是通过 aggregate 方法来实现的。</strong></p>
<ul>
<li><p><strong>Avg ：求平均值。比如想要获取所有图书的价格平均值。那么可以使用以下代码实现</strong></p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Avg</span><br><span class="line">result = Book.objects.aggregate(Avg(<span class="string">'price'</span>))</span><br><span class="line">print(result)</span><br></pre>

<p>以上的打印结果是：</p>
<pre class="highlight"><span class="line">&#123;&quot;price__avg&quot;:23.0&#125;</span><br></pre>

<p>其中 price__avg 的结构是根据 field__avg 规则构成的。如果想要修改默认的名字，那么可以将 Avg 赋值<br>给一个关键字参数。示例代码如下：</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Avg</span><br><span class="line">result = Book.objects.aggregate(my_avg=Avg(<span class="string">'price'</span>))</span><br><span class="line">print(result)</span><br></pre>

<p>那么以上的结果打印为：</p>
<pre class="highlight"><span class="line">&#123;<span class="string">"my_avg"</span>:<span class="number">23</span>&#125;</span><br></pre>
</li>
<li><p><strong>Count ：获取指定的对象的个数。示例代码如下：</strong></p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count</span><br><span class="line">result = Book.objects.aggregate(book_num=Count(<span class="string">'id'</span>))</span><br></pre>

<p>以上的 result 将返回 Book 表中总共有多少本图书。  Count 类中，还有另外一个参数叫做 distinct ，默<br>认是等于 False ，如果是等于 True ，那么将去掉那些重复的值。比如要获取作者表中所有的不重复的邮箱<br>总共有多少个，那么可以通过以下代码来实现：</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> djang.db.models <span class="keyword">import</span> Count</span><br><span class="line">result = Author.objects.aggregate(count=Count(<span class="string">'email'</span>,distinct=<span class="literal">True</span>))</span><br></pre>
</li>
<li><p><strong>Max 和 Min ：获取指定对象的最大值和最小值。比如想要获取 Author 表中，最大的年龄和最小的年龄分别</strong><br><strong>是多少。那么可以通过以下代码来实现：</strong></p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Max,Min</span><br><span class="line">result = Author.objects.aggregate(Max(<span class="string">'age'</span>),Min(<span class="string">'age'</span>))</span><br></pre>

<p>如果最大的年龄是88,最小的年龄是18。那么以上的result将为：</p>
<pre class="highlight"><span class="line">&#123;<span class="string">"age__max"</span>:<span class="number">88</span>,<span class="string">"age__min"</span>:<span class="number">18</span>&#125;</span><br></pre>
</li>
<li><p><strong>Sum ：求指定对象的总和。比如要求图书的销售总额。那么可以使用以下代码实现：</strong></p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> djang.db.models <span class="keyword">import</span> Sum</span><br><span class="line">result =</span><br><span class="line">Book.objects.annotate(total=Sum(<span class="string">"bookstore__price"</span>)).values(<span class="string">"name"</span>,<span class="string">"total"</span>)</span><br></pre>

<p>以上的代码 annotate 的意思是给 Book 表在查询的时候添加一个字段叫做 total ，这个字段的数据来源是<br>从 BookStore 模型的 price 的总和而来。 values 方法是只提取 name 和 total 两个字段的值。</p>
<p>更多的聚合函数请参考官方文档：<a href="https://docs.djangoproject.com/en/2.0/ref/models/querysets/#aggregation-functions" target="_blank" rel="noopener">https://docs.djangoproject.com/en/2.0/ref/models/querysets/#aggregation-functions</a></p>
</li>
</ul>
<h3 id="aggregate和annotate的区别："><a href="#aggregate和annotate的区别：" class="headerlink" title="aggregate和annotate的区别："></a>aggregate和annotate的区别：</h3><ul>
<li>aggregate ：返回使用聚合函数后的字段和值。</li>
<li>annotate ：在原来模型字段的基础之上添加一个使用了聚合函数的字段，并且在使用聚合函数的时候，会<br>使用当前这个模型的主键进行分组（group by）。 比如以上 Sum 的例子，如果使用的是 annotate ，那么将<br>在每条图书的数据上都添加一个字段叫做 total ，计算这本书的销售总额。 而如果使用的是 aggregate ，<br>那么将求所有图书的销售总额。</li>
</ul>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Author</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">  <span class="string">"""作者模型"""</span></span><br><span class="line">  name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">  age = models.IntegerField()</span><br><span class="line">  email = models.EmailField()</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">    db_table = <span class="string">'author'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Publisher</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">  <span class="string">"""出版社模型"""</span></span><br><span class="line">  name = models.CharField(max_length=<span class="number">300</span>)</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">    db_table = <span class="string">'publisher'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">  <span class="string">"""图书模型"""</span></span><br><span class="line">  name = models.CharField(max_length=<span class="number">300</span>)</span><br><span class="line">  pages = models.IntegerField()</span><br><span class="line">  price = models.FloatField()</span><br><span class="line">  rating = models.FloatField()</span><br><span class="line">  author = models.ForeignKey(Author,on_delete=models.CASCADE)</span><br><span class="line">  publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">    db_table = <span class="string">'book'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookOrder</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">  <span class="string">"""图书订单模型"""</span></span><br><span class="line">  book = models.ForeignKey(<span class="string">"Book"</span>,on_delete=models.CASCADE)</span><br><span class="line">  price = models.FloatField()</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">    db_table = <span class="string">'book_order'</span></span><br></pre>



<h3 id="F表达式和Q表达式："><a href="#F表达式和Q表达式：" class="headerlink" title="F表达式和Q表达式："></a>F表达式和Q表达式：</h3><h4 id="F表达式："><a href="#F表达式：" class="headerlink" title="F表达式："></a>F表达式：</h4><p>F表达式 是用来优化 ORM 操作数据库的。比如我们要将公司所有员工的薪水都增加1000元，如果按照正常的流<br>程，应该是先从数据库中提取所有的员工工资到Python内存中，然后使用Python代码在员工工资的基础之上增加<br>1000元，最后再保存到数据库中。这里面涉及的流程就是，首先从数据库中提取数据到Python内存中，然后在<br>Python内存中做完运算，之后再保存到数据库中。示例代码如下：</p>
<pre class="highlight"><span class="line">employees = Employee.objects.all()</span><br><span class="line"><span class="keyword">for</span> employee <span class="keyword">in</span> employees:</span><br><span class="line">  employee.salary += <span class="number">1000</span></span><br><span class="line">  employee.save()</span><br></pre>

<p>而我们的 F表达式 就可以优化这个流程，他可以不需要先把数据从数据库中提取出来，计算完成后再保存回去，他可以直接执行 SQL语句 ，就将员工的工资增加1000元。示例代码如下：</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> djang.db.models <span class="keyword">import</span> F</span><br><span class="line">Employee.object.update(salary=F(<span class="string">"salary"</span>)+<span class="number">1000</span>)</span><br><span class="line"><span class="comment"># 直接把sql传输到数据库!!!!!</span></span><br></pre>

<p>F表达式 并不会马上从数据库中获取数据，而是在生成 SQL 语句的时候，动态的获取传给 F表达式 的值。<br>比如如果想要获取作者中， name 和 email 相同的作者数据。如果不使用 F表达式 ，那么需要使用以下代码来完<br>成：</p>
<pre class="highlight"><span class="line">authors = Author.objects.all()</span><br><span class="line"><span class="keyword">for</span> author <span class="keyword">in</span> authors:</span><br><span class="line">	<span class="keyword">if</span> author.name == author.email:</span><br><span class="line">   		print(author)</span><br></pre>

<p>如果使用 F表达式 ，那么一行代码就可以搞定。示例代码如下：</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line">authors = Author.objects.filter(name=F(<span class="string">"email"</span>))</span><br><span class="line"><span class="comment"># where  email = name</span></span><br></pre>

<h4 id="Q表达式："><a href="#Q表达式：" class="headerlink" title="Q表达式："></a>Q表达式：</h4><p>如果想要实现所有价格高于100元，并且评分达到9.0以上评分的图书。那么可以通过以下代码来实现：</p>
<pre class="highlight"><span class="line">books = Book.objects.filter(price__gte=<span class="number">100</span>,rating__gte=<span class="number">9</span>)</span><br></pre>

<p>以上这个案例是一个并集查询，可以简单的通过传递多个条件进去来实现。 但是如果想要实现一些复杂的查询语<br>句，比如要查询所有价格低于10元，或者是评分低于9分的图书。那就没有办法通过传递多个条件进去实现了。这<br>时候就需要使用 Q表达式 来实现了。示例代码如下：</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line">books = Book.objects.filter(Q(price__lte=<span class="number">10</span>) | Q(rating__lte=<span class="number">9</span>))</span><br></pre>

<p>以上是进行或运算，当然还可以进行其他的运算，比如有 &amp; 和 ~（非） 等。一些用 Q 表达式的例子如下：</p>
<pre class="highlight"><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"><span class="comment"># 获取id等于3的图书</span></span><br><span class="line">books = Book.objects.filter(Q(id=<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 获取id等于3，或者名字中包含文字"记"的图书</span></span><br><span class="line">books = Book.objects.filter(Q(id=<span class="number">3</span>)|Q(name__contains(<span class="string">"记"</span>)))</span><br><span class="line"><span class="comment"># 获取价格大于100，并且书名中包含"记"的图书</span></span><br><span class="line">books = Book.objects.filter(Q(price__gte=<span class="number">100</span>)&amp;Q(name__contains(<span class="string">"记"</span>)))</span><br><span class="line"><span class="comment"># 获取书名包含“记”，但是id不等于3的图书</span></span><br><span class="line">books = Book.objects.filter(Q(name__contains=<span class="string">'记'</span>) &amp; ~Q(id=<span class="number">3</span>))</span><br></pre>



<h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><pre class="highlight"><span class="line"><span class="comment"># data</span></span><br><span class="line">针对某些date或者datetime类型的字段。可以指定date的范围。并且这个时间过滤，还可以使用链式调用。示</span><br><span class="line">例代码如下：</span><br><span class="line">articles = Article.objects.filter(pub_date__date=date(<span class="number">2018</span>,<span class="number">3</span>,<span class="number">29</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">以上代码的意思是查找时间为2018/3/29这一天发表的所有文章。</span></span><br><span class="line"><span class="string">将翻译成以下的sql语句：</span></span><br><span class="line"><span class="string">select ... WHERE DATE(CONVERT_TZ(`front_article`.`pub_date`, 'UTC',</span></span><br><span class="line"><span class="string">'Asia/Shanghai')) = 2018-03-29</span></span><br><span class="line"><span class="string">注意，因为默认情况下MySQL的表中是没有存储时区相关的信息的。因此我们需要下载一些时区表的文件，然后添</span></span><br><span class="line"><span class="string">加到Mysql的配置路径中。如果你用的是windows操作系统。那么在</span></span><br><span class="line"><span class="string">http://dev.mysql.com/downloads/timezones.html下载timezone_2018d_posix.zip - POSIX</span></span><br><span class="line"><span class="string">standard。然后将下载下来的所有文件拷贝到C:\ProgramData\MySQL\MySQL Server 5.7\Data\mysql</span></span><br><span class="line"><span class="string">中，如果提示文件名重复，那么选择覆盖即可。</span></span><br><span class="line"><span class="string">如果用的是linux或者mac系统，那么在命令行中执行以下命令：mysql_tzinfo_to_sql</span></span><br><span class="line"><span class="string">/usr/share/zoneinfo | mysql -D mysql -u root -p，然后输入密码，从系统中加载时区文件更新到</span></span><br><span class="line"><span class="string">mysql中。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># year 根据年份进行查找</span></span><br><span class="line">articles = Article.objects.filter(pub_date__year=<span class="number">2018</span>)</span><br><span class="line">articles = Article.objects.filter(pub_date__year__gte=<span class="number">2017</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">等价于:</span></span><br><span class="line"><span class="string">select ... where pub_date between '2018-01-01' and '2018-12-31';</span></span><br><span class="line"><span class="string">select ... where pub_date &gt;= '2017-01-01';</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># month 同year,根据月份查</span></span><br><span class="line"><span class="comment"># day  同year,根据日期查</span></span><br><span class="line"><span class="comment"># week_day Django 1.11新增的查找方式。同year，根据星期几进行查找。1表示星期天，7表示星期六，2-6代表的是星期一到星期五。</span></span><br><span class="line"><span class="comment"># time 根据时间查</span></span><br><span class="line">articles = Article.objects.filter(pub_date__time=datetime.time(<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>));</span><br></pre>
]]></content>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx简介</title>
    <url>/2019/02/23/nginx%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="1-nginx-功能介绍"><a href="#1-nginx-功能介绍" class="headerlink" title="1. nginx 功能介绍"></a>1. nginx 功能介绍</h1><p>Nginx因为它的稳定性、丰富的模块库、灵活的配置和低系统资源的消耗而闻名．业界一致认为它是Apache2.2＋mod_proxy_balancer的轻量级代替者，不仅是因为响应静态页面的速度非常快，而且它的模块数量达到Apache的近2/3。对proxy和rewrite模块的支持很彻底，还支持mod_fcgi、ssl、vhosts ，适合用来做mongrel clusters的前端HTTP响应。<br>nginx和Apache一样使用模块化设计，nginx模块包括内置模块和第三方模块，其中内置模块中包含主模块和事件模块。</p>
<p>nginx处理请求逻辑图<br><img src="https://img-blog.csdnimg.cn/20190511170603322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20190511170603322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h1 id="2-nginx可以提供的服务"><a href="#2-nginx可以提供的服务" class="headerlink" title="2. nginx可以提供的服务"></a>2. nginx可以提供的服务</h1><pre class="highlight"><span class="line">1. web 服务.</span><br><span class="line">2. 负载均衡 （反向代理）</span><br><span class="line">3. web cache（web 缓存）</span><br></pre>
<h1 id="3-nginx-的优点"><a href="#3-nginx-的优点" class="headerlink" title="3. nginx 的优点"></a>3. nginx 的优点</h1><pre class="highlight"><span class="line">1. 高并发。静态小文件</span><br><span class="line">2. 占用资源少。2万并发、10个线程，内存消耗几百M。</span><br><span class="line">3. 功能种类比较多。web,cache,proxy。每一个功能都不是特别强。</span><br><span class="line">4. 支持epoll模型，使得nginx可以支持高并发。</span><br><span class="line">5. nginx 配合动态服务和Apache有区别。（FASTCGI 接口）</span><br><span class="line">6. 利用nginx可以对IP限速，可以限制连接数。</span><br><span class="line">7. 配置简单，更灵活。</span><br></pre>

<h1 id="4-nginx应用场合"><a href="#4-nginx应用场合" class="headerlink" title="4. nginx应用场合"></a>4. nginx应用场合</h1><pre class="highlight"><span class="line">1. 静态服务器。（图片，视频服务）另一个lighttpd。并发几万，html，js，css，flv，jpg，gif等。</span><br><span class="line">2. 动态服务，nginx——fastcgi 的方式运行PHP，jsp。（PHP并发在500-1500，MySQL 并发在300-1500）。</span><br><span class="line">3. 反向代理，负载均衡。日pv2000W以下，都可以直接用nginx做代理。</span><br><span class="line">4. 缓存服务。类似 SQUID,VARNISH。</span><br></pre>
<h1 id="5-主流web服务产品对比说明"><a href="#5-主流web服务产品对比说明" class="headerlink" title="5. 主流web服务产品对比说明"></a>5. 主流web服务产品对比说明</h1><h2 id="5-1-Apache-特性"><a href="#5-1-Apache-特性" class="headerlink" title="5.1 Apache-特性"></a>5.1 Apache-特性</h2><pre class="highlight"><span class="line">1. 2.2版本本身稳定强大，据官方说：其2.4版本性能更强。</span><br><span class="line">2. prefork模式取消了进程创建开销，性能很高。</span><br><span class="line">3. 处理动态业务数据时，因关联到后端的引擎和数据库，瓶颈不在与Apache本身。</span><br><span class="line">4. 高并发时消耗系统资源相对多一些。</span><br><span class="line">5. 基于传统的select模型。</span><br><span class="line">6. 扩展库，DSO方法。</span><br></pre>
<h2 id="5-2-nginx-特性"><a href="#5-2-nginx-特性" class="headerlink" title="5.2 nginx-特性"></a>5.2 nginx-特性</h2><pre class="highlight"><span class="line">1. 基于异步IO模型，（epoll，kqueue），性能强，能够支持上万并发。</span><br><span class="line">2. 对小文件支持很好，性能很高（限静态小文件1M）。</span><br><span class="line">3. 代码优美，扩展库必须编译进主程序。</span><br><span class="line">4. 消耗代码资源比较低。</span><br><span class="line">5.  ighttpd（百度贴吧，豆瓣）</span><br><span class="line">6. 基于异步IO模式，性能和nginx相近。</span><br><span class="line">7. 扩展库是SO模式，比nginx要灵活。</span><br><span class="line">8. 通过差距（mod_secdownload）可实现文件URL地址加密。</span><br></pre>
<h2 id="5-3-web服务产品性能对比测试"><a href="#5-3-web服务产品性能对比测试" class="headerlink" title="5.3 web服务产品性能对比测试"></a>5.3 web服务产品性能对比测试</h2><h3 id="5-3-1-静态数据性能对比"><a href="#5-3-1-静态数据性能对比" class="headerlink" title="5.3.1 静态数据性能对比"></a>5.3.1 静态数据性能对比</h3><pre class="highlight"><span class="line">1. 处理静态文件Apache性能比nginx和lighttpd要差。</span><br><span class="line">2. nginx在处理小文件优势明显。</span><br><span class="line">3. 处理静态小文件（小于1M），nginx和lighttpd比Apache更有优势，lighttpd最强。</span><br></pre>
<h3 id="5-3-2-动态数据性能对比"><a href="#5-3-2-动态数据性能对比" class="headerlink" title="5.3.2 动态数据性能对比"></a>5.3.2 动态数据性能对比</h3><pre class="highlight"><span class="line">1. 处理动态内容三者相差不大，主要取决于PHP和数据库的压力。</span><br><span class="line">2. 当处理动态数据时，三者差距不大，从测试结果看，Apache更有优势一点。这是因为处理动态数据能力取决于PHP和后端数据的提供服务能力。也就是说瓶颈不在web服务器上。</span><br><span class="line">3. 一般PHP引擎支持的并发参考值300-1000，JAVA引擎并发300-1000，数据库的并发300-1000.</span><br></pre>
<h3 id="5-3-3-为什么nginx的总体性能比Apache高。"><a href="#5-3-3-为什么nginx的总体性能比Apache高。" class="headerlink" title="5.3.3 为什么nginx的总体性能比Apache高。"></a>5.3.3 为什么nginx的总体性能比Apache高。</h3><pre class="highlight"><span class="line">1. nginx使用最新的epoll和kqueue网络IO模型，而Apache使用床头的select模式。</span><br><span class="line">2. 目前Linux下能够承受高并发访问的squid、Memcached 都采用的是epoll网络IO模型。</span><br></pre>

<h3 id="5-3-4-如何选择WEB服务器"><a href="#5-3-4-如何选择WEB服务器" class="headerlink" title="5.3.4 如何选择WEB服务器"></a>5.3.4 如何选择WEB服务器</h3><pre class="highlight"><span class="line">静态业务：高并发、采用nginx，lighttpd，根据自己的掌握程度或公司的要求。</span><br><span class="line">动态业务：采用nginx和Apache均可。</span><br><span class="line">既有静态业务又有动态业务：nginx或Apache，不要多选要单选。</span><br><span class="line">动态业务可以由前端代理（haproxy）,根据页面元素的类型，向后转发相应的服务器进行处理。</span><br><span class="line">思想：我们工作都不要追求一步到位，满足需求的前提下，先用，然后逐步完善。</span><br><span class="line">提示：nginx做web（Apache，lighttpd）、反向代理（haproxy,lvs,nat）及缓存服务器（squid）也是不错的。</span><br><span class="line">最终建议：对外的业务nginx，对内的业务Apache（yum httpd mysql-server php）。</span><br></pre>

<h1 id="6-nginx实战过程"><a href="#6-nginx实战过程" class="headerlink" title="6. nginx实战过程"></a>6. nginx实战过程</h1><h2 id="6-1-安装依赖包"><a href="#6-1-安装依赖包" class="headerlink" title="6.1 安装依赖包"></a>6.1 安装依赖包</h2><ul>
<li>nginx安装依赖GCC、openssl-devel、pcre-devel和zlib-devel软件库。</li>
<li>Pcre全称（Perl Compatible Regular Expressions），中文perl兼容正则表达式，<a href="http://www.pcre.org/" target="_blank" rel="noopener">pcre官方站点</a>。<pre class="highlight"><span class="line">yum install  pcre pcre-devel -y </span><br><span class="line">yum install openssl openssl-devel -y</span><br></pre>

</li>
</ul>
<h2 id="6-2-开始编译"><a href="#6-2-开始编译" class="headerlink" title="6.2 开始编译"></a>6.2 开始编译</h2><p>使用<strong>./configure –help</strong>查看各个模块的使用情况，使用<strong>–without-http_ssi_module</strong>的方式关闭不需要的模块。可以使用<strong>–with-http_perl_modules</strong>方式安装需要的模块。</p>
<h3 id="6-2-1-编译命令"><a href="#6-2-1-编译命令" class="headerlink" title="6.2.1 编译命令"></a>6.2.1 编译命令</h3><pre class="highlight"><span class="line">tar -zxf nginx<span class="number">-1.10</span><span class="number">.1</span>.tar.gz </span><br><span class="line">cd nginx<span class="number">-1.10</span><span class="number">.1</span>/</span><br><span class="line">./configure --prefix=/data/nginx<span class="number">-1.10</span><span class="number">.1</span> --user=nginx --group=nginx  --<span class="keyword">with</span>-http_ssl_module  --<span class="keyword">with</span>-http_stub_status_module</span><br><span class="line"></span><br><span class="line">useradd nginx -M -s /sbin/nologin </span><br><span class="line">make &amp;&amp; make install </span><br><span class="line">ln -s /data/nginx<span class="number">-1.10</span><span class="number">.1</span> /data/nginx</span><br></pre>
<h3 id="6-2-2-测试nginx配置文件是否正常"><a href="#6-2-2-测试nginx配置文件是否正常" class="headerlink" title="6.2.2 测试nginx配置文件是否正常"></a>6.2.2 测试nginx配置文件是否正常</h3><pre class="highlight"><span class="line">/data/nginx/sbin/nginx -t </span><br><span class="line">nginx: the configuration file /data/nginx<span class="number">-1.10</span><span class="number">.1</span>/conf/nginx.conf syntax <span class="keyword">is</span> ok</span><br><span class="line">nginx: configuration file /data/nginx<span class="number">-1.10</span><span class="number">.1</span>/conf/nginx.conf test <span class="keyword">is</span> successful</span><br></pre>
<h3 id="6-2-3-启动nginx服务器"><a href="#6-2-3-启动nginx服务器" class="headerlink" title="6.2.3 启动nginx服务器"></a>6.2.3 启动nginx服务器</h3><pre class="highlight"><span class="line">/data/nginx/sbin/nginx  -t  <span class="comment">##检查配置文件</span></span><br><span class="line">/data/nginx/sbin/nginx      <span class="comment">##确定nginx服务</span></span><br><span class="line">netstat -lntup |grep nginx      <span class="comment">## 检查进程是否正常</span></span><br><span class="line">curl http://localhost           <span class="comment">## 确认结果</span></span><br></pre>
<h3 id="6-2-4-nginx其他命令"><a href="#6-2-4-nginx其他命令" class="headerlink" title="6.2.4 nginx其他命令"></a>6.2.4 nginx其他命令</h3><pre class="highlight"><span class="line">nginx -s signal</span><br><span class="line">signal：</span><br><span class="line">stop — fast shutdown</span><br><span class="line">quit — graceful shutdown</span><br><span class="line">reload — reloading the configuration file</span><br><span class="line">reopen — reopening the log files</span><br><span class="line">用来打开日志文件，这样nginx会把新日志信息写入这个新的文件中</span><br></pre>
<hr>
<p><strong>/data/nginx/sbin/nginx -V</strong> 查看已经编译的参数。</p>
<p>使用kill命令操作nginx。格式：<em>kill -信号 PID</em></p>
<p>信号名称</p>
<ul>
<li>TERM,INT 快速关闭</li>
<li>QUIT 优雅的关闭，保持吸纳有的客户端连接</li>
<li>HUP 重启应用新的配置文件</li>
<li>USR1 重新打开日志文件</li>
<li>USR2 升级程序</li>
<li>WINCH 优雅的关闭工作进程</li>
</ul>
<p><strong>例子：</strong></p>
<pre class="highlight"><span class="line">kill -QUIT  &#96;cat &#x2F;data&#x2F;nginx&#x2F;nginx.pid&#96;</span><br><span class="line">kill -HUP &#96;cat &#x2F;data&#x2F;nginx&#x2F;nginx.pid&#96;</span><br></pre>

<h1 id="7-nginx配置文件"><a href="#7-nginx配置文件" class="headerlink" title="7. nginx配置文件"></a>7. nginx配置文件</h1><p><strong>配置基础配置文件</strong></p>
<pre class="highlight"><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">### 测试配置文件是否正常</span><br><span class="line">shell&gt; &#x2F;data&#x2F;nginx&#x2F;sbin&#x2F;nginx -t </span><br><span class="line">nginx: the configuration file &#x2F;data&#x2F;nginx-1.10.3&#x2F;conf&#x2F;nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file &#x2F;data&#x2F;nginx-1.10.3&#x2F;conf&#x2F;nginx.conf test is successful</span><br><span class="line">shell&gt; curl -I http:&#x2F;&#x2F;localhost</span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br></pre>
<h1 id="8-nginx监控"><a href="#8-nginx监控" class="headerlink" title="8. nginx监控"></a>8. nginx监控</h1><p><strong>开启nginx的监控服务</strong></p>
<h2 id="8-1-开启状态页"><a href="#8-1-开启状态页" class="headerlink" title="8.1 开启状态页"></a>8.1 开启状态页</h2><pre class="highlight"><span class="line"><span class="comment">#设定查看Nginx状态的地址   </span></span><br><span class="line">location /status &#123;  </span><br><span class="line">  stub_status on;   	<span class="comment">#表示开启stubStatus的工作状态统计功能。</span></span><br><span class="line">  access_log off;   	<span class="comment">#access_log off; 关闭access_log 日志记录功能。</span></span><br><span class="line">  <span class="comment">#auth_basic "status";   							#auth_basic 是nginx的一种认证机制。</span></span><br><span class="line">  <span class="comment">#auth_basic_user_file conf/htpasswd;	#用来指定密码文件的位置。</span></span><br><span class="line">&#125;</span><br></pre>
<h2 id="8-2-配置登录密码"><a href="#8-2-配置登录密码" class="headerlink" title="8.2 配置登录密码"></a>8.2 配置登录密码</h2><pre class="highlight"><span class="line">yum install -y httpd-tools</span><br><span class="line">/usr/local/apache/bin/htpasswd -c /data/nginx/conf/htpasswd biglittleant </span><br><span class="line">New password:</span><br></pre>
<p><strong>完成后会在/<em>data/nginx/conf/</em>目录下生成htpasswd文件。</strong></p>
<h2 id="8-3-访问URL"><a href="#8-3-访问URL" class="headerlink" title="8.3 访问URL"></a>8.3 访问URL</h2><pre class="highlight"><span class="line">curl http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>/status</span><br><span class="line"></span><br><span class="line">Active connections:  <span class="number">1</span></span><br><span class="line">server accepts handled requests</span><br><span class="line"> <span class="number">16</span> <span class="number">16</span> <span class="number">18</span></span><br><span class="line">Reading: <span class="number">0</span> Writing: <span class="number">1</span> Waiting: <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#active connections – 活跃的连接数量</span></span><br><span class="line"><span class="comment">#server accepts handled requests — 总共处理了16个连接 , 成功创建16次握手, 总共处理了18个请求</span></span><br><span class="line"><span class="comment">#Reading — 读取客户端的连接数: Writing 响应数据到客户端的数量; Waiting 开启 keep-alive 的情况下,这个值等于 active – (reading+writing), 意思就是 Nginx 已经处理完正在等候下一次请求指令的驻留连接.</span></span><br></pre>
<h2 id="8-4-编写zabbix监控脚本"><a href="#8-4-编写zabbix监控脚本" class="headerlink" title="8.4 编写zabbix监控脚本"></a>8.4 编写zabbix监控脚本</h2><pre class="highlight"><span class="line">nginx_status_fun()&#123;</span><br><span class="line">    NGINX_PORT=$<span class="number">1</span></span><br><span class="line">    NGINX_COMMAND=$<span class="number">2</span></span><br><span class="line">    nginx_active()&#123;</span><br><span class="line">        /usr/bin/curl <span class="string">"http://127.0.0.1:"</span>$NGINX_PORT<span class="string">"/status/"</span> <span class="number">2</span>&gt;/dev/null| grep <span class="string">'Active'</span> | awk <span class="string">'&#123;print $NF&#125;'</span></span><br><span class="line">        &#125;</span><br><span class="line">    nginx_reading()&#123;</span><br><span class="line">        /usr/bin/curl <span class="string">"http://127.0.0.1:"</span>$NGINX_PORT<span class="string">"/status/"</span> <span class="number">2</span>&gt;/dev/null| grep <span class="string">'Reading'</span> | awk <span class="string">'&#123;print $2&#125;'</span></span><br><span class="line">       &#125;</span><br><span class="line">    nginx_writing()&#123;</span><br><span class="line">        /usr/bin/curl <span class="string">"http://127.0.0.1:"</span>$NGINX_PORT<span class="string">"/status/"</span> <span class="number">2</span>&gt;/dev/null| grep <span class="string">'Writing'</span> | awk <span class="string">'&#123;print $4&#125;'</span></span><br><span class="line">       &#125;</span><br><span class="line">    nginx_waiting()&#123;</span><br><span class="line">        /usr/bin/curl <span class="string">"http://127.0.0.1:"</span>$NGINX_PORT<span class="string">"/status/"</span> <span class="number">2</span>&gt;/dev/null| grep <span class="string">'Waiting'</span> | awk <span class="string">'&#123;print $6&#125;'</span></span><br><span class="line">       &#125;</span><br><span class="line">    nginx_accepts()&#123;</span><br><span class="line">        /usr/bin/curl <span class="string">"http://127.0.0.1:"</span>$NGINX_PORT<span class="string">"/status/"</span> <span class="number">2</span>&gt;/dev/null| awk NR==<span class="number">3</span> | awk <span class="string">'&#123;print $1&#125;'</span></span><br><span class="line">       &#125;</span><br><span class="line">    nginx_handled()&#123;</span><br><span class="line">        /usr/bin/curl <span class="string">"http://127.0.0.1:"</span>$NGINX_PORT<span class="string">"/status/"</span> <span class="number">2</span>&gt;/dev/null| awk NR==<span class="number">3</span> | awk <span class="string">'&#123;print $2&#125;'</span></span><br><span class="line">       &#125;</span><br><span class="line">    nginx_requests()&#123;</span><br><span class="line">        /usr/bin/curl <span class="string">"http://127.0.0.1:"</span>$NGINX_PORT<span class="string">"/status/"</span> <span class="number">2</span>&gt;/dev/null| awk NR==<span class="number">3</span> | awk <span class="string">'&#123;print $3&#125;'</span></span><br><span class="line">       &#125;</span><br><span class="line">    case $NGINX_COMMAND <span class="keyword">in</span></span><br><span class="line">        active)</span><br><span class="line">            nginx_active;</span><br><span class="line">            ;;</span><br><span class="line">        reading)</span><br><span class="line">            nginx_reading;</span><br><span class="line">            ;;</span><br><span class="line">        writing)</span><br><span class="line">            nginx_writing;</span><br><span class="line">            ;;</span><br><span class="line">        waiting)</span><br><span class="line">            nginx_waiting;</span><br><span class="line">            ;;</span><br><span class="line">        accepts)</span><br><span class="line">            nginx_accepts;</span><br><span class="line">            ;;</span><br><span class="line">        handled)</span><br><span class="line">            nginx_handled;</span><br><span class="line">            ;;</span><br><span class="line">        requests)</span><br><span class="line">            nginx_requests;</span><br><span class="line">        esac </span><br><span class="line">&#125;</span><br></pre>
<h1 id="9-nginx优化"><a href="#9-nginx优化" class="headerlink" title="9. nginx优化"></a>9. nginx优化</h1><h2 id="9-1-nginx内核优化"><a href="#9-1-nginx内核优化" class="headerlink" title="9.1 nginx内核优化"></a>9.1 nginx内核优化</h2><pre class="highlight"><span class="line">net.ipv4.tcp_fin_timeout = <span class="number">2</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = <span class="number">1</span></span><br><span class="line">net.ipv4.tcp_syncookies = <span class="number">1</span></span><br><span class="line">net.ipv4.tcp_keepalive_time = <span class="number">600</span></span><br><span class="line">net.ipv4.ip_local_port_range = <span class="number">4000</span>    <span class="number">65000</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = <span class="number">16384</span></span><br><span class="line">net.ipv4.tcp_max_tw_buckets = <span class="number">36000</span></span><br><span class="line">net.ipv4.route.gc_timeout = <span class="number">100</span></span><br><span class="line">net.ipv4.tcp_syn_retries = <span class="number">1</span></span><br><span class="line">net.ipv4.tcp_synack_retries = <span class="number">1</span></span><br><span class="line">net.core.somaxconn = <span class="number">16384</span></span><br><span class="line">net.core.netdev_max_backlog = <span class="number">16384</span></span><br><span class="line">net.ipv4.tcp_max_orphans = <span class="number">16384</span></span><br><span class="line"><span class="comment">#以下参数是对iptables防火墙的优化，防火墙不开会提示，可以忽略不理。</span></span><br><span class="line">net.ipv4.ip_conntrack_max = <span class="number">25000000</span></span><br><span class="line">net.ipv4.netfilter.ip_conntrack_max=<span class="number">25000000</span></span><br><span class="line">net.ipv4.netfilter.ip_conntrack_tcp_timeout_established=<span class="number">180</span></span><br><span class="line">net.ipv4.netfilter.ip_conntrack_tcp_timeout_time_wait=<span class="number">120</span></span><br><span class="line">net.ipv4.netfilter.ip_conntrack_tcp_timeout_close_wait=<span class="number">60</span></span><br><span class="line">net.ipv4.netfilter.ip_conntrack_tcp_timeout_fin_wait=<span class="number">120</span></span><br></pre>
<h1 id="10-扩展一："><a href="#10-扩展一：" class="headerlink" title="10. 扩展一："></a>10. 扩展一：</h1><h2 id="10-1-nginx全局变量"><a href="#10-1-nginx全局变量" class="headerlink" title="10.1  nginx全局变量"></a>10.1  nginx全局变量</h2><pre class="highlight"><span class="line">$args：这个变量等于请求行中的参数，同$query_string。</span><br><span class="line">$is_args: 如果已经设置$args，则该变量的值为&quot;?&quot;，否则为&quot;&quot;。</span><br><span class="line">$content_length： 请求头中的Content-length字段。</span><br><span class="line">$content_type： 请求头中的Content-Type字段。</span><br><span class="line">$document_uri： 与$uri相同。</span><br><span class="line">$document_root： 当前请求在root指令中指定的值。</span><br><span class="line">$host： 请求主机头字段，否则为服务器名称。</span><br><span class="line">$http_user_agent： 客户端agent信息。</span><br><span class="line">$http_cookie： 客户端cookie信息。</span><br><span class="line">$limit_rate： 这个变量可以限制连接速率。</span><br><span class="line">$request_method： 客户端请求的动作，通常为GET或POST。</span><br><span class="line">$remote_addr： 客户端的IP地址。</span><br><span class="line">$remote_port： 客户端的端口。</span><br><span class="line">$remote_user： 已经经过Auth Basic Module验证的用户名。</span><br><span class="line">$request_body_file&#96;: 客户端请求主体的临时文件名。</span><br><span class="line">$request_uri: 请求的URI，带参数</span><br><span class="line">$request_filename： 当前请求的文件路径，由root或alias指令与URI请求生成。</span><br><span class="line">$scheme： 所用的协议，比如http或者是https，比如rewrite ^(.+)$ $scheme:&#x2F;&#x2F;example.com$1 redirect;。</span><br><span class="line">$server_protocol： 请求使用的协议，通常是HTTP&#x2F;1.0或HTTP&#x2F;1.1。</span><br><span class="line">$server_addr： 服务器地址，在完成一次系统调用后可以确定这个值。</span><br><span class="line">$server_name： 服务器名称。</span><br><span class="line">$server_port： 请求到达服务器的端口号。</span><br><span class="line">$request_uri： 包含请求参数的原始URI，不包含主机名，如：&#x2F;foo&#x2F;bar.php?arg&#x3D;baz，它无法修改。</span><br><span class="line">$uri： 不带请求参数的当前URI，$uri不包含主机名，如&#x2F;foo&#x2F;bar.html可能和最初的值有不同，比如经过重定向之类的。它可以通过内部重定向，或者使用index指令进行修改。不包括协议和主机名，例如&#x2F;foo&#x2F;bar.html。</span><br></pre>

<p><strong>例子：</strong></p>
<pre class="highlight"><span class="line">访问链接是：http://localhost:<span class="number">88</span>/test1/test.php </span><br><span class="line">网站路径是：/var/www/html</span><br><span class="line"></span><br><span class="line">$host：localhost</span><br><span class="line">$server_port：<span class="number">88</span></span><br><span class="line">$request_uri：http://localhost:<span class="number">88</span>/test1/test.php</span><br><span class="line">$document_uri：/test1/test.php</span><br><span class="line">$document_root：/var/www/html</span><br><span class="line">$request_filename：/var/www/html/test1/test.php</span><br></pre>
<p><strong>nginx plus – ngx_http_status_module</strong></p>
<p>商业版的 nginx plus 通过他的 ngx_http_status_module 提供了比 nginx 更多的监控指标，可以参看 <a href="http://demo.nginx.com/status.html" target="_blank" rel="noopener">http://demo.nginx.com/status.html</a></p>
<p><strong>nginx access log 分析</strong><br>nginx 的 access log 中可以记录很多有价值的信息，通过分析 access log，可以收集到很多指标。<br>python 编写的 linux 工具 ngxtop 就实现了对 access log 的分析功能。</p>
<p><strong>NDK – ngx_devel_kit</strong><br>NDK 是一个拓展nginx服务器核心功能的模块，第三方模块开发可以基于它来快速实现。NDK提供函数和宏处理一些基本任务，减轻第三方模块开发的代码量。</p>
<p><strong>nginx lua – lua-nginx-module</strong><br>nginx的lua模块，通过这个模块，可以对nginx做定制开发</p>
<h2 id="10-2-web服务器事件处理模型"><a href="#10-2-web服务器事件处理模型" class="headerlink" title="10.2  web服务器事件处理模型"></a>10.2  web服务器事件处理模型</h2><p><strong>select</strong><br>select最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。<br>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，事实上从现在看来，这也是它所剩不多的优点之一。<br>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。<br>另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。</p>
<p><strong>poll</strong><br>poll在1986年诞生于System V Release 3，它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。<br>poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。<br>另外，select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll()的时候将再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。</p>
<p><strong>epoll</strong><br>直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll，它几乎具备了之前所说的一切优点，被公认为Linux2.6下性能最好的多路I/O就绪通知方法。<br>epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。<br>epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。<br>另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</p>
<p><strong>nginx -s reload 过程</strong><br>nginx主进程读取配置文件，如果发现配置文件变更，会创建一个新的主进程，然后同时旧的进程，及旧的子进程关闭，旧进程会拒绝新的连接，服务到自己的连接结束，然后关闭。</p>
<p><strong>Apache select模型和 nginx epoll 模型对比讲解</strong></p>
<p>Nginx的高并发得益于其采用了epoll模型，与传统的服务器程序架构不同，epoll是linux内核2.6以后才出现的。下面通过比较Apache和Nginx工作原理来比较。</p>
<p>传统Apache都是多进程或者多线程来工作，假设是多进程工作（prefork），apache会先生成几个进程，类似进程池的工作原理，只不过这里的进程池会随着请求数目的增加而增加。对于每一个连接，apache都是在一个进程内处理完毕。具体是 recv（），以及根据 URI 去进行磁盘I/O来寻找文件，还有 send（）都是阻塞的。其实说白了都是 apche 对于套接字的I/O，读或者写，但是读或者写都是阻塞的，阻塞意味着进程就得挂起进入sleep状态，那么一旦连接数很多，Apache必然要生成更多的进程来响应请求，一旦进程多了，CPU对于进程的切换就频繁了，很耗资源和时间，所以就导致apache性能下降了，说白了就是处理不过来这么多进程了。其实仔细想想，如果对于进程每个请求都没有阻塞，那么效率肯定会提高很多。</p>
<p>Nginx采用epoll模型，异步非阻塞。对于Nginx来说，把一个完整的连接请求处理都划分成了事件，一个一个的事件。比如accept（）， recv（），磁盘I/O，send（）等，每部分都有相应的模块去处理，一个完整的请求可能是由几百个模块去处理。真正核心的就是事件收集和分发模块，这就是管理所有模块的核心。只有核心模块的调度才能让对应的模块占用CPU资源，从而处理请求。拿一个HTTP请求来说，首先在事件收集分发模块注册感兴趣的监听事件，注册好之后不阻塞直接返回，接下来就不需要再管了，等待有连接来了内核会通知你(epoll的轮询会告诉进程)，cpu就可以处理其他事情去了。一旦有请求来，那么对整个请求分配相应的上下文（其实已经预先分配好），这时候再注册新的感兴趣的事件(read函数)，同样客户端数据来了内核会自动通知进程可以去读数据了，读了数据之后就是解析，解析完后去磁盘找资源（I/O），一旦I/O完成会通知进程，进程开始给客户端发回数据send()，这时候也不是阻塞的，调用后就等内核发回通知发送的结果就行。整个下来把一个请求分成了很多个阶段，每个阶段都到很多模块去注册，然后处理，都是异步非阻塞。异步这里指的就是做一个事情，不需要等返回结果，做好了会自动通知你。</p>
<p><strong>select/epoll的特点</strong></p>
<p><strong>select的特点</strong>：select 选择句柄的时候，是遍历所有句柄，也就是说句柄有事件响应时，select需要遍历所有句柄才能获取到哪些句柄有事件通知，因此效率是非常低。但是如果连接很少的情况下， select和epoll的LT触发模式相比， 性能上差别不大。<br>这里要多说一句，select支持的句柄数是有限制的， 同时只支持1024个，这个是句柄集合限制的，如果超过这个限制，很可能导致溢出，而且非常不容易发现问题， 当然可以通过修改linux的socket内核调整这个参数。<br><strong>epoll的特点</strong>：epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高，内核将句柄用红黑树保存的。<br>对于epoll而言还有ET和LT的区别，LT表示水平触发，ET表示边缘触发，两者在性能以及代码实现上差别也是非常大的。</p>
<p>不管是Nginx还是Squid这种反向代理，其网络模式都是事件驱动。事件驱动其实是很老的技术，早期的select、poll都是如此。后来基于内核通知的更高级事件机制出现，如libevent里的epoll，使事件驱动性能得以提高。事件驱动的本质还是IO事件，应用程序在多个IO句柄间快速切换，实现所谓的异步IO。事件驱动服务器，最适合做的就是这种IO密集型工作，如反向代理，它在客户端与WEB服务器之间起一个数据中转作用，纯粹是IO操作，自身并不涉及到复杂计算。反向代理用事件驱动来做，显然更好，一个工作进程就可以run了，没有进程、线程管理的开销，CPU、内存消耗都小。</p>
<p>所以Nginx、Squid都是这样做的。当然，Nginx也可以是多进程 + 事件驱动的模式，几个进程跑libevent，不需要Apache那样动辄数百的进程数。Nginx处理静态文件效果也很好，那是因为静态文件本身也是磁盘IO操作，处理过程一样。至于说多少万的并发连接，这个毫无意义。随手写个网络程序都能处理几万的并发，但如果大部分客户端阻塞在那里，就没什么价值。</p>
<p>再看看Apache或者Resin这类应用服务器，之所以称他们为应用服务器，是因为他们真的要跑具体的业务应用，如科学计算、图形图像、数据库读写等。它们很可能是CPU密集型的服务，事件驱动并不合适。例如一个计算耗时2秒，那么这2秒就是完全阻塞的，什么event都没用。想想MySQL如果改成事件驱动会怎么样，一个大型的join或sort就会阻塞住所有客户端。这个时候多进程或线程就体现出优势，每个进程各干各的事，互不阻塞和干扰。当然，现代CPU越来越快，单个计算阻塞的时间可能很小，但只要有阻塞，事件编程就毫无优势。所以进程、线程这类技术，并不会消失，而是与事件机制相辅相成，长期存在。</p>
<p><strong>总言之，事件驱动适合于IO密集型服务，多进程或线程适合于CPU密集型服务，它们各有各的优势，并不存在谁取代谁的倾向。</strong></p>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql锁</title>
    <url>/2019/02/14/Mysql%E9%94%81/</url>
    <content><![CDATA[<p>锁是计算机协调多个进程或线程并发访问某一资源的机制。锁保证数据并发访问的一致性、有效性；锁冲突也是影响数据库并发访问性能的一个重要因素。锁是Mysql在服务器层和存储引擎层的的并发控制。</p>
<p>加锁是消耗资源的，锁的各种操作，包括获得锁、检测锁是否是否已解除、释放锁等。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczEuYmRzdGF0aWMuY29tLzcwY0Z2WFNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTI0MTU0OTYwOTYsMzQyMTczMjE1OSZmbT0yNiZncD0wLmpwZw?x-oss-process=image/format,png" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczEuYmRzdGF0aWMuY29tLzcwY0Z2WFNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTI0MTU0OTYwOTYsMzQyMTczMjE1OSZmbT0yNiZncD0wLmpwZw?x-oss-process=image/format,png" class="lozad post-image"></p>
<h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><h2 id="共享锁与排他锁"><a href="#共享锁与排他锁" class="headerlink" title="共享锁与排他锁"></a>共享锁与排他锁</h2><ul>
<li><p>共享锁（读锁）：其他事务可以读，但不能写。</p>
</li>
<li><p>排他锁（写锁） ：其他事务不能读取，也不能写。</p>
<h2 id="粒度锁"><a href="#粒度锁" class="headerlink" title="粒度锁"></a>粒度锁</h2><p>MySQL 不同的存储引擎支持不同的锁机制，所有的存储引擎都以自己的方式显现了锁机制，服务器层完全不了解存储引擎中的锁实现：</p>
</li>
<li><p>MyISAM 和 MEMORY 存储引擎采用的是表级锁（table-level locking）</p>
</li>
<li><p>BDB 存储引擎采用的是页面锁（page-level locking），但也支持表级锁</p>
</li>
<li><p>InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。</p>
</li>
</ul>
<p>默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。</p>
<p>但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。</p>
<p><strong>不同粒度锁的比较：</strong></p>
<ul>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<ul>
<li>这些存储引擎通过总是一次性同时获取所有需要的锁以及总是按相同的顺序获取表锁来避免死锁。</li>
<li>表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用</li>
</ul>
</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<ul>
<li>最大程度的支持并发，同时也带来了最大的锁开销。</li>
<li>在 InnoDB 中，除单个 SQL 组成的事务外，<br>锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。</li>
<li>行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统</li>
</ul>
</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。<h1 id="MyISAM-表锁"><a href="#MyISAM-表锁" class="headerlink" title="MyISAM 表锁"></a>MyISAM 表锁</h1><h2 id="MyISAM表级锁模式："><a href="#MyISAM表级锁模式：" class="headerlink" title="MyISAM表级锁模式："></a>MyISAM表级锁模式：</h2></li>
<li>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li>
<li>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；</li>
</ul>
<p>MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。 其他线程的读、 写操作都会等待，直到锁被释放为止。</p>
<p>默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。 （This ensures that updates to a table are not “starved” even when there is heavy SELECT activity for the table. However, if there are many updates for a table, SELECT statements wait until there are no more updates.）。</p>
<p>这也正是 MyISAM 表不太适合于有大量更新操作和查询操作应用的原因，因为，大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。同时，一些需要长时间运行的查询操作，也会使写线程“饿死” ，应用中应尽量避免出现长时间运行的查询操作（在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解” ，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行）。</p>
<p><strong>可以设置改变读锁和写锁的优先级：</strong></p>
<ul>
<li>通过指定启动参数low-priority-updates，使MyISAM引擎默认给予读请求以优先的权利。</li>
<li>通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。</li>
<li>通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。</li>
<li>给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。<h2 id="MyISAM加表锁方法："><a href="#MyISAM加表锁方法：" class="headerlink" title="MyISAM加表锁方法："></a>MyISAM加表锁方法：</h2>MyISAM 在执行查询语句（SELECT）前，会自动给涉及的表加读锁，在执行更新操作<br>（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。</li>
</ul>
<p>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因。</p>
<p>MyISAM存储引擎支持并发插入，以减少给定表的读和写操作之间的争用：</p>
<p>如果MyISAM表在数据文件中间没有空闲块，则行始终插入数据文件的末尾。 在这种情况下，你可以自由混合并发使用MyISAM表的INSERT和SELECT语句而不需要加锁——你可以在其他线程进行读操作的时候，同时将行插入到MyISAM表中。 文件中间的空闲块可能是从表格中间删除或更新的行而产生的。 如果文件中间有空闲快，则并发插入会被禁用，但是当所有空闲块都填充有新数据时，它又会自动重新启用。 要控制此行为，可以使用MySQL的concurrent_insert系统变量。</p>
<p>如果你使用LOCK TABLES显式获取表锁，则可以请求READ LOCAL锁而不是READ锁，以便在锁定表时，其他会话可以使用并发插入。</p>
<ul>
<li>当concurrent_insert设置为0时，不允许并发插入。</li>
<li>当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个线程读表的同时，另一个线程从表尾插入记录。这也是MySQL的默认设置。</li>
<li>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。</li>
</ul>
<p><strong>查询表级锁争用情况：</strong><br>可以通过检查 table_locks_waited 和 table_locks_immediate 状态变量来分析系统上的表锁的争夺，如果 Table_locks_waited 的值比较高，则说明存在着较严重的表级锁争用情况：</p>
<pre class="highlight"><span class="line">mysql&gt; SHOW STATUS LIKE &#39;Table%&#39;;</span><br><span class="line">+-----------------------+---------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-----------------------+---------+</span><br><span class="line">| Table_locks_immediate | 1151552 |</span><br><span class="line">| Table_locks_waited | 15324 |</span><br><span class="line">+-----------------------+---------+</span><br></pre>
<h1 id="InnoDB行级锁和表级锁"><a href="#InnoDB行级锁和表级锁" class="headerlink" title="InnoDB行级锁和表级锁"></a>InnoDB行级锁和表级锁</h1><h2 id="InnoDB锁模式："><a href="#InnoDB锁模式：" class="headerlink" title="InnoDB锁模式："></a>InnoDB锁模式：</h2><p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p>
<ul>
<li><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</p>
</li>
<li><p>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。<br>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p>
</li>
<li><p>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</p>
</li>
<li><p>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</p>
</li>
</ul>
<p><strong>锁模式的兼容情况：</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0zNzc2MTYxMmVhZDExZGRjMzc2MmE0YzIwZGRhYjNmM183MjB3LmpwZw?x-oss-process=image/format,png" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi0zNzc2MTYxMmVhZDExZGRjMzc2MmE0YzIwZGRhYjNmM183MjB3LmpwZw?x-oss-process=image/format,png" class="lozad post-image"></p>
<p>（如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务； 反之， 如果两者不兼容，该事务就要等待锁释放。）</p>
<h2 id="InnoDB加锁方法："><a href="#InnoDB加锁方法：" class="headerlink" title="InnoDB加锁方法："></a>InnoDB加锁方法：</h2><ul>
<li>意向锁是 InnoDB 自动加的， 不需用户干预。</li>
<li>对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB<br>会自动给涉及数据集加排他锁（X)；</li>
<li>对于普通 SELECT 语句，InnoDB 不会加任何锁；<br>事务可以通过以下语句显式给记录集加共享锁或排他锁：<ul>
<li>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</li>
<li>排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</li>
</ul>
</li>
</ul>
<ul>
<li>隐式锁定：<br>InnoDB在事务执行过程中，使用两阶段锁协议：</li>
</ul>
<p>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</p>
<p>锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。</p>
<ul>
<li>显式锁定 ：<pre class="highlight"><span class="line">select ... lock in share mode &#x2F;&#x2F;共享锁 </span><br><span class="line">select ... for update &#x2F;&#x2F;排他锁</span><br></pre>

</li>
</ul>
<p><strong>select for update：</strong></p>
<p>在执行这个 select 查询语句的时候，会将对应的索引访问条目进行上排他锁（X 锁），也就是说这个语句对应的锁就相当于update带来的效果。</p>
<p>select *** for update 的使用场景：为了让自己查到的数据确保是最新数据，并且查到后的数据只允许自己来修改的时候，需要用到 for update 子句。</p>
<p><strong>select lock in share mode</strong> ：in share mode 子句的作用就是将查找到的数据加上一个 share 锁，这个就是表示其他的事务只能对这些数据进行简单的select 操作，并不能够进行 DML 操作。select *** lock in share mode 使用场景：为了确保自己查到的数据没有被其他的事务正在修改，也就是说确保查到的数据是最新的数据，并且不允许其他人来修改数据。但是自己不一定能够修改数据，因为有可能其他的事务也对这些数据 使用了 in share mode 的方式上了 S 锁。</p>
<p><strong>性能影响：</strong><br>select for update 语句，相当于一个 update 语句。在业务繁忙的情况下，如果事务没有及时的commit或者rollback 可能会造成其他事务长时间的等待，从而影响数据库的并发使用效率。<br>select lock in share mode 语句是一个给查找的数据上一个共享锁（S 锁）的功能，它允许其他的事务也对该数据上S锁，但是不能够允许对该数据进行修改。如果不及时的commit 或者rollback 也可能会造成大量的事务等待。</p>
<p><strong>for update 和 lock in share mode 的区别：</strong></p>
<p>前一个上的是排他锁（X 锁），一旦一个事务获取了这个锁，其他的事务是没法在这些数据上执行 for update ；后一个是共享锁，多个事务可以同时的对相同数据执行 lock in share mode。</p>
<h2 id="InnoDB-行锁实现方式："><a href="#InnoDB-行锁实现方式：" class="headerlink" title="InnoDB 行锁实现方式："></a>InnoDB 行锁实现方式：</h2><ul>
<li>InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</li>
<li>不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。</li>
<li>只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时，<br>别忘了检查 SQL 的执行计划（可以通过 explain 检查 SQL 的执行计划），以确认是否真正使用了索引。（更多阅读：MySQL索引总结）</li>
<li>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个session是访问不同行的记录， 但是如果是使用相同的索引键， 是会出现锁冲突的（后使用这些索引的session需要等待先使用索引的session释放锁后，才能获取锁）。 应用设计的时候要注意这一点。<h2 id="InnoDB的间隙锁："><a href="#InnoDB的间隙锁：" class="headerlink" title="InnoDB的间隙锁："></a>InnoDB的间隙锁：</h2>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</li>
</ul>
<p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p>
<h2 id="InnoDB使用间隙锁的目的："><a href="#InnoDB使用间隙锁的目的：" class="headerlink" title="InnoDB使用间隙锁的目的："></a>InnoDB使用间隙锁的目的：</h2><ol>
<li>防止幻读，以满足相关隔离级别的要求；</li>
<li>满足恢复和复制的需要：</li>
</ol>
<p>MySQL 通过 BINLOG 录入执行成功的 INSERT、UPDATE、DELETE 等更新数据的 SQL 语句，并由此实现 MySQL 数据库的恢复和主从复制。MySQL 的恢复机制（复制其实就是在 Slave Mysql 不断做基于 BINLOG 的恢复）有以下特点：</p>
<p>一是 MySQL 的恢复是 SQL 语句级的，也就是重新执行 BINLOG 中的 SQL 语句。</p>
<p>二是 MySQL 的 Binlog 是按照事务提交的先后顺序记录的， 恢复也是按这个顺序进行的。</p>
<p>由此可见，MySQL 的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读。</p>
<p><strong>InnoDB 在不同隔离级别下的一致性读及锁的差异：</strong><br>锁和多版本数据（MVCC）是 InnoDB 实现一致性读和 ISO/ANSI SQL92 隔离级别的手段。</p>
<p>因此，在不同的隔离级别下，InnoDB 处理 SQL 时采用的一致性读策略和需要的锁是不同的：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWNiLnpoaW1nLmNvbS84MC92Mi1jODNjNjQ1OWY4ZGM5M2E1ZjE1N2ZlMWUzMDgwMDg4ZF83MjB3LmpwZw?x-oss-process=image/format,png" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWNiLnpoaW1nLmNvbS84MC92Mi1jODNjNjQ1OWY4ZGM5M2E1ZjE1N2ZlMWUzMDgwMDg4ZF83MjB3LmpwZw?x-oss-process=image/format,png" class="lozad post-image"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi01Njg5NTFmNGNkZmViOTQxNjA0MjYyN2E3Yjk0YzRhY183MjB3LmpwZw?x-oss-process=image/format,png" alt="" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi01Njg5NTFmNGNkZmViOTQxNjA0MjYyN2E3Yjk0YzRhY183MjB3LmpwZw?x-oss-process=image/format,png" class="lozad post-image"></p>
<p>对于许多 SQL，隔离级别越高，InnoDB 给记录集加的锁就越严格（尤其是使用范围条件的时候），产生锁冲突的可能性也就越高，从而对并发性事务处理性能的 影响也就越大。</p>
<p>因此， 我们在应用中， 应该尽量使用较低的隔离级别， 以减少锁争用的机率。实际上，通过优化事务逻辑，大部分应用使用 Read Commited 隔离级别就足够了。对于一些确实需要更高隔离级别的事务， 可以通过在程序中执行 SET SESSION TRANSACTION ISOLATION</p>
<p>LEVEL REPEATABLE READ 或 SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE 动态改变隔离级别的方式满足需求。</p>
<h2 id="获取-InnoDB-行锁争用情况："><a href="#获取-InnoDB-行锁争用情况：" class="headerlink" title="获取 InnoDB 行锁争用情况："></a>获取 InnoDB 行锁争用情况：</h2><p>可以通过检查 InnoDB_row_lock 状态变量来分析系统上的行锁的争夺情况：</p>
<pre class="highlight"><span class="line">mysql&gt; show status like &#39;innodb_row_lock%&#39;; </span><br><span class="line">+-------------------------------+-------+ </span><br><span class="line">| Variable_name | Value | </span><br><span class="line">+-------------------------------+-------+ </span><br><span class="line">| InnoDB_row_lock_current_waits | 0 | </span><br><span class="line">| InnoDB_row_lock_time | 0 | </span><br><span class="line">| InnoDB_row_lock_time_avg | 0 | </span><br><span class="line">| InnoDB_row_lock_time_max | 0 | </span><br><span class="line">| InnoDB_row_lock_waits | 0 | </span><br><span class="line">+-------------------------------+-------+ </span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre>


<p><strong>LOCK TABLES 和 UNLOCK TABLES</strong><br>Mysql也支持lock tables和unlock tables，这都是在服务器层（MySQL Server层）实现的，和存储引擎无关，它们有自己的用途，并不能替代事务处理。 （除了禁用了autocommint后可以使用，其他情况不建议使用）：</p>
<p>LOCK TABLES 可以锁定用于当前线程的表。如果表被其他线程锁定，则当前线程会等待，直到可以获取所有锁定为止。<br>UNLOCK TABLES 可以释放当前线程获得的任何锁定。当前线程执行另一个 LOCK TABLES 时，<br>或当与服务器的连接被关闭时，所有由当前线程锁定的表被隐含地解锁</p>
<h2 id="LOCK-TABLES语法："><a href="#LOCK-TABLES语法：" class="headerlink" title="LOCK TABLES语法："></a>LOCK TABLES语法：</h2><ul>
<li>在用 LOCK TABLES 对 InnoDB 表加锁时要注意，要将 AUTOCOMMIT 设为 0，否则MySQL 不会给表加锁；</li>
<li>事务结束前，不要用 UNLOCK TABLES 释放表锁，因为 UNLOCK TABLES会隐含地提交事务；</li>
<li>COMMIT 或 ROLLBACK 并不能释放用 LOCK TABLES 加的表级锁，必须用UNLOCK TABLES 释放表锁。<br>正确的方式见如下语句：<br>例如，如果需要写表 t1 并从表 t 读，可以按如下做：<pre class="highlight"><span class="line">SET AUTOCOMMIT&#x3D;0; </span><br><span class="line">LOCK TABLES t1 WRITE, t2 READ, ...; </span><br><span class="line">[do something with tables t1 and t2 here]; </span><br><span class="line">COMMIT; </span><br><span class="line">UNLOCK TABLES;</span><br></pre>


</li>
</ul>
<h2 id="使用LOCK-TABLES的场景："><a href="#使用LOCK-TABLES的场景：" class="headerlink" title="使用LOCK TABLES的场景："></a>使用LOCK TABLES的场景：</h2><p>给表显示加表级锁（InnoDB表和MyISAM都可以），一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。（与MyISAM默认的表锁行为类似）</p>
<p>在用 LOCK TABLES 给表显式加表锁时，必须同时取得所有涉及到表的锁，并且 MySQL 不支持锁升级。也就是说，在执行 LOCK TABLES 后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。</p>
<p>其实，在MyISAM自动加锁（表锁）的情况下也大致如此，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因。</p>
<p>例如，有一个订单表 orders，其中记录有各订单的总金额 total，同时还有一个 订单明细表 order_detail，其中记录有各订单每一产品的金额小计 subtotal，假设我们需要检 查这两个表的金额合计是否相符，可能就需要执行如下两条 SQL：</p>
<pre class="highlight"><span class="line">Select sum(total) from orders; </span><br><span class="line">Select sum(subtotal) from order_detail;</span><br></pre>
<p>这时，如果不先给两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，<br>order_detail 表可能已经发生了改变。因此，正确的方法应该是：</p>
<pre class="highlight"><span class="line">Lock tables orders read local, order_detail read local; </span><br><span class="line">Select sum(total) from orders; </span><br><span class="line">Select sum(subtotal) from order_detail; </span><br><span class="line">Unlock tables;</span><br></pre>
<p>（在 LOCK TABLES 时加了“local”选项，其作用就是允许当你持有表的读锁时，其他用户可以在满足 MyISAM 表并发插入条件的情况下，在表尾并发插入记录（MyISAM 存储引擎支持“并发插入”））</p>
<h1 id="死锁（Deadlock-Free）"><a href="#死锁（Deadlock-Free）" class="headerlink" title="死锁（Deadlock Free）"></a>死锁（Deadlock Free）</h1><ul>
<li><p>死锁产生：</p>
<ul>
<li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</li>
<li>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。</li>
<li>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li>
</ul>
</li>
<li><p><strong>检测死锁</strong>：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p>
</li>
<li><p>死锁恢复：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p>
</li>
<li><p>外部锁的死锁检测：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决</p>
</li>
<li><p>死锁影响性能：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖innodb_lock_wait_timeout设置进行事务回滚。</p>
<h2 id="MyISAM避免死锁："><a href="#MyISAM避免死锁：" class="headerlink" title="MyISAM避免死锁："></a>MyISAM避免死锁：</h2></li>
<li><p>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。</p>
<h2 id="InnoDB避免死锁："><a href="#InnoDB避免死锁：" class="headerlink" title="InnoDB避免死锁："></a>InnoDB避免死锁：</h2></li>
<li><p>为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用SELECT … FOR UPDATE语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</p>
</li>
<li><p>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</p>
</li>
<li><p>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</p>
</li>
<li><p>通过SELECT … LOCK IN SHARE MODE获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</p>
</li>
<li><p>改变事务隔离级别</p>
</li>
</ul>
<p>如果出现死锁，可以用 SHOW INNODB STATUS 命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p>
<h2 id="一些优化锁性能的建议"><a href="#一些优化锁性能的建议" class="headerlink" title="一些优化锁性能的建议"></a>一些优化锁性能的建议</h2><ol>
<li>尽量使用较低的隔离级别；</li>
<li>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会</li>
<li>选择合理的事务大小，小事务发生锁冲突的几率也更小</li>
<li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁</li>
<li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会</li>
<li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响</li>
<li>不要申请超过实际需要的锁级别</li>
<li>除非必须，查询时不要显示加锁。 MySQL的MVCC可以实现事务中的查询不用加锁，优化事务性能；MVCC只在COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作</li>
<li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能<h1 id="乐观锁、悲观锁"><a href="#乐观锁、悲观锁" class="headerlink" title="乐观锁、悲观锁"></a>乐观锁、悲观锁</h1></li>
</ol>
<ul>
<li><p><strong>乐观锁(Optimistic Lock)</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。<br>乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p>
</li>
<li><p><strong>悲观锁(Pessimistic Lock)</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。<br>悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>常用数据库 知识点大全 (Mysql，Redis，MongoDB)</title>
    <url>/2020/01/05/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%20%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E5%85%A8%20(Mysql%EF%BC%8CRedis%EF%BC%8CMongoDB)/</url>
    <content><![CDATA[<h3 id="1-Mysql"><a href="#1-Mysql" class="headerlink" title="1. Mysql"></a>1. Mysql</h3><p><strong>简介：</strong></p>
<p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。<br>MySQL是一种关系型数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。<br>MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。</p>
<h3 id="五大引擎"><a href="#五大引擎" class="headerlink" title="五大引擎"></a>五大引擎</h3><pre class="highlight"><span class="line">因MyISAM 和 InnoDB 是主要引擎所以多做概述</span><br></pre>

<ul>
<li><p><strong>MyISAM</strong>：<br>Myisam只支持表级锁，用户在操作 myisam 表时，select、update、delete、insert、语句都会给表自动加锁，如果加锁以后的表满足 insert 并发的情况下，可以在表的尾部插入新的数据。也可以通过 locktable 命令来锁表，这样的操作主要是可以模仿事务，<strong>但消耗特别大</strong>。</p>
<p>因为MyISAM表有无法处理事务，所以它只适合在一下几种情况下使用<br>1.选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。<br>2.插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。</p>
</li>
<li><p><strong>InnoDB</strong>：</p>
<p>1.更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。<br>2.事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。<br>3.自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。<br>4.外键约束。MySQL支持外键的存储引擎只有InnoDB。<br>5.支持自动增加列AUTO_INCREMENT属性。</p>
<ul>
<li>Innodb支持事务和行级锁。</li>
<li>事物的ACID属性：atomicity、consistent、isolation、durable</li>
<li>Innodb属于索引组织表。</li>
<li>Innodb有两种存储方式，<strong>共享表空间</strong>和<strong>多表空间</strong>存储</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020020621203888.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/2020020621203888.png" class="lozad post-image"><br><strong>MyISAM &amp; InnoDB 差异：</strong></p>
<pre class="highlight"><span class="line">- 自增长差异：</span><br><span class="line"></span><br><span class="line">MyISAM 引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，</span><br><span class="line">它可以根据前面几列进行排序后递增。</span><br><span class="line"></span><br><span class="line">InnoDB 引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列</span><br><span class="line"></span><br><span class="line">- 主键差异：</span><br><span class="line"></span><br><span class="line">MyISAM 允许没有任何索引和主键的存在，</span><br><span class="line">MyISAM 的索引都是保存行的地址</span><br><span class="line"></span><br><span class="line">InnoDB 如果没有设定主键 或者 非空唯一索引，就会自动生成一个6字节的主键（用户不可见）</span><br><span class="line">InnoDB 的数据是主索引的一部分，附加索引保存的是主索引的值。</span><br><span class="line"></span><br><span class="line">- count()函数差异：</span><br><span class="line"></span><br><span class="line">MyISAM 保存有表的总行数，如果 select count(*) from table; 会直接取出该值</span><br><span class="line">InnoDB 没有保存表的总行数，如果使用 select count(*) from table; 就会遍历整个表，消耗相当之大，但是加了 where  条件后，MyIASM 和 InnoDB 的处理方式都一样</span><br><span class="line"></span><br><span class="line">- 全文索引差异：</span><br><span class="line"></span><br><span class="line">MyISAM 支持 FullText 类型的全文索引</span><br><span class="line">InnoDB 不支持 FullText 类型的全文索引，但是 InnoDB 可以使用 </span><br><span class="line">	sphinx 插件支持全文索引，并且效果更好</span><br><span class="line"></span><br><span class="line">delete from table </span><br><span class="line">使用这条命令时，InnoDB不会从新建立表，而实一条条的删除数据，在InnoDB上如果要清空保存有大量数据的表，最好不要使用这条命令。（推荐使用 truncate table，不过需要用户有 diop 此表的权限）</span><br><span class="line"></span><br><span class="line">- 索引保留位置差异：</span><br><span class="line"></span><br><span class="line">MYISAM 的索引以表名 + .MYI 文件分别保存</span><br><span class="line">InnoDB 的索引和数据一起保存在 表空间里</span><br><span class="line"></span><br><span class="line">- 存储疫情选择差异：</span><br><span class="line">MyISAM B+tree</span><br><span class="line">InnoDB B-tree</span><br><span class="line">12345678910111213141516171819202122232425262728293031323334353637</span><br></pre>

<p><img src="https://img-blog.csdnimg.cn/20200616091010658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200616091010658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<ul>
<li><p><strong>MEMORY</strong> <code>/meməri/ -- 买么瑞</code>：<br><code>使用MEMORY引擎主要是因为速度，好处就在MEMORY采用的逻辑存储是系统内存,极大的提高了储存数据表的性能； 坏处就是当mysqld守护进程崩溃时，所有的Memory数据都会丢失。</code><br>一般在以下几种情况下使用Memory存储引擎：</p>
<p>1.目标数据较小，而且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。<br>2.如果数据是临时的，而且必须立即使用，那么就可以存放在内存表中。<br>3.存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。</p>
</li>
<li><p><strong>MERGE</strong> <code>/mɜːdʒ/ -- 么耳吱</code>：<br>MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表结构必须完全相同，所以就相当于一个集合器。比起其他储存引擎MERGE不是很优秀，但是在某些情况下MERGE还是非常的有用。对于服务器日志这种信息，一般常用的存储策略是将数据分成很多表，每个名称与特定的时间端相关。</p>
</li>
<li><p><strong>ARCHIVE</strong> <code>/&#39;ɑ:kaiv/ -- 阿尔铠武</code>：<br>Archive是归档的意思，在归档之后很多的高级功能就不再支持了，仅仅支持最基本的插入和查询两种功能。在MySQL 5.5版以前，Archive是不支持索引，但是在MySQL 5.5以后的版本就开始支持索引了。Archive拥有很好的压缩机制，它使用zlib压缩库，在记录被请求时会实时压缩，所以它经常被用来当做仓库使用。</p>
</li>
<li><p><strong>BDB(BerkeleyDB)</strong></p>
</li>
<li><p><strong>EXAMPLE</strong> <code>/ɪɡˈzæmpl/ -- 诶个曾伯</code></p>
</li>
<li><p><strong>FEDERATED</strong> <code>/&#39;fɛdə,retɪd/ -- F艾 的瑞der</code></p>
</li>
<li><p><strong>CSV</strong></p>
</li>
<li><p><strong>BLACKHOLE</strong></p>
</li>
</ul>
<h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h3><h4 id="InnoDB事务原理"><a href="#InnoDB事务原理" class="headerlink" title="InnoDB事务原理"></a>InnoDB事务原理</h4><ol>
<li><p>事务（Transaction）是数据库区别于文件系统的重要特性之一，事务会把数据库从一种一致性状态转换为另一种一致性状态。</p>
</li>
<li><p>在数据库提交时，可以确保要么所有修改都已保存，要么所有修改都不保存。</p>
<pre class="highlight"><span class="line"> MySQL数据库默认采用自动提交(autocommit)模式, 也就是说修改数据(insert、update、delete)的操 作会自动的触发事务,完成事务的提交或者回滚</span><br><span class="line"> 开启事务使用 begin 或者 start transaction; </span><br><span class="line"> 回滚事务使用 rollback;</span><br><span class="line"> pymysql 里面的 conn.commit() 操作就是提交事务</span><br><span class="line"> pymysql 里面的 conn.rollback() 操作就是回滚事务</span><br><span class="line">12345</span><br></pre>

</li>
</ol>
<h4 id="事务的（ACID）特征"><a href="#事务的（ACID）特征" class="headerlink" title="事务的（ACID）特征"></a>事务的（ACID）特征</h4><ol>
<li><strong>原子性</strong>(Atomicity)：整个事物的所有操作要么全部提交成功，要么全部失败回滚(不会出现部分执行的情况)。</li>
<li><strong>一致性</strong>(Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。</li>
<li><strong>隔离性</strong>(Isolation)：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。</li>
<li><strong>持久性</strong>(Durability): 一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>
</ol>
<h4 id="事物隔离级别"><a href="#事物隔离级别" class="headerlink" title="事物隔离级别"></a>事物隔离级别</h4><ul>
<li><p><strong>未提交读: 脏读（READ UNCOMMITTED）</strong> 读未提交</p>
<ol>
<li>事务2查询到的数据是事务1中修改但未提交的数据，因为事务1回滚了数据</li>
<li>所以事务2查询的数据是不正确的，因此出现了脏读的问题。</li>
</ol>
<p>（存在4个问题 脏读、不可重复读、幻读、更新丢失）<br><strong>解决方法:</strong><br>将数据库事务隔离级别调整到 <strong>Read_Commited</strong> 读已提交</p>
</li>
<li><p><strong>提交读: 不可重复读（READ COMMITTED）</strong></p>
<ol>
<li>事务2执行update语句但未提交前，事务1的前两个select操作返回结果是相同的。</li>
<li>但事务2执行commit操作后，事务1的第三个select操作就读取到事务2对数据的改变。</li>
<li>导致与前两次select操作返回不同的数据，因此出现了不可重复读的问题。</li>
</ol>
<p>（不可重复读、幻读、丢失更新）<br><strong>解决方法：</strong><br>将数据库事务隔离级别调整到 <strong>Repeatable_read</strong> 可重复 读</p>
</li>
<li><p><strong>可重复读: 幻读（REPEATABLE READ）：这是MySQL的默认事务隔离级别</strong></p>
<ol>
<li>事务每开启一个实例，都会分配一个版本号给它，如果读取的数据行正在被其它事务执行DELETE或UPDATE操作（即该行上有排他锁）</li>
<li>这时该事物的读取操作不会等待行上的锁释放，而是根据版本号去读取行的快照数据（记录在undo log中）</li>
<li>这样，事务中的查询操作返回的都是同一版本下的数据，解决了不可重复读问题。</li>
<li>虽然该隔离级别下解决了不可重复读问题，但理论上会导致另一个问题：幻读（Phantom Read）。</li>
<li>一个事务在执行过程中，另一个事物对已有数据行的更改，MVCC机制可保障该事物读取到的原有数据行的内容相同</li>
<li>但并不能阻止另一个事务插入新的数据行，这就会导致该事物中凭空多出数据行，像出现了幻读一样，这便是幻读问题。</li>
</ol>
<p><strong>简易版</strong><br>指 事务A 对一个表中的数据进行了修改，而且该修改涉及到表中的所有数据行；同时另一个 事务B 也在修改表中的数据，该修改像表中插入一条新数据。那么经过操作之后，操作 事务A 的用户就会发现表中还有没修改的数据行，就像发觉了幻觉一样，故 <strong>幻读</strong>。<br>（存在两个问题 幻读、丢失更新）<br><strong>解决方法</strong><br>将数据库事务隔离级别调整到 <strong>Serializable_read</strong> 串行读</p>
</li>
<li><p><strong>可串行读（SERIALIZABLE）</strong> 序列化&amp;串行读</p>
</li>
</ul>
<ol>
<li>这是事务的最高隔离级别，通过强制事务排序，使之不可能相互冲突，就是在每个读的数据行加上共享锁来实现</li>
<li>在该隔离级别下，可以解决前面出现的脏读、不可重复读和幻读问题，但也会导致大量的超时和锁竞争现象，一般不推荐使用</li>
</ol>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>read uncommitted（未提交读）</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>read committed（提交读）</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>repeatable read（可重复读）</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>serializable （可串行化）</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p><strong>级别高低：脏读 &lt; 不可重复读 &lt; 幻读</strong><br>所以只要是设置了 最高级别 Serializable 就解决了 前三个问题了，当时 他的资源消耗是最致命的。</p>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p><strong>什么是锁？</strong></p>
<p>锁是协调多个进程或线程并发访问某一资源的一种机制。在数据库当中，除了传统的计算资源（CPU、RAM、I/O等等）的争用之外，数据也是一种供许多用户共享访问的资源。如何保证数据并发访问的一致性、有效性，是所有数据库必须解决的一个问题，锁的冲突也是影响数据库并发访问性能的一个重要因素。从这一角度来说，锁对于数据库而言就显得尤为重要。</p>
<p><strong>在 Mysql中 有两种锁：Lock 和 Latch</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200129113951541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200129113951541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" class="lozad post-image"></p>
<p>Latch一般称为闩锁（轻量级的锁），因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差，在InnoDB引擎中，Latch又可以分为mutex（互斥量）和 rwlock（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。</p>
<p>Lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。</p>
<p>关于Latch更详细的讲解可以参考：<a href="https://www.cnblogs.com/geaozhang/p/7287108.html" target="_blank" rel="noopener">关于MySQL latch争用深入分析与判断</a>，本文主要关注的是Lock锁。</p>
<h4 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h4><p>对数据的操作其实只有两种，也就是读和写，而数据库在实现锁时，也会对这两种操作使用不同的锁；InnoDB 实现了标准的行级锁，也就是共享锁（Shared Lock）和互斥锁（Exclusive Lock）。</p>
<ul>
<li>共享锁（读锁），允许事务读一行数据。</li>
<li>排他锁（写锁），允许事务删除或更新一行数据。</li>
</ul>
<p><strong>共享锁之间是兼容的，而互斥锁与其他任意锁都不兼容：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200129121004560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200129121004560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" class="lozad post-image"><br><strong>共享锁代表了读操作、互斥锁代表了写操作，所以我们可以在数据库中并行读，但是只能串行写，只有这样才能保证不会发生线程竞争，实现线程安全。</strong></p>
<h4 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h4><p>Lock锁根据粒度主要分为表锁、页锁和行锁。不同的存储引擎拥有的锁粒度都不同。<br><img src="https://img-blog.csdnimg.cn/20200129121157490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200129121157490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" class="lozad post-image"></p>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。<br>当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并发度大打折扣。<br><strong>使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。</strong></p>
<h4 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h4><p>页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。<br>在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。<br><strong>使用页级锁定的主要是BerkeleyDB存储引擎。</strong></p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>行级锁定最大的特点就是锁定对象的粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。<br>虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。<br><strong>使用行级锁定的主要是InnoDB存储引擎。</strong></p>
<p><strong>总结</strong></p>
<ul>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ul>
<h4 id="InnoDB中的锁"><a href="#InnoDB中的锁" class="headerlink" title="InnoDB中的锁"></a>InnoDB中的锁</h4><p><strong>意向锁</strong></p>
<p>上节提到InnoDB 支持多种粒度的锁，也就是行锁和表锁。为了支持多粒度锁定，InnoDB 存储引擎引入了意向锁（Intention Lock）。</p>
<p>那什么是意向锁呢？我们在这里可以举一个例子：<strong>如果没有意向锁，当已经有人使用行锁对表中的某一行进行修改时，如果另外一个请求要对全表进行修改，那么就需要对所有的行是否被锁定进行扫描，在这种情况下，效率是非常低的；不过，在引入意向锁之后，当有人使用行锁对表中的某一行进行修改之前，会先为表添加意向互斥锁（IX），再为行记录添加互斥锁（X），在这时如果有人尝试对全表进行修改就不需要判断表中的每一行数据是否被加锁了，只需要通过等待意向互斥锁被释放就可以了。</strong></p>
<p>与上一节中提到的两种锁的种类相似的是，意向锁也分为两种：</p>
<ul>
<li>意向共享锁（IS）：事务想要在获得表中某些记录的共享锁，需要在表上先加意向共享锁。</li>
<li>意向互斥锁（IX）：事务想要在获得表中某些记录的互斥锁，需要在表上先加意向互斥锁。</li>
</ul>
<p>以上原文出处：<br><a href="https://blog.csdn.net/bruceleenumberone/article/details/81865045" target="_blank" rel="noopener">https://blog.csdn.net/bruceleenumberone/article/details/81865045</a></p>
<hr>
<h3 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h3><ol>
<li>按操作划分：DML锁，DDL锁</li>
<li>按锁的粒度划分：<strong>表级锁、行级锁、页级锁</strong></li>
<li>按锁级别划分：<strong>共享锁、排他锁</strong></li>
<li>按加锁方式划分：自动锁、显示锁</li>
<li>按使用方式划分：<strong>乐观锁、悲观锁</strong></li>
</ol>
<h3 id="乐观锁实现方法"><a href="#乐观锁实现方法" class="headerlink" title="乐观锁实现方法"></a>乐观锁实现方法</h3><ol>
<li>每次获取商品时，（读操作）不对该商品加锁。</li>
<li>写操作加锁</li>
<li>在更新数据的时候需要比较程序中的库存量与数据库中的库存量是否相等，如果相等则进行更新</li>
<li>反之程序重新获取库存量，再次进行比较，直到两个库存量的数值相等才进行数据更新。</li>
</ol>
<p><strong>举例：</strong><br>我们收藏购物车 就是乐观锁。假如商品只有1件的时候，所有人都会加入购物车，但是购买只会有一个人</p>
<pre class="highlight"><span class="line"><span class="comment">#### 乐观锁实现加一操作代码</span></span><br><span class="line"><span class="comment"># 我们可以看到，只有当对数量-1操作时才会加锁，只有当程序中值和数据库中的值相等时才正真执行。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">//不加锁</span></span><br><span class="line"><span class="string">select id,name,stock where id=1;</span></span><br><span class="line"><span class="string">//业务处理</span></span><br><span class="line"><span class="string">begin;</span></span><br><span class="line"><span class="string">update shop set stock=stock-1 where id=1 and stock=stock;</span></span><br><span class="line"><span class="string">commit;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="number">12345678910</span></span><br></pre>



<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><ol>
<li>每次获取商品时，对该商品加排他锁。</li>
<li>也就是在用户A获取获取 id=1 的商品信息时对该行记录加锁，期间其他用户阻塞等待访问该记录。</li>
</ol>
<p>举例：<br>购买商品的付款时间就是悲观锁，购买商品 30分钟付款时间 就是开的悲观锁，假设商品只有一个，这三个小时我买了没付钱、最后订单取消。这30分钟你都不会购买到次商品</p>
<pre class="highlight"><span class="line"><span class="comment">#### 悲观锁实现加一操作代码</span></span><br><span class="line"><span class="comment"># 我们可以看到，首先通过begin开启一个事物，在获得shop信息和修改数据的整个过程中都对数据加锁，保证了数据的一致性。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">begin;</span></span><br><span class="line"><span class="string">select id,name,stock as old_stock from shop  where id=1 for update;</span></span><br><span class="line"><span class="string">update shop set stock=stock-1 where id=1 and stock=old_stock;</span></span><br><span class="line"><span class="string">commit</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre>



<h3 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h3><ol>
<li>排它锁又叫写锁，如果事务T对A加上排它锁，则其它事务都不能对A加任何类型的锁。获准排它锁的事务既能读数据，又能写数据。</li>
<li>用法 ： SELECT … FOR UPDATE</li>
</ol>
<p><strong>举例：</strong></p>
<pre class="highlight"><span class="line">如果我们进入洗手间是为了上厕所，那么就不能允许任何人进来了。</span><br><span class="line">这就是排他锁，也叫写锁，就是我们对数据进行写操作的时候，要想获得写锁，获得写锁的事务既可以写数据也可以读数据。</span><br><span class="line">当时，如果数据库已经被别人增加了排他锁，那么后面的事务是无法在获得该数据库得任何锁得。</span><br><span class="line">也就是说，如果事务A对 数据加上了排他锁后，则其他事务不能在对 数据 加任何类型得封锁。获准排他锁得事务既能读数据，又能修改数据。</span><br><span class="line">1234</span><br></pre>

<h3 id="共享锁-share-lock"><a href="#共享锁-share-lock" class="headerlink" title="共享锁(share lock)"></a>共享锁(share lock)</h3><ol>
<li>共享锁又叫读锁，如果事务T对A加上共享锁，则其它事务只能对A再加共享锁，不能加其它锁。</li>
<li>获准共享锁的事务只能读数据，不能写数据。</li>
<li>用法： SELECT … LOCK IN SHARE MODE;</li>
</ol>
<p><strong>举例：</strong></p>
<pre class="highlight"><span class="line">如果我们进家里的洗手间只是想洗手，一般不会锁门，其他人也可以来洗手，但是 其他人是不可以进来上厕所的。</span><br><span class="line">这就是共享锁，也叫读锁，就是我们对数据进行读取操作的时候，其实是不会改变数据的值的。所以我们可以给数据库增加读锁，获得读锁的事务j就可以读取数据了。</span><br><span class="line">当数据库已经被别人增加了读锁的时候，其他新来的事务y也可以读数据，但是不能写。</span><br><span class="line">也就是说，如果 事务A 对数据加上了 共享锁后，则 其他事务只能对 数据 再加共享锁，不能加排他锁。获取共享锁的事务只能读数据，不能修改数据。</span><br><span class="line">1234</span><br></pre>



<h3 id="Btree-B-tree"><a href="#Btree-B-tree" class="headerlink" title="Btree/B+tree"></a>Btree/B+tree</h3><h3 id="Btree"><a href="#Btree" class="headerlink" title="Btree"></a>Btree</h3><p>Btree是一种多路自平衡搜索树，它类似普通的二叉树，但是Btree允许每个节点有更多的子节点。Btree示意图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200206151155853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200206151155853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>由上图可知 <strong>Btree 的一些特点:</strong></p>
<ol>
<li>所有键值分布在整个树中</li>
<li>任何关键字出现且只出现在一个节点中</li>
<li>搜索有可能在非叶子节点结束</li>
<li>在关键字全集内做一次查找，性能逼近二分查找算法</li>
</ol>
<h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B+tree"></a>B+tree</h3><p>B+树是B树的变体，也是一种多路平衡查找树，B+树的示意图为：</p>
<p><img src="https://img-blog.csdnimg.cn/20200206151537864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200206151537864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>由图可看出B+tree的特点 同时也是 <strong>Btree 和 B+tree的区别</strong></p>
<ol>
<li>所有关键字存储在叶子节点，非叶子节点不存储真正的data</li>
<li>为所有叶子节点增加了一个链指针 只有一个</li>
</ol>
<p><strong>在数据存储的索引结构上 Btree 更偏向于 纵向深度的存储数据 而 B+tree 更青睐于 横向广度的存储数据。</strong></p>
<p><a href="https://www.jianshu.com/p/0371c9569736" target="_blank" rel="noopener">参考原址-(写的非常好)</a></p>
<h3 id="MySQL主从复制原理"><a href="#MySQL主从复制原理" class="headerlink" title="MySQL主从复制原理"></a>MySQL主从复制原理</h3><h5 id="什么是mysql的主从复制？"><a href="#什么是mysql的主从复制？" class="headerlink" title="什么是mysql的主从复制？"></a>什么是mysql的主从复制？</h5><p>MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p>
<h5 id="mysql复制原理"><a href="#mysql复制原理" class="headerlink" title="mysql复制原理"></a>mysql复制原理</h5><ol>
<li>master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；</li>
<li>slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件</li>
<li>同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200206210611596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200206210611596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h5 id="也就是说"><a href="#也就是说" class="headerlink" title="也就是说"></a>也就是说</h5><ul>
<li>从库会生成两个线程,一个I/O线程,一个SQL线程;</li>
<li>I/O线程会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;</li>
<li>主库会生成一个log dump线程,用来给从库I/O线程传binlog;</li>
<li>SQL线程,会读取relay log文件中的日志,并解析成sql语句逐一执行;</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/96212530" target="_blank" rel="noopener">主从复制原址</a></p>
<h3 id="binlog日志"><a href="#binlog日志" class="headerlink" title="binlog日志"></a>binlog日志</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>mysql-binlog是MySQL数据库的二进制日志，用于记录用户对数据库操作的SQL语句（(除了数据查询语句）信息。可以使用mysqlbin命令查看二进制日志的内容。</p>
<h4 id="MySQL-binlog格式"><a href="#MySQL-binlog格式" class="headerlink" title="MySQL binlog格式"></a>MySQL binlog格式</h4><p>binlog的格式也有三种：STATEMENT、ROW、MIXED 。</p>
<ol>
<li><strong>STATMENT模式</strong>：基于SQL语句的复制(statement-based replication, SBR)，每一条会修改数据的sql语句会记录到binlog中。</li>
</ol>
<ul>
<li>优点：不需要记录每一条SQL语句与每行的数据变化，这样子binlog的日志也会比较少，减少了磁盘IO，提高性能。</li>
<li>缺点：在某些情况下会导致master-slave中的数据不一致(如sleep()函数， last_insert_id()，以及user-defined functions(udf)等会出现问题)</li>
</ul>
<ol>
<li><strong>基于行的复制</strong>(row-based replication, RBR)：不记录每一条SQL语句的上下文信息，仅需记录哪条数据被修改了，修改成了什么样子了。</li>
</ol>
<ul>
<li>优点：不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题。</li>
<li>缺点：会产生大量的日志，尤其是alter table的时候会让日志暴涨。</li>
</ul>
<ol>
<li><strong>混合模式复制</strong>(mixed-based replication, MBR)：以上两种模式的混合使用，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式。</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>无论是增量备份还是主从复制，都是需要开启mysql-binlog日志，最好跟数据目录设置到不同的磁盘分区，可以降低io等待，提升性能；并且在磁盘故障的时候可以利用mysql-binlog恢复数据。</p>
<h3 id="mysql优化"><a href="#mysql优化" class="headerlink" title="mysql优化"></a>mysql优化</h3><h4 id="Mysql优化综合性的问题："><a href="#Mysql优化综合性的问题：" class="headerlink" title="Mysql优化综合性的问题："></a>Mysql优化综合性的问题：</h4><ol>
<li>表的是设计合理化(符合 3范式)</li>
<li>添加适当的索引(index)[四种：普通索引，主键索引，唯一索引，unique，全文索引]</li>
<li>分表技术(水平分割，垂直分割)</li>
<li>读写[写：update/delete/add]分离</li>
<li>存储过程[模块化编程，可以提高速度]</li>
<li>对mysql配置优化[配置最大并发数，my.ini调整缓存大小]</li>
<li>Mysql服务器引荐升级</li>
<li>定时的去清楚不需要的数据，定时进行碎片整理</li>
</ol>
<p><strong>1. 数据库的表设计</strong></p>
<ul>
<li>第一范式：1NF是对属性的原子性约束，要求属性(列)具有原子性，不可再分解；(只要是关系型数据库都满足1NF)</li>
<li>第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；</li>
<li>第三范式：3NF是对字段冗余性的约束，它要求字段没有冗余。没有冗余的数据库设计可以做到。</li>
</ul>
<p><strong>2. 索引</strong></p>
<ol>
<li>主键索引<br><code>当把一张表的某列设置为主键的时候，则该列就是主键索引。</code></li>
<li>唯一索引<br><code>当表的某列被指定为unique约束时，这列就是唯一索引</code></li>
<li>普通索引<br><code>一般来说，普通索引是先创建表，然后创建普通索引。</code></li>
<li>全文索引<br><code>全文索引，主要是针对文件，比如文章的索引全文索引针对MyISAM有用，针对innodb没有用</code></li>
</ol>
<p><strong>3. 表的分割</strong><br>水平分割：<br>大数据量的表,我们在提供检索的时候，应该根据业务的需求，找到表的标准，并在检索页面约束用户的检索方式，而且要配合分页，<br>案例：大数据量的用户表<br>三张表：A, B, C</p>
<pre class="highlight"><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> A(</span><br><span class="line"></span><br><span class="line">       <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,<span class="comment">/* 这个id不能设置自增长 */</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>)<span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span><span class="string">''</span>，</span><br><span class="line"></span><br><span class="line">       pwd <span class="built_in">varchar</span>(<span class="number">32</span>)<span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span><span class="string">''</span></span><br><span class="line"></span><br><span class="line">)<span class="keyword">engine</span> = myisam <span class="keyword">default</span> <span class="keyword">charset</span> = utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> B(</span><br><span class="line"></span><br><span class="line">        <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>主键，/ *这个<span class="keyword">id</span>不能设置自增长* /</span><br><span class="line"></span><br><span class="line">        <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>)<span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span><span class="string">''</span>，</span><br><span class="line"></span><br><span class="line">        pwd <span class="built_in">varchar</span>(<span class="number">32</span>)<span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span><span class="string">''</span></span><br><span class="line"></span><br><span class="line">    )<span class="keyword">engine</span> = myisam <span class="keyword">default</span> <span class="keyword">charset</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> C(</span><br><span class="line"></span><br><span class="line">        <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>主键，/ *这个<span class="keyword">id</span>不能设置自增长* /</span><br><span class="line"></span><br><span class="line">        <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>)<span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span><span class="string">''</span>，</span><br><span class="line"></span><br><span class="line">        pwd <span class="built_in">varchar</span>(<span class="number">32</span>)<span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span><span class="string">''</span></span><br><span class="line"></span><br><span class="line">    )<span class="keyword">engine</span> = myisam <span class="keyword">default</span> <span class="keyword">charset</span> = utf8;</span><br><span class="line">123456789101112131415161718192021222324252627282930</span><br></pre>



<p>垂直分割：</p>
<p>把某个表的某些字段，这些字段，在查询时候并不关系，但是数据量很大，我们建议将这些字段放到一个表中，从而提高效率，</p>
<p><a href="https://blog.csdn.net/github_34457546/article/details/81634989" target="_blank" rel="noopener">Mysql优化原文链接</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200206221445570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200206221445570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<hr>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Redis（全称：Remote Dictionary Server 远程字典服务）是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。</p>
<h3 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h3><h4 id="Redis-的优点-和-缺点"><a href="#Redis-的优点-和-缺点" class="headerlink" title="Redis 的优点 和 缺点"></a>Redis 的优点 和 缺点</h4><p><strong>优点</strong>:</p>
<ul>
<li>数据类型多 <code>上面有介绍</code></li>
<li>快<br>\1. 纯内存操作<br>\2. 单线程避免上下文切换<br>\3. 非阻塞IO多路复用机制</li>
</ul>
<p><strong>缺点</strong><br>- 内存限制，不能用作海量数据</p>
<h3 id="redis的五大数据类型实现原理"><a href="#redis的五大数据类型实现原理" class="headerlink" title="redis的五大数据类型实现原理"></a>redis的五大数据类型实现原理</h3><pre class="highlight"><span class="line">1. redis中所有数据结构都以唯一的key字符串作为名称，然后通过这个唯一的key来获取对应的value&#96;</span><br><span class="line">&#96;2. 不同的数据类型数据结构差异就在于value的结构不一样</span><br></pre>



<p><strong>1. 字符串（string）</strong></p>
<ul>
<li><strong>value的数据结构（数组）</strong></li>
</ul>
<ol>
<li>字符串value数据结构类似于数组，采用与分配容易空间来减少内存频繁分配</li>
<li>当字符串长度小于1M时，扩容就是加倍现有空间</li>
<li>如果字符串长度操作1M时，扩容时最多扩容1M空间，字符串最大长度为 512M</li>
</ol>
<ul>
<li><strong>字符串的使用场景（缓存）</strong></li>
</ul>
<ol>
<li>字符串一个常见的用途是缓存用户信息，我们将用户信息使用JSON序列化成字符串</li>
<li>取用户信息时会经过一次反序列化的过程</li>
</ol>
<p><strong>2. list（列表）</strong></p>
<ul>
<li><strong>value的数据结构（双向链表）</strong></li>
</ul>
<ol>
<li>列表的数据结构是双向链表，这意味着插入和删除的时间复杂度是0(1)，索引的时间复杂度位0(n)</li>
<li>当列表弹出最后一个元素后，该数据结构会被自动删除，内存被回手</li>
</ol>
<ul>
<li><strong>列表的使用场景（队列、栈）</strong></li>
</ul>
<p><strong>3. hash（字典）</strong></p>
<ul>
<li><strong>value的数据结构（HashMap）</strong></li>
</ul>
<ol>
<li>redis中的字典也是HashMap（数组+列表）的二维结构</li>
<li>不同的是redis的字典的值只能是字符串</li>
</ol>
<ul>
<li><strong>hash的使用场景（缓存）</strong></li>
</ul>
<ol>
<li>hash可以用来缓存用户信息，与字符串一次性全部序列化整个对象不同，hash可以对每个字段进行单独存储</li>
<li>这样可以部分获取用户信息，节约网络流量</li>
<li>hash也有缺点，hash结构的存储消耗要高于单个字符串</li>
</ol>
<p><strong>4. set ( 集合对象 )</strong></p>
<ul>
<li><strong>集合对象 set 是 string 类型</strong>（整数也会转换成string类型进行存储）的无序集合。</li>
<li><strong>集合类型和列表类型的最大的区别是</strong><br>有序性 – &gt; 列表有序<br>唯一性 – &gt; 集合唯一</li>
<li><strong>数据结构</strong><br>底层数据结构以intset或者hashtable来存储</li>
<li><strong>最多包含2^32-1元素。</strong></li>
</ul>
<p><strong>5. Sorted set (有序集合对象)</strong></p>
<ul>
<li>有序集合类型为集合中的每个元素都关联了一个分数</li>
<li>数据结构</li>
</ul>
<ol>
<li>内部是以ziplist或者skiplist+hashtable来实现<br>skiplist，也就是跳跃表</li>
</ol>
<h4 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h4><p><strong>前言</strong><br>由于<strong>Redis</strong>的数据都存放在内存中，如果没有配置持久化，<strong>redis</strong>重启后数据就全丢失了，于是需要开启<strong>redis</strong>的持久化功能，将数据保存到磁盘上，当<strong>redis</strong>重启后，可以从磁盘中恢复数据。<strong>redis</strong>提供两种方式进行持久化，一种是<strong>RDB</strong>持久化（原理是将Reids在内存中的数据库记录定时<strong>dump</strong>到磁盘上的<strong>RDB</strong>持久化），另外一种是<strong>AOF</strong>（append only file）持久化（原理是将<strong>Reids</strong>的操作日志以追加的方式写入文件）。</p>
<p><strong>RDB：</strong><br>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。<br><img src="https://img-blog.csdnimg.cn/20200130221139725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200130221139725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<p><strong>AOF：</strong><br>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。<br><img src="https://img-blog.csdnimg.cn/2020013022120278.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/2020013022120278.png" class="lozad post-image"></p>
<p><strong>二者之间的优缺点</strong></p>
<p><strong>RDB的优势</strong></p>
<ol>
<li>一旦采用该方式，那么你的 <strong>整个Redis数据库将只包含一个文件</strong>，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li>
<li>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的<strong>将一个单独的文件压缩后再转移到其它存储介质上</strong>。</li>
<li>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是 f<strong>ork 出子进程，之后再由子进程完成这些持久化的工作</strong>，这样就可以极大的避免服务进程执行IO操作了。</li>
<li>相比于AOF机制，如果 <strong>数据集很大，RDB的启动效率会更高</strong>。</li>
</ol>
<p><strong>RDB的劣势</strong></p>
<ol>
<li>如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为<strong>系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失</strong>。</li>
<li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果<strong>当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟</strong>。</li>
</ol>
<p><strong>AOF的优势</strong></p>
<ol>
<li>该机制可以带来更高的<strong>数据安全性，即数据持久性</strong>。Redis中提供了3种同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即<strong>每次发生的数据变化都会被立即记录到磁盘中</strong>。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。</li>
<li>由于<strong>该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容</strong>。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。</li>
<li>如果<strong>日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中</strong>，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</li>
<li><strong>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作</strong>。事实上，我们也可以<strong>通过该文件完成数据的重建。</strong></li>
</ol>
<p><strong>AOF的劣势</strong></p>
<ol>
<li>对于相同数量的数据集而言，AOF文件通常要大于RDB文件。<strong>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</strong></li>
<li>根据同步策略的不同，<strong>AOF在运行效率上往往会慢于RDB</strong>。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</li>
</ol>
<p>二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。</p>
<h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><pre class="highlight"><span class="line">redis有哪几种集群?&#96;</span><br><span class="line">&#96;主从模式 哨兵模式 codis</span><br></pre>

<h4 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h4><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave),数据的复制是单向的，只能由主节点到从节点。</p>
<p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。<br><img src="https://img-blog.csdnimg.cn/20200131175346472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200131175346472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h4><ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
<li>读写分离：可以用于实现读写分离，主库写、从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量；</li>
<li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li>
</ol>
<h4 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h4><p>主从复制过程大体可以分为3个阶段：连接建立阶段（即准备阶段）、数据同步阶段、命令传播阶段。</p>
<p>在从节点执行 slaveof 命令后，复制过程便开始运作，下面图示大概可以看到，<br>从图中可以看出复制过程大致分为6个过程</p>
<p><img src="https://img-blog.csdnimg.cn/20200131175642144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200131175642144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" class="lozad post-image"><br><a href="https://segmentfault.com/a/1190000018268350" target="_blank" rel="noopener">主从复制参考原址</a></p>
<h4 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h4><h4 id="CPA原理"><a href="#CPA原理" class="headerlink" title="CPA原理"></a>CPA原理</h4><ol>
<li>CPA原理是分布式存储理论的基石： C(一致性)； A(可用性)； P(分区容忍性);</li>
<li>当主从网络无法连通时，修改操作无法同步到节点，所以“一致性”无法满足</li>
<li>除非我们牺牲“可用性”，也就是暂停分布式节点服务，不再提供修改数据功能，知道网络恢复<br>一句话概括CAP: 当网络分区发生时，一致性 和 可用性 两难全</li>
</ol>
<h4 id="redis主从同步介绍"><a href="#redis主从同步介绍" class="headerlink" title="redis主从同步介绍"></a>redis主从同步介绍</h4><ol>
<li>和MySQL主从复制的原因一样，Redis虽然读取写入的速度都特别快，但是也会产生读压力特别大的情况。</li>
<li>为了分担读压力，Redis支持主从复制，Redis的主从结构可以采用一主多从或者级联结构。</li>
<li>Redis主从复制可以根据是否是全量分为全量同步和增量同步。<br><code>注：redis主节点Master挂掉时，运维让从节点Slave接管（redis主从默认无法自动切换，需要运维手动切换）</code></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200131225847853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200131225847853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h3 id="redis主动同步机制"><a href="#redis主动同步机制" class="headerlink" title="redis主动同步机制"></a>redis主动同步机制</h3><h4 id="全量同步（快照同步）RDB"><a href="#全量同步（快照同步）RDB" class="headerlink" title="全量同步（快照同步）RDB"></a>全量同步（快照同步）RDB</h4><p>从服务器把有的数据全部丢弃，让主服务把所有数据全部发给他</p>
<pre class="highlight"><span class="line">注：Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：</span><br></pre>

<ol>
<li>从服务器连接主服务器，发送SYNC命令；</li>
<li>主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；</li>
<li>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；</li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；</li>
<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；</li>
<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li>
<li>完成上面几个步骤后就完成了从服务器数据初始化的所有操作，从服务器此时可以接收来自用户的读请求。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200131225935669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200131225935669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h4 id="增量同步-AOF"><a href="#增量同步-AOF" class="headerlink" title="增量同步 AOF"></a>增量同步 AOF</h4><p>全量同步：从服务器把有的数据全部丢弃，让主服务把所有数据全部发给他</p>
<ol>
<li>主节点会将那些对自己状态产生修改性影响的指令记录在本地内存buffer中，然后异步将buffer中指令同步到从节点</li>
<li>从节点一边执行同步指令达到主节点状态，一边向主节点反馈自己同步到哪里（偏移量）</li>
<li>当网络状态不好时，从节点无法和主节点进行同步，当网络恢复时需要进行快照同步</li>
</ol>
<h4 id="Redis主从同步策略"><a href="#Redis主从同步策略" class="headerlink" title="Redis主从同步策略"></a>Redis主从同步策略</h4><ol>
<li>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。</li>
<li>当然，如果有需要，slave 在任何时候都可以发起全量同步。</li>
<li>redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</li>
</ol>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol>
<li>如果多个Slave断线了，需要重启的时候，因为只要Slave启动，就会发送sync请求和主机全量同步，当多个同时出现的时候，可能会导致Master IO剧增宕机。</li>
<li>不能自动切换master，所以master如果挂掉了，整个集群都不可以写入啦</li>
</ol>
<p><a href="https://blog.csdn.net/weixin_42711549/article/details/83061052" target="_blank" rel="noopener">Redis主从同步参考地址</a></p>
<h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p>哨兵模式如何解决主从问题？</p>
<p>当用Redis做主从方案时，假如master宕机，Redis本身无法自动进行主备切换<br>而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自动切换。</p>
<p><strong>哨兵是redis集群架构中非常重要的一个组件，主要功能如下:</strong></p>
<ol>
<li>集群监控，负责监控redis master 和slave进程是否正常工作。</li>
<li>消息通知，如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移，如果master node挂掉了，会自动转移到slave node上。</li>
<li>配置中心，如果故障转移发生了，通知client客户端新的master地址。</li>
</ol>
<p><strong>哨兵本身也是分布式的，作为一个哨兵集群去运行的，相互协同工作</strong></p>
<ol>
<li>故障转移时，判断一个master node宕机了，需要大部分哨兵都同意才行，涉及到分布式选举问题。</li>
<li>及时部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身就是单点，那么就不靠谱。</li>
</ol>
<p><strong>哨兵的核心知识</strong></p>
<ul>
<li>哨兵至少需要3个实例，来保证自己的健壮性。</li>
<li>哨兵+redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用性</li>
<li>对于哨兵+redis主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充分的测试和演练。<br><a href="https://www.cnblogs.com/Eugene-Jin/p/10819601.html" target="_blank" rel="noopener">哨兵详解</a></li>
</ul>
<h3 id="哨兵模式—-sentinel"><a href="#哨兵模式—-sentinel" class="headerlink" title="哨兵模式—-sentinel"></a>哨兵模式—-sentinel</h3><h4 id="sentinel作用"><a href="#sentinel作用" class="headerlink" title="sentinel作用"></a>sentinel作用</h4><ol>
<li>当用Redis做主从方案时，假如master宕机，Redis本身无法自动进行主备切换</li>
<li>而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自动切换。</li>
</ol>
<h4 id="sentinel原理"><a href="#sentinel原理" class="headerlink" title="sentinel原理"></a>sentinel原理</h4><ol>
<li>sentinel负责持续监控主节点的健康，当主节挂掉时，自动选择一个最优的从节点切换成主节点</li>
<li>从节点来连接集群时会首先连接sentinel，通过sentinel来查询主节点的地址</li>
<li>当主节点发生故障时，sentinel会将最新的主节点地址告诉客户端，可以实现无需重启自动切换redis</li>
</ol>
<h4 id="Sentinel支持集群"><a href="#Sentinel支持集群" class="headerlink" title="Sentinel支持集群"></a>Sentinel支持集群</h4><ol>
<li>只使用单个sentinel进程来监控redis集群是不可靠的，当sentinel进程宕掉后sentinel本身也有单点问题</li>
<li>如果有多个sentinel，redis的客户端可以随意地连接任意一个sentinel来获得关于redis集群中的信息。</li>
</ol>
<h4 id="Sentinel版本"><a href="#Sentinel版本" class="headerlink" title="Sentinel版本"></a>Sentinel版本</h4><ol>
<li>Sentinel当前稳定版本称为Sentinel 2，Redis2.8和Redis3.0附带稳定的哨兵版本</li>
<li>安装完redis-3.2.8后，redis-3.2.8/src/redis-sentinel启动程序 redis-3.2.8/sentinel.conf是配置文件。</li>
</ol>
<h4 id="运行sentinel两种方式（效果相同）"><a href="#运行sentinel两种方式（效果相同）" class="headerlink" title="运行sentinel两种方式（效果相同）"></a>运行sentinel两种方式（效果相同）</h4><p>法1：redis-sentinel /path/to/sentinel.conf<br>法2：redis-server /path/to/sentinel.conf –sentinel</p>
<ol>
<li>以上两种方式，都必须指定一个sentinel的配置文件sentinel.conf，如果不指定，将无法启动sentinel。</li>
<li>sentinel默认监听26379端口，所以运行前必须确定该端口没有被别的进程占用。</li>
</ol>
<h4 id="sentinel-conf配置文件说明"><a href="#sentinel-conf配置文件说明" class="headerlink" title="sentinel.conf配置文件说明"></a>sentinel.conf配置文件说明</h4><ol>
<li>配置文件只需要配置master的信息就好啦，不用配置slave的信息，因为slave能够被自动检测到</li>
<li>需要注意的是，配置文件在sentinel运行期间是会被动态修改的，例如当发生主备切换时候，配置文件中的master会被修改为另外一个slave。</li>
<li>这样，之后sentinel如果重启时，就可以根据这个配置来恢复其之前所监控的redis集群的状态。</li>
</ol>
<pre class="highlight"><span class="line"><span class="comment"># sentinel.conf 配置说明</span></span><br><span class="line">sentinel monitor mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">2</span></span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">60000</span></span><br><span class="line">sentinel failover-timeout mymaster <span class="number">180000</span></span><br><span class="line">sentinel parallel-syncs mymaster <span class="number">1</span></span><br><span class="line"><span class="number">12345</span></span><br></pre>

<h4 id="配置传播"><a href="#配置传播" class="headerlink" title="配置传播"></a>配置传播</h4><ol>
<li>一旦一个sentinel成功地对一个master进行了failover，它将会把关于master的最新配置通过广播形式通知其它sentinel，其它的sentinel则更新对应master的配置。</li>
<li>一个faiover要想被成功实行，sentinel必须能够向选为master的slave发送SLAVE OF NO ONE命令，然后能够通过INFO命令看到新master的配置信息。</li>
<li>当将一个slave选举为master并发送SLAVE OF NO ONE`后，即使其它的slave还没针对新master重新配置自己，failover也被认为是成功了的。</li>
</ol>
<p>因为每一个配置都有一个版本号，所以以版本号最大的那个为标准：</p>
<ol>
<li>假设有一个名为mymaster的地址为192.168.1.50:6379。</li>
<li>一开始，集群中所有的sentinel都知道这个地址，于是为mymaster的配置打上版本号1。</li>
<li>一段时候后mymaster死了，有一个sentinel被授权用版本号2对其进行failover。</li>
<li>如果failover成功了，假设地址改为了192.168.1.50:9000，此时配置的版本号为2</li>
<li>进行failover的sentinel会将新配置广播给其他的sentinel，发现新配置的版本号为2时，版本号变大了，说明配置更新了，于是就会采用最新的版本号为2的配置。</li>
</ol>
<h4 id="sentinel缺点"><a href="#sentinel缺点" class="headerlink" title="sentinel缺点"></a>sentinel缺点</h4><p>redis的slave和master数据时完全一样的，但是有个问题，redis数据时存储在内存中<br>内存空间有限，所以哨兵模式不能处理大的数据量</p>
<p>如何解决？codis</p>
<h3 id="codis集群"><a href="#codis集群" class="headerlink" title="codis集群"></a>codis集群</h3><p><strong>简介</strong></p>
<p>Codis 是一个分布式 Redis 解决方案, 对于上层的应用来说, 连接到 Codis Proxy 和连接原生的 Redis Server 没有明显的区别 (不支持的命令列表), 上层应用可以像使用单机的 Redis 一样使用, Codis 底层会处理请求的转发, 不停机的数据迁移等工作, 所有后边的一切事情, 对于前面的客户端来说是透明的, 可以简单的认为后边连接的是一个内存无限大的 Redis 服务.</p>
<p>codis是redis集群解决方案之一，codis是GO语言开发的代理中间件<br>当客户端向codis发送指令时，codis负责将指令转发给后面的redis实例来执行，并将返回结果转发给客户端</p>
<p><strong>为什么会出现codis</strong></p>
<ol>
<li>在大数据高并发场景下，单个redis实例往往会无法应对</li>
<li>首先redis内存不易过大，内存太大会导致rdb文件过大，导致主从同步时间过长</li>
<li>其次在CPU利用率中上，单个redis实例只能利用单核，数据量太大，压力就会特别大</li>
</ol>
<p><strong>codis部署方案</strong><br>\4. 单个codis代理支撑的QPS比较有限，通过启动多个codis代理可以显著增加整体QPS<br>\5. 多codis还能起到容灾功能，挂掉一个codis代理还有很多codis代理可以继续服务<br><img src="https://img-blog.csdnimg.cn/20200131202616740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200131202616740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br><strong>codis分片的原理</strong></p>
<ol>
<li>codis负责将特定key转发到特定redis实例，codis默认将所有key划分为1024个槽位</li>
<li>首先会对客户端传来的key进行crc32计算hash值，然后将hash后的整数值对1024进行取模，这个余数就是对应的key槽位</li>
<li>每个槽位都会唯一映射到后面的多个redis实例之一，codis会在内存中维护槽位和redis实例的映射关系</li>
<li>这样有了上面key对应的槽位，那么它应该转发到那个redis实例就很明确了</li>
<li>槽位数量默认是1024，如果集群中节点较多，建议将这个数值大一些，比如2048,4096</li>
</ol>
<p><strong>不同codis槽位如何同步</strong></p>
<ol>
<li>如果codis槽位值存在内存中，那么不同的codis实例间的槽位关系得不到同步</li>
<li>所以codis还需要一个分布式配置存储的数据库专门来持久化槽位关系</li>
<li>codis将槽位关系存储在zookeeper中，并且提供一个dashboard可以来观察和修改槽位关系</li>
</ol>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p><strong>布隆过滤器是什么？（判断某个key一定不存在）</strong></p>
<ol>
<li>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构</li>
<li>特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</li>
<li>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。<br>使用：<br>　　1. 布隆过滤器在NoSQL数据库领域中应用的非常广泛<br>　　2. 当用户来查询某一个row时，可以先通过内存中的布隆过滤器过滤掉大量不存在的row请求，然后去再磁盘进行查询<br>　　3. 布隆过滤器说某个值不存在时，那肯定就是不存在，可以显著降低数据库IO请求数量</li>
</ol>
<p><strong>应用场景</strong></p>
<ul>
<li>场景1（给用户推荐新闻）</li>
</ul>
<ol>
<li>当用户看过的新闻，肯定会被过滤掉，对于没有看多的新闻，可能会过滤极少的一部分（误判）。</li>
<li>这样可以完全保证推送给用户的新闻都是无重复的。</li>
</ol>
<ul>
<li>场景2（爬虫url去重）</li>
</ul>
<ol>
<li>在爬虫系统中，我们需要对url去重，已经爬取的页面不再爬取</li>
<li>当url高达几千万时，如果一个集合去装下这些URL地址非常浪费空间</li>
<li>使用布隆过滤器可以大幅降低去重存储消耗，只不过也会使爬虫系统错过少量页面</li>
</ol>
<p><strong>布隆过滤器原理</strong></p>
<ol>
<li>每个布隆过滤器对应到Redis的数据结构是一个大型的数组和几个不一样的无偏hash函数</li>
<li>如下图：f、g、h就是这样的hash函数（无偏差指让hash映射到数组的位置比较随机）</li>
</ol>
<p><strong>添加：值到布隆过滤器</strong><br>\1. 向布隆过滤器添加key,会使用 f、g、h hash函数对key算出一个整数索引，然后对长度取余<br>\2. 每个hash函数都会算出一个不同的位置，把算出的位置都设置成1就完成了布隆过滤器添加过程<br><strong>查询：布隆过滤器值</strong><br>\1. 当查询某个key时，先用hash函数算出一个整数索引，然后对长度取余<br>\2. 当你有一个不为1时肯定不存在这个key，当全部都为1时可能有这个key<br>\3. 这样内存中的布隆过滤器过滤掉大量不存在的row请求，然后去再磁盘进行查询，减少IO操作<br><strong>删除：不支持</strong><br>\1. 目前我们知道布隆过滤器可以支持 add 和 isExist 操作<br>\2. 如何解决这个问题，答案是计数删除，但是计数删除需要存储一个数值，而不是原先的 bit 位，会增大占用的内存大小。<br>\3. 增加一个值就是将对应索引槽上存储的值加一，删除则是减一，判断是否存在则是看值是否大于0。</p>
<p><img src="https://img-blog.csdnimg.cn/20200131223226757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200131223226757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<h3 id="redis事物与分布式锁"><a href="#redis事物与分布式锁" class="headerlink" title="redis事物与分布式锁"></a>redis事物与分布式锁</h3><h4 id="redis事物"><a href="#redis事物" class="headerlink" title="redis事物"></a>redis事物</h4><ol>
<li>严格意义来讲,Redis的事务和我们理解的传统数据库(如mysql)的事务是不一样的；</li>
<li>Redis的事务实质上是命令的集合，在一个事务中要么所有命令都被执行，要么所有命令都不执行。</li>
</ol>
<p>需要注意的是:<br>　　1.Redis的事务没有关系数据库事务提供的回滚（rollback），所以开发者必须在事务执行失败后进行后续的处理；<br>　　2.如果在一个事务中的命令出现错误，那么所有的命令都不会执行；<br>　　3.如果在一个事务中出现运行错误，那么正确的命令会被执行。</p>
<h4 id="redis事物介绍"><a href="#redis事物介绍" class="headerlink" title="redis事物介绍"></a>redis事物介绍</h4><ol>
<li>redis事物是可以一次执行多个命令，本质是一组命令的集合。</li>
<li>一个事务中的所有命令都会序列化，按顺序串行化的执行而不会被其他命令插入<br>作用：一个队列中，一次性、顺序性、排他性的执行一系列命令</li>
</ol>
<h4 id="redis事物基本使用"><a href="#redis事物基本使用" class="headerlink" title="redis事物基本使用"></a>redis事物基本使用</h4><ol>
<li>下面指令演示了一个完整的事物过程，所有指令在exec前不执行，而是缓存在服务器的一个事物队列中</li>
<li>服务器一旦收到exec指令才开始执行事物队列，执行完毕后一次性返回所有结果</li>
<li>因为redis是单线程的，所以不必担心自己在执行队列是被打断，可以保证这样的“原子性”</li>
</ol>
<p><code>注：redis事物在遇到指令失败后，后面的指令会继续执行</code><br><strong>mysql的rollback与redis的discard的区别:</strong></p>
<ol>
<li>mysql回滚为sql全部成功才执行,一条sql失败则全部失败,执行rollback后所有语句造成的影响消失</li>
<li>redis的discard只是结束本次事务,正确命令造成的影响仍然还在.</li>
</ol>
<pre class="highlight"><span class="line">&gt; multi（开始一个redis事物）</span><br><span class="line">incr books</span><br><span class="line">incr books</span><br><span class="line">&gt; exec （执行事物）</span><br><span class="line">&gt; discard （丢弃事物）</span><br><span class="line"><span class="number">12345</span></span><br></pre>



<h4 id="watch指令"><a href="#watch指令" class="headerlink" title="watch指令"></a>watch指令</h4><ol>
<li><p>watch其实就是redis提供的一种乐观锁，可以解决并发修改问题</p>
</li>
<li><p>watch会在事物开始前盯住一个或多个关键变量，当服务器收到exec指令要顺序执行缓存中的事物队列时</p>
</li>
<li><p>redis会检查关键变量自watch后是否被修改（包括当前事物所在的客户端）</p>
</li>
<li><p>如果关键变量被人改动过，exec指令就会返回null回复告知客户端事物执行失败，这个时候客户端会选择重试<br>注：redis禁用在multi和exec之间执行watch指令，必须在multi之前盯住关键变量，否则会出错</p>
</li>
</ol>
<h3 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h3><h4 id="redis原子操作"><a href="#redis原子操作" class="headerlink" title="redis原子操作"></a>redis原子操作</h4><ol>
<li>原子操作是指不会被线程调度机制打断的操作</li>
<li>这种操作一旦开始，就会一直运行到结束，中间不会切换任何进程</li>
</ol>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><ol>
<li>分布式锁本质是占一个坑，当别的进程也要来占坑时发现已经被占，就会放弃或者稍后重试</li>
<li>占坑一般使用 setnx(set if not exists)指令，只允许一个客户端占坑</li>
<li>先来先占，用完了在调用del指令释放坑</li>
</ol>
<pre class="highlight"><span class="line">&gt; setnx lock:codehole true</span><br><span class="line">.... <span class="keyword">do</span> something critical ....</span><br><span class="line">&gt; del lock:codehole</span><br><span class="line"><span class="number">123</span></span><br></pre>

<ol>
<li>但是这样有一个问题，如果逻辑执行到中间出现异常，可能导致del指令没有被调用，这样就会陷入死锁，锁永远无法释放</li>
<li>为了解决死锁问题，我们拿到锁时可以加上一个expire过期时间，这样即使出现异常，当到达过期时间也会自动释放锁</li>
</ol>
<pre class="highlight"><span class="line">&gt; setnx lock:codehole true</span><br><span class="line">&gt; expire lock:codehole <span class="number">5</span></span><br><span class="line">.... <span class="keyword">do</span> something critical ....</span><br><span class="line">&gt; del lock:codehole</span><br><span class="line"><span class="number">1234</span></span><br></pre>

<ol>
<li>这样又有一个问题，setnx和expire是两条指令而不是原子指令，如果两条指令之间进程挂掉依然会出现死锁</li>
<li>为了治理上面乱象，在redis 2.8中加入了set指令的扩展参数，使setnx和expire指令可以一起执行</li>
</ol>
<pre class="highlight"><span class="line">&gt; set lock:codehole true ex <span class="number">5</span> nx</span><br><span class="line"><span class="string">''</span><span class="string">' do something '</span><span class="string">''</span></span><br><span class="line">&gt; del lock:codehole </span><br><span class="line"><span class="number">123</span></span><br></pre>



<h3 id="redis雪崩-amp-穿透-amp-击穿"><a href="#redis雪崩-amp-穿透-amp-击穿" class="headerlink" title="redis雪崩&amp;穿透&amp;击穿"></a>redis雪崩&amp;穿透&amp;击穿</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><ul>
<li>定义</li>
</ul>
<ol>
<li>缓存穿透是指查询一个一定不存在的数据，由于缓存不命中，接着查询数据库也无法查询出结果，</li>
<li>虽然也不会写入到缓存中，但是这将会导致每个查询都会去请求数据库，造成缓存穿透；</li>
</ol>
<ul>
<li>解决方法 ：布隆过滤</li>
</ul>
<ol>
<li>对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；</li>
</ol>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><ul>
<li>定义</li>
</ul>
<ol>
<li>缓存雪崩是指，由于缓存层承载着大量请求，有效的保护了存储层，但是如果缓存层由于某些原因整体不能提供服务</li>
<li>于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</li>
</ol>
<ul>
<li>解决方法</li>
</ul>
<ol>
<li>保证缓存层服务高可用性：比如 Redis Sentinel 和 Redis Cluster 都实现了高可用</li>
<li>依赖隔离组件为后端限流并降级：比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</li>
</ol>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><ul>
<li>定义：</li>
</ul>
<ol>
<li>缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况</li>
<li>当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</li>
</ol>
<ul>
<li>解决方法</li>
</ul>
<ol>
<li>解决方式也很简单，可以将热点数据设置为永远不过期；</li>
<li>或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据</li>
</ol>
<h3 id="redis项目缓存实现"><a href="#redis项目缓存实现" class="headerlink" title="redis项目缓存实现"></a>redis项目缓存实现</h3><p>待补充</p>
<hr>
<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>更高的写入负载</li>
<li>高可用性</li>
<li>表结构不明确，且数据在不断变大</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>不能保证事务安全性</li>
<li>消耗内存大</li>
</ol>
<h4 id="MongoDB为什么快"><a href="#MongoDB为什么快" class="headerlink" title="MongoDB为什么快"></a>MongoDB为什么快</h4><p>写快：<br>写入数据存在在内存里就返回给应用程序，<br>而保存到硬体的操作则在后台异步完成</p>
<hr>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h4 id="RabbitMQ使用场景"><a href="#RabbitMQ使用场景" class="headerlink" title="RabbitMQ使用场景"></a>RabbitMQ使用场景</h4><ol>
<li>异步处理</li>
<li>应用解耦</li>
<li>流量削锋</li>
<li>日志处理：Kalfka消息中间件</li>
</ol>
<h4 id="RabbitMq与Redis队列对比"><a href="#RabbitMq与Redis队列对比" class="headerlink" title="RabbitMq与Redis队列对比"></a>RabbitMq与Redis队列对比</h4><ol>
<li>可靠消费</li>
<li>可靠发布</li>
<li>高可用</li>
<li>持久化</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础知识点大全</title>
    <url>/2020/09/06/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h2 id="Python知识点"><a href="#Python知识点" class="headerlink" title="Python知识点"></a>Python知识点</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><ol>
<li>进程是资源分配最小单位</li>
<li><strong>一个运行起来的程序就是一个进程</strong><br>什么是程序（程序是我们存储在硬盘里的代码、文件）<br>当我们双击图标，打开程序的时候，实际上就是通过I/O操作（读写）内存条里面<br>内存条就是我们所指的资源</li>
<li>进程之间内存独立，不能相互访问</li>
</ol>
<p><strong>进程定义拓展回答内容</strong>：</p>
<ol>
<li>程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，这种执行的程序就称之为进程</li>
<li>程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念</li>
<li>在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。</li>
<li>进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。</li>
<li>进程之间有自己独立的内存，各进程之间不能相互访问</li>
<li>创建一个新线程很简单，创建新进程需要对父进程进行复制</li>
</ol>
<h4 id="进程和程序的区别"><a href="#进程和程序的区别" class="headerlink" title="进程和程序的区别"></a>进程和程序的区别</h4><ol>
<li>程序只是一个普通文件，是一个机器代码指令和数据的集合，所以，程序是一个静态的实体</li>
<li>而进程是程序运行在数据集上的动态过程，进程是一个动态实体，它应创建而产生，应调度执行因等待资源或事件而被处于等待状态，因完成任务而被撤消</li>
<li>进程是系统进行资源分配和调度的一个独立单位</li>
<li>一个程序对应多个进程，一个进程为多个程序服务（两者之间是多对多的关系）</li>
<li>一个程序执行在不同的数据集上就成为不同的进程，进程可以控制 块 来唯一标识每个程序</li>
</ol>
<p><strong>多道编程概念</strong>:</p>
<ul>
<li>多道编程： 在计算机内存中同时存放几道相互独立的程序，他们共享系统资源，相互穿插运行</li>
<li>单道编程： 计算机内存中只允许一个的程序运行</li>
</ul>
<p><code>进程具有独立的内存空间，所以没有办法相互通信</code><br><strong>进程通信</strong>:</p>
<p>python提供了多种进程通信的方式，主要<strong>Queue</strong>和<strong>Pipe</strong>这两种方式，<strong>Queue</strong>用 于多个进程间实现通信，<strong>Pipe</strong>是两个进程的通信。</p>
<ul>
<li>Queue有两个方法：<br>\1. Put方法：以插入数据到队列中<br>\2. Get方法：从队列读取并且删除一个元素</li>
<li>Pipe常用于两个进程，两个进程分别位于管道的两端<br>Pipe方法返回（conn1,conn2）代表一个管道的两个端，Pipe方法有duplex参数，默认为True，即全双工模式，若为FALSE，conn1只负责接收信息，conn2负责发送，</li>
<li>managers</li>
<li>RabbitMQ、redis等</li>
</ul>
<p><strong>进程间互相访问数据的四种方法</strong>:<br><code>注：不同进程间内存是不共享的，所以互相之间不能访问对方数据</code></p>
<ol>
<li>利用Queues实现父进程到子进程（或子进程间）的数据传递</li>
<li>使用管道pipe实现两个进程间数据传递</li>
<li>Managers实现很多进程间数据共享</li>
<li>借助redis中间件进行数据共享</li>
</ol>
<p><strong>进程池</strong>:<br>为什么需要进程池?</p>
<ul>
<li>一次性开启指定数量的进程</li>
<li>如果有十个进程，有一百个任务，一次可以处理多少个（一次性只能处理十个）</li>
<li>防止进程开启数量过多导致服务器压力过大</li>
<li>开进程池是为了效率,进程直接的切换是属于IO调度，每个进程的内存空间都有自己的寄存器，堆栈和文件。</li>
</ul>
<pre class="highlight"><span class="line"><span class="keyword">from</span>  multiprocessing <span class="keyword">import</span> Process,Pool</span><br><span class="line"><span class="keyword">import</span> time,os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(i)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"in the process"</span>,os.getpid()) <span class="comment">#打印子进程的pid</span></span><br><span class="line"><span class="keyword">return</span> i+<span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(arg)</span>:</span></span><br><span class="line">print(<span class="string">'--&gt;exec done:'</span>,arg,os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = Pool(<span class="number">3</span>)                      <span class="comment">#进程池最多允许5个进程放入进程池</span></span><br><span class="line">    print(<span class="string">"主进程pid："</span>,os.getpid())     <span class="comment">#打印父进程的pid</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">       <span class="comment">#用法1 callback作用是指定只有当Foo运行结束后就执行callback调用的函数,父进程调用的callback函数</span></span><br><span class="line">        pool.apply_async(func=foo, args=(i,),callback=call)</span><br><span class="line">        <span class="comment">#用法2 串行 启动进程不在用Process而是直接用pool.apply()</span></span><br><span class="line">        <span class="comment"># pool.apply(func=foo, args=(i,))</span></span><br><span class="line">    print(<span class="string">'end'</span>)</span><br><span class="line">    pool.close()    <span class="comment">#关闭pool</span></span><br><span class="line">    pool.join()     <span class="comment">#进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</span></span><br></pre>

<p><strong>进程池优点</strong>：</p>
<pre class="highlight"><span class="line">不仅仅减少了IO而且还减少了内存。</span><br><span class="line">下面的例子便可以区分 其他语言的进程池还可以根据服务器的压力来增减，有着上限和下限。</span><br><span class="line">12</span><br></pre>

<p><strong>建议：超过五个进程就用进程池</strong></p>
<p><strong>有了进程为什么还要线程？</strong></p>
<ol>
<li>进程优点：<br>提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率</li>
<li>进程的两个重要缺点<br>a. 第一点：进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。<br>b. 第二点：进程在执行的过程中如果阻塞，即使进程中有些工作不依赖于输入的数据，也将无法执行（例如等待输入，整个进程就会挂起）。<br>c. 例如，我们在使用qq聊天， qq做为一个独立进程如果同一时间只能干一件事，那他如何实现在同一时刻 即能监听键盘输入、又能监听其它人给你发的消息<br>d. 你会说，操作系统不是有分时么？分时是指在不同进程间的分时呀<br>e. 即操作系统处理一会你的qq任务，又切换到word文档任务上了，每个cpu时间片分给你的qq程序时，你的qq还是只能同时干一件事呀</li>
</ol>
<hr>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><strong>线程的定义</strong>:</p>
<ol>
<li>线程是系统调度的最小单位</li>
<li>同进程下线程资源共享</li>
<li>进程无法自己执行，只有通过线程操作CPU，内存</li>
<li>为了保证数据安全，必须使用线程锁</li>
</ol>
<p><strong>线程定义拓展回答内容</strong>:</p>
<ol>
<li>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位</li>
<li>一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务</li>
<li>无论你启多少个线程，你有多少个cpu, Python在执行的时候会淡定的在同一时刻只允许一个线程运行</li>
<li>进程本身是无法自己执行的，要操作cpu，必须创建一个线程，线程是一系列指令的集合</li>
<li>所有在同一个进程里的线程是共享同一块内存空间的，不同进程间内存空间不同</li>
<li>同一个进程中的各线程可以相互访问资源，线程可以操作同进程中的其他线程，但进程仅能操作子进程</li>
<li>两个进程想通信，必须要通过一个中间代理</li>
<li>对主线程的修改可能回影响其他子线程，对主进程修改不会影响其他进程因为进程间内存相互独立，但是同一进程下的线程共享内存</li>
</ol>
<p><strong>进程和线程的区别</strong>:</p>
<ol>
<li>进程包含线程</li>
<li>线程共享内存空间</li>
<li>进程内存是独立的（不可互相访问）</li>
<li>进程可以生成子进程，子进程之间互相不能互相访问（相当于在父级进程克隆两个子进程）</li>
<li>在一个进程里面线程之间可以交流。两个进程想通信，必须通过一个中间代理来实现</li>
<li>创建新线程很简单，创建新进程需要对其父进程进行克隆。</li>
<li>一个线程可以控制或操作同一个进程里面的其它线程。但进程只能操作子进程。</li>
<li>父进程可以修改不影响子进程，但不能修改。</li>
<li>线程可以帮助应用程序同时做几件事</li>
</ol>
<p><strong>for循环同时启动多个线程</strong>：</p>
<pre class="highlight"><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">(num)</span>:</span> <span class="comment">#定义每个线程要运行的函数</span></span><br><span class="line">    print(<span class="string">"running on number:%s"</span> %num)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    t = threading.Thread(target=sayhi,args=(<span class="string">'t-%s'</span>%i,))</span><br><span class="line">    t.start()</span><br></pre>

<p><strong>t.join()： 实现所有线程都执行结束后再执行主线程</strong>：</p>
<pre class="highlight"><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">(num)</span>:</span> <span class="comment">#定义每个线程要运行的函数</span></span><br><span class="line">    print(<span class="string">"running on number:%s"</span> %num)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">t_objs = []    <span class="comment">#将进程实例对象存储在这个列表中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    t = threading.Thread(target=sayhi,args=(<span class="string">'t-%s'</span>%i,))</span><br><span class="line">    t.start()          <span class="comment">#启动一个线程，程序不会阻塞</span></span><br><span class="line">    t_objs.append(t)</span><br><span class="line">print(threading.active_count())    <span class="comment">#打印当前活跃进程数量</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> t_objs: <span class="comment">#利用for循环等待上面50个进程全部结束</span></span><br><span class="line">    t.join()     <span class="comment">#阻塞某个程序</span></span><br><span class="line">print(threading.current_thread())    <span class="comment">#打印执行这个命令进程</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"----------------all threads has finished....."</span>)</span><br><span class="line">print(threading.active_count())</span><br><span class="line">print(<span class="string">'cost time:'</span>,time.time() - start_time)</span><br></pre>



<p><strong>setDaemon(): 守护线程，主线程退出时，需要子线程随主线程退出</strong>:</p>
<pre class="highlight"><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">(num)</span>:</span> <span class="comment">#定义每个线程要运行的函数</span></span><br><span class="line">    print(<span class="string">"running on number:%s"</span> %num)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    t = threading.Thread(target=sayhi,args=(<span class="string">'t-%s'</span>%i,))</span><br><span class="line">    t.setDaemon(<span class="literal">True</span>)  <span class="comment">#把当前线程变成守护线程，必须在t.start()前设置</span></span><br><span class="line">    t.start()          <span class="comment">#启动一个线程，程序不会阻塞</span></span><br><span class="line">print(<span class="string">'cost time:'</span>,time.time() - start_time)</span><br></pre>



<p><strong>GIL全局解释器锁：保证同一时间仅有一个线程对资源有操作权限</strong>:</p>
<pre class="highlight"><span class="line">作用：在一个进程内，同一时刻只能有一个线程执行&#96;</span><br><span class="line">&#96;说明：python多线程中GIL锁只是在CPU操作时（如：计算）才是串行的，其他都是并行的，所以比串行快很多</span><br></pre>

<ol>
<li>为了解决不同线程同时访问同一资源时，数据保护问题，而产生了GIL</li>
<li>GIL在解释器的层面限制了程序在同一时间只有一个线程被CPU实际执行，而不管你的程序里实际开了多少条线程</li>
<li>CPython自己定义了一个全局解释器锁，同一时间仅仅有一个线程可以拿到这个数据</li>
<li>python之所以会产生这种不好的状况是因为python启用一个线程是调用操作系统原生线程，就是C接口</li>
<li>但是这仅仅是CPython这个版本的问题，在PyPy，中就没有这种缺陷</li>
</ol>
<p><strong>线程锁</strong>:</p>
<ol>
<li>当一个线程对某个资源进行CPU计算的操作时加一个线程锁，只有当前线程计算完成主动释放锁，其他线程才能对其操作</li>
<li>这样就可以防止还未计算完成，释放GIL锁后其他线程对这个资源操作导致混乱问题</li>
<li>线程锁本质把线程中的数据加了一把互斥锁</li>
</ol>
<h4 id="有了GIL全局解释器锁为什么还需要线程锁"><a href="#有了GIL全局解释器锁为什么还需要线程锁" class="headerlink" title="有了GIL全局解释器锁为什么还需要线程锁"></a>有了GIL全局解释器锁为什么还需要线程锁</h4><p>因为cpu是分时使用的</p>
<p>GIL是限制同一个进程中只有一个线程进入Python解释器。。。。。<br>而线程锁是由于在线程进行数据操作时保证数据操作的安全性(同一个进程中线程之间可以共用信息，如果同时对数据进行操作，则会出现公共数据错误)<br>其实线程锁完全可以替代GIL，但是Python的后续功能模块都是加在GIL基础上的，所以无法更改或去掉GIL,这就是Python语言最大的bug…只能用多进程或协程改善，或者直接用其他语言写这部分</p>
<h4 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h4><p>两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去</p>
<p><strong>用户锁</strong>:</p>
<pre class="highlight"><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">lock = threading.Lock()          <span class="comment">#1 生成全局锁</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num                  <span class="comment">#2 在每个线程中都获取这个全局变量</span></span><br><span class="line">    print(<span class="string">'--get num:'</span>,num )</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    lock.acquire()              <span class="comment">#3 修改数据前加锁</span></span><br><span class="line">    num  -= <span class="number">1</span>                   <span class="comment">#4 对此公共变量进行-1操作</span></span><br><span class="line">    lock.release()              <span class="comment">#5 修改后释放</span></span><br></pre>



<p><strong>Semaphore(信号量)</strong>:</p>
<ol>
<li>互斥锁 同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据</li>
<li>比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去</li>
<li>作用就是同一时刻允许运行的线程数量</li>
</ol>
<p><strong>多线程</strong></p>
<ul>
<li><p>GIL锁：</p>
<p>全局解释锁，每次只能一个线程获得cpu的使用权：为了线程安全，也就是为了解决多线程之间的数据完整性和状态同步而加的锁，因为我们知道线程之间的数据是共享的。</p>
</li>
<li><p>join()作用：</p>
<p>在进程中可以阻塞主进程的执行, 直到等待子线程全部完成之后, 才继续运行主线程后面的代码</p>
</li>
<li><p>setDaemon()：</p>
<p>将该线程标记为守护线程或用户线程</p>
</li>
</ul>
<p><strong>线程池</strong></p>
<ul>
<li>使用以下模块创建线程池：</li>
</ul>
<ol>
<li>使用threadpool模块，这是个python的第三方模块，支持python2和python3</li>
<li>使用concurrent.futures模块，这个模块是python3中自带的模块，但是，python2.7以上版本也可以安装使用</li>
</ol>
<ul>
<li>线程池实现并发:</li>
</ul>
  <pre class="highlight"><span class="line">python</span><br><span class="line">import requests</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">def fetch_request(url):</span><br><span class="line">    result &#x3D; requests.get(url)</span><br><span class="line">    print(result.text)</span><br><span class="line"></span><br><span class="line">url_list &#x3D; [</span><br><span class="line">    &#39;https:&#x2F;&#x2F;www.baidu.com&#39;,</span><br><span class="line">    &#39;https:&#x2F;&#x2F;www.google.com&#x2F;&#39;,         #google页面会卡住，知道页面超时后这个进程才结束</span><br><span class="line">    &#39;http:&#x2F;&#x2F;dig.chouti.com&#x2F;&#39;,          #chouti页面内容会直接返回，不会等待Google页面的返回</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">pool &#x3D; ThreadPoolExecutor(10)            # 创建一个线程池，最多开10个线程</span><br><span class="line">for url in url_list:</span><br><span class="line">    pool.submit(fetch_request,url)       # 去线程池中获取一个线程，线程去执行fetch_request方法</span><br><span class="line"></span><br><span class="line">pool.shutdown(True)                      # 主线程自己关闭，让子线程自己拿任务执行</span><br></pre>



<hr>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><strong>什么是协程（进入上一次调用的状态）</strong></p>
<ol>
<li>协程，又称微线程，纤程，协程是一种用户态的轻量级线程。</li>
<li>线程的切换会保存到CPU的栈里，协程拥有自己的寄存器上下文和栈，</li>
<li>协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈</li>
<li>协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态</li>
<li>协程最主要的作用是在单线程的条件下实现并发的效果，但实际上还是串行的（像yield一样）</li>
<li>协程能在单线程处理高并发</li>
</ol>
<p><strong>协程的定义</strong>：</p>
<ol>
<li>协程在单线程下实现并发效果</li>
<li>协程遇IO自动切换</li>
<li>协程保留上一次调用状态</li>
</ol>
<p><strong>协程的优点</strong>:</p>
<ol>
<li>无需线程上下文切换的开销</li>
<li>无需原子操作锁定及同步的开销，因为协程是串行的</li>
<li>方便切换控制流，简化编程模型</li>
<li>高并发，高扩展，低成本，一个cpu支持上万个协程没有问题，所以非常适合高并发处理</li>
</ol>
<p><strong>协程的缺点</strong>:</p>
<ol>
<li>无法利用多核的优势，但是协程和进程配合就可以使协程运行在不同的cpu上，就可以利用 多核的优势，但是在现实中，大部分场景都没有这个需要</li>
<li>只要一个协程阻塞（Blocking），就会阻塞整个协程，因为协程是串行的,这个问题必须要解决，才能让协程大范围应用</li>
</ol>
<ul>
<li>解决方法：<br>如果遇到<strong>io</strong>操作，则进行协程切换,去执行其他的协程，可以用<strong>gevent</strong>来实现，具体的实现是这样的，<br>比如协程1通过os去读一个file，这个时候就是一个 io操作，在调用os的接口前，就会有一个列表，协议1的这个操作就会被注册到这个列表中，然后就切换到其他协程去处理；等待os拿到要读file后，也会把这个文件句柄放在这个列表中，然后等待在切换到<br>协程1的时候，协程1就可以直接从列表中拿到数据，这样就可以实现不阻塞了</li>
</ul>
<p><strong>协程处理并发</strong>：</p>
<ul>
<li><strong>Gevent<br>遇IO自动切换</strong></li>
</ul>
<ol>
<li>Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程</li>
<li>协程之所以快是因为遇到I/O操作就切换（最后只有CPU运算）</li>
<li>其实Gevent模块仅仅是对greenlet的再封装，将I/O间的手动切换变成自动切换</li>
</ol>
<ul>
<li><strong>Greenlet<br>遇IO手动切换</strong></li>
</ul>
<ol>
<li>Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。</li>
</ol>
<p><strong>使用协程处理并发</strong><br><code>注：Gevent只用起一个线程，当请求发出去后gevent就不管,永远就只有一个线程工作，谁先回来先处理</code></p>
<pre class="highlight"><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这些请求谁先回来就先处理谁</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_async</span><span class="params">(method, url, req_kwargs)</span>:</span></span><br><span class="line">    response = requests.request(method=method, url=url, **req_kwargs)</span><br><span class="line">    print(response.url, response.content)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">##### 发送请求 #####</span></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(fetch_async, method=<span class="string">'get'</span>, url=<span class="string">'https://www.python.org/'</span>, req_kwargs=&#123;&#125;),</span><br><span class="line">    gevent.spawn(fetch_async, method=<span class="string">'get'</span>, url=<span class="string">'https://www.google.com/'</span>, req_kwargs=&#123;&#125;),</span><br><span class="line">    gevent.spawn(fetch_async, method=<span class="string">'get'</span>, url=<span class="string">'https://github.com/'</span>, req_kwargs=&#123;&#125;),</span><br><span class="line">])</span><br></pre>

<h5 id="select、poll、epoll（重点）："><a href="#select、poll、epoll（重点）：" class="headerlink" title="select、poll、epoll（重点）："></a>select、poll、epoll（重点）：</h5><h4 id="I-O的实质是什么？"><a href="#I-O的实质是什么？" class="headerlink" title="I/O的实质是什么？"></a>I/O的实质是什么？</h4><p>I/O的实质是将硬盘中的数据，或收到的数据实现从内核态 copy到 用户态的过程<br>本文讨论的背景是Linux环境下的network IO。<br>比如微信读取本地硬盘的过程<br>微信进程会发送一个读取硬盘的请求—-》操作系统<br>只有内核才能够读取硬盘中的数据—》数据返回给微信程序（看上去就好像是微信直接读取）</p>
<h4 id="用户态-amp-内核态"><a href="#用户态-amp-内核态" class="headerlink" title="用户态 &amp; 内核态"></a>用户态 &amp; 内核态</h4><p>系统空间分为两个部分，一部分是内核态，一部分是用户态的部分<br>内核态：内核态的空间资源只有操作系统能够访问<br>用户态：我们写的普通程序使用的空间</p>
<p><img src="https://img-blog.csdnimg.cn/20200224132553804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200224132553804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br><img src="https://img-blog.csdnimg.cn/20200224132633111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200224132633111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<ul>
<li><strong>select （能监控数量有限，不能告诉用户程序具体哪个连接有数据）</strong></li>
</ul>
<p>单个进程就可以同时处理多个网络连接的io请求（同时阻塞多个io操作）。基本原理就是程序呼叫select，然后整个程序就阻塞状态，这时候，kernel内核就会轮询检查所有select负责的文件描述符fd，当找到其中那个的数据准备好了文件描述符，会返回给select，select通知系统调用，将数据从kernel内核复制到进程缓冲区(用户空间)。</p>
<ul>
<li><strong>poll（和select一样，仅仅去除了最大监控数量）</strong></li>
</ul>
<ol>
<li>poll和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制<br>差别如下：</li>
</ol>
<p>描述fd集合的方式不同，poll使用 pollfd 结构而不是select结构fd_set结构，所以poll是链式的，没有最大连接数的限制<br>poll有一个特点是水平触发，也就是通知程序fd就绪后，这次没有被处理，那么下次poll的时候会再次通知同个fd已经就绪。</p>
<ul>
<li><strong>epoll (不仅没有最大监控数量限制，还能告诉用户程序哪个连接有活跃)</strong><br><code>注：epoll被认为是linux下性能最好的多路io就绪通知方法</code></li>
</ul>
<ol>
<li>epoll直到Linux2.6（centos6以后）才出现了由内核直接支持</li>
<li>Epoll没有最大文件描述符数量限制</li>
<li>epoll最重要的优点是他可以直接告诉用户程序哪一个，比如现在用epoll去监控10000个socket链接，交给内核去监测，现在有一个连接有数据了，在有有一个连接有数据了，epoll会直接高数用户程序哪个连接有数据了</li>
</ol>
<p>epoll是select和poll的改进方案，在 linux 上可以取代 select 和 poll，可以处理大量连接的性能问题</p>
<ul>
<li><strong>epoll能实现高并发原理</strong></li>
</ul>
<ol>
<li><p>epoll() 中内核则维护一个链表，epoll_wait 直接检查链表是不是空就知道是否有文件描述符准备好了。</p>
</li>
<li><p>在内核实现中 epoll 是根据每个 sockfd 上面的与设备驱动程序建立起来的回调函数实现的。</p>
</li>
<li><p>某个 sockfd 上的事件发生时，与它对应的回调函数就会被调用，把这个 sockfd 加入链表。</p>
</li>
<li><p>epoll上面链表中获取文件描述，这里使用内存映射（mmap）技术， 避免了复制大量文件描述符带来的开销<br>内存映射（mmap）：内存映射文件，是由一个文件到一块内存的映射，将不必再对文件执行I/O操作</p>
<p><strong>epoll有4个动作：创建，注册，等待，取消注册，很显然我们用不着</strong></p>
</li>
</ol>
<ul>
<li><p><strong>epoll和select，poll还有一个本质的区别的就是:</strong></p>
<p>select 和 poll 只有在下次在循环回来，再去操作系统获取文件描述符<br>epoll 会直接告诉程序，我们这里已经就绪了，你可以接受数据了，等下一次协程去调用 epoll_wait 的时候就可以直接拿到就绪的文件描述符</p>
</li>
</ul>
<p><strong>猴子补丁</strong></p>
<p>即在运行时对方法 / 类 / 属性 / 功能进行修改，把新的代码作为解决方案代替原有的程序，也就是为其打上补丁。</p>
<p>在使用gevent模块的使用会遇到猴子补丁</p>
<pre class="highlight"><span class="line"><span class="keyword">import</span> gevent.monkey</span><br><span class="line"> </span><br><span class="line">gevent.monkey.patch_all()</span><br><span class="line"></span><br><span class="line">注解：使用猴子补丁的方式，gevent能够修改标准库里面大部分的阻塞式系统调用，包括socket、ssl、threading和 select等模块，而变为协作式运行。也就是通过猴子补丁的monkey.patch_xxx()来将python标准库中模块或函数改成gevent中的响应的具有协程的协作式对象。这样在不改变原有代码的情况下，将应用的阻塞式方法，变成协程式的。</span><br></pre>



<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p><strong>介绍</strong></p>
<p>装饰器(Decorators)是 Python 的一个重要部分。<br>简单地说：他们是修改其他函数的功能的函数。他们有助于让我们的代码更简短，也更Pythonic（Python范儿）。</p>
<p><strong>装饰器的概念</strong>：</p>
<pre class="highlight"><span class="line">1. 装饰器实际上就是一个函数</span><br><span class="line">2. 有2个特别之处，参数是一个函数。返回值是一个参数</span><br><span class="line">12</span><br></pre>

<p><strong>装饰器的简单理解</strong>:</p>
<pre class="highlight"><span class="line">实际上就是为了给一个程序添加功能，但是该程序已经上线或者已被使用，</span><br><span class="line">那么就不能大批量的修改源码，这样不现实，因此就产生了装饰器。</span><br><span class="line">注意点：</span><br><span class="line">1. 不能修改被装饰的函数的源代码</span><br><span class="line">2. 不能修改被装饰的函数的调用方式</span><br><span class="line">12345</span><br></pre>

<p><strong>装饰器组成方式</strong>：</p>
<pre class="highlight"><span class="line">函数+实参高阶函数+返回值高阶函数+嵌套函数+语法糖 &#x3D; 装饰器</span><br><span class="line">1</span><br></pre>

<ul>
<li><p><strong>有关高阶函数的理解</strong>：</p>
<ol>
<li>把一个函数名当作实参传给另外一个函数（”实参高阶函数“）</li>
<li>返回值中包含函数名（”返回值高阶函数“）</li>
</ol>
</li>
<li><p><strong>嵌套函数的理解</strong>：</p>
<p>嵌套函数指的是在函数内部定义一个函数，而不是调用。</p>
</li>
<li><p><strong>语法糖</strong>：</p>
<p>写法：@xx ，一般写在函数的上方</p>
</li>
</ul>
<p><strong>装饰器实例</strong></p>
<ul>
<li><p><strong>使用高阶函数模拟装饰器:</strong></p>
<pre class="highlight"><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">	start_time = time.time()</span><br><span class="line">	func()</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'函数执行时间为'</span>, time.time() - start_time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">'开始执行test'</span></span><br><span class="line">	time.sleep(<span class="number">3</span>)</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'test执行结束'</span></span><br><span class="line">timer(test)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">开始执行test</span></span><br><span class="line"><span class="string">test执行结束</span></span><br><span class="line"><span class="string">函数执行时间为 3.00332999229</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre>
</li>
<li><p><strong>计算运行时间装饰器:</strong></p>
<pre class="highlight"><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span>   <span class="comment">#timer(test1)  func=test1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func(*args,**kwargs)      <span class="comment">#run test1</span></span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        print(<span class="string">"running time is %s"</span>%(stop_time-start_time))</span><br><span class="line">    <span class="keyword">return</span> deco</span><br><span class="line"><span class="meta">@timer     # test1=timer(test1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"in the test1"</span>)</span><br><span class="line">test1()</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre>
</li>
<li><p><strong>装饰无参函数，示例代码如下：</strong></p>
<pre class="highlight"><span class="line"><span class="comment">#装饰器装饰的函数无参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span>      <span class="comment">#func其实指的就是test</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">()</span>:</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func()               <span class="comment">#这里其实是对test的调用</span></span><br><span class="line">        stop = time.time()</span><br><span class="line">        <span class="keyword">print</span> (stop-start)</span><br><span class="line">    <span class="keyword">return</span> deco</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer               #test函数使用装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"test is running"</span>)</span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">test <span class="keyword">is</span> running</span><br><span class="line"><span class="number">2.003510952</span></span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre>



</li>
</ul>
<ul>
<li><p><strong>装饰有参函数，示例代码如下：</strong></p>
<pre class="highlight"><span class="line"><span class="comment">#装饰器装饰的函数有参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(*args,**kwargs)</span>:</span>    <span class="comment">#添加可变参数*args和**kwargs</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func(*args,**kwargs)      <span class="comment">#这里也是一样，添加可变参数*args和**kwargs</span></span><br><span class="line">        stop = time.time()</span><br><span class="line">        <span class="keyword">print</span> (stop-start)</span><br><span class="line">    <span class="keyword">return</span> deco</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(value)</span>:</span>     <span class="comment">#test函数有个参数value,正因为装饰器timer装饰的函数test有参数value,因此在timer中的有了可变参数</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"test is running %s"</span> %value)</span><br><span class="line">test(<span class="string">"22"</span>)</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">test <span class="keyword">is</span> running <span class="number">22</span></span><br><span class="line"><span class="number">2.00424408913</span></span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre>



</li>
</ul>
<ul>
<li><p><strong>带参数的装饰器，示例代码如下：</strong></p>
<pre class="highlight"><span class="line"><span class="comment">#装饰器带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(parameter)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">out_wapper</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wapper</span><span class="params">(*wargs,**kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> parameter == <span class="string">"task1"</span>:</span><br><span class="line">                start = time.time()</span><br><span class="line">                func(*wargs,**kwargs)</span><br><span class="line">                stop = time.time()</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">"the task1 is run:"</span>,stop-start)</span><br><span class="line">            <span class="keyword">elif</span> parameter == <span class="string">"task2"</span>:</span><br><span class="line">                func(*wargs, **kwargs)</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">"the task2 is run:"</span>)</span><br><span class="line">        <span class="keyword">return</span> wapper</span><br><span class="line">    <span class="keyword">return</span> out_wapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(parameter = "task1")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task1</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"in the task1"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(parameter = "task2")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"in the task2"</span></span><br><span class="line"></span><br><span class="line">task1()</span><br><span class="line">task2()</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"><span class="keyword">in</span> the task1</span><br><span class="line">(<span class="string">'the task1 is run:'</span>, <span class="number">2.002906084060669</span>)</span><br><span class="line"><span class="keyword">in</span> the task2</span><br><span class="line">the task2 <span class="keyword">is</span> run:</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233</span></span><br></pre>



</li>
</ul>
<p><strong>装饰器使用场景</strong></p>
<blockquote>
<p>授权：装饰器能有助于检查某个人是否被授权去使用一个web应用的端点(endpoint)。它们被大量使用于Flask和Django web框架中<br>日志：在记录日志的地方添加装饰器<br>缓存：通过装饰器获取缓存中的值</p>
</blockquote>
<p><strong>闭包</strong></p>
<ul>
<li><p><strong>定义</strong>：</p>
<p>如果在一个函数的内部定义了另一个函数，外部的我们叫他外函数，内部的我们叫他内函数。那闭包就是，在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包</p>
</li>
</ul>
<hr>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p><strong>定义</strong>:</p>
<ol>
<li>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</li>
<li>迭代器是一个可以记住遍历的位置的对象。</li>
<li>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</li>
<li>迭代器有两个基本的方法：iter() 和 next()。</li>
<li>字符串，列表或元组对象都可用于创建迭代器：</li>
</ol>
<p><strong>可迭代对象</strong>:</p>
<p>在Python世界里，一切皆对象。对象根据定义的维度，又可以分为各种不同的类型，比如：文件对象，字符串对象，列表对象。。。等等。<br>一句话：“实现了<strong>inter</strong>方法的对象就叫做可迭代对象”，<strong>inter</strong>方法的作用就是返回一个迭代器对象。<br>直观理解就是能用for循环进行迭代的对象就是可迭代对象。比如：字符串，列表，元祖，字典，集合等等，都是可迭代对象。</p>
<p><strong>next()与iter()</strong>:</p>
<pre class="highlight"><span class="line">next()返回迭代器的下一个项目</span><br><span class="line">next语法:</span><br><span class="line">next(iterator[,dafault])</span><br><span class="line"></span><br><span class="line">iterator -- 可迭代对象</span><br><span class="line">default -- 可选，用于设置在没有下一个元素时返回该默认值，如果不设置，又没有下一个元素则会触发 StopIteration 异常。</span><br><span class="line"></span><br><span class="line">iter():</span><br><span class="line">iter()函数用来生成迭代器</span><br><span class="line">iter语法:</span><br><span class="line">12345678910</span><br></pre>

<p><strong>迭代器实现斐波那契</strong></p>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.a = <span class="number">0</span></span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        res = self.a</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        <span class="keyword">if</span> self.count &gt; self.n:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">print(list(Fib(<span class="number">5</span>)))</span><br><span class="line">print(list(Fib(<span class="number">10</span>)))</span><br></pre>

<ul>
<li><p><strong>生成器和迭代器之间的区别</strong></p>
<p>在使用生成器时，我们创建一个函数；在使用迭代器时，我们使用内置函数iter()和next()。 在生成器中，我们使用关键字‘yield’来每次生成/返回一个对象。 生成器中有多少‘yield’语句，你可以自定义。 每次‘yield’暂停循环时，生成器会保存本地变量的状态。而迭代器并不会使用局部变量，它只需要一个可迭代对象进行迭代。 使用类可以实现你自己的迭代器，但无法实现生成器。 生成器运行速度快，语法简洁，更简单。 迭代器更能节约内存。</p>
</li>
</ul>
<hr>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><ul>
<li><p><strong>生成器定义、简介</strong></p>
<p>在python中，生成器是根据某种算法边循环边计算的一种机制。主要就是用于操作大量数据的时候，<br>一般我们会将操作的数据读入内存中处理，可以计算机的内存是比较宝贵的资源，我认为的当要处理的数据超过内存四分之一的大小时就应该使用生成器。</p>
</li>
<li><p><strong>生成器的作用</strong></p>
</li>
</ul>
<ol>
<li><p>通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的。</p>
</li>
<li><p>而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>
</li>
<li><p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？</p>
</li>
<li><p>这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p>
</li>
</ol>
<ul>
<li><strong>特点</strong></li>
</ul>
<ol>
<li><p>和传统的容器相比，生成器更节省内存。</p>
</li>
<li><p>延迟计算，在我们需要结果时就调用一下生成器的next()方法即可。</p>
</li>
<li><p>可迭代，你可以像遍历list一样，遍历生成器</p>
</li>
</ol>
<ul>
<li><strong>生成器工作原理</strong></li>
</ul>
<ol>
<li><p>生成器是这样一个函数，它记住上一次返回时在函数体中的位置。</p>
</li>
<li><p>对生成器函数的第二次（或第 n 次）调用跳转至该函数中间，而上次调用的所有局部变量都保持不变。</p>
</li>
<li><p>生成器不仅“记住”了它数据状态；生成器还“记住”了它在流控制构造中的位置。</p>
</li>
<li><p>生成器是一个函数，而且函数的参数都会保留。</p>
</li>
<li><p>迭代到下一次的调用时，所使用的参数都是第一次所保留下的，即是说，在整个所有函数调用的参数都是第一次所调用时保留的，而不是新创建的</p>
<p><strong>在python中有两种方式创建生成器：生成器表达式 和 生成器函数。</strong></p>
</li>
</ol>
<ul>
<li><strong>生成器 和 普通函数的区别 ？</strong></li>
</ul>
<p>生成式函数和普通函数只有一个区别，普通函数使用return返回结果，而生成器函 数使用yield返回结果。<br>yield的特点在于，它并不是结束函数，而是在返回结果后将函数处于一种挂起状态，等待再次next函数的调用，然后从上次挂起的地方(yield)继续执行。</p>
<ul>
<li><strong>可迭代的数据类型</strong></li>
</ul>
<p>列表、元组、字典和集合都是可迭代的对象，可以从其中获得迭代器。<br>所有这些对象都可用iter()方法获取迭代器:</p>
<ul>
<li><p><strong><code>yield运行机制</code></strong>:</p>
<p>在Python中，yield就是这样的一个生成器。</p>
</li>
</ul>
<ol>
<li>当你问生成器要一个数时，生成器会执行，直至出现 yield 语句，生成器把yield 的参数给你，之后生成器就不会往下继续运行。</li>
<li>当你问他要下一个数时，他会从上次的状态开始运行，直至出现yield语句，把参数给你，之后停下。如此反复</li>
<li>在python中，当你定义一个函数，使用了yield关键字时，这个函数就是一个生成器</li>
<li>它的执行会和其他普通的函数有很多不同，函数返回的是一个对象，而不是你平常所用return语句那样，能得到结果值。如果想取得值，那得调用next()函数</li>
<li>每当调用一次迭代器的next函数，生成器函数运行到yield之处，返回yield后面的值且在这个地方暂停，所有的状态都会被保持住，直到下次next函数被调用，或者碰到异常循环退出。</li>
</ol>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max_num)</span>:</span></span><br><span class="line">    a,b = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt; max_num:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a,b=b,a+b</span><br><span class="line"></span><br><span class="line">g = fib(<span class="number">10</span>)               <span class="comment">#生成一个生成器：[1，2, 3, 5, 8, 13]</span></span><br><span class="line">print(g.__next__())       <span class="comment">#第一次调用返回：1</span></span><br><span class="line">print(list(g))            <span class="comment">#把剩下元素变成列表：[2, 3, 5, 8, 13]</span></span><br></pre>

<p>每次执行send()或next()只是返回了对应yield表达式的参数值，其实对应表达式并未执行，直到下次再执行send()或next()才会执行上次返回参数的yield表达式，所谓的执行yield表达式就是给其赋值，并返回下一个yield表达式的参数值！<br><a href="https://www.jianshu.com/p/36168970b0eb" target="_blank" rel="noopener">yield机制详细地址</a></p>
<hr>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><strong>简介</strong>：</p>
<p>面向对象编程(Object Oriented Programming-OOP) 是一种解决软件复用的设计和编程方法。 这种方法把软件系统中相近相似的操作逻辑和操作 应用数据、状态,以类的型式描述出来,以对象实例的形式在软件系统中复用,以达到提高软件开发效率的作用。<br>其实面向对象也很简单，却也很难，熟能生巧。你需要了解类和对象，要学会定义类，创建对象。</p>
<p><strong>特点</strong>：</p>
<ol>
<li>类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li>
<li>方法：类中定义的函数。</li>
<li>类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li>
<li>数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。</li>
<li>方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li>
<li>局部变量：定义在方法中的变量，只作用于当前实例的类。</li>
<li>实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li>
<li>继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。</li>
<li>实例化：创建一个类的实例，类的具体对象。</li>
<li>对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li>
</ol>
<pre class="highlight"><span class="line">下面详细介绍:</span><br></pre>

<h3 id="1-方法"><a href="#1-方法" class="headerlink" title="1. 方法"></a>1. 方法</h3><p><strong>1.1 静态方法</strong>：</p>
<ul>
<li>定义：使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法；</li>
<li>调用：实例对象和类对象都可以调用。</li>
<li>特性: 静态方法只是名义上归类管理，实际上在静态方法里访问不了类或则实例中的任何属性</li>
<li>作用：静态方法可以更好的组织代码，防止代码变大后变得比较混乱。</li>
<li>静态方法使用场景：<ol>
<li>我们要写一个只在类中运行而不在实例中运行的方法.</li>
<li>经常有一些跟类有关系的功能但在运行时又不需要实例和类参与的情况下需要用到静态方法.</li>
<li>比如更改环境变量或者修改其他类的属性等能用到静态方法.</li>
<li>这种情况可以直接用函数解决, 但这样同样会扩散类内部的代码，造成维护困难.</li>
</ol>
</li>
</ul>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"I am a static method"</span>)</span><br><span class="line">d = Dog(<span class="string">"ChenRonghua"</span>)</span><br><span class="line">d.eat()                     <span class="comment">#方法1：使用实例调用</span></span><br><span class="line"></span><br><span class="line">Dog.eat()                   <span class="comment">#方法2：使用类直接调用</span></span><br></pre>



<p><strong>1.2 类方法</strong>：</p>
<ul>
<li>定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）；</li>
<li>调用：实例对象和类对象都可以调用。</li>
<li>作用：无需实例化直接被类调用</li>
<li>类方法使用场景： 当我们还未创建实例，但是需要调用类中的方法</li>
</ul>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    name = <span class="string">'类变量'</span> <span class="comment">#在这里如果不定义类变量仅定义实例变量依然报错</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = <span class="string">'实例变量'</span></span><br><span class="line">        self.name = name</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self,food)</span>:</span></span><br><span class="line">        print(<span class="string">"%s is eating %s"</span>%(self.name,food))</span><br><span class="line">Dog.eat(<span class="string">'baozi'</span>)                   <span class="comment">#方法1：使用类直接调用</span></span><br><span class="line">d = Dog(<span class="string">"ChenRonghua"</span>)          </span><br><span class="line">d.eat(<span class="string">"包子"</span>)                      <span class="comment">#方法2：使用实例d调用</span></span><br></pre>



<p><strong>1.3 实例方法</strong>：</p>
<ul>
<li>定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法（也可以传类的属性和方法）；</li>
<li>调用：只能由实例对象调用。</li>
</ul>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">" %s is eating"</span> % self.name)</span><br><span class="line">d = Dog(<span class="string">"ChenRonghua"</span>)</span><br><span class="line">d.eat()</span><br><span class="line"><span class="comment"># 调用会出以下错误， 说NoneType is not callable, 因为eat此时已经变成一个静态属性了， </span></span><br><span class="line"><span class="comment"># 不是方法了， 想调用已经不需要加()号了，直接d.eat就可以了</span></span><br></pre>



<h5 id="1-4-魔法方法"><a href="#1-4-魔法方法" class="headerlink" title="1.4 魔法方法:"></a>1.4 魔法方法:</h5><p>我们在调用python类中的某个方法时，通常会看到某些特殊的方法，它们总被双下划线所包围，像这种格式：”<strong>方法名</strong>“，这些方法很强大，充满魔力，可以让你实现很多功能。，如果你的对象实现（重载）了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，你可以定义自己想要的行为，而这一切都是自动发生的。因此了解这类方法的作用及用户很有必要，以下对基本魔法方法做出总结，请看：<a href="https://www.jianshu.com/p/2ec468e58b89" target="_blank" rel="noopener">魔法方法表格</a></p>
<p>type生成类调用顺序:</p>
<p><strong>new</strong> : 先于<strong>init</strong>方法，每生成一个实例执行一次，<strong>new</strong> 类方法创建实例对象<br><strong>init</strong> : <strong>init</strong>方法每生成一个实例就会执行一次，初始化实例对象<br><strong>call</strong> : 后与<strong>init</strong>方法，C()() 使用类再加一个括号调用， C为类名称<br><strong>del</strong> : 析构方法，删除无用的内存对象（当程序结束会自动自行析构方法）</p>
<p><strong>类实例化时魔法方法调用顺序</strong></p>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'__new__'</span>)</span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)   <span class="comment"># 必须返回父类的__new__方法，否则不不执行__init__方法，无法创建实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        print(<span class="string">'__init__'</span>)</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>                <span class="comment"># 作用：打印实例时显示指定字符串，而不是内存地址</span></span><br><span class="line">        print(<span class="string">'__str__'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span>        <span class="comment"># 当执行C()(*args) 或者 s1(*args) 就会执行__call__</span></span><br><span class="line">        print(<span class="string">'__call__'</span>,*args)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span>                <span class="comment"># 作用：清除无用的实例对内存的暂用</span></span><br><span class="line">        print(<span class="string">'__del__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1、实例化时机会执行__new__、__init__</span></span><br><span class="line">s1 = Student(<span class="string">'tom'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、执行 实例()  就会执行__call__ 方法，并将参数传递给__call__函数</span></span><br><span class="line">s1(<span class="string">'call01'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、当打印实例时就会执行 __str__ 方法下返回的字符串（默认返回的实例地址）</span></span><br><span class="line">print(s1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4、析构方法：当删除实例时就会调用 __del__ 方法</span></span><br><span class="line"><span class="keyword">del</span> s1</span><br><span class="line"><span class="comment"># 析构方法作用：在程序结束后会自动执行析构方法删除所有实例</span></span><br><span class="line"><span class="comment"># 但是在程序运行时有很多实例是无用的，但是python内存回收机制却不会自动删除他们，这样就浪费内存</span></span><br><span class="line"><span class="comment"># 我们可以执行 del s1 ，那么在程序运行时，python内存回收机制会检测到这些实例时无用的，才会删除</span></span><br><span class="line"><span class="comment"># 其实我们执行del s1，并没有回收内存，只不过是摘除门牌号，python内存回收机制发现没有门牌号后会自动回收内存</span></span><br></pre>



<p><strong><strong>new</strong> &amp; <strong>init</strong>详解</strong>:</p>
<ol>
<li><strong>new</strong> 至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动 提供</li>
<li><strong>new</strong> 必须要有返回值，返回实例化出来的实例，这点在自己实现 <strong>new</strong> 时要特别注 意，可以return父类 <strong>new</strong> 出来的实例，或者直接是object的 <strong>new</strong> 出来的实例</li>
<li><strong>init</strong> 有一个参数self，就是这个 <strong>new</strong> 返回的实例， <strong>init</strong> 在 <strong>\new</strong> 的基础上 可以完成一些其它初始化的动作， <strong>init</strong> 不需要返回值 我们可以将类比作制造商， <strong>new</strong> 方法就是前期的原材料购买环节， <strong>init</strong> 方法就是在 有原材料的基础上，加工，初始化商品环节。</li>
</ol>
<h4 id="1-5-单例模式："><a href="#1-5-单例模式：" class="headerlink" title="1.5 单例模式："></a>1.5 单例模式：</h4><p><strong>new</strong>方法书写：</p>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">	print(self)</span><br><span class="line">	print(<span class="string">"这是 init 方法"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></span><br><span class="line">	print(id(cls))</span><br><span class="line">	print(<span class="string">"这是 __new__ 方法"</span>)</span><br><span class="line">	ret = object.__new__(cls)</span><br><span class="line">	print(res)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(id(A))</span><br><span class="line">--&gt;: 12345678987654321</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">--&gt;: 12345678987654321</span><br><span class="line">这是 new 方法</span><br><span class="line">--&gt;: &lt;__main__.A object at 0x105b96ac8&gt;</span><br><span class="line">--&gt;: &lt;__main__.A object at 0x105b96ac8&gt;</span><br></pre>



<h4 id="线程安全的单例"><a href="#线程安全的单例" class="headerlink" title="线程安全的单例:"></a>线程安全的单例:</h4><pre class="highlight"><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">线程安全的单利模式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">紧跟with后面的语句被求值后，返回对象的 __enter__() 方法被调用，这个方法的返回值将被赋值给as后面的变量。</span></span><br><span class="line"><span class="string">当with后面的代码块全部被执行完之后，将调用前面返回对象的 __exit__()方法</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">synchronized</span><span class="params">(func)</span>:</span></span><br><span class="line">    func.__lock__ = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lock_func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> func.__lock__:</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lock_func</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="comment"># 关键在于这，每一次实例化的时候，我们都只会返回这同一个instance对象</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls.instance:</span><br><span class="line">            cls.instance = super(Singleton, cls).__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br></pre>

<p>先看类，可以看出这里我们先定义了一个类属性instance，接着我们重写了父类的<strong>new</strong>方法，这个方法就是我们在实例化一个对象时最先调用的一个方法。和其他静态语言不一样，其他静态语言，直接调用了构造方法，一般情况下初始化的程序也写在构造方法之中。而python实例化一个对象和初始化是分开的。<strong>new</strong>是类方法，<strong>init</strong>是实例方法，也就是说，<strong>init</strong>是在对象已经创建完成之后，才执行。</p>
<p>在python3中，调用父类的方法是用super()来调用。所以我们这里的思路就是，还是用父类的方法去创造，但是我们要加一个判断，就是说，当这个对象也就是类属性并不为空的时候，我们就不在实例化，而是返回一个已经实例化的类属性。</p>
<h4 id="线程不安全的单例"><a href="#线程不安全的单例" class="headerlink" title="线程不安全的单例"></a>线程不安全的单例</h4><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">	__instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, age)</span>:</span></span><br><span class="line">		<span class="comment"># 如果类属性__instance的值为None，那么就创建一个对象</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> cls.__instance:</span><br><span class="line">			cls.__instance = object.__new__(cls)</span><br><span class="line">		<span class="comment"># 如果已经有实例存在，直接返回</span></span><br><span class="line">		<span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line">a = Singleton(<span class="string">"Zhangsan"</span>, <span class="number">18</span>)</span><br><span class="line">b = Singleton(<span class="string">"lisi"</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">print(id(a))</span><br><span class="line">print(id(b))</span><br><span class="line"></span><br><span class="line">a.age = <span class="number">30</span>   <span class="comment"># 给a指向的对象添加一个属性</span></span><br><span class="line">print(b.age)  <span class="comment"># 获取b指向的对象的age属性</span></span><br></pre>

<p><strong><strong>del</strong></strong></p>
<p>Python 通过调用 <strong>init</strong>() 方法构造当前类的实例化对象，而 <strong>del</strong>() 方法，功能正好和 <strong>init</strong>() 相反，其用来销毁实例化对象。</p>
<p>事实上在编写程序时，如果之前创建的类实例化对象后续不再使用，最好在适当位置手动将其销毁，释放其占用的内存空间（整个过程称为垃圾回收（简称GC））。<br>大多数情况下，Python 开发者不需要手动进行垃圾回收，因为 Python 有自动的垃圾回收机制，能自动将不需要使用的实例对象进行销毁。</p>
<p>无论是手动销毁，还是 Python 自动帮我们销毁，都会调用 <strong>del</strong>() 方法。</p>
<h3 id="2-特性"><a href="#2-特性" class="headerlink" title="2. 特性"></a>2. 特性</h3><h4 id="面向对象三大特性-封装，继承，多态"><a href="#面向对象三大特性-封装，继承，多态" class="headerlink" title="面向对象三大特性: 封装，继承，多态"></a><code>面向对象三大特性: 封装，继承，多态</code></h4><h4 id="2-1-封装"><a href="#2-1-封装" class="headerlink" title="2.1 封装:"></a>2.1 封装:</h4><ol>
<li>在类中对数据的赋值、内部调用对外部用户是透明的</li>
<li>这使类变成了一个胶囊或容器，里面包含着类的数据和方法</li>
<li>作用：<ul>
<li>防止数据被随意修改<ul>
<li>使外部程序不需要关注对象内部的构造，只需要通过对外提供的接口进行直接访问</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>继承的种类</strong></p>
<ol>
<li>单继承：一个类继承单个基类</li>
<li>多继承:一个类继承多个基类</li>
<li>多级继承：一个类继承自单个基类，后者继承自另一个基类</li>
<li>分层继承：多个类继承自单个基类</li>
<li>混合继承：两种或多种类型继承的混合</li>
</ol>
<p><strong>封装的好处：</strong></p>
<ol>
<li>将变化隔离</li>
<li>便于使用</li>
<li>提高复用性</li>
<li>提高安全性</li>
</ol>
<pre class="highlight"><span class="line">封装：将数据进行封装到对象中，以供其他函数进行调用</span><br></pre>



<h4 id="2-2-Inheritance-继承（代码重用"><a href="#2-2-Inheritance-继承（代码重用" class="headerlink" title="2.2 Inheritance 继承（代码重用:"></a>2.2 Inheritance 继承（代码重用:</h4><ol>
<li>一个类可以派生出子类，在这个父类里定义的属性、方法自动被子类继承</li>
<li>比如CS中的警察和恐怖分子，可以将两个角色的相同点写到一个父类中，然后同时去继承它</li>
<li>使用经典类： Person.<strong>init</strong>(self, name, age) 并重写写父类Person的构造方法，实现，先覆盖，再继承，再重构</li>
</ol>
<p><strong>继承的优点：</strong></p>
<ol>
<li>节省代码,减少代码的重复性</li>
<li>增强耦合性(也就是增强代码可读性)</li>
<li>使代码更加规范化</li>
<li>子类可以调用父类的所有属性</li>
</ol>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'D'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(D)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># def talk(self):</span></span><br><span class="line">    <span class="comment">#     print('B')</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(D)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'C'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(B,C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># def talk(self):</span></span><br><span class="line">    <span class="comment">#     print('A')</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.talk()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 黑人，白人都继承父类Person就可以都有父类的属性和方法了</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span>  <span class="comment">#执行Person.__init__(self,name,age)时就会将传入的参数执行一遍</span></span><br><span class="line">        self.name = name          <span class="comment">#所以在BlackPerson中不仅有name,age而且还有sex</span></span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = <span class="string">"normal"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"person is talking...."</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WhitePerson</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlackPerson</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,strength)</span>:</span>     <span class="comment">#先覆盖，再继承，再重构</span></span><br><span class="line">        <span class="comment">#先覆盖父类的__init__方法，再继承父类__init__，再加自己的参数</span></span><br><span class="line">        Person.__init__(self,name,age)        <span class="comment">#先继承父类Person，这里self就是BlackPerson本身</span></span><br><span class="line">        <span class="comment">#先将name,age传给子类BlackPerson,然后调用Person.__init__构造方法将参数出入父类（）</span></span><br><span class="line">        self.strength = strength              <span class="comment">#然后再重构自己的方法,即写自己的参数</span></span><br><span class="line">        print(self.name,self.age,self.sex)</span><br><span class="line">        print(self.strength)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"black balabla"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"is walking...."</span>)</span><br><span class="line"></span><br><span class="line">b = BlackPerson(<span class="string">"wei er smith"</span>,<span class="number">22</span>,<span class="string">"Strong"</span>)</span><br><span class="line">b.talk()</span><br><span class="line">b.walk()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line"><span class="comment"># wei er smith 22 normal</span></span><br><span class="line"><span class="comment"># Strong</span></span><br><span class="line"><span class="comment"># black balabla</span></span><br><span class="line"><span class="comment"># is walking....</span></span><br><span class="line"><span class="comment"># person is talking....</span></span><br></pre>

<p><strong>新式类经典类区别：</strong></p>
<p>Python 2.x中默认都是经典类，只有显式继承了object才是新式类<br>Python 3.x中默认都是新式类，不必显式的继承object<br>当类是经典类时，多继承情况下，会按照深度优先方式查找<br>当类是新式类时，多继承情况下，会按照广度优先方式查找</p>
<h4 id="2-3-Polymorphism-多态（接口重用）"><a href="#2-3-Polymorphism-多态（接口重用）" class="headerlink" title="2.3 Polymorphism 多态（接口重用）"></a>2.3 Polymorphism 多态（接口重用）</h4><ol>
<li>多态是面向对象的重要特性,简单点说:“一个接口，多种实现”</li>
<li>指一个基类中派生出了不同的子类，且每个子类在继承同样的方法名的同时又对父类的方法做了不同的实现</li>
<li>这就是同一种事物表现出的多种形态</li>
<li>比如黄种人继承了人talk这个功能，但是他说的是中文，而美国人的talk是英文，但是他们是同样的talk</li>
</ol>
<pre class="highlight"><span class="line">作用：简单的讲就是允许父类调用子类的方法</span><br></pre>

<p>很多人喜欢将多态与多态性二者混为一谈，然后百思不得其解，其实只要分开看，就会很明朗。</p>
<ol>
<li>多态指的是一类事物有多种形态，（一个抽象类有多个子类，因而多态的概念依赖于继承）</li>
<li>多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。</li>
</ol>
<pre class="highlight"><span class="line"><span class="comment"># 多态举例</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span>    <span class="comment"># Constructor of the class</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>              <span class="comment"># Abstract method, defined by convention only</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">"Subclass must implement abstract method"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Meow!'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Woof! Woof!'</span></span><br><span class="line"></span><br><span class="line">animals = [Cat(<span class="string">'Missy'</span>),</span><br><span class="line">           Dog(<span class="string">'Lassie'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> animals:</span><br><span class="line">    print(animal.name + <span class="string">': '</span> + animal.talk())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line"><span class="comment"># Missy: Meow!</span></span><br><span class="line"><span class="comment"># Lassie: Woof! Woof!</span></span><br></pre>

<p><strong>Python中多态的特点</strong></p>
<ol>
<li>只关心对象的实例方法是否同名，不关心对象所属的类型；</li>
<li>对象所属的类之间，继承关系可有可无；</li>
<li>多态的好处可以增加代码的外部调用灵活度，让代码更加通用，兼容性比较强；</li>
<li>多态是调用方法的技巧，不会影响到类的内部设计。</li>
</ol>
<h3 id="3-属性"><a href="#3-属性" class="headerlink" title="3. 属性"></a>3. 属性</h3><ol>
<li><strong>类的公有属性</strong><br>public_attrs：能在类的外部被使用或直接访问。在类内部的方法中使用时 public_attrs_attrs，在类的外部class_name.public_attrs。</li>
<li><strong>类的私有属性</strong><br><strong>private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.</strong>private_attrs。</li>
<li><strong>类的(公有)方法</strong><br>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。<br>self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定是用 self。</li>
<li><strong>类的私有方法</strong><br><strong>private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.</strong>private_methods。</li>
</ol>
<h3 id="4-反射-hasattr、getattr、setattr-和-delattr"><a href="#4-反射-hasattr、getattr、setattr-和-delattr" class="headerlink" title="4. 反射: hasattr、getattr、setattr 和 delattr"></a>4. 反射: hasattr、getattr、setattr 和 delattr</h3><p>在做程序开发中，我们常常会遇到这样的需求：需要执行对象里的某个方法，或需要调用对象中的某个变量，但是由于种种原因我们无法确定这个方法或变量是否存在，这是我们需要用一个特殊的方法或机制要访问和操作这个未知的方法或变量，这中机制就称之为反射。</p>
<p>反射就是通过字符串的形式，导入模块；通过字符串的形式，去模块寻找指定函数，并执行。利用字符串的形式去对象（模块）中操作（查找/获取/删除/添加）成员，一种基于字符串的事件驱动！<br><a href="https://www.cnblogs.com/kongk/p/8645202.html" target="_blank" rel="noopener">–反射详解–</a></p>
<h4 id="四大属性"><a href="#四大属性" class="headerlink" title="四大属性:"></a><code>四大属性:</code></h4><ul>
<li><p><strong>hasattr(ogj,name_str) 判断一个对象里是否有对应的字符串方法</strong></p>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self,food)</span>:</span></span><br><span class="line">        print(<span class="string">"eat method!!!"</span>)</span><br><span class="line">d = Dog()</span><br><span class="line"></span><br><span class="line"><span class="comment">#hasattr判断对象d是否有eat方法，有返回True，没有返回False</span></span><br><span class="line">print(hasattr(d,<span class="string">'eat'</span>))     <span class="comment">#True</span></span><br><span class="line">print(hasattr(d,<span class="string">'cat'</span>))     <span class="comment">#False</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre>
</li>
<li><p><strong>getattr(obj,name_str) 根据字符串去获取obj对象里的对应的方法的内存地址</strong></p>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"eat method!!!"</span>)</span><br><span class="line">d = Dog()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hasattr(d,<span class="string">'eat'</span>):          <span class="comment"># hasattr判断实例是否有eat方法</span></span><br><span class="line">    func = getattr(d, <span class="string">'eat'</span>)  <span class="comment"># getattr获取实例d的eat方法内存地址</span></span><br><span class="line">    func()                    <span class="comment"># 执行实例d的eat方法</span></span><br><span class="line"><span class="comment">#运行结果：  eat method!!!</span></span><br><span class="line"><span class="number">123456789</span></span><br></pre>
</li>
<li><p><strong>使用stattr给类实例对象动态添加一个新的方法</strong></p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abc</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"%s正在交谈"</span>%self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">"汇森"</span>)</span><br><span class="line">setattr(p,<span class="string">"talk"</span>,abc)   <span class="comment"># 将abc函数添加到对象中p中，并命名为talk</span></span><br><span class="line">p.talk(p)               <span class="comment"># 调用talk方法，因为这是额外添加的方法，需手动传入对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果 汇森正在交谈</span></span><br><span class="line"></span><br><span class="line">setattr(p,<span class="string">"age"</span>,<span class="number">30</span>)     <span class="comment"># 添加一个变量age,复制为30</span></span><br><span class="line">print(p.age)            <span class="comment"># 打印结果:30</span></span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre>
</li>
<li><p><strong>delattr删除对象中的变量。注意：不能用于删除方法</strong></p>
<pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s正在交谈"</span>%self.name)</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">"汇森"</span>)</span><br><span class="line"></span><br><span class="line">delattr(p,<span class="string">"name"</span>)       <span class="comment"># 删除name变量</span></span><br><span class="line">print(p.name)           <span class="comment"># 此时将报错</span></span><br><span class="line"><span class="number">12345678910</span></span><br></pre>

</li>
</ul>
<h3 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h3><h4 id="1-深拷贝浅拷贝"><a href="#1-深拷贝浅拷贝" class="headerlink" title="1. 深拷贝浅拷贝"></a>1. 深拷贝浅拷贝</h4><p><strong>1.1 预备知识一——python的变量及其存储</strong></p>
<ol>
<li>python的一切变量都是对象，变量的存储，采用了引用语义的方式，存储的只是一个变量的值所在的内存地址，而不是这个变量的只本身</li>
<li>不管多么复杂的数据结构，浅拷贝都只会copy一层。<br>理解：两个人公用一张桌子，只要桌子不变，桌子上的菜发生了变化两个人是共同感受的。</li>
</ol>
<p><strong>1.2 浅copy与deepcopy</strong></p>
<ol>
<li>浅copy： 不管多么复杂的数据结构，浅拷贝都只会copy一层</li>
<li>deepcopy : 深拷贝会完全复制原变量相关的所有数据，在内存中生成一套完全一样的内容，我们对这两个变量中任意一个修改都不会影响其他变量</li>
</ol>
<pre class="highlight"><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">sourceList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">copyList = copy.copy(sourceList)</span><br><span class="line">deepcopyList = copy.deepcopy(sourceList)</span><br><span class="line"></span><br><span class="line">sourceList[<span class="number">3</span>][<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line"></span><br><span class="line">print(sourceList)           <span class="comment"># [1, 2, 3, [100, 5, 6]]</span></span><br><span class="line">print(copyList)             <span class="comment"># [1, 2, 3, [100, 5, 6]]</span></span><br><span class="line">print(deepcopyList)         <span class="comment"># [1, 2, 3, [4, 5, 6]]</span></span><br></pre>



<h4 id="2-python垃圾回收机制"><a href="#2-python垃圾回收机制" class="headerlink" title="2. python垃圾回收机制"></a>2. python垃圾回收机制</h4><p><strong>2.1 引用计数:</strong></p>
<ol>
<li>当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁时，对象的引用计数减1.</li>
<li>当对象的引用计数减少为0时，就意味着对象已经再没有被使用了，可以将其内存释放掉。</li>
</ol>
<p><strong>2.2 标记－清除:</strong></p>
<ol>
<li>它分为两个阶段：第一阶段是标记阶段，GC会把所有的活动对象打上标记，第二阶段是把那些没有标记的对象非活动对象进行回收。</li>
<li>对象之间通过引用（指针）连在一起，构成一个有向图</li>
<li>从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象，根对象就是全局变量、调用栈、寄存器。</li>
</ol>
<pre class="highlight"><span class="line">注：像是PyIntObject、PyStringObject这些不可变对象是不可能产生循环引用的，因为它们内部不可能持有其它对象的引用。</span><br></pre>

<p><img src="https://img-blog.csdnimg.cn/2020012811083048.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/2020012811083048.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>
<ol>
<li>在上图中，可以从程序变量直接访问块1，并且可以间接访问块2和3,程序无法访问块4和5</li>
<li>第一步将标记块1，并记住块2和3以供稍后处理。</li>
<li>第二步将标记块2，第三步将标记块3，但不记得块2，因为它已被标记。</li>
<li>扫描阶段将忽略块1，2和3，因为它们已被标记，但会回收块4和5。</li>
</ol>
<p><strong>2.3 分代回收：</strong></p>
<ol>
<li>分代回收是建立在标记清除技术基础之上的，是一种以空间换时间的操作方式。</li>
<li>Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代）</li>
<li>他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。</li>
<li>新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发</li>
<li>把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推</li>
<li>老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。</li>
</ol>
<h4 id="3-上下文管理"><a href="#3-上下文管理" class="headerlink" title="3 上下文管理"></a>3 上下文管理</h4><p><strong>3.1 什么是with语句</strong></p>
<ol>
<li>with是一种上下文管理协议，目的在于从流程图中把 try,except 和finally 关键字和资源分配释放相关代码统统去掉，简化try….except….finlally的处理流程。</li>
<li>所以使用with处理的对象必须有enter()和exit()这两个方法<ol>
<li>with通过enter方法初始化（enter方法在语句体执行之前进入运行）<ol start="2">
<li>然后在exit中做善后以及处理异常（exit()方法在语句体执行完毕退出后运行）</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>3.2 with语句使用场景</strong></p>
<ol>
<li>with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源</li>
<li>比如文件使用后自动关闭、线程中锁的自动获取和释放等。</li>
</ol>
<p><strong>3.3 with处理文件操作的实例</strong></p>
<pre class="highlight"><span class="line"><span class="keyword">with</span> open(<span class="string">'/etc/passwd'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">		print(line)</span><br><span class="line"><span class="comment"># 这段代码的作用：打开一个文件，如果一切正常，把文件对象赋值给f，然后用迭代器遍历文件中每一行，当完成时，关闭文件；</span></span><br><span class="line"><span class="comment"># 而无论在这段代码的任何地方，如果发生异常，此时文件仍会被关闭。</span></span><br></pre>



<h4 id="4-高阶函数"><a href="#4-高阶函数" class="headerlink" title="4 高阶函数"></a>4 高阶函数</h4><p><strong>4.1 lambda基本使用</strong></p>
<ol>
<li>lambda只是一个表达式，函数体比def简单很多。</li>
<li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li>
<li>lambda表达式是起到一个函数速写的作用。允许在代码内嵌入一个函数的定义。</li>
<li>格式：lambda的一般形式是关键字lambda后面跟一个或多个参数，紧跟一个冒号，之后是一个表达式。</li>
</ol>
<pre class="highlight"><span class="line">f = <span class="keyword">lambda</span> x,y,z:x+y+z</span><br><span class="line">print(f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))                    <span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line">my_lambda = <span class="keyword">lambda</span> arg : arg + <span class="number">1</span></span><br><span class="line">print(my_lambda(<span class="number">10</span>))                <span class="comment"># 11</span></span><br><span class="line"><span class="number">12345</span></span><br></pre>

<p><strong>4.2 三元运算:</strong></p>
<ol>
<li>三元运算格式： result=值1 if x&lt;y else 值2 if条件成立result=1,否则result=2</li>
<li>作用：三元运算，又称三目运算，主要作用是减少代码量，是对简单的条件语句的缩写</li>
</ol>
<pre class="highlight"><span class="line">name = <span class="string">'Tom'</span> <span class="keyword">if</span> <span class="number">1</span> == <span class="number">1</span> <span class="keyword">else</span> <span class="string">'fly'</span></span><br><span class="line">print(name)</span><br><span class="line"><span class="comment"># 运行结果： Tom</span></span><br><span class="line"></span><br><span class="line">f = <span class="keyword">lambda</span> x:x <span class="keyword">if</span> x % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">else</span> x + <span class="number">100</span></span><br><span class="line">print(f(<span class="number">10</span>))                    <span class="comment"># 110</span></span><br></pre>

<h5 id="map-函数用法："><a href="#map-函数用法：" class="headerlink" title="map()函数用法："></a>map()函数用法：</h5><p><strong>map(function, iterable, …)</strong><br><strong>功能：</strong></p>
<ul>
<li>将第一个参数 function 依次作用在参数可迭代对象中的每一个元素上，返回包含每次 function 函数返回值的新迭代器</li>
<li>map() 会根据提供的函数对指定序列做映射。(映射及对应)</li>
<li>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</li>
</ul>
<p><strong>参数：</strong><br>function – 函数，有两个参数<br>iterable – 一个或多个可迭代对象（如：序列）</p>
<p><strong>返回值：</strong><br>Python 3.x 返回迭代器</p>
<pre class="highlight"><span class="line"><span class="comment"># demo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line">ret = map(func, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">print(list(ret))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre>

<h5 id="reduce-函数语法"><a href="#reduce-函数语法" class="headerlink" title="reduce()函数语法"></a>reduce()函数语法</h5><p><strong>reduce(function, iterable[, initializer])</strong><br><strong>功能：</strong></p>
<ul>
<li>函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。<br>其效果类似：reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</li>
<li>reduce() 函数会对参数序列中元素进行累积。</li>
<li>函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</li>
</ul>
<p><strong>参数：</strong><br>function – 函数，有两个参数<br>iterable – 可迭代对象<br>initializer – 可选，初始参数</p>
<p><strong>返回值：</strong><br>返回函数计算结果。</p>
<pre class="highlight"><span class="line"><span class="comment"># demo:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"> </span><br><span class="line">r = reduce(add, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line">print(r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 运行结果：</span></span><br><span class="line"><span class="number">25</span></span><br></pre>

<h5 id="filter-函数："><a href="#filter-函数：" class="headerlink" title="filter()函数："></a>filter()函数：</h5><p><strong>filter(function, iterable)</strong><br><strong>功能</strong></p>
<ul>
<li>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新迭代器对象中</li>
<li>filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</li>
</ul>
<p><strong>参数：</strong><br>function – 判断函数<br>iterable – 可迭代对象（如：序列）</p>
<p><strong>返回值：</strong><br>返回一个迭代器对象</p>
<pre class="highlight"><span class="line"><span class="comment"># demo：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">tmplist = filter(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">newlist = list(tmplist)</span><br><span class="line">print(newlist)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre>

<h5 id="sorted-函数"><a href="#sorted-函数" class="headerlink" title="sorted()函数"></a>sorted()函数</h5><p><strong>sorted(iterable, key=abs, reverse=False)</strong><br><strong>功能:</strong></p>
<ul>
<li>对所有可迭代的对象进行排序操作</li>
</ul>
<p><strong>参数:</strong><br>iterable – 可迭代对象。<br>key – key指定的函数将作用于可迭代对象上的每一个元素，并根据key函数返回的结果进行排序<br>reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）</p>
<p><strong>返回值:</strong><br>返回重新排序的列表</p>
<pre class="highlight"><span class="line"><span class="comment"># demo:</span></span><br><span class="line"></span><br><span class="line">print(sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>]))</span><br><span class="line">运行结果：[<span class="number">-21</span>, <span class="number">-12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">36</span>]</span><br><span class="line">print(sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>], key=abs))</span><br><span class="line"></span><br><span class="line"><span class="comment">#abs 匿名函数</span></span><br><span class="line">运行结果：[<span class="number">5</span>, <span class="number">9</span>, <span class="number">-12</span>, <span class="number">-21</span>, <span class="number">36</span>]</span><br></pre>

<h5 id="返回函数："><a href="#返回函数：" class="headerlink" title="返回函数："></a>返回函数：</h5><p><strong>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</strong></p>
<pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></span><br><span class="line">        ax = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        <span class="keyword">return</span> ax</span><br><span class="line">    <span class="keyword">return</span> sum        <span class="comment">#将定义的函数sum()作为结果值返回</span></span><br><span class="line"> </span><br><span class="line">f = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">f()</span><br></pre>





<p><strong>4.3 filter()函数可以对序列做过滤处理</strong></p>
<p>利用 filter、lambda表达式 获取l1中元素小于33的所有元素 l1 = [11, 22, 33, 44, 55]</p>
<pre class="highlight"><span class="line">l1= [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>]</span><br><span class="line">a = filter(<span class="keyword">lambda</span> x: x&lt;<span class="number">33</span>, l1)</span><br><span class="line">print(list(a))</span><br></pre>

<p><strong>4.4 Map是对序列根据设定条件进行操作后返回他设置的是操作方法</strong><br><code>利用map，lambda表达式将所有偶数元素加100</code></p>
<pre class="highlight"><span class="line">l1= [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>]</span><br><span class="line">ret = map(<span class="keyword">lambda</span> x:x <span class="keyword">if</span> x % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">else</span> x + <span class="number">100</span>,l1)</span><br><span class="line">print(list(ret))</span><br><span class="line"><span class="comment"># 运行结果： [11, 122, 33, 144, 55]</span></span><br></pre>

<p><strong>4.5 reduce函数</strong></p>
<p>使用reduce进行求和运算</p>
<ol>
<li>reduce()函数即为化简函数，它的执行过程为：每一次迭代，都将上一次的迭代结果与下一个元素一同传入二元func函数中去执行。</li>
<li>在reduce()函数中，init是可选的，如果指定，则作为第一次迭代的第一个元素使用，如果没有指定，就取seq中的第一个元素。</li>
</ol>
<pre class="highlight"><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span>	</span><br><span class="line"> <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">print(reduce(f, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]))  <span class="comment"># 25</span></span><br><span class="line"><span class="comment"># 1、先计算头两个元素：f(1, 3)，结果为4；</span></span><br><span class="line"><span class="comment"># 2、再把结果和第3个元素计算：f(4, 5)，结果为9；</span></span><br><span class="line"><span class="comment"># 3、再把结果和第4个元素计算：f(9, 7)，结果为16；</span></span><br><span class="line"><span class="comment"># 4、再把结果和第5个元素计算：f(16, 9)，结果为25；</span></span><br><span class="line"><span class="comment"># 5、由于没有更多的元素了，计算结束，返回结果25。</span></span><br><span class="line"></span><br><span class="line">print( reduce(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])  )  <span class="comment"># 25</span></span><br></pre>

<p><strong>4.6 sorted函数</strong></p>
<p>sorted对字典排序</p>
<pre class="highlight"><span class="line">d = &#123;<span class="string">'k1'</span>:<span class="number">1</span>, <span class="string">'k3'</span>: <span class="number">3</span>, <span class="string">'k2'</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment"># d.items() = [('k1', 1), ('k3', 3), ('k2', 2)]</span></span><br><span class="line">a = sorted(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">print(a)            <span class="comment"># [('k1', 1), ('k2', 2), ('k3', 3)]</span></span><br></pre>



<hr>
<h3 id="subprocess模块"><a href="#subprocess模块" class="headerlink" title="subprocess模块"></a>subprocess模块</h3><p>subprocess是Python 2.4中新增的一个模块，它允许你生成新的进程，连接到它们的 input/output/error 管道，并获取它们的返回（状态）码。这个模块的目的在于替换几个旧的模块和方法，如：</p>
<ul>
<li>os.system</li>
<li>os.spawn*</li>
</ul>
<h5 id="subprocess模块中的常用函数"><a href="#subprocess模块中的常用函数" class="headerlink" title="subprocess模块中的常用函数"></a>subprocess模块中的常用函数</h5><ul>
<li><strong>subprocess.run()</strong><br>Python 3.5中新增的函数。执行指定的命令，等待命令执行完成后返回一个包含执行结果的CompletedProcess类的实例。</li>
<li><strong>subprocess.call()</strong><br>执行指定的命令，返回命令执行状态，其功能类似于os.system(cmd)。</li>
<li><strong>subprocess.check_call()</strong><br>Python 2.5中新增的函数。 执行指定的命令，如果执行成功则返回状态码，否则抛出异常。其功能等价于subprocess.run(…, check=True)。</li>
<li><strong>subprocess.check_output()</strong><br>Python 2.7中新增的的函数。执行指定的命令，如果执行状态码为0则返回命令执行结果，否则抛出异常。</li>
<li><strong>subprocess.getoutput(cmd)</strong><br>接收字符串格式的命令，执行命令并返回执行结果，其功能类似于<br>os.popen(cmd).read()和commands.getoutput(cmd)。</li>
<li><strong>subprocess.getstatusoutput(cmd)</strong><br>执行cmd命令，返回一个元组(命令执行状态, 命令执行结果输出)，其功能类似于commands.getstatusoutput()。</li>
</ul>
<h3 id="paramiko模块"><a href="#paramiko模块" class="headerlink" title="paramiko模块"></a>paramiko模块</h3><p>paramiko是一个用于做远程控制的模块，使用该模块可以对远程服务器进行命令或文件操作,paramiko是用python语言写的一个模块，遵循SSH2协议，支持以加密和认证的方式，进行远程服务器的连接。</p>
<p>由于使用的是python这样的能够跨平台运行的语言，所以所有python支持的平台，如Linux, Solaris, BSD, MacOS X, Windows等，paramiko都可以支持，因此，如果需要使用SSH从一个平台连接到另外一个平台，进行一系列的操作时，paramiko是最佳工具之一。</p>
<h4 id="python２和python３的区别："><a href="#python２和python３的区别：" class="headerlink" title="python２和python３的区别："></a>python２和python３的区别：</h4><ol>
<li>python2 解释器默认编码：ascii　　python3 解释器默认编码：utf-8</li>
<li>range在Python2中返回列表，而在Python3中返回range可迭代对象。</li>
<li>在Python2中有两个不等运算符!=和&lt;&gt;，在Python3中去掉了&lt;&gt;，只有!=符号表示不等</li>
<li>在Python2中long是比int取值范围更大的整数，Python3中取消了long类型，int的取值范围扩大到之前的long类型范围。</li>
<li>python2 的代码混乱，重复较多，冗余。python3源码规范、清晰、简单优美。</li>
<li>python3x：unicode 默认是4个字节表示一个字符、python2x :unicode 默认2个字节表示一个字符</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
