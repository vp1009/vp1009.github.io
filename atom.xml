<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Richard Marx</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/vp1009/vp1009.github.io.git/"/>
  <updated>2020-09-13T13:07:32.000Z</updated>
  <id>https://github.com/vp1009/vp1009.github.io.git/</id>
  
  <author>
    <name>Mr.L</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python基础知识点大全</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/09/06/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E5%85%A8/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/09/06/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E5%85%A8/</id>
    <published>2020-09-05T16:01:17.000Z</published>
    <updated>2020-09-13T13:07:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python知识点"><a href="#Python知识点" class="headerlink" title="Python知识点"></a>Python知识点</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><ol><li>进程是资源分配最小单位</li><li><strong>一个运行起来的程序就是一个进程</strong><br>什么是程序（程序是我们存储在硬盘里的代码、文件）<br>当我们双击图标，打开程序的时候，实际上就是通过I/O操作（读写）内存条里面<br>内存条就是我们所指的资源</li><li>进程之间内存独立，不能相互访问</li></ol><p><strong>进程定义拓展回答内容</strong>：</p><ol><li>程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，这种执行的程序就称之为进程</li><li>程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念</li><li>在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。</li><li>进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。</li><li>进程之间有自己独立的内存，各进程之间不能相互访问</li><li>创建一个新线程很简单，创建新进程需要对父进程进行复制</li></ol><h4 id="进程和程序的区别"><a href="#进程和程序的区别" class="headerlink" title="进程和程序的区别"></a>进程和程序的区别</h4><ol><li>程序只是一个普通文件，是一个机器代码指令和数据的集合，所以，程序是一个静态的实体</li><li>而进程是程序运行在数据集上的动态过程，进程是一个动态实体，它应创建而产生，应调度执行因等待资源或事件而被处于等待状态，因完成任务而被撤消</li><li>进程是系统进行资源分配和调度的一个独立单位</li><li>一个程序对应多个进程，一个进程为多个程序服务（两者之间是多对多的关系）</li><li>一个程序执行在不同的数据集上就成为不同的进程，进程可以控制 块 来唯一标识每个程序</li></ol><p><strong>多道编程概念</strong>:</p><ul><li>多道编程： 在计算机内存中同时存放几道相互独立的程序，他们共享系统资源，相互穿插运行</li><li>单道编程： 计算机内存中只允许一个的程序运行</li></ul><p><code>进程具有独立的内存空间，所以没有办法相互通信</code><br><strong>进程通信</strong>:</p><p>python提供了多种进程通信的方式，主要<strong>Queue</strong>和<strong>Pipe</strong>这两种方式，<strong>Queue</strong>用 于多个进程间实现通信，<strong>Pipe</strong>是两个进程的通信。</p><ul><li>Queue有两个方法：<br>\1. Put方法：以插入数据到队列中<br>\2. Get方法：从队列读取并且删除一个元素</li><li>Pipe常用于两个进程，两个进程分别位于管道的两端<br>Pipe方法返回（conn1,conn2）代表一个管道的两个端，Pipe方法有duplex参数，默认为True，即全双工模式，若为FALSE，conn1只负责接收信息，conn2负责发送，</li><li>managers</li><li>RabbitMQ、redis等</li></ul><p><strong>进程间互相访问数据的四种方法</strong>:<br><code>注：不同进程间内存是不共享的，所以互相之间不能访问对方数据</code></p><ol><li>利用Queues实现父进程到子进程（或子进程间）的数据传递</li><li>使用管道pipe实现两个进程间数据传递</li><li>Managers实现很多进程间数据共享</li><li>借助redis中间件进行数据共享</li></ol><p><strong>进程池</strong>:<br>为什么需要进程池?</p><ul><li>一次性开启指定数量的进程</li><li>如果有十个进程，有一百个任务，一次可以处理多少个（一次性只能处理十个）</li><li>防止进程开启数量过多导致服务器压力过大</li><li>开进程池是为了效率,进程直接的切换是属于IO调度，每个进程的内存空间都有自己的寄存器，堆栈和文件。</li></ul><pre class="highlight"><span class="line"><span class="keyword">from</span>  multiprocessing <span class="keyword">import</span> Process,Pool</span><br><span class="line"><span class="keyword">import</span> time,os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(i)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"in the process"</span>,os.getpid()) <span class="comment">#打印子进程的pid</span></span><br><span class="line"><span class="keyword">return</span> i+<span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(arg)</span>:</span></span><br><span class="line">print(<span class="string">'--&gt;exec done:'</span>,arg,os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = Pool(<span class="number">3</span>)                      <span class="comment">#进程池最多允许5个进程放入进程池</span></span><br><span class="line">    print(<span class="string">"主进程pid："</span>,os.getpid())     <span class="comment">#打印父进程的pid</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">       <span class="comment">#用法1 callback作用是指定只有当Foo运行结束后就执行callback调用的函数,父进程调用的callback函数</span></span><br><span class="line">        pool.apply_async(func=foo, args=(i,),callback=call)</span><br><span class="line">        <span class="comment">#用法2 串行 启动进程不在用Process而是直接用pool.apply()</span></span><br><span class="line">        <span class="comment"># pool.apply(func=foo, args=(i,))</span></span><br><span class="line">    print(<span class="string">'end'</span>)</span><br><span class="line">    pool.close()    <span class="comment">#关闭pool</span></span><br><span class="line">    pool.join()     <span class="comment">#进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</span></span><br></pre><p><strong>进程池优点</strong>：</p><pre class="highlight"><span class="line">不仅仅减少了IO而且还减少了内存。</span><br><span class="line">下面的例子便可以区分 其他语言的进程池还可以根据服务器的压力来增减，有着上限和下限。</span><br><span class="line">12</span><br></pre><p><strong>建议：超过五个进程就用进程池</strong></p><p><strong>有了进程为什么还要线程？</strong></p><ol><li>进程优点：<br>提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率</li><li>进程的两个重要缺点<br>a. 第一点：进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。<br>b. 第二点：进程在执行的过程中如果阻塞，即使进程中有些工作不依赖于输入的数据，也将无法执行（例如等待输入，整个进程就会挂起）。<br>c. 例如，我们在使用qq聊天， qq做为一个独立进程如果同一时间只能干一件事，那他如何实现在同一时刻 即能监听键盘输入、又能监听其它人给你发的消息<br>d. 你会说，操作系统不是有分时么？分时是指在不同进程间的分时呀<br>e. 即操作系统处理一会你的qq任务，又切换到word文档任务上了，每个cpu时间片分给你的qq程序时，你的qq还是只能同时干一件事呀</li></ol><hr><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><strong>线程的定义</strong>:</p><ol><li>线程是系统调度的最小单位</li><li>同进程下线程资源共享</li><li>进程无法自己执行，只有通过线程操作CPU，内存</li><li>为了保证数据安全，必须使用线程锁</li></ol><p><strong>线程定义拓展回答内容</strong>:</p><ol><li>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位</li><li>一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务</li><li>无论你启多少个线程，你有多少个cpu, Python在执行的时候会淡定的在同一时刻只允许一个线程运行</li><li>进程本身是无法自己执行的，要操作cpu，必须创建一个线程，线程是一系列指令的集合</li><li>所有在同一个进程里的线程是共享同一块内存空间的，不同进程间内存空间不同</li><li>同一个进程中的各线程可以相互访问资源，线程可以操作同进程中的其他线程，但进程仅能操作子进程</li><li>两个进程想通信，必须要通过一个中间代理</li><li>对主线程的修改可能回影响其他子线程，对主进程修改不会影响其他进程因为进程间内存相互独立，但是同一进程下的线程共享内存</li></ol><p><strong>进程和线程的区别</strong>:</p><ol><li>进程包含线程</li><li>线程共享内存空间</li><li>进程内存是独立的（不可互相访问）</li><li>进程可以生成子进程，子进程之间互相不能互相访问（相当于在父级进程克隆两个子进程）</li><li>在一个进程里面线程之间可以交流。两个进程想通信，必须通过一个中间代理来实现</li><li>创建新线程很简单，创建新进程需要对其父进程进行克隆。</li><li>一个线程可以控制或操作同一个进程里面的其它线程。但进程只能操作子进程。</li><li>父进程可以修改不影响子进程，但不能修改。</li><li>线程可以帮助应用程序同时做几件事</li></ol><p><strong>for循环同时启动多个线程</strong>：</p><pre class="highlight"><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">(num)</span>:</span> <span class="comment">#定义每个线程要运行的函数</span></span><br><span class="line">    print(<span class="string">"running on number:%s"</span> %num)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    t = threading.Thread(target=sayhi,args=(<span class="string">'t-%s'</span>%i,))</span><br><span class="line">    t.start()</span><br></pre><p><strong>t.join()： 实现所有线程都执行结束后再执行主线程</strong>：</p><pre class="highlight"><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">(num)</span>:</span> <span class="comment">#定义每个线程要运行的函数</span></span><br><span class="line">    print(<span class="string">"running on number:%s"</span> %num)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">t_objs = []    <span class="comment">#将进程实例对象存储在这个列表中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    t = threading.Thread(target=sayhi,args=(<span class="string">'t-%s'</span>%i,))</span><br><span class="line">    t.start()          <span class="comment">#启动一个线程，程序不会阻塞</span></span><br><span class="line">    t_objs.append(t)</span><br><span class="line">print(threading.active_count())    <span class="comment">#打印当前活跃进程数量</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> t_objs: <span class="comment">#利用for循环等待上面50个进程全部结束</span></span><br><span class="line">    t.join()     <span class="comment">#阻塞某个程序</span></span><br><span class="line">print(threading.current_thread())    <span class="comment">#打印执行这个命令进程</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"----------------all threads has finished....."</span>)</span><br><span class="line">print(threading.active_count())</span><br><span class="line">print(<span class="string">'cost time:'</span>,time.time() - start_time)</span><br></pre><p><strong>setDaemon(): 守护线程，主线程退出时，需要子线程随主线程退出</strong>:</p><pre class="highlight"><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">(num)</span>:</span> <span class="comment">#定义每个线程要运行的函数</span></span><br><span class="line">    print(<span class="string">"running on number:%s"</span> %num)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    t = threading.Thread(target=sayhi,args=(<span class="string">'t-%s'</span>%i,))</span><br><span class="line">    t.setDaemon(<span class="literal">True</span>)  <span class="comment">#把当前线程变成守护线程，必须在t.start()前设置</span></span><br><span class="line">    t.start()          <span class="comment">#启动一个线程，程序不会阻塞</span></span><br><span class="line">print(<span class="string">'cost time:'</span>,time.time() - start_time)</span><br></pre><p><strong>GIL全局解释器锁：保证同一时间仅有一个线程对资源有操作权限</strong>:</p><pre class="highlight"><span class="line">作用：在一个进程内，同一时刻只能有一个线程执行&#96;</span><br><span class="line">&#96;说明：python多线程中GIL锁只是在CPU操作时（如：计算）才是串行的，其他都是并行的，所以比串行快很多</span><br></pre><ol><li>为了解决不同线程同时访问同一资源时，数据保护问题，而产生了GIL</li><li>GIL在解释器的层面限制了程序在同一时间只有一个线程被CPU实际执行，而不管你的程序里实际开了多少条线程</li><li>CPython自己定义了一个全局解释器锁，同一时间仅仅有一个线程可以拿到这个数据</li><li>python之所以会产生这种不好的状况是因为python启用一个线程是调用操作系统原生线程，就是C接口</li><li>但是这仅仅是CPython这个版本的问题，在PyPy，中就没有这种缺陷</li></ol><p><strong>线程锁</strong>:</p><ol><li>当一个线程对某个资源进行CPU计算的操作时加一个线程锁，只有当前线程计算完成主动释放锁，其他线程才能对其操作</li><li>这样就可以防止还未计算完成，释放GIL锁后其他线程对这个资源操作导致混乱问题</li><li>线程锁本质把线程中的数据加了一把互斥锁</li></ol><h4 id="有了GIL全局解释器锁为什么还需要线程锁"><a href="#有了GIL全局解释器锁为什么还需要线程锁" class="headerlink" title="有了GIL全局解释器锁为什么还需要线程锁"></a>有了GIL全局解释器锁为什么还需要线程锁</h4><p>因为cpu是分时使用的</p><p>GIL是限制同一个进程中只有一个线程进入Python解释器。。。。。<br>而线程锁是由于在线程进行数据操作时保证数据操作的安全性(同一个进程中线程之间可以共用信息，如果同时对数据进行操作，则会出现公共数据错误)<br>其实线程锁完全可以替代GIL，但是Python的后续功能模块都是加在GIL基础上的，所以无法更改或去掉GIL,这就是Python语言最大的bug…只能用多进程或协程改善，或者直接用其他语言写这部分</p><h4 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h4><p>两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去</p><p><strong>用户锁</strong>:</p><pre class="highlight"><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">lock = threading.Lock()          <span class="comment">#1 生成全局锁</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num                  <span class="comment">#2 在每个线程中都获取这个全局变量</span></span><br><span class="line">    print(<span class="string">'--get num:'</span>,num )</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    lock.acquire()              <span class="comment">#3 修改数据前加锁</span></span><br><span class="line">    num  -= <span class="number">1</span>                   <span class="comment">#4 对此公共变量进行-1操作</span></span><br><span class="line">    lock.release()              <span class="comment">#5 修改后释放</span></span><br></pre><p><strong>Semaphore(信号量)</strong>:</p><ol><li>互斥锁 同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据</li><li>比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去</li><li>作用就是同一时刻允许运行的线程数量</li></ol><p><strong>多线程</strong></p><ul><li><p>GIL锁：</p><p>全局解释锁，每次只能一个线程获得cpu的使用权：为了线程安全，也就是为了解决多线程之间的数据完整性和状态同步而加的锁，因为我们知道线程之间的数据是共享的。</p></li><li><p>join()作用：</p><p>在进程中可以阻塞主进程的执行, 直到等待子线程全部完成之后, 才继续运行主线程后面的代码</p></li><li><p>setDaemon()：</p><p>将该线程标记为守护线程或用户线程</p></li></ul><p><strong>线程池</strong></p><ul><li>使用以下模块创建线程池：</li></ul><ol><li>使用threadpool模块，这是个python的第三方模块，支持python2和python3</li><li>使用concurrent.futures模块，这个模块是python3中自带的模块，但是，python2.7以上版本也可以安装使用</li></ol><ul><li>线程池实现并发:</li></ul>  <pre class="highlight"><span class="line">python</span><br><span class="line">import requests</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">def fetch_request(url):</span><br><span class="line">    result &#x3D; requests.get(url)</span><br><span class="line">    print(result.text)</span><br><span class="line"></span><br><span class="line">url_list &#x3D; [</span><br><span class="line">    &#39;https:&#x2F;&#x2F;www.baidu.com&#39;,</span><br><span class="line">    &#39;https:&#x2F;&#x2F;www.google.com&#x2F;&#39;,         #google页面会卡住，知道页面超时后这个进程才结束</span><br><span class="line">    &#39;http:&#x2F;&#x2F;dig.chouti.com&#x2F;&#39;,          #chouti页面内容会直接返回，不会等待Google页面的返回</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">pool &#x3D; ThreadPoolExecutor(10)            # 创建一个线程池，最多开10个线程</span><br><span class="line">for url in url_list:</span><br><span class="line">    pool.submit(fetch_request,url)       # 去线程池中获取一个线程，线程去执行fetch_request方法</span><br><span class="line"></span><br><span class="line">pool.shutdown(True)                      # 主线程自己关闭，让子线程自己拿任务执行</span><br></pre><hr><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><strong>什么是协程（进入上一次调用的状态）</strong></p><ol><li>协程，又称微线程，纤程，协程是一种用户态的轻量级线程。</li><li>线程的切换会保存到CPU的栈里，协程拥有自己的寄存器上下文和栈，</li><li>协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈</li><li>协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态</li><li>协程最主要的作用是在单线程的条件下实现并发的效果，但实际上还是串行的（像yield一样）</li><li>协程能在单线程处理高并发</li></ol><p><strong>协程的定义</strong>：</p><ol><li>协程在单线程下实现并发效果</li><li>协程遇IO自动切换</li><li>协程保留上一次调用状态</li></ol><p><strong>协程的优点</strong>:</p><ol><li>无需线程上下文切换的开销</li><li>无需原子操作锁定及同步的开销，因为协程是串行的</li><li>方便切换控制流，简化编程模型</li><li>高并发，高扩展，低成本，一个cpu支持上万个协程没有问题，所以非常适合高并发处理</li></ol><p><strong>协程的缺点</strong>:</p><ol><li>无法利用多核的优势，但是协程和进程配合就可以使协程运行在不同的cpu上，就可以利用 多核的优势，但是在现实中，大部分场景都没有这个需要</li><li>只要一个协程阻塞（Blocking），就会阻塞整个协程，因为协程是串行的,这个问题必须要解决，才能让协程大范围应用</li></ol><ul><li>解决方法：<br>如果遇到<strong>io</strong>操作，则进行协程切换,去执行其他的协程，可以用<strong>gevent</strong>来实现，具体的实现是这样的，<br>比如协程1通过os去读一个file，这个时候就是一个 io操作，在调用os的接口前，就会有一个列表，协议1的这个操作就会被注册到这个列表中，然后就切换到其他协程去处理；等待os拿到要读file后，也会把这个文件句柄放在这个列表中，然后等待在切换到<br>协程1的时候，协程1就可以直接从列表中拿到数据，这样就可以实现不阻塞了</li></ul><p><strong>协程处理并发</strong>：</p><ul><li><strong>Gevent<br>遇IO自动切换</strong></li></ul><ol><li>Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程</li><li>协程之所以快是因为遇到I/O操作就切换（最后只有CPU运算）</li><li>其实Gevent模块仅仅是对greenlet的再封装，将I/O间的手动切换变成自动切换</li></ol><ul><li><strong>Greenlet<br>遇IO手动切换</strong></li></ul><ol><li>Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。</li></ol><p><strong>使用协程处理并发</strong><br><code>注：Gevent只用起一个线程，当请求发出去后gevent就不管,永远就只有一个线程工作，谁先回来先处理</code></p><pre class="highlight"><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这些请求谁先回来就先处理谁</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_async</span><span class="params">(method, url, req_kwargs)</span>:</span></span><br><span class="line">    response = requests.request(method=method, url=url, **req_kwargs)</span><br><span class="line">    print(response.url, response.content)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">##### 发送请求 #####</span></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(fetch_async, method=<span class="string">'get'</span>, url=<span class="string">'https://www.python.org/'</span>, req_kwargs=&#123;&#125;),</span><br><span class="line">    gevent.spawn(fetch_async, method=<span class="string">'get'</span>, url=<span class="string">'https://www.google.com/'</span>, req_kwargs=&#123;&#125;),</span><br><span class="line">    gevent.spawn(fetch_async, method=<span class="string">'get'</span>, url=<span class="string">'https://github.com/'</span>, req_kwargs=&#123;&#125;),</span><br><span class="line">])</span><br></pre><h5 id="select、poll、epoll（重点）："><a href="#select、poll、epoll（重点）：" class="headerlink" title="select、poll、epoll（重点）："></a>select、poll、epoll（重点）：</h5><h4 id="I-O的实质是什么？"><a href="#I-O的实质是什么？" class="headerlink" title="I/O的实质是什么？"></a>I/O的实质是什么？</h4><p>I/O的实质是将硬盘中的数据，或收到的数据实现从内核态 copy到 用户态的过程<br>本文讨论的背景是Linux环境下的network IO。<br>比如微信读取本地硬盘的过程<br>微信进程会发送一个读取硬盘的请求—-》操作系统<br>只有内核才能够读取硬盘中的数据—》数据返回给微信程序（看上去就好像是微信直接读取）</p><h4 id="用户态-amp-内核态"><a href="#用户态-amp-内核态" class="headerlink" title="用户态 &amp; 内核态"></a>用户态 &amp; 内核态</h4><p>系统空间分为两个部分，一部分是内核态，一部分是用户态的部分<br>内核态：内核态的空间资源只有操作系统能够访问<br>用户态：我们写的普通程序使用的空间</p><p><img src="https://img-blog.csdnimg.cn/20200224132553804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200224132553804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br><img src="https://img-blog.csdnimg.cn/20200224132633111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200224132633111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><ul><li><strong>select （能监控数量有限，不能告诉用户程序具体哪个连接有数据）</strong></li></ul><p>单个进程就可以同时处理多个网络连接的io请求（同时阻塞多个io操作）。基本原理就是程序呼叫select，然后整个程序就阻塞状态，这时候，kernel内核就会轮询检查所有select负责的文件描述符fd，当找到其中那个的数据准备好了文件描述符，会返回给select，select通知系统调用，将数据从kernel内核复制到进程缓冲区(用户空间)。</p><ul><li><strong>poll（和select一样，仅仅去除了最大监控数量）</strong></li></ul><ol><li>poll和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制<br>差别如下：</li></ol><p>描述fd集合的方式不同，poll使用 pollfd 结构而不是select结构fd_set结构，所以poll是链式的，没有最大连接数的限制<br>poll有一个特点是水平触发，也就是通知程序fd就绪后，这次没有被处理，那么下次poll的时候会再次通知同个fd已经就绪。</p><ul><li><strong>epoll (不仅没有最大监控数量限制，还能告诉用户程序哪个连接有活跃)</strong><br><code>注：epoll被认为是linux下性能最好的多路io就绪通知方法</code></li></ul><ol><li>epoll直到Linux2.6（centos6以后）才出现了由内核直接支持</li><li>Epoll没有最大文件描述符数量限制</li><li>epoll最重要的优点是他可以直接告诉用户程序哪一个，比如现在用epoll去监控10000个socket链接，交给内核去监测，现在有一个连接有数据了，在有有一个连接有数据了，epoll会直接高数用户程序哪个连接有数据了</li></ol><p>epoll是select和poll的改进方案，在 linux 上可以取代 select 和 poll，可以处理大量连接的性能问题</p><ul><li><strong>epoll能实现高并发原理</strong></li></ul><ol><li><p>epoll() 中内核则维护一个链表，epoll_wait 直接检查链表是不是空就知道是否有文件描述符准备好了。</p></li><li><p>在内核实现中 epoll 是根据每个 sockfd 上面的与设备驱动程序建立起来的回调函数实现的。</p></li><li><p>某个 sockfd 上的事件发生时，与它对应的回调函数就会被调用，把这个 sockfd 加入链表。</p></li><li><p>epoll上面链表中获取文件描述，这里使用内存映射（mmap）技术， 避免了复制大量文件描述符带来的开销<br>内存映射（mmap）：内存映射文件，是由一个文件到一块内存的映射，将不必再对文件执行I/O操作</p><p><strong>epoll有4个动作：创建，注册，等待，取消注册，很显然我们用不着</strong></p></li></ol><ul><li><p><strong>epoll和select，poll还有一个本质的区别的就是:</strong></p><p>select 和 poll 只有在下次在循环回来，再去操作系统获取文件描述符<br>epoll 会直接告诉程序，我们这里已经就绪了，你可以接受数据了，等下一次协程去调用 epoll_wait 的时候就可以直接拿到就绪的文件描述符</p></li></ul><p><strong>猴子补丁</strong></p><p>即在运行时对方法 / 类 / 属性 / 功能进行修改，把新的代码作为解决方案代替原有的程序，也就是为其打上补丁。</p><p>在使用gevent模块的使用会遇到猴子补丁</p><pre class="highlight"><span class="line"><span class="keyword">import</span> gevent.monkey</span><br><span class="line"> </span><br><span class="line">gevent.monkey.patch_all()</span><br><span class="line"></span><br><span class="line">注解：使用猴子补丁的方式，gevent能够修改标准库里面大部分的阻塞式系统调用，包括socket、ssl、threading和 select等模块，而变为协作式运行。也就是通过猴子补丁的monkey.patch_xxx()来将python标准库中模块或函数改成gevent中的响应的具有协程的协作式对象。这样在不改变原有代码的情况下，将应用的阻塞式方法，变成协程式的。</span><br></pre><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p><strong>介绍</strong></p><p>装饰器(Decorators)是 Python 的一个重要部分。<br>简单地说：他们是修改其他函数的功能的函数。他们有助于让我们的代码更简短，也更Pythonic（Python范儿）。</p><p><strong>装饰器的概念</strong>：</p><pre class="highlight"><span class="line">1. 装饰器实际上就是一个函数</span><br><span class="line">2. 有2个特别之处，参数是一个函数。返回值是一个参数</span><br><span class="line">12</span><br></pre><p><strong>装饰器的简单理解</strong>:</p><pre class="highlight"><span class="line">实际上就是为了给一个程序添加功能，但是该程序已经上线或者已被使用，</span><br><span class="line">那么就不能大批量的修改源码，这样不现实，因此就产生了装饰器。</span><br><span class="line">注意点：</span><br><span class="line">1. 不能修改被装饰的函数的源代码</span><br><span class="line">2. 不能修改被装饰的函数的调用方式</span><br><span class="line">12345</span><br></pre><p><strong>装饰器组成方式</strong>：</p><pre class="highlight"><span class="line">函数+实参高阶函数+返回值高阶函数+嵌套函数+语法糖 &#x3D; 装饰器</span><br><span class="line">1</span><br></pre><ul><li><p><strong>有关高阶函数的理解</strong>：</p><ol><li>把一个函数名当作实参传给另外一个函数（”实参高阶函数“）</li><li>返回值中包含函数名（”返回值高阶函数“）</li></ol></li><li><p><strong>嵌套函数的理解</strong>：</p><p>嵌套函数指的是在函数内部定义一个函数，而不是调用。</p></li><li><p><strong>语法糖</strong>：</p><p>写法：@xx ，一般写在函数的上方</p></li></ul><p><strong>装饰器实例</strong></p><ul><li><p><strong>使用高阶函数模拟装饰器:</strong></p><pre class="highlight"><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">start_time = time.time()</span><br><span class="line">func()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'函数执行时间为'</span>, time.time() - start_time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'开始执行test'</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'test执行结束'</span></span><br><span class="line">timer(test)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">开始执行test</span></span><br><span class="line"><span class="string">test执行结束</span></span><br><span class="line"><span class="string">函数执行时间为 3.00332999229</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></li><li><p><strong>计算运行时间装饰器:</strong></p><pre class="highlight"><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span>   <span class="comment">#timer(test1)  func=test1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func(*args,**kwargs)      <span class="comment">#run test1</span></span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        print(<span class="string">"running time is %s"</span>%(stop_time-start_time))</span><br><span class="line">    <span class="keyword">return</span> deco</span><br><span class="line"><span class="meta">@timer     # test1=timer(test1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"in the test1"</span>)</span><br><span class="line">test1()</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></li><li><p><strong>装饰无参函数，示例代码如下：</strong></p><pre class="highlight"><span class="line"><span class="comment">#装饰器装饰的函数无参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span>      <span class="comment">#func其实指的就是test</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">()</span>:</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func()               <span class="comment">#这里其实是对test的调用</span></span><br><span class="line">        stop = time.time()</span><br><span class="line">        <span class="keyword">print</span> (stop-start)</span><br><span class="line">    <span class="keyword">return</span> deco</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer               #test函数使用装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"test is running"</span>)</span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">test <span class="keyword">is</span> running</span><br><span class="line"><span class="number">2.003510952</span></span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></li></ul><ul><li><p><strong>装饰有参函数，示例代码如下：</strong></p><pre class="highlight"><span class="line"><span class="comment">#装饰器装饰的函数有参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(*args,**kwargs)</span>:</span>    <span class="comment">#添加可变参数*args和**kwargs</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func(*args,**kwargs)      <span class="comment">#这里也是一样，添加可变参数*args和**kwargs</span></span><br><span class="line">        stop = time.time()</span><br><span class="line">        <span class="keyword">print</span> (stop-start)</span><br><span class="line">    <span class="keyword">return</span> deco</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(value)</span>:</span>     <span class="comment">#test函数有个参数value,正因为装饰器timer装饰的函数test有参数value,因此在timer中的有了可变参数</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"test is running %s"</span> %value)</span><br><span class="line">test(<span class="string">"22"</span>)</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">test <span class="keyword">is</span> running <span class="number">22</span></span><br><span class="line"><span class="number">2.00424408913</span></span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></li></ul><ul><li><p><strong>带参数的装饰器，示例代码如下：</strong></p><pre class="highlight"><span class="line"><span class="comment">#装饰器带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(parameter)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">out_wapper</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wapper</span><span class="params">(*wargs,**kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> parameter == <span class="string">"task1"</span>:</span><br><span class="line">                start = time.time()</span><br><span class="line">                func(*wargs,**kwargs)</span><br><span class="line">                stop = time.time()</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">"the task1 is run:"</span>,stop-start)</span><br><span class="line">            <span class="keyword">elif</span> parameter == <span class="string">"task2"</span>:</span><br><span class="line">                func(*wargs, **kwargs)</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">"the task2 is run:"</span>)</span><br><span class="line">        <span class="keyword">return</span> wapper</span><br><span class="line">    <span class="keyword">return</span> out_wapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(parameter = "task1")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task1</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"in the task1"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(parameter = "task2")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"in the task2"</span></span><br><span class="line"></span><br><span class="line">task1()</span><br><span class="line">task2()</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"><span class="keyword">in</span> the task1</span><br><span class="line">(<span class="string">'the task1 is run:'</span>, <span class="number">2.002906084060669</span>)</span><br><span class="line"><span class="keyword">in</span> the task2</span><br><span class="line">the task2 <span class="keyword">is</span> run:</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233</span></span><br></pre></li></ul><p><strong>装饰器使用场景</strong></p><blockquote><p>授权：装饰器能有助于检查某个人是否被授权去使用一个web应用的端点(endpoint)。它们被大量使用于Flask和Django web框架中<br>日志：在记录日志的地方添加装饰器<br>缓存：通过装饰器获取缓存中的值</p></blockquote><p><strong>闭包</strong></p><ul><li><p><strong>定义</strong>：</p><p>如果在一个函数的内部定义了另一个函数，外部的我们叫他外函数，内部的我们叫他内函数。那闭包就是，在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包</p></li></ul><hr><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p><strong>定义</strong>:</p><ol><li>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</li><li>迭代器是一个可以记住遍历的位置的对象。</li><li>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</li><li>迭代器有两个基本的方法：iter() 和 next()。</li><li>字符串，列表或元组对象都可用于创建迭代器：</li></ol><p><strong>可迭代对象</strong>:</p><p>在Python世界里，一切皆对象。对象根据定义的维度，又可以分为各种不同的类型，比如：文件对象，字符串对象，列表对象。。。等等。<br>一句话：“实现了<strong>inter</strong>方法的对象就叫做可迭代对象”，<strong>inter</strong>方法的作用就是返回一个迭代器对象。<br>直观理解就是能用for循环进行迭代的对象就是可迭代对象。比如：字符串，列表，元祖，字典，集合等等，都是可迭代对象。</p><p><strong>next()与iter()</strong>:</p><pre class="highlight"><span class="line">next()返回迭代器的下一个项目</span><br><span class="line">next语法:</span><br><span class="line">next(iterator[,dafault])</span><br><span class="line"></span><br><span class="line">iterator -- 可迭代对象</span><br><span class="line">default -- 可选，用于设置在没有下一个元素时返回该默认值，如果不设置，又没有下一个元素则会触发 StopIteration 异常。</span><br><span class="line"></span><br><span class="line">iter():</span><br><span class="line">iter()函数用来生成迭代器</span><br><span class="line">iter语法:</span><br><span class="line">12345678910</span><br></pre><p><strong>迭代器实现斐波那契</strong></p><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.a = <span class="number">0</span></span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        res = self.a</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        <span class="keyword">if</span> self.count &gt; self.n:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">print(list(Fib(<span class="number">5</span>)))</span><br><span class="line">print(list(Fib(<span class="number">10</span>)))</span><br></pre><ul><li><p><strong>生成器和迭代器之间的区别</strong></p><p>在使用生成器时，我们创建一个函数；在使用迭代器时，我们使用内置函数iter()和next()。 在生成器中，我们使用关键字‘yield’来每次生成/返回一个对象。 生成器中有多少‘yield’语句，你可以自定义。 每次‘yield’暂停循环时，生成器会保存本地变量的状态。而迭代器并不会使用局部变量，它只需要一个可迭代对象进行迭代。 使用类可以实现你自己的迭代器，但无法实现生成器。 生成器运行速度快，语法简洁，更简单。 迭代器更能节约内存。</p></li></ul><hr><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><ul><li><p><strong>生成器定义、简介</strong></p><p>在python中，生成器是根据某种算法边循环边计算的一种机制。主要就是用于操作大量数据的时候，<br>一般我们会将操作的数据读入内存中处理，可以计算机的内存是比较宝贵的资源，我认为的当要处理的数据超过内存四分之一的大小时就应该使用生成器。</p></li><li><p><strong>生成器的作用</strong></p></li></ul><ol><li><p>通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的。</p></li><li><p>而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p></li><li><p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？</p></li><li><p>这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p></li></ol><ul><li><strong>特点</strong></li></ul><ol><li><p>和传统的容器相比，生成器更节省内存。</p></li><li><p>延迟计算，在我们需要结果时就调用一下生成器的next()方法即可。</p></li><li><p>可迭代，你可以像遍历list一样，遍历生成器</p></li></ol><ul><li><strong>生成器工作原理</strong></li></ul><ol><li><p>生成器是这样一个函数，它记住上一次返回时在函数体中的位置。</p></li><li><p>对生成器函数的第二次（或第 n 次）调用跳转至该函数中间，而上次调用的所有局部变量都保持不变。</p></li><li><p>生成器不仅“记住”了它数据状态；生成器还“记住”了它在流控制构造中的位置。</p></li><li><p>生成器是一个函数，而且函数的参数都会保留。</p></li><li><p>迭代到下一次的调用时，所使用的参数都是第一次所保留下的，即是说，在整个所有函数调用的参数都是第一次所调用时保留的，而不是新创建的</p><p><strong>在python中有两种方式创建生成器：生成器表达式 和 生成器函数。</strong></p></li></ol><ul><li><strong>生成器 和 普通函数的区别 ？</strong></li></ul><p>生成式函数和普通函数只有一个区别，普通函数使用return返回结果，而生成器函 数使用yield返回结果。<br>yield的特点在于，它并不是结束函数，而是在返回结果后将函数处于一种挂起状态，等待再次next函数的调用，然后从上次挂起的地方(yield)继续执行。</p><ul><li><strong>可迭代的数据类型</strong></li></ul><p>列表、元组、字典和集合都是可迭代的对象，可以从其中获得迭代器。<br>所有这些对象都可用iter()方法获取迭代器:</p><ul><li><p><strong><code>yield运行机制</code></strong>:</p><p>在Python中，yield就是这样的一个生成器。</p></li></ul><ol><li>当你问生成器要一个数时，生成器会执行，直至出现 yield 语句，生成器把yield 的参数给你，之后生成器就不会往下继续运行。</li><li>当你问他要下一个数时，他会从上次的状态开始运行，直至出现yield语句，把参数给你，之后停下。如此反复</li><li>在python中，当你定义一个函数，使用了yield关键字时，这个函数就是一个生成器</li><li>它的执行会和其他普通的函数有很多不同，函数返回的是一个对象，而不是你平常所用return语句那样，能得到结果值。如果想取得值，那得调用next()函数</li><li>每当调用一次迭代器的next函数，生成器函数运行到yield之处，返回yield后面的值且在这个地方暂停，所有的状态都会被保持住，直到下次next函数被调用，或者碰到异常循环退出。</li></ol><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max_num)</span>:</span></span><br><span class="line">    a,b = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt; max_num:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a,b=b,a+b</span><br><span class="line"></span><br><span class="line">g = fib(<span class="number">10</span>)               <span class="comment">#生成一个生成器：[1，2, 3, 5, 8, 13]</span></span><br><span class="line">print(g.__next__())       <span class="comment">#第一次调用返回：1</span></span><br><span class="line">print(list(g))            <span class="comment">#把剩下元素变成列表：[2, 3, 5, 8, 13]</span></span><br></pre><p>每次执行send()或next()只是返回了对应yield表达式的参数值，其实对应表达式并未执行，直到下次再执行send()或next()才会执行上次返回参数的yield表达式，所谓的执行yield表达式就是给其赋值，并返回下一个yield表达式的参数值！<br><a href="https://www.jianshu.com/p/36168970b0eb" target="_blank" rel="noopener">yield机制详细地址</a></p><hr><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><strong>简介</strong>：</p><p>面向对象编程(Object Oriented Programming-OOP) 是一种解决软件复用的设计和编程方法。 这种方法把软件系统中相近相似的操作逻辑和操作 应用数据、状态,以类的型式描述出来,以对象实例的形式在软件系统中复用,以达到提高软件开发效率的作用。<br>其实面向对象也很简单，却也很难，熟能生巧。你需要了解类和对象，要学会定义类，创建对象。</p><p><strong>特点</strong>：</p><ol><li>类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li>方法：类中定义的函数。</li><li>类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li>数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li>方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li>局部变量：定义在方法中的变量，只作用于当前实例的类。</li><li>实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li>继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。</li><li>实例化：创建一个类的实例，类的具体对象。</li><li>对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ol><pre class="highlight"><span class="line">下面详细介绍:</span><br></pre><h3 id="1-方法"><a href="#1-方法" class="headerlink" title="1. 方法"></a>1. 方法</h3><p><strong>1.1 静态方法</strong>：</p><ul><li>定义：使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法；</li><li>调用：实例对象和类对象都可以调用。</li><li>特性: 静态方法只是名义上归类管理，实际上在静态方法里访问不了类或则实例中的任何属性</li><li>作用：静态方法可以更好的组织代码，防止代码变大后变得比较混乱。</li><li>静态方法使用场景：<ol><li>我们要写一个只在类中运行而不在实例中运行的方法.</li><li>经常有一些跟类有关系的功能但在运行时又不需要实例和类参与的情况下需要用到静态方法.</li><li>比如更改环境变量或者修改其他类的属性等能用到静态方法.</li><li>这种情况可以直接用函数解决, 但这样同样会扩散类内部的代码，造成维护困难.</li></ol></li></ul><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"I am a static method"</span>)</span><br><span class="line">d = Dog(<span class="string">"ChenRonghua"</span>)</span><br><span class="line">d.eat()                     <span class="comment">#方法1：使用实例调用</span></span><br><span class="line"></span><br><span class="line">Dog.eat()                   <span class="comment">#方法2：使用类直接调用</span></span><br></pre><p><strong>1.2 类方法</strong>：</p><ul><li>定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）；</li><li>调用：实例对象和类对象都可以调用。</li><li>作用：无需实例化直接被类调用</li><li>类方法使用场景： 当我们还未创建实例，但是需要调用类中的方法</li></ul><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    name = <span class="string">'类变量'</span> <span class="comment">#在这里如果不定义类变量仅定义实例变量依然报错</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = <span class="string">'实例变量'</span></span><br><span class="line">        self.name = name</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self,food)</span>:</span></span><br><span class="line">        print(<span class="string">"%s is eating %s"</span>%(self.name,food))</span><br><span class="line">Dog.eat(<span class="string">'baozi'</span>)                   <span class="comment">#方法1：使用类直接调用</span></span><br><span class="line">d = Dog(<span class="string">"ChenRonghua"</span>)          </span><br><span class="line">d.eat(<span class="string">"包子"</span>)                      <span class="comment">#方法2：使用实例d调用</span></span><br></pre><p><strong>1.3 实例方法</strong>：</p><ul><li>定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法（也可以传类的属性和方法）；</li><li>调用：只能由实例对象调用。</li></ul><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">" %s is eating"</span> % self.name)</span><br><span class="line">d = Dog(<span class="string">"ChenRonghua"</span>)</span><br><span class="line">d.eat()</span><br><span class="line"><span class="comment"># 调用会出以下错误， 说NoneType is not callable, 因为eat此时已经变成一个静态属性了， </span></span><br><span class="line"><span class="comment"># 不是方法了， 想调用已经不需要加()号了，直接d.eat就可以了</span></span><br></pre><h5 id="1-4-魔法方法"><a href="#1-4-魔法方法" class="headerlink" title="1.4 魔法方法:"></a>1.4 魔法方法:</h5><p>我们在调用python类中的某个方法时，通常会看到某些特殊的方法，它们总被双下划线所包围，像这种格式：”<strong>方法名</strong>“，这些方法很强大，充满魔力，可以让你实现很多功能。，如果你的对象实现（重载）了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，你可以定义自己想要的行为，而这一切都是自动发生的。因此了解这类方法的作用及用户很有必要，以下对基本魔法方法做出总结，请看：<a href="https://www.jianshu.com/p/2ec468e58b89" target="_blank" rel="noopener">魔法方法表格</a></p><p>type生成类调用顺序:</p><p><strong>new</strong> : 先于<strong>init</strong>方法，每生成一个实例执行一次，<strong>new</strong> 类方法创建实例对象<br><strong>init</strong> : <strong>init</strong>方法每生成一个实例就会执行一次，初始化实例对象<br><strong>call</strong> : 后与<strong>init</strong>方法，C()() 使用类再加一个括号调用， C为类名称<br><strong>del</strong> : 析构方法，删除无用的内存对象（当程序结束会自动自行析构方法）</p><p><strong>类实例化时魔法方法调用顺序</strong></p><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'__new__'</span>)</span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)   <span class="comment"># 必须返回父类的__new__方法，否则不不执行__init__方法，无法创建实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        print(<span class="string">'__init__'</span>)</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>                <span class="comment"># 作用：打印实例时显示指定字符串，而不是内存地址</span></span><br><span class="line">        print(<span class="string">'__str__'</span>)</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span>        <span class="comment"># 当执行C()(*args) 或者 s1(*args) 就会执行__call__</span></span><br><span class="line">        print(<span class="string">'__call__'</span>,*args)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span>                <span class="comment"># 作用：清除无用的实例对内存的暂用</span></span><br><span class="line">        print(<span class="string">'__del__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1、实例化时机会执行__new__、__init__</span></span><br><span class="line">s1 = Student(<span class="string">'tom'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、执行 实例()  就会执行__call__ 方法，并将参数传递给__call__函数</span></span><br><span class="line">s1(<span class="string">'call01'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、当打印实例时就会执行 __str__ 方法下返回的字符串（默认返回的实例地址）</span></span><br><span class="line">print(s1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4、析构方法：当删除实例时就会调用 __del__ 方法</span></span><br><span class="line"><span class="keyword">del</span> s1</span><br><span class="line"><span class="comment"># 析构方法作用：在程序结束后会自动执行析构方法删除所有实例</span></span><br><span class="line"><span class="comment"># 但是在程序运行时有很多实例是无用的，但是python内存回收机制却不会自动删除他们，这样就浪费内存</span></span><br><span class="line"><span class="comment"># 我们可以执行 del s1 ，那么在程序运行时，python内存回收机制会检测到这些实例时无用的，才会删除</span></span><br><span class="line"><span class="comment"># 其实我们执行del s1，并没有回收内存，只不过是摘除门牌号，python内存回收机制发现没有门牌号后会自动回收内存</span></span><br></pre><p><strong><strong>new</strong> &amp; <strong>init</strong>详解</strong>:</p><ol><li><strong>new</strong> 至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动 提供</li><li><strong>new</strong> 必须要有返回值，返回实例化出来的实例，这点在自己实现 <strong>new</strong> 时要特别注 意，可以return父类 <strong>new</strong> 出来的实例，或者直接是object的 <strong>new</strong> 出来的实例</li><li><strong>init</strong> 有一个参数self，就是这个 <strong>new</strong> 返回的实例， <strong>init</strong> 在 <strong>\new</strong> 的基础上 可以完成一些其它初始化的动作， <strong>init</strong> 不需要返回值 我们可以将类比作制造商， <strong>new</strong> 方法就是前期的原材料购买环节， <strong>init</strong> 方法就是在 有原材料的基础上，加工，初始化商品环节。</li></ol><h4 id="1-5-单例模式："><a href="#1-5-单例模式：" class="headerlink" title="1.5 单例模式："></a>1.5 单例模式：</h4><p><strong>new</strong>方法书写：</p><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">print(self)</span><br><span class="line">print(<span class="string">"这是 init 方法"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></span><br><span class="line">print(id(cls))</span><br><span class="line">print(<span class="string">"这是 __new__ 方法"</span>)</span><br><span class="line">ret = object.__new__(cls)</span><br><span class="line">print(res)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(id(A))</span><br><span class="line">--&gt;: 12345678987654321</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">--&gt;: 12345678987654321</span><br><span class="line">这是 new 方法</span><br><span class="line">--&gt;: &lt;__main__.A object at 0x105b96ac8&gt;</span><br><span class="line">--&gt;: &lt;__main__.A object at 0x105b96ac8&gt;</span><br></pre><h4 id="线程安全的单例"><a href="#线程安全的单例" class="headerlink" title="线程安全的单例:"></a>线程安全的单例:</h4><pre class="highlight"><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">线程安全的单利模式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">紧跟with后面的语句被求值后，返回对象的 __enter__() 方法被调用，这个方法的返回值将被赋值给as后面的变量。</span></span><br><span class="line"><span class="string">当with后面的代码块全部被执行完之后，将调用前面返回对象的 __exit__()方法</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">synchronized</span><span class="params">(func)</span>:</span></span><br><span class="line">    func.__lock__ = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lock_func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> func.__lock__:</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lock_func</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="comment"># 关键在于这，每一次实例化的时候，我们都只会返回这同一个instance对象</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls.instance:</span><br><span class="line">            cls.instance = super(Singleton, cls).__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br></pre><p>先看类，可以看出这里我们先定义了一个类属性instance，接着我们重写了父类的<strong>new</strong>方法，这个方法就是我们在实例化一个对象时最先调用的一个方法。和其他静态语言不一样，其他静态语言，直接调用了构造方法，一般情况下初始化的程序也写在构造方法之中。而python实例化一个对象和初始化是分开的。<strong>new</strong>是类方法，<strong>init</strong>是实例方法，也就是说，<strong>init</strong>是在对象已经创建完成之后，才执行。</p><p>在python3中，调用父类的方法是用super()来调用。所以我们这里的思路就是，还是用父类的方法去创造，但是我们要加一个判断，就是说，当这个对象也就是类属性并不为空的时候，我们就不在实例化，而是返回一个已经实例化的类属性。</p><h4 id="线程不安全的单例"><a href="#线程不安全的单例" class="headerlink" title="线程不安全的单例"></a>线程不安全的单例</h4><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">__instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, age)</span>:</span></span><br><span class="line"><span class="comment"># 如果类属性__instance的值为None，那么就创建一个对象</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cls.__instance:</span><br><span class="line">cls.__instance = object.__new__(cls)</span><br><span class="line"><span class="comment"># 如果已经有实例存在，直接返回</span></span><br><span class="line"><span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line">a = Singleton(<span class="string">"Zhangsan"</span>, <span class="number">18</span>)</span><br><span class="line">b = Singleton(<span class="string">"lisi"</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">print(id(a))</span><br><span class="line">print(id(b))</span><br><span class="line"></span><br><span class="line">a.age = <span class="number">30</span>   <span class="comment"># 给a指向的对象添加一个属性</span></span><br><span class="line">print(b.age)  <span class="comment"># 获取b指向的对象的age属性</span></span><br></pre><p><strong><strong>del</strong></strong></p><p>Python 通过调用 <strong>init</strong>() 方法构造当前类的实例化对象，而 <strong>del</strong>() 方法，功能正好和 <strong>init</strong>() 相反，其用来销毁实例化对象。</p><p>事实上在编写程序时，如果之前创建的类实例化对象后续不再使用，最好在适当位置手动将其销毁，释放其占用的内存空间（整个过程称为垃圾回收（简称GC））。<br>大多数情况下，Python 开发者不需要手动进行垃圾回收，因为 Python 有自动的垃圾回收机制，能自动将不需要使用的实例对象进行销毁。</p><p>无论是手动销毁，还是 Python 自动帮我们销毁，都会调用 <strong>del</strong>() 方法。</p><h3 id="2-特性"><a href="#2-特性" class="headerlink" title="2. 特性"></a>2. 特性</h3><h4 id="面向对象三大特性-封装，继承，多态"><a href="#面向对象三大特性-封装，继承，多态" class="headerlink" title="面向对象三大特性: 封装，继承，多态"></a><code>面向对象三大特性: 封装，继承，多态</code></h4><h4 id="2-1-封装"><a href="#2-1-封装" class="headerlink" title="2.1 封装:"></a>2.1 封装:</h4><ol><li>在类中对数据的赋值、内部调用对外部用户是透明的</li><li>这使类变成了一个胶囊或容器，里面包含着类的数据和方法</li><li>作用：<ul><li>防止数据被随意修改<ul><li>使外部程序不需要关注对象内部的构造，只需要通过对外提供的接口进行直接访问</li></ul></li></ul></li></ol><p><strong>继承的种类</strong></p><ol><li>单继承：一个类继承单个基类</li><li>多继承:一个类继承多个基类</li><li>多级继承：一个类继承自单个基类，后者继承自另一个基类</li><li>分层继承：多个类继承自单个基类</li><li>混合继承：两种或多种类型继承的混合</li></ol><p><strong>封装的好处：</strong></p><ol><li>将变化隔离</li><li>便于使用</li><li>提高复用性</li><li>提高安全性</li></ol><pre class="highlight"><span class="line">封装：将数据进行封装到对象中，以供其他函数进行调用</span><br></pre><h4 id="2-2-Inheritance-继承（代码重用"><a href="#2-2-Inheritance-继承（代码重用" class="headerlink" title="2.2 Inheritance 继承（代码重用:"></a>2.2 Inheritance 继承（代码重用:</h4><ol><li>一个类可以派生出子类，在这个父类里定义的属性、方法自动被子类继承</li><li>比如CS中的警察和恐怖分子，可以将两个角色的相同点写到一个父类中，然后同时去继承它</li><li>使用经典类： Person.<strong>init</strong>(self, name, age) 并重写写父类Person的构造方法，实现，先覆盖，再继承，再重构</li></ol><p><strong>继承的优点：</strong></p><ol><li>节省代码,减少代码的重复性</li><li>增强耦合性(也就是增强代码可读性)</li><li>使代码更加规范化</li><li>子类可以调用父类的所有属性</li></ol><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'D'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(D)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># def talk(self):</span></span><br><span class="line">    <span class="comment">#     print('B')</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(D)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'C'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(B,C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># def talk(self):</span></span><br><span class="line">    <span class="comment">#     print('A')</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.talk()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 黑人，白人都继承父类Person就可以都有父类的属性和方法了</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span>  <span class="comment">#执行Person.__init__(self,name,age)时就会将传入的参数执行一遍</span></span><br><span class="line">        self.name = name          <span class="comment">#所以在BlackPerson中不仅有name,age而且还有sex</span></span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = <span class="string">"normal"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"person is talking...."</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WhitePerson</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlackPerson</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,strength)</span>:</span>     <span class="comment">#先覆盖，再继承，再重构</span></span><br><span class="line">        <span class="comment">#先覆盖父类的__init__方法，再继承父类__init__，再加自己的参数</span></span><br><span class="line">        Person.__init__(self,name,age)        <span class="comment">#先继承父类Person，这里self就是BlackPerson本身</span></span><br><span class="line">        <span class="comment">#先将name,age传给子类BlackPerson,然后调用Person.__init__构造方法将参数出入父类（）</span></span><br><span class="line">        self.strength = strength              <span class="comment">#然后再重构自己的方法,即写自己的参数</span></span><br><span class="line">        print(self.name,self.age,self.sex)</span><br><span class="line">        print(self.strength)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"black balabla"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"is walking...."</span>)</span><br><span class="line"></span><br><span class="line">b = BlackPerson(<span class="string">"wei er smith"</span>,<span class="number">22</span>,<span class="string">"Strong"</span>)</span><br><span class="line">b.talk()</span><br><span class="line">b.walk()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line"><span class="comment"># wei er smith 22 normal</span></span><br><span class="line"><span class="comment"># Strong</span></span><br><span class="line"><span class="comment"># black balabla</span></span><br><span class="line"><span class="comment"># is walking....</span></span><br><span class="line"><span class="comment"># person is talking....</span></span><br></pre><p><strong>新式类经典类区别：</strong></p><p>Python 2.x中默认都是经典类，只有显式继承了object才是新式类<br>Python 3.x中默认都是新式类，不必显式的继承object<br>当类是经典类时，多继承情况下，会按照深度优先方式查找<br>当类是新式类时，多继承情况下，会按照广度优先方式查找</p><h4 id="2-3-Polymorphism-多态（接口重用）"><a href="#2-3-Polymorphism-多态（接口重用）" class="headerlink" title="2.3 Polymorphism 多态（接口重用）"></a>2.3 Polymorphism 多态（接口重用）</h4><ol><li>多态是面向对象的重要特性,简单点说:“一个接口，多种实现”</li><li>指一个基类中派生出了不同的子类，且每个子类在继承同样的方法名的同时又对父类的方法做了不同的实现</li><li>这就是同一种事物表现出的多种形态</li><li>比如黄种人继承了人talk这个功能，但是他说的是中文，而美国人的talk是英文，但是他们是同样的talk</li></ol><pre class="highlight"><span class="line">作用：简单的讲就是允许父类调用子类的方法</span><br></pre><p>很多人喜欢将多态与多态性二者混为一谈，然后百思不得其解，其实只要分开看，就会很明朗。</p><ol><li>多态指的是一类事物有多种形态，（一个抽象类有多个子类，因而多态的概念依赖于继承）</li><li>多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。</li></ol><pre class="highlight"><span class="line"><span class="comment"># 多态举例</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span>    <span class="comment"># Constructor of the class</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>              <span class="comment"># Abstract method, defined by convention only</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">"Subclass must implement abstract method"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Meow!'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Woof! Woof!'</span></span><br><span class="line"></span><br><span class="line">animals = [Cat(<span class="string">'Missy'</span>),</span><br><span class="line">           Dog(<span class="string">'Lassie'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> animals:</span><br><span class="line">    print(animal.name + <span class="string">': '</span> + animal.talk())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line"><span class="comment"># Missy: Meow!</span></span><br><span class="line"><span class="comment"># Lassie: Woof! Woof!</span></span><br></pre><p><strong>Python中多态的特点</strong></p><ol><li>只关心对象的实例方法是否同名，不关心对象所属的类型；</li><li>对象所属的类之间，继承关系可有可无；</li><li>多态的好处可以增加代码的外部调用灵活度，让代码更加通用，兼容性比较强；</li><li>多态是调用方法的技巧，不会影响到类的内部设计。</li></ol><h3 id="3-属性"><a href="#3-属性" class="headerlink" title="3. 属性"></a>3. 属性</h3><ol><li><strong>类的公有属性</strong><br>public_attrs：能在类的外部被使用或直接访问。在类内部的方法中使用时 public_attrs_attrs，在类的外部class_name.public_attrs。</li><li><strong>类的私有属性</strong><br><strong>private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.</strong>private_attrs。</li><li><strong>类的(公有)方法</strong><br>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。<br>self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定是用 self。</li><li><strong>类的私有方法</strong><br><strong>private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.</strong>private_methods。</li></ol><h3 id="4-反射-hasattr、getattr、setattr-和-delattr"><a href="#4-反射-hasattr、getattr、setattr-和-delattr" class="headerlink" title="4. 反射: hasattr、getattr、setattr 和 delattr"></a>4. 反射: hasattr、getattr、setattr 和 delattr</h3><p>在做程序开发中，我们常常会遇到这样的需求：需要执行对象里的某个方法，或需要调用对象中的某个变量，但是由于种种原因我们无法确定这个方法或变量是否存在，这是我们需要用一个特殊的方法或机制要访问和操作这个未知的方法或变量，这中机制就称之为反射。</p><p>反射就是通过字符串的形式，导入模块；通过字符串的形式，去模块寻找指定函数，并执行。利用字符串的形式去对象（模块）中操作（查找/获取/删除/添加）成员，一种基于字符串的事件驱动！<br><a href="https://www.cnblogs.com/kongk/p/8645202.html" target="_blank" rel="noopener">–反射详解–</a></p><h4 id="四大属性"><a href="#四大属性" class="headerlink" title="四大属性:"></a><code>四大属性:</code></h4><ul><li><p><strong>hasattr(ogj,name_str) 判断一个对象里是否有对应的字符串方法</strong></p><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self,food)</span>:</span></span><br><span class="line">        print(<span class="string">"eat method!!!"</span>)</span><br><span class="line">d = Dog()</span><br><span class="line"></span><br><span class="line"><span class="comment">#hasattr判断对象d是否有eat方法，有返回True，没有返回False</span></span><br><span class="line">print(hasattr(d,<span class="string">'eat'</span>))     <span class="comment">#True</span></span><br><span class="line">print(hasattr(d,<span class="string">'cat'</span>))     <span class="comment">#False</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></li><li><p><strong>getattr(obj,name_str) 根据字符串去获取obj对象里的对应的方法的内存地址</strong></p><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"eat method!!!"</span>)</span><br><span class="line">d = Dog()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hasattr(d,<span class="string">'eat'</span>):          <span class="comment"># hasattr判断实例是否有eat方法</span></span><br><span class="line">    func = getattr(d, <span class="string">'eat'</span>)  <span class="comment"># getattr获取实例d的eat方法内存地址</span></span><br><span class="line">    func()                    <span class="comment"># 执行实例d的eat方法</span></span><br><span class="line"><span class="comment">#运行结果：  eat method!!!</span></span><br><span class="line"><span class="number">123456789</span></span><br></pre></li><li><p><strong>使用stattr给类实例对象动态添加一个新的方法</strong></p><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abc</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"%s正在交谈"</span>%self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">"汇森"</span>)</span><br><span class="line">setattr(p,<span class="string">"talk"</span>,abc)   <span class="comment"># 将abc函数添加到对象中p中，并命名为talk</span></span><br><span class="line">p.talk(p)               <span class="comment"># 调用talk方法，因为这是额外添加的方法，需手动传入对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果 汇森正在交谈</span></span><br><span class="line"></span><br><span class="line">setattr(p,<span class="string">"age"</span>,<span class="number">30</span>)     <span class="comment"># 添加一个变量age,复制为30</span></span><br><span class="line">print(p.age)            <span class="comment"># 打印结果:30</span></span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></li><li><p><strong>delattr删除对象中的变量。注意：不能用于删除方法</strong></p><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s正在交谈"</span>%self.name)</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">"汇森"</span>)</span><br><span class="line"></span><br><span class="line">delattr(p,<span class="string">"name"</span>)       <span class="comment"># 删除name变量</span></span><br><span class="line">print(p.name)           <span class="comment"># 此时将报错</span></span><br><span class="line"><span class="number">12345678910</span></span><br></pre></li></ul><h3 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h3><h4 id="1-深拷贝浅拷贝"><a href="#1-深拷贝浅拷贝" class="headerlink" title="1. 深拷贝浅拷贝"></a>1. 深拷贝浅拷贝</h4><p><strong>1.1 预备知识一——python的变量及其存储</strong></p><ol><li>python的一切变量都是对象，变量的存储，采用了引用语义的方式，存储的只是一个变量的值所在的内存地址，而不是这个变量的只本身</li><li>不管多么复杂的数据结构，浅拷贝都只会copy一层。<br>理解：两个人公用一张桌子，只要桌子不变，桌子上的菜发生了变化两个人是共同感受的。</li></ol><p><strong>1.2 浅copy与deepcopy</strong></p><ol><li>浅copy： 不管多么复杂的数据结构，浅拷贝都只会copy一层</li><li>deepcopy : 深拷贝会完全复制原变量相关的所有数据，在内存中生成一套完全一样的内容，我们对这两个变量中任意一个修改都不会影响其他变量</li></ol><pre class="highlight"><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">sourceList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">copyList = copy.copy(sourceList)</span><br><span class="line">deepcopyList = copy.deepcopy(sourceList)</span><br><span class="line"></span><br><span class="line">sourceList[<span class="number">3</span>][<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line"></span><br><span class="line">print(sourceList)           <span class="comment"># [1, 2, 3, [100, 5, 6]]</span></span><br><span class="line">print(copyList)             <span class="comment"># [1, 2, 3, [100, 5, 6]]</span></span><br><span class="line">print(deepcopyList)         <span class="comment"># [1, 2, 3, [4, 5, 6]]</span></span><br></pre><h4 id="2-python垃圾回收机制"><a href="#2-python垃圾回收机制" class="headerlink" title="2. python垃圾回收机制"></a>2. python垃圾回收机制</h4><p><strong>2.1 引用计数:</strong></p><ol><li>当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁时，对象的引用计数减1.</li><li>当对象的引用计数减少为0时，就意味着对象已经再没有被使用了，可以将其内存释放掉。</li></ol><p><strong>2.2 标记－清除:</strong></p><ol><li>它分为两个阶段：第一阶段是标记阶段，GC会把所有的活动对象打上标记，第二阶段是把那些没有标记的对象非活动对象进行回收。</li><li>对象之间通过引用（指针）连在一起，构成一个有向图</li><li>从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象，根对象就是全局变量、调用栈、寄存器。</li></ol><pre class="highlight"><span class="line">注：像是PyIntObject、PyStringObject这些不可变对象是不可能产生循环引用的，因为它们内部不可能持有其它对象的引用。</span><br></pre><p><img src="https://img-blog.csdnimg.cn/2020012811083048.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/2020012811083048.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><ol><li>在上图中，可以从程序变量直接访问块1，并且可以间接访问块2和3,程序无法访问块4和5</li><li>第一步将标记块1，并记住块2和3以供稍后处理。</li><li>第二步将标记块2，第三步将标记块3，但不记得块2，因为它已被标记。</li><li>扫描阶段将忽略块1，2和3，因为它们已被标记，但会回收块4和5。</li></ol><p><strong>2.3 分代回收：</strong></p><ol><li>分代回收是建立在标记清除技术基础之上的，是一种以空间换时间的操作方式。</li><li>Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代）</li><li>他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。</li><li>新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发</li><li>把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推</li><li>老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。</li></ol><h4 id="3-上下文管理"><a href="#3-上下文管理" class="headerlink" title="3 上下文管理"></a>3 上下文管理</h4><p><strong>3.1 什么是with语句</strong></p><ol><li>with是一种上下文管理协议，目的在于从流程图中把 try,except 和finally 关键字和资源分配释放相关代码统统去掉，简化try….except….finlally的处理流程。</li><li>所以使用with处理的对象必须有enter()和exit()这两个方法<ol><li>with通过enter方法初始化（enter方法在语句体执行之前进入运行）<ol start="2"><li>然后在exit中做善后以及处理异常（exit()方法在语句体执行完毕退出后运行）</li></ol></li></ol></li></ol><p><strong>3.2 with语句使用场景</strong></p><ol><li>with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源</li><li>比如文件使用后自动关闭、线程中锁的自动获取和释放等。</li></ol><p><strong>3.3 with处理文件操作的实例</strong></p><pre class="highlight"><span class="line"><span class="keyword">with</span> open(<span class="string">'/etc/passwd'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">print(line)</span><br><span class="line"><span class="comment"># 这段代码的作用：打开一个文件，如果一切正常，把文件对象赋值给f，然后用迭代器遍历文件中每一行，当完成时，关闭文件；</span></span><br><span class="line"><span class="comment"># 而无论在这段代码的任何地方，如果发生异常，此时文件仍会被关闭。</span></span><br></pre><h4 id="4-高阶函数"><a href="#4-高阶函数" class="headerlink" title="4 高阶函数"></a>4 高阶函数</h4><p><strong>4.1 lambda基本使用</strong></p><ol><li>lambda只是一个表达式，函数体比def简单很多。</li><li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li><li>lambda表达式是起到一个函数速写的作用。允许在代码内嵌入一个函数的定义。</li><li>格式：lambda的一般形式是关键字lambda后面跟一个或多个参数，紧跟一个冒号，之后是一个表达式。</li></ol><pre class="highlight"><span class="line">f = <span class="keyword">lambda</span> x,y,z:x+y+z</span><br><span class="line">print(f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))                    <span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line">my_lambda = <span class="keyword">lambda</span> arg : arg + <span class="number">1</span></span><br><span class="line">print(my_lambda(<span class="number">10</span>))                <span class="comment"># 11</span></span><br><span class="line"><span class="number">12345</span></span><br></pre><p><strong>4.2 三元运算:</strong></p><ol><li>三元运算格式： result=值1 if x&lt;y else 值2 if条件成立result=1,否则result=2</li><li>作用：三元运算，又称三目运算，主要作用是减少代码量，是对简单的条件语句的缩写</li></ol><pre class="highlight"><span class="line">name = <span class="string">'Tom'</span> <span class="keyword">if</span> <span class="number">1</span> == <span class="number">1</span> <span class="keyword">else</span> <span class="string">'fly'</span></span><br><span class="line">print(name)</span><br><span class="line"><span class="comment"># 运行结果： Tom</span></span><br><span class="line"></span><br><span class="line">f = <span class="keyword">lambda</span> x:x <span class="keyword">if</span> x % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">else</span> x + <span class="number">100</span></span><br><span class="line">print(f(<span class="number">10</span>))                    <span class="comment"># 110</span></span><br></pre><h5 id="map-函数用法："><a href="#map-函数用法：" class="headerlink" title="map()函数用法："></a>map()函数用法：</h5><p><strong>map(function, iterable, …)</strong><br><strong>功能：</strong></p><ul><li>将第一个参数 function 依次作用在参数可迭代对象中的每一个元素上，返回包含每次 function 函数返回值的新迭代器</li><li>map() 会根据提供的函数对指定序列做映射。(映射及对应)</li><li>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</li></ul><p><strong>参数：</strong><br>function – 函数，有两个参数<br>iterable – 一个或多个可迭代对象（如：序列）</p><p><strong>返回值：</strong><br>Python 3.x 返回迭代器</p><pre class="highlight"><span class="line"><span class="comment"># demo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line">ret = map(func, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">print(list(ret))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre><h5 id="reduce-函数语法"><a href="#reduce-函数语法" class="headerlink" title="reduce()函数语法"></a>reduce()函数语法</h5><p><strong>reduce(function, iterable[, initializer])</strong><br><strong>功能：</strong></p><ul><li>函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。<br>其效果类似：reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</li><li>reduce() 函数会对参数序列中元素进行累积。</li><li>函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</li></ul><p><strong>参数：</strong><br>function – 函数，有两个参数<br>iterable – 可迭代对象<br>initializer – 可选，初始参数</p><p><strong>返回值：</strong><br>返回函数计算结果。</p><pre class="highlight"><span class="line"><span class="comment"># demo:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"> </span><br><span class="line">r = reduce(add, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line">print(r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 运行结果：</span></span><br><span class="line"><span class="number">25</span></span><br></pre><h5 id="filter-函数："><a href="#filter-函数：" class="headerlink" title="filter()函数："></a>filter()函数：</h5><p><strong>filter(function, iterable)</strong><br><strong>功能</strong></p><ul><li>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新迭代器对象中</li><li>filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</li></ul><p><strong>参数：</strong><br>function – 判断函数<br>iterable – 可迭代对象（如：序列）</p><p><strong>返回值：</strong><br>返回一个迭代器对象</p><pre class="highlight"><span class="line"><span class="comment"># demo：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">tmplist = filter(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">newlist = list(tmplist)</span><br><span class="line">print(newlist)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre><h5 id="sorted-函数"><a href="#sorted-函数" class="headerlink" title="sorted()函数"></a>sorted()函数</h5><p><strong>sorted(iterable, key=abs, reverse=False)</strong><br><strong>功能:</strong></p><ul><li>对所有可迭代的对象进行排序操作</li></ul><p><strong>参数:</strong><br>iterable – 可迭代对象。<br>key – key指定的函数将作用于可迭代对象上的每一个元素，并根据key函数返回的结果进行排序<br>reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）</p><p><strong>返回值:</strong><br>返回重新排序的列表</p><pre class="highlight"><span class="line"><span class="comment"># demo:</span></span><br><span class="line"></span><br><span class="line">print(sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>]))</span><br><span class="line">运行结果：[<span class="number">-21</span>, <span class="number">-12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">36</span>]</span><br><span class="line">print(sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>], key=abs))</span><br><span class="line"></span><br><span class="line"><span class="comment">#abs 匿名函数</span></span><br><span class="line">运行结果：[<span class="number">5</span>, <span class="number">9</span>, <span class="number">-12</span>, <span class="number">-21</span>, <span class="number">36</span>]</span><br></pre><h5 id="返回函数："><a href="#返回函数：" class="headerlink" title="返回函数："></a>返回函数：</h5><p><strong>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</strong></p><pre class="highlight"><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></span><br><span class="line">        ax = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        <span class="keyword">return</span> ax</span><br><span class="line">    <span class="keyword">return</span> sum        <span class="comment">#将定义的函数sum()作为结果值返回</span></span><br><span class="line"> </span><br><span class="line">f = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">f()</span><br></pre><p><strong>4.3 filter()函数可以对序列做过滤处理</strong></p><p>利用 filter、lambda表达式 获取l1中元素小于33的所有元素 l1 = [11, 22, 33, 44, 55]</p><pre class="highlight"><span class="line">l1= [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>]</span><br><span class="line">a = filter(<span class="keyword">lambda</span> x: x&lt;<span class="number">33</span>, l1)</span><br><span class="line">print(list(a))</span><br></pre><p><strong>4.4 Map是对序列根据设定条件进行操作后返回他设置的是操作方法</strong><br><code>利用map，lambda表达式将所有偶数元素加100</code></p><pre class="highlight"><span class="line">l1= [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>]</span><br><span class="line">ret = map(<span class="keyword">lambda</span> x:x <span class="keyword">if</span> x % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">else</span> x + <span class="number">100</span>,l1)</span><br><span class="line">print(list(ret))</span><br><span class="line"><span class="comment"># 运行结果： [11, 122, 33, 144, 55]</span></span><br></pre><p><strong>4.5 reduce函数</strong></p><p>使用reduce进行求和运算</p><ol><li>reduce()函数即为化简函数，它的执行过程为：每一次迭代，都将上一次的迭代结果与下一个元素一同传入二元func函数中去执行。</li><li>在reduce()函数中，init是可选的，如果指定，则作为第一次迭代的第一个元素使用，如果没有指定，就取seq中的第一个元素。</li></ol><pre class="highlight"><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span></span><br><span class="line"> <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">print(reduce(f, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]))  <span class="comment"># 25</span></span><br><span class="line"><span class="comment"># 1、先计算头两个元素：f(1, 3)，结果为4；</span></span><br><span class="line"><span class="comment"># 2、再把结果和第3个元素计算：f(4, 5)，结果为9；</span></span><br><span class="line"><span class="comment"># 3、再把结果和第4个元素计算：f(9, 7)，结果为16；</span></span><br><span class="line"><span class="comment"># 4、再把结果和第5个元素计算：f(16, 9)，结果为25；</span></span><br><span class="line"><span class="comment"># 5、由于没有更多的元素了，计算结束，返回结果25。</span></span><br><span class="line"></span><br><span class="line">print( reduce(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])  )  <span class="comment"># 25</span></span><br></pre><p><strong>4.6 sorted函数</strong></p><p>sorted对字典排序</p><pre class="highlight"><span class="line">d = &#123;<span class="string">'k1'</span>:<span class="number">1</span>, <span class="string">'k3'</span>: <span class="number">3</span>, <span class="string">'k2'</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment"># d.items() = [('k1', 1), ('k3', 3), ('k2', 2)]</span></span><br><span class="line">a = sorted(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">print(a)            <span class="comment"># [('k1', 1), ('k2', 2), ('k3', 3)]</span></span><br></pre><hr><h3 id="subprocess模块"><a href="#subprocess模块" class="headerlink" title="subprocess模块"></a>subprocess模块</h3><p>subprocess是Python 2.4中新增的一个模块，它允许你生成新的进程，连接到它们的 input/output/error 管道，并获取它们的返回（状态）码。这个模块的目的在于替换几个旧的模块和方法，如：</p><ul><li>os.system</li><li>os.spawn*</li></ul><h5 id="subprocess模块中的常用函数"><a href="#subprocess模块中的常用函数" class="headerlink" title="subprocess模块中的常用函数"></a>subprocess模块中的常用函数</h5><ul><li><strong>subprocess.run()</strong><br>Python 3.5中新增的函数。执行指定的命令，等待命令执行完成后返回一个包含执行结果的CompletedProcess类的实例。</li><li><strong>subprocess.call()</strong><br>执行指定的命令，返回命令执行状态，其功能类似于os.system(cmd)。</li><li><strong>subprocess.check_call()</strong><br>Python 2.5中新增的函数。 执行指定的命令，如果执行成功则返回状态码，否则抛出异常。其功能等价于subprocess.run(…, check=True)。</li><li><strong>subprocess.check_output()</strong><br>Python 2.7中新增的的函数。执行指定的命令，如果执行状态码为0则返回命令执行结果，否则抛出异常。</li><li><strong>subprocess.getoutput(cmd)</strong><br>接收字符串格式的命令，执行命令并返回执行结果，其功能类似于<br>os.popen(cmd).read()和commands.getoutput(cmd)。</li><li><strong>subprocess.getstatusoutput(cmd)</strong><br>执行cmd命令，返回一个元组(命令执行状态, 命令执行结果输出)，其功能类似于commands.getstatusoutput()。</li></ul><h3 id="paramiko模块"><a href="#paramiko模块" class="headerlink" title="paramiko模块"></a>paramiko模块</h3><p>paramiko是一个用于做远程控制的模块，使用该模块可以对远程服务器进行命令或文件操作,paramiko是用python语言写的一个模块，遵循SSH2协议，支持以加密和认证的方式，进行远程服务器的连接。</p><p>由于使用的是python这样的能够跨平台运行的语言，所以所有python支持的平台，如Linux, Solaris, BSD, MacOS X, Windows等，paramiko都可以支持，因此，如果需要使用SSH从一个平台连接到另外一个平台，进行一系列的操作时，paramiko是最佳工具之一。</p><h4 id="python２和python３的区别："><a href="#python２和python３的区别：" class="headerlink" title="python２和python３的区别："></a>python２和python３的区别：</h4><ol><li>python2 解释器默认编码：ascii　　python3 解释器默认编码：utf-8</li><li>range在Python2中返回列表，而在Python3中返回range可迭代对象。</li><li>在Python2中有两个不等运算符!=和&lt;&gt;，在Python3中去掉了&lt;&gt;，只有!=符号表示不等</li><li>在Python2中long是比int取值范围更大的整数，Python3中取消了long类型，int的取值范围扩大到之前的long类型范围。</li><li>python2 的代码混乱，重复较多，冗余。python3源码规范、清晰、简单优美。</li><li>python3x：unicode 默认是4个字节表示一个字符、python2x :unicode 默认2个字节表示一个字符</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python知识点&quot;&gt;&lt;a href=&quot;#Python知识点&quot; class=&quot;headerlink&quot; title=&quot;Python知识点&quot;&gt;&lt;/a&gt;Python知识点&lt;/h2&gt;&lt;h3 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="python" scheme="https://github.com/vp1009/vp1009.github.io.git/categories/python/"/>
    
    
      <category term="python" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django + uWSGI + Nginx 的生产环境部署，及WSGI &amp; uwsgi &amp; uWSGI 的作用</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/08/29/Django%20+%20uWSGI%20+%20Nginx%20%E7%9A%84%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%8F%8AWSGI%20&amp;%20uwsgi%20&amp;%20uWSGI%20%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/08/29/Django%20+%20uWSGI%20+%20Nginx%20%E7%9A%84%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%8F%8AWSGI%20&amp;%20uwsgi%20&amp;%20uWSGI%20%E7%9A%84%E4%BD%9C%E7%94%A8/</id>
    <published>2020-08-28T16:18:29.000Z</published>
    <updated>2020-09-13T12:02:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>uWSGI的 <a href="https://blog.csdn.net/weixin_44685869/article/details/103951161" target="_blank" rel="noopener">介绍 看这里</a></p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><ol><li>Nginx是一个Web服务器,其中的HTTP服务器功能和uWSGI功能很类似</li><li>但是Nginx还可以用作更多用途，比如最常用的反向代理、负载均衡、拦截攻击等，而且性能极高</li></ol><h4 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h4><ol><li>Django是一个Web框架，框架的作用在于处理request和 reponse，其他的不是框架所关心的内容。</li><li>所以如何部署Django不是Django所需要关心的。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200304220900982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200304220900982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><pre class="highlight"><span class="line">这里举个小例子：</span><br><span class="line">我们的浏览器是 出生在海外的华侨，通过HTTP(飞机) 从 Nginx(日本) 回到  (Python 中国)</span><br><span class="line">下飞机 到了之后发现语言不通，急忙的找到了我。</span><br><span class="line">他说日语(uwsgi)“こんにちは“</span><br><span class="line">我会日语啊 我把这句话 转换成了 汉语(uWSGI)给 别人听</span><br><span class="line">这样就可以 在 中国(Python) 让日本人(浏览器) 生活了。</span><br><span class="line">但是 博主是东北人 光会转义 日语-&gt;普通话 还不行 还要和我的家人们说东北话(WSGI)</span><br><span class="line">此时 就已经非常完美的解决了语言不通的问题了。</span><br><span class="line">12345678</span><br></pre><ul><li>请求处理整体流程</li></ul><ol><li>nginx接收到浏览器发送过来的http请求，将包进行解析，分析url</li><li>静态文件请求：就直接访问用户给nginx配置的静态文件目录，直接返回用户请求的静态文件</li><li>动态接口请求：那么nginx就将请求转发给uWSGI，最后到达django处理</li></ol><ul><li>各模块作用</li></ul><ol><li><p>nginx：是对外的服务器，外部浏览器通过url访问nginx，nginx主要处理静态请求</p></li><li><p>uWSGI：是对内的服务器，主要用来处理动态请求</p></li><li><p>uwsgi：是一种web协议，接收到请求之后将包进行处理，处理成wsgi可以接受的格式，并发给wsgi</p></li><li><p>wsgi：是python专用的web协议，根据请求调用应用程序（django）的某个文件，某个文件的某个函数</p></li><li><p>django：是真正干活的，查询数据等资源，把处理的结果再次返回给WSGI， WSGI 将返回值进行打包，打包成uwsgi能够接收的格式</p></li><li><p>uwsgi接收wsgi发送的请求，并转发给nginx,nginx最终将返回值返回给浏览器</p></li></ol><h3 id="Django-uwsgi方案"><a href="#Django-uwsgi方案" class="headerlink" title="Django + uwsgi方案"></a>Django + uwsgi方案</h3><ol><li>没有nginx而只有uwsgi的服务器，则是Internet请求直接由uwsgi处理，并反馈到web项目中。</li><li>nginx可以实现安全过滤，防DDOS等保护安全的操作，并且如果配置了多台服务器，nginx可以保证服务器的负载相对均衡。</li><li>而uwsgi则是一个web服务器，实现了WSGI协议(Web Server Gateway Interface)，http协议等，它可以接收和处理请求，发出响应等。<br>所以只用uwsgi也是可以的。</li></ol><h3 id="nginx和uWSGI特点"><a href="#nginx和uWSGI特点" class="headerlink" title="nginx和uWSGI特点"></a>nginx和uWSGI特点</h3><ul><li>nginx的作用</li></ul><ol><li>反向代理，可以拦截一些web攻击，保护后端的web服务器</li><li>负载均衡，根据轮询算法，分配请求到多节点web服务器</li><li>缓存静态资源，加快访问速度，释放web服务器的内存占用，专项专用</li></ol><ul><li>uWSGI的适用</li></ul><ol><li><p>单节点服务器的简易部署</p></li><li><p>轻量级，好部署</p></li></ol><p>Django + Uwsgi + Nginx 的生产环境部署</p><h4 id="在centos-7中安装python3环境"><a href="#在centos-7中安装python3环境" class="headerlink" title="在centos 7中安装python3环境"></a>在centos 7中安装python3环境</h4><pre class="highlight"><span class="line"><span class="comment"># 1、yum更新yum源</span></span><br><span class="line">yum update</span><br><span class="line"><span class="comment"># 2、安装Python 3.7所需的依赖否则安装后没有pip3包</span></span><br><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make</span><br><span class="line"><span class="comment"># 3、在官网下载所需版本，这里用的是3.7.0版本</span></span><br><span class="line">wget https://www.python.org/ftp/<span class="number">3.7</span><span class="number">.0</span>/Python<span class="number">-3.7</span><span class="number">.0</span>.tgz</span><br><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="comment"># 1、yum更新yum源</span></span><br><span class="line">yum update</span><br><span class="line"><span class="comment"># 2、安装Python 3.7所需的依赖否则安装后没有pip3包</span></span><br><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make</span><br><span class="line"><span class="comment"># 3、在官网下载所需版本，这里用的是3.7.0版本</span></span><br><span class="line">wget https://www.python.org/ftp/<span class="number">3.7</span><span class="number">.0</span>/Python<span class="number">-3.7</span><span class="number">.0</span>.tgz</span><br><span class="line">　　<span class="number">2</span>、安装Python</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、解压</span></span><br><span class="line">tar -xvf Python<span class="number">-3.7</span><span class="number">.0</span>.tgz</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、配置编译</span></span><br><span class="line">cd Python<span class="number">-3.7</span><span class="number">.0</span></span><br><span class="line">./configure --prefix=/usr/local/python3  <span class="comment"># 配置编译的的路径（这里--prefix是指定编译安装的文件夹）</span></span><br><span class="line">./configure --enable-optimizations  <span class="comment"># 执行该代码后，会编译安装到 /usr/local/bin/ 下，且不用添加软连接或环境变量</span></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">ln -s /usr/local/python3/bin/python3 /usr/bin/python3  <span class="comment"># 添加软连接</span></span><br><span class="line">ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、将/usr/local/python3/bin加入PATH</span></span><br><span class="line">[root@linux-node1 testProj]<span class="comment"># vim /etc/profile</span></span><br><span class="line"><span class="comment">#然后在文件末尾添加</span></span><br><span class="line">export PATH=$PATH:/usr/local/python3/bin</span><br><span class="line"></span><br><span class="line">[root@linux-node1 testProj]<span class="comment"># source /etc/profile # 修改完后，还需要让这个环境变量在配置信息中生效，执行命令</span></span><br></pre><h4 id="初始化一个django项目"><a href="#初始化一个django项目" class="headerlink" title="初始化一个django项目"></a>初始化一个django项目</h4><pre class="highlight"><span class="line"><span class="comment"># 初始化一个django项目</span></span><br><span class="line"></span><br><span class="line">[root@linux-node1 /] pip3 install django==<span class="number">2.0</span><span class="number">.4</span></span><br><span class="line">[root@linux-node1 /] mkdir /code/</span><br><span class="line">[root@linux-node1 /] cd /code/</span><br><span class="line">[root@linux-node1 testProj] django-admin startproject mmcsite</span><br><span class="line">[root@linux-node1 testProj] cd /code/mmcsite</span><br><span class="line">[root@linux-node1 testProj] python3 manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span></span><br><span class="line"></span><br><span class="line">页面中访问：http://<span class="number">192.168</span><span class="number">.56</span><span class="number">.11</span>:<span class="number">8000</span>/</span><br></pre><h4 id="安装uwsgi-并使用uWSGI启动这个服务"><a href="#安装uwsgi-并使用uWSGI启动这个服务" class="headerlink" title="安装uwsgi 并使用uWSGI启动这个服务"></a>安装uwsgi 并使用uWSGI启动这个服务</h4><pre class="highlight"><span class="line"><span class="string">'''1. 安装uwsgi'''</span></span><br><span class="line">[root@linux-node1 /]<span class="comment"># pip3 install uwsgi</span></span><br><span class="line">[root@linux-node1 /]<span class="comment"># ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''2. 配置uwsgi.ini启动文件'''</span></span><br><span class="line">[root@linux-node1 /]<span class="comment"># vim uwsgi.ini</span></span><br><span class="line">[uwsgi]</span><br><span class="line">socket = <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">3031</span></span><br><span class="line">chdir = /code/mmcsite</span><br><span class="line">wsgi-file = /code/mmcsite/wsgi.py</span><br><span class="line">processes = <span class="number">5</span></span><br><span class="line">threads = <span class="number">30</span></span><br><span class="line">master = true</span><br><span class="line">daemonize = /code/mmcsite/uwsgi.log</span><br><span class="line">module=mmcsite.wsgi</span><br><span class="line">pidfile = /code/mmcsite/uwsgi.pid</span><br><span class="line">chmod-socket=<span class="number">666</span></span><br><span class="line">enable-threads = true</span><br><span class="line"></span><br><span class="line"><span class="string">'''3. 使用uwsgi启动django：一定要在这个项目目录中'''</span></span><br><span class="line">[root@linux-node1 /]<span class="comment"># uwsgi --http 192.168.56.11:80 --file mmcsite/wsgi.py --static-map=/static=static</span></span><br><span class="line">访问项目：http://<span class="number">192.168</span><span class="number">.56</span><span class="number">.11</span></span><br><span class="line"></span><br><span class="line">[root@linux-node2 demo2]<span class="comment"># vim /code/mmcsite/uwsgi.ini  # uwsgi.ini文件</span></span><br><span class="line">[uwsgi]</span><br><span class="line">socket = <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">3031</span>                  <span class="comment"># 指定socket监听的地址和端口</span></span><br><span class="line">chdir = /code/mmcsite                  <span class="comment"># 项目路径 </span></span><br><span class="line">wsgi-file = /code/mmcsite/wsgi.py      <span class="comment"># django的wsgi文件路径</span></span><br><span class="line">processes = <span class="number">5</span>                          <span class="comment"># 启动五个进程</span></span><br><span class="line">threads = <span class="number">30</span>                           <span class="comment"># 每个进程启动30个线程</span></span><br><span class="line">master = true</span><br><span class="line">daemonize = /code/mmcsite/uwsgi.log    <span class="comment"># 日志存放路径</span></span><br><span class="line">module=mmcsite.wsgi                    <span class="comment"># 使用mmcsite.wsgi模块</span></span><br><span class="line">pidfile = /code/mmcsite/uwsgi.pid      <span class="comment"># uwsgi启动进程id存放路径</span></span><br><span class="line">chmod-socket=<span class="number">666</span>                       <span class="comment"># socket权限</span></span><br><span class="line">enable-threads = true                  <span class="comment"># 允许用内嵌的语言启动线程，这将允许你在app程序中产生一个子线程</span></span><br></pre><h4 id="安装配置nginx"><a href="#安装配置nginx" class="headerlink" title="安装配置nginx"></a>安装配置nginx</h4><pre class="highlight"><span class="line"><span class="string">'''1. 配置nginx YUM源'''</span></span><br><span class="line">[root@linux-node1 /] vim /etc/yum.repos.d/nginx.repo</span><br><span class="line"><span class="number">12</span></span><br></pre><p>[nginx]<br>name=nginx repo</p><h1 id="下面这行centos根据你自己的操作系统修改比如：OS-rehel"><a href="#下面这行centos根据你自己的操作系统修改比如：OS-rehel" class="headerlink" title="下面这行centos根据你自己的操作系统修改比如：OS/rehel"></a>下面这行centos根据你自己的操作系统修改比如：OS/rehel</h1><h1 id="6是你Linux系统的版本，可以通过URL查看路径是否正确"><a href="#6是你Linux系统的版本，可以通过URL查看路径是否正确" class="headerlink" title="6是你Linux系统的版本，可以通过URL查看路径是否正确"></a>6是你Linux系统的版本，可以通过URL查看路径是否正确</h1><p>baseurl=<a href="http://nginx.org/packages/centos/7/$basearch/" target="_blank" rel="noopener">http://nginx.org/packages/centos/7/$basearch/</a><br>gpgcheck=0<br>enabled=1</p><pre class="highlight"><span class="line">&#39;&#39;&#39;2. 安装nginx&#39;&#39;&#39;</span><br><span class="line">[root@linux-node1 &#x2F;] yum -y install nginx</span><br><span class="line"></span><br><span class="line">安装nginx</span><br><span class="line">1234</span><br><span class="line">[root@linux-node1 &#x2F;]# vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;django.conf </span><br><span class="line">server &#123;</span><br><span class="line">    listen       8888;</span><br><span class="line">    server_name  192.168.56.11;</span><br><span class="line">    client_max_body_size 5M;</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_buffers 32 4K;#压缩在内存中缓冲32块 每块4K</span><br><span class="line">    gzip_comp_level 6 ;#压缩级别 推荐6</span><br><span class="line">    gzip_min_length 4000;#开始压缩的最小长度4bit</span><br><span class="line">        gzip_types text&#x2F;plain application&#x2F;json application&#x2F;javascript application&#x2F;x-javascript application&#x2F;css application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript application&#x2F;x-httpd-php image&#x2F;jpeg image&#x2F;gif image&#x2F;png image&#x2F;x-ms-bmp;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">              include uwsgi_params;</span><br><span class="line">              uwsgi_pass 127.0.0.1:3031;</span><br><span class="line">              uwsgi_ignore_client_abort on;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 &#x2F;404.html;</span><br><span class="line">            location &#x3D; &#x2F;40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 &#x2F;50x.html;</span><br><span class="line">            location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">配置nginx</span><br></pre><h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><pre class="highlight"><span class="line">[root@linux-node1 demo2]<span class="comment"># systemctl restart nginx   # 开启nginx</span></span><br><span class="line">[root@linux-node1 demo2]<span class="comment"># uwsgi --ini uwsgi.ini     # 启动uwsgi的django项目</span></span><br><span class="line"><span class="comment"># http://192.168.56.11:8888/ 访问项目</span></span><br><span class="line">[root@linux-node1 demo2]<span class="comment"># uwsgi --stop uwsgi.pid    # 关闭uwsgi</span></span><br></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;uWSGI的 &lt;a href=&quot;https://blog.csdn.net/weixin_44685869/article/details/103951161&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;介绍 看这里&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;Ng
      
    
    </summary>
    
    
      <category term="docker" scheme="https://github.com/vp1009/vp1009.github.io.git/categories/docker/"/>
    
    
      <category term="python" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Docker 的基本常用命令</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/08/27/Docker%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/08/27/Docker%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-08-26T18:18:06.000Z</published>
    <updated>2020-09-13T12:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200304173914455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200304173914455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" class="lozad post-image"></p><p>docker 镜像管理常用命令</p><table><thead><tr><th>命令</th><th>示意</th></tr></thead><tbody><tr><td>docker help</td><td>查看docker帮助</td></tr><tr><td>docker image –help</td><td>查看 docker中 镜像相关帮助</td></tr><tr><td>docker image ls</td><td>查看当前所有镜像</td></tr><tr><td>docker image inspect nginx</td><td>查看指定镜像（nginx镜像）详细信息</td></tr><tr><td>docker pull nginx:1.14</td><td>下载指定版本镜像 nginx</td></tr><tr><td>docker image rm nginx:1.14</td><td>删除nginx 1.14版本</td></tr><tr><td>docker image save nginx &gt; nginx.tar</td><td>导出niginx镜像</td></tr></tbody></table><p>docker创建容器常用命令</p><p>docker run 常用参数</p><table><thead><tr><th>命令</th><th>示意</th></tr></thead><tbody><tr><td>-d:</td><td>后台运行容器，并返回容器ID；</td></tr><tr><td>-i:</td><td>以交互模式运行容器，通常与 -t 同时使用；</td></tr><tr><td>-t:</td><td>为容器重新分配一个伪输入终端，通常与 -i 同时使用；</td></tr><tr><td>-P:</td><td>随机端口映射，容器内部端口随机映射到主机的高端口</td></tr><tr><td>-p:</td><td>指定端口映射，格式为：主机(宿主)端口:容器端口</td></tr><tr><td>–name=“nginx-lb”:</td><td>为容器指定一个名称；</td></tr><tr><td>–dns 8.8.8.8:</td><td>指定容器使用的DNS服务器，默认和宿主一致；</td></tr></tbody></table><p>docker run 其他参数</p><table><thead><tr><th>命令</th><th>示意</th></tr></thead><tbody><tr><td>–dns-search example.com:</td><td>指定容器DNS搜索域名，默认和宿主一致；</td></tr><tr><td>-h “mars”:</td><td>指定容器的hostname；</td></tr><tr><td>-e username=“ritchie”:</td><td>设置环境变量；</td></tr><tr><td>–env-file=[]:</td><td>从指定文件读入环境变量；</td></tr><tr><td>–cpuset=“0-2” or –cpuset=“0,1,2”:</td><td>绑定容器到指定CPU运行；</td></tr><tr><td>-m :</td><td>设置容器使用内存最大值；</td></tr><tr><td>–net=“bridge”:</td><td>指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</td></tr><tr><td>–link=[]:</td><td>添加链接到另一个容器；</td></tr><tr><td>–expose=[]:</td><td>开放一个端口或一组端口；</td></tr><tr><td>–volume , -v:</td><td>绑定一个卷</td></tr><tr><td>-a stdin:</td><td>指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</td></tr><tr><td>docker run</td><td>其他参数</td></tr></tbody></table><table><thead><tr><th>命令</th><th>示意</th></tr></thead><tbody><tr><td>docker run –help</td><td>查看创建容器帮助</td></tr><tr><td>docker run -it centos</td><td>创建centos镜像并进入终端</td></tr><tr><td>docker run -d nginx</td><td>后台启动nginx容器</td></tr><tr><td>docker stop 6bb09dce461f</td><td>关闭一个容器</td></tr><tr><td>docker ps -l</td><td>查看最近运行的容器</td></tr><tr><td>docker run -itd centos</td><td>启用一个伪终端守护centos容器</td></tr><tr><td>docker container run -d –name web3 -e test=123456 -p 8800:80 -h webhostname –restart always nginx</td><td></td></tr><tr><td>-d</td><td>后台启动nginx容器</td></tr><tr><td>–name web3</td><td>自定义容器名字(默认会是一段随机字符串)</td></tr><tr><td>-e test=123456</td><td>启动容器添加变量 test=123456 (echo $test)</td></tr><tr><td>-p 8800:80</td><td>宿主机的8800端口映射到docker容器的80端口中</td></tr><tr><td>-h webhostname</td><td>docker容器主机名 (a300f394af88)</td></tr><tr><td>–restart always</td><td>宿主机重启自动拉起这个docker容器</td></tr><tr><td>nginx</td><td>使用这个nginx镜像启动容器</td></tr><tr><td>docker logs web</td><td>查看上面启动的web容器的日志</td></tr><tr><td>docker exec -it web bash</td><td>进入容器web</td></tr></tbody></table><h4 id="容器资源限制"><a href="#容器资源限制" class="headerlink" title="容器资源限制"></a>容器资源限制</h4><ol><li><p>内存限额： 允许容器最多使用500M内存和100M的Swap，并禁用 OOM Killer<br>docker run -d –name nginx03 –memory=“500m” –memory-swap=“600m” –oom-kill-disable nginx</p></li><li><p>CPU限额：<br>docker run -d –name nginx04 –cpus=“1.5” nginx # 允许容器最多使用一个半的CPU<br>docker run -d –name nginx05 –cpus=”.5” nginx # 允许容器最多使用50%的CPU</p></li></ol><p>docker 管理 容器常用命令</p><table><thead><tr><th>命令</th><th>示意</th></tr></thead><tbody><tr><td>docker ps</td><td>仅列出当前运行的容器</td></tr><tr><td>docker ps -l</td><td>列出最新创建得容器</td></tr><tr><td>docker ps -a</td><td>列出素有容器(包括 未运行的)</td></tr><tr><td>docker inspect web4</td><td>列出指定容器的详细信息</td></tr></tbody></table><p>持久化容器</p><table><thead><tr><th>docker exec -it web4 bash</th><th>进入容器web4中</th></tr></thead><tbody><tr><td>touch 1.txt 2.txt</td><td>对容器进行修改</td></tr><tr><td>docker commit web4 nginx:web4</td><td>将修改后的web4容器提交为一个新镜像 nginx:web4</td></tr><tr><td>docker images</td><td>可以看到 多了一个 TAG标记为 web4 的镜像</td></tr><tr><td>docker run -d –name web4-1 nginx:web4</td><td>使用刚刚提交的镜像web4创建一个容器web4-1</td></tr><tr><td>docker exec -it web4-1 bash</td><td>进入web4-1的bash环境</td></tr></tbody></table><p>从宿主机复制文件到docker容器</p><table><thead><tr><th>docker cp nginx.tar web4-1:/home</th><th>将宿主机nginx.tar文件拷贝到容器web4-1的/home目录中</th></tr></thead><tbody><tr><td>docker exec -it web4-1 ls /home</td><td>在容器web4-1中执行 “ls /home” 命令</td></tr></tbody></table><p>容器常用查询命令</p><table><thead><tr><th>docker logs web4-1</th><th>查看web4-1中控制台日志</th></tr></thead><tbody><tr><td>docker port 55f870061ed9</td><td>查看指定容器端口映射</td></tr><tr><td>docker top 00f7ddc96622</td><td>查看容器中有哪些进程</td></tr><tr><td>docker stats 00f7ddc96622</td><td>查看容器资源使用情况</td></tr></tbody></table><p>启动、停止、删除 容器</p><table><thead><tr><th>docker ps -a</th><th>列出素有容器(包括 未运行的)</th></tr></thead><tbody><tr><td>docker start web</td><td>启动容器web</td></tr><tr><td>docker stop web</td><td>停止容器web</td></tr><tr><td>docker rm web</td><td>删除容器</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200304173914455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM
      
    
    </summary>
    
    
      <category term="docker" scheme="https://github.com/vp1009/vp1009.github.io.git/categories/docker/"/>
    
    
      <category term="python" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Docker 镜像 &amp; 容器和镜像的联系 读写层</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/08/25/Docker%20%E9%95%9C%E5%83%8F%20&amp;%20%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E7%9A%84%E8%81%94%E7%B3%BB%20%E8%AF%BB%E5%86%99%E5%B1%82/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/08/25/Docker%20%E9%95%9C%E5%83%8F%20&amp;%20%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E7%9A%84%E8%81%94%E7%B3%BB%20%E8%AF%BB%E5%86%99%E5%B1%82/</id>
    <published>2020-08-24T17:24:07.000Z</published>
    <updated>2020-09-13T11:59:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200304131346637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200304131346637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" class="lozad post-image"></p><p>Docker 镜像</p><h4 id="镜像是什么？"><a href="#镜像是什么？" class="headerlink" title="镜像是什么？"></a>镜像是什么？</h4><ul><li>一个分层存储的文件</li><li>一个软件的环境</li><li>一个镜像可以创建N个容器</li><li>一个标准化的交付</li><li>一个不包含Linux内核而又精简的Linux操作系统</li></ul><p>人性化一点 ↓</p><ol><li>docker镜像不包含Linux内核而又精简的Linux操作系统</li><li>docker镜像是一个分层存储的文件，一个镜像可以创建N个容器</li><li>可以这么理解，docker 镜像是 docker 容器的静态视角，docker 容器是 docker 镜像的运行状态。</li><li>容器只是对docker镜像的引用，如果docker镜像删除，此镜像创建的容器也都失效</li></ol><p>镜像不是一个单一的文件，而是有多层结构。我们可以通过 docker history &lt;ID/NAME&gt; 查看镜像中各层内容及大小，每层对应着DOckerfile 中的一条命令。Docker镜像默认存储在 /var/lib/docker/<storage-driver>中。</p><p>是在驱动中 所以说目录下的文件都有可能 最佳推荐：<code>overlay2</code></p><pre class="highlight"><span class="line">docker info  查看</span><br><span class="line"></span><br><span class="line">Storage Driver: overlay2</span><br></pre><h4 id="镜像从哪里来的？"><a href="#镜像从哪里来的？" class="headerlink" title="镜像从哪里来的？"></a>镜像从哪里来的？</h4><p>Docker Hub 是由 Docker公司负责维护公共注册中心，包含大量的容器镜像，Docker工具默认从这个公共镜像库下载镜像<br>地址: <a href="https://hub.docker.com/explore" target="_blank" rel="noopener">https://hub.docker.com/explore</a></p><p>我们看一下 镜像默认源 docker info<br><img src="https://img-blog.csdnimg.cn/20200304134108864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200304134108864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>拿到了地址 我们 ping 一下<br><img src="https://img-blog.csdnimg.cn/20200304134254433.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200304134254433.png" class="lozad post-image"><br>amazonaws:亚马逊服务器<br>也可以浏览器 访问一下端口<br><img src="https://img-blog.csdnimg.cn/20200304134401377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200304134401377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><h5 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h5><p><a href="https://www.daocloud/mirror" target="_blank" rel="noopener">https://www.daocloud/mirror</a></p><pre class="highlight"><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh |sh -s http://f1361db2.m.daocloud.io</span><br><span class="line"><span class="number">1</span></span><br></pre><p>我们可以通过 命令查看 镜像加速的地址</p><pre class="highlight"><span class="line">cat /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">&#123;<span class="string">"registry-mirrors"</span>: [<span class="string">"http://f1361db2.m.daocloud.io"</span>]&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre><p>配置完 重启docker</p><pre class="highlight"><span class="line">systemctl restart docker</span><br><span class="line"><span class="number">1</span></span><br></pre><p>Docker 镜像和容器的联系、区别</p><p><img src="https://img-blog.csdnimg.cn/20200304142824563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200304142824563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>图中可以看出</p><ul><li>容器其实是在镜像的最上面加了一层读写层，在运行容器里文件改动时，会先从镜像里要写的文件复制到容器自己的文件系统中（读写层）。</li><li>如果容器删除了，最上面的读写层也就删除了，改动也就丢失了。</li><li>所以无论多少个容器共享一个镜像，所做的写操作都是从镜像的文件系统中复制（引用）过来的操作的，并不会修改镜像的源文件，这种方式提高磁盘利用率。</li><li>若想持久化这些改动，可以通过 docker commit 将容器保存成一个新的镜像。</li></ul><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><pre class="highlight"><span class="line"><span class="comment"># 创建 nginx容器</span></span><br><span class="line">docker run -itd nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="number">12345</span></span><br></pre><p><img src="https://img-blog.csdnimg.cn/20200304143630125.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200304143630125.png" class="lozad post-image"><br>我们访问这个 容器的ID</p><pre class="highlight"><span class="line"><span class="comment"># 进入镜像</span></span><br><span class="line">docker <span class="keyword">exec</span> -it <span class="number">5</span>ceaf43bd114 bash</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line"><span class="number">1234</span></span><br></pre><p><img src="https://img-blog.csdnimg.cn/20200304143824221.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200304143824221.png" class="lozad post-image"><br>可以看出这个是和 镜像一样的。由此证出，docker 容器只是对 镜像进行了引用</p><p><code>***</code><br>读写层的意思就是说，</p><ul><li><p>镜像会将所有数据拷贝到读写层，然后进行操作</p></li><li><p>你在容器中 进行写入东西的时候 不管你写入多少，是对 引用的镜像是无反应的。<br><code>***</code></p></li></ul><h4 id="docker-容器和镜像的具体区别"><a href="#docker-容器和镜像的具体区别" class="headerlink" title="docker 容器和镜像的具体区别"></a>docker 容器和镜像的具体区别</h4><ol><li>当由 ubuntu:14.04 镜像启动容器时，ubuntu:14.04 镜像的镜像层内容将作为容器的 rootfs；</li><li>而 ubuntu:14.04 镜像的 json 文件，会由 docker daemon 解析，并提取出其中的容器执行入口 CMD 信息，<br>以及容器进程的环境变量 ENV 信息，最终初始化容器进程。</li><li>当然，容器进程的执行入口来源于镜像提供的 rootfs。</li></ol><p><img src="https://img-blog.csdnimg.cn/2020030414582499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/2020030414582499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><h4 id="rootfs"><a href="#rootfs" class="headerlink" title="rootfs"></a>rootfs</h4><ol><li>rootfs 是 docker 容器在启动时内部进程可见的文件系统，即 docker 容器的根目录。</li><li>rootfs 通常包含一个操作系统运行所需的文件系统，例如可能包含典型的类 Unix 操作系统中的目录系统，<br>如 /dev、/proc、/bin、/etc、/lib、/usr、/tmp 及运行 docker 容器所需的配置文件、工具等。</li><li>在传统的 Linux 操作系统内核启动时，首先挂载一个只读的 rootfs，当系统检测其完整性之后，再将其切换为读写模式。</li><li>而在 docker 架构中，当 docker daemon 为 docker 容器挂载 rootfs 时，沿用了 Linux 内核启动时的做法，即将 rootfs 设为只读模式。</li><li>在挂载完毕之后，利用联合挂载(union mount)技术在已有的只读 rootfs 上再挂载一个读写层。</li><li>这样，可读写的层处于 docker 容器文件系统的最顶层，其下可能联合挂载了多个只读的层，</li><li>只有在 docker 容器运行过程中文件系统发生变化时，才会把变化的文件内容写到可读写层，并隐藏只读层中的旧版本文件。</li></ol><h4 id="查看容器中镜像内容"><a href="#查看容器中镜像内容" class="headerlink" title="查看容器中镜像内容"></a>查看容器中镜像内容</h4><pre class="highlight"><span class="line"><span class="comment"># 创建web1 容器</span></span><br><span class="line">docker run -itd --name=web1 -p <span class="number">192.168</span><span class="number">.56</span><span class="number">.14</span>:<span class="number">81</span>:<span class="number">80</span> nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器内容</span></span><br><span class="line">docker inspect web1 | more</span><br></pre><p>以下就是容器的详细信息</p><pre class="highlight"><span class="line"><span class="comment"># 只摘选局部</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"GraphDriver"</span>: &#123;</span><br><span class="line">            <span class="string">"Data"</span>: &#123;</span><br><span class="line">                <span class="string">"LowerDir"</span>: <span class="string">"/var/lib/docker/overlay2/51692869029f819494bb402dc70aa2869b8d1848c3b65c549a010a260e44cc13-init/diff:/var/lib/docker/overlay2/09fa1314e484781dfc1fb25a6cf5df2502fe35dea9025a373a3cb0202732ccce/diff:/var/lib/docker/overlay2/162ec5c9be56e5d718011c09ed087eda04b755e1a68bd1953c60f175e6635e68/diff:/var/lib/docker/overlay2/7c1b27ff59a397ae7d6bd106db579e90476f57bb1ecef9fcb1a6f1ad5ce43b7c/diff"</span>,</span><br><span class="line">                <span class="string">"MergedDir"</span>: <span class="string">"/var/lib/docker/overlay2/51692869029f819494bb402dc70aa2869b8d1848c3b65c549a010a260e44cc13/merged"</span>,</span><br><span class="line">                <span class="string">"UpperDir"</span>: <span class="string">"/var/lib/docker/overlay2/51692869029f819494bb402dc70aa2869b8d1848c3b65c549a010a260e44cc13/diff"</span>,</span><br><span class="line">                <span class="string">"WorkDir"</span>: <span class="string">"/var/lib/docker/overlay2/51692869029f819494bb402dc70aa2869b8d1848c3b65c549a010a260e44cc13/work"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"Name"</span>: <span class="string">"overlay2"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"NetworkSettings"</span>: &#123;</span><br><span class="line">            <span class="string">"Ports"</span>: &#123;</span><br><span class="line">                <span class="string">"80/tcp"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">"HostIp"</span>: <span class="string">"192.168.56.14"</span>,</span><br><span class="line">                        <span class="string">"HostPort"</span>: <span class="string">"81"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:11:00:02"</span>,</span><br><span class="line">            <span class="string">"Networks"</span>: &#123;</span><br><span class="line">                <span class="string">"bridge"</span>: &#123;</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"172.17.0.1"</span>,</span><br><span class="line">                    <span class="string">"IPAddress"</span>: <span class="string">"172.17.0.2"</span>,</span><br><span class="line">                    <span class="string">"IPPrefixLen"</span>: <span class="number">16</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre><p>可以看到 读写层（自己 吧下面得数字 Ctrl + F 看吧）</p><pre class="highlight"><span class="line">[root@linux-node4 diff] cd /var/lib/docker/overlay2/<span class="number">51692869029</span>f819494bb402dc70aa2869b8d1848c3b65c549a010a260e44cc13</span><br><span class="line"></span><br><span class="line">[root@linux-node4 <span class="number">51692869029</span>f819494bb402dc70aa2869b8d1848c3b65c549a010a260e44cc13]<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读写层的文件 </span></span><br><span class="line">diff  link  lower  merged  work</span><br></pre><p>work 是工作的地方<br>diff 是镜像和读写层的差异<br>merged 是镜像引用下来的 读写层</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200304131346637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM
      
    
    </summary>
    
    
      <category term="docker" scheme="https://github.com/vp1009/vp1009.github.io.git/categories/docker/"/>
    
    
      <category term="python" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 配置文件</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/08/23/Nginx%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/08/23/Nginx%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</id>
    <published>2020-08-23T15:11:01.000Z</published>
    <updated>2020-09-13T11:57:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200302114623831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200302114623831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" class="lozad post-image"></p><p><strong>Nginx 配置</strong></p><h5 id="nginx配置文件注释"><a href="#nginx配置文件注释" class="headerlink" title="nginx配置文件注释"></a>nginx配置文件注释</h5><pre class="highlight"><span class="line"><span class="meta">#</span><span class="bash">运行用户</span></span><br><span class="line">user nobody;</span><br><span class="line"><span class="meta">#</span><span class="bash">启动进程,通常设置成和cpu的数量相等</span></span><br><span class="line">worker_processes  1;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">全局错误日志及PID文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  info;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">pid        logs/nginx.pid;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">工作模式及连接数上限</span></span><br><span class="line">events &#123;</span><br><span class="line">    #epoll是多路复用IO(I/O Multiplexing)中的一种方式,</span><br><span class="line">    #仅用于linux2.6以上内核,可以大大提高nginx的性能</span><br><span class="line">    use   epoll; </span><br><span class="line"> </span><br><span class="line">    #单个后台worker process进程的最大并发链接数    </span><br><span class="line">    worker_connections  1024;</span><br><span class="line"> </span><br><span class="line">    # 并发总数是 worker_processes 和 worker_connections 的乘积</span><br><span class="line">    # 即 max_clients = worker_processes * worker_connections</span><br><span class="line">    # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4  为什么</span><br><span class="line">    # 为什么上面反向代理要除以4，应该说是一个经验值</span><br><span class="line">    # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000</span><br><span class="line">    # worker_connections 值的设置跟物理内存大小有关</span><br><span class="line">    # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数</span><br><span class="line">    # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右</span><br><span class="line">    # 我们来看看360M内存的VPS可以打开的文件句柄数是多少：</span><br><span class="line">    # $ cat /proc/sys/fs/file-max</span><br><span class="line">    # 输出 34336</span><br><span class="line">    # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内</span><br><span class="line">    # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置</span><br><span class="line">    # 使得并发总数小于操作系统可以打开的最大文件数目</span><br><span class="line">    # 其实质也就是根据主机的物理CPU和内存进行配置</span><br><span class="line">    # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。</span><br><span class="line">    # ulimit -SHn 65535</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">http &#123;</span><br><span class="line">    #设定mime类型,类型由mime.type文件定义</span><br><span class="line">    include    mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    #设定日志格式</span><br><span class="line">    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">                      '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">                      '"$http_user_agent" "$http_x_forwarded_for"';</span><br><span class="line"> </span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line"> </span><br><span class="line">    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，</span><br><span class="line">    #对于普通应用，必须设为 on,</span><br><span class="line">    #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，</span><br><span class="line">    #以平衡磁盘与网络I/O处理速度，降低系统的uptime.</span><br><span class="line">    sendfile     on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"> </span><br><span class="line">    #连接超时时间</span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    tcp_nodelay     on;</span><br><span class="line"> </span><br><span class="line">    #开启gzip压缩</span><br><span class="line">    gzip  on;</span><br><span class="line">    gzip_disable "MSIE [1-6].";</span><br><span class="line"> </span><br><span class="line">    #设定请求缓冲</span><br><span class="line">    client_header_buffer_size    128k;</span><br><span class="line">    large_client_header_buffers  4 128k;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    #设定虚拟主机配置</span><br><span class="line">    server &#123;</span><br><span class="line">        #侦听80端口</span><br><span class="line">        listen    80;</span><br><span class="line">        #定义使用 www.nginx.cn访问</span><br><span class="line">        server_name  www.nginx.cn;</span><br><span class="line"> </span><br><span class="line">        #定义服务器的默认网站根目录位置</span><br><span class="line">        root html;</span><br><span class="line"> </span><br><span class="line">        #设定本虚拟主机的访问日志</span><br><span class="line">        access_log  logs/nginx.access.log  main;</span><br><span class="line"> </span><br><span class="line">        #默认请求</span><br><span class="line">        location / &#123;</span><br><span class="line">            </span><br><span class="line">            #定义首页索引文件的名称</span><br><span class="line">            index index.php index.html index.htm;   </span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        # 定义错误提示页面</span><br><span class="line">        error_page   500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        #静态文件，nginx自己处理</span><br><span class="line">        location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123;</span><br><span class="line">            </span><br><span class="line">            #过期30天，静态文件不怎么更新，过期可以设大一点，</span><br><span class="line">            #如果频繁更新，则可以设置得小一点。</span><br><span class="line">            expires 30d;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.</span><br><span class="line">        location ~ .php$ &#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">            include fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        #禁止访问 .htxxx 文件</span><br><span class="line">            location ~ /.ht &#123;</span><br><span class="line">            deny all;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre><h5 id="nginx配置举例"><a href="#nginx配置举例" class="headerlink" title="nginx配置举例"></a>nginx配置举例</h5><pre class="highlight"><span class="line">user  work;</span><br><span class="line">worker_processes 8;</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line">error_log  logs/error.log warn;</span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line">pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  65535;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> load modules compiled as Dynamic Shared Object (DSO)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">dso &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    load ngx_http_fastcgi_module.so;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    load ngx_http_rewrite_module.so;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">&#125;</span></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    server_names_hash_bucket_size 128;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nopush      on;</span><br><span class="line">    tcp_nodelay     on;</span><br><span class="line"></span><br><span class="line">    fastcgi_connect_timeout 5;</span><br><span class="line">    fastcgi_send_timeout 10;</span><br><span class="line">    fastcgi_read_timeout 10;</span><br><span class="line">    fastcgi_buffer_size 64k;</span><br><span class="line">    fastcgi_buffers 4 64k;</span><br><span class="line">    fastcgi_busy_buffers_size 128k;</span><br><span class="line">    fastcgi_temp_file_write_size 128k;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  60;</span><br><span class="line">    keepalive_requests 1024;</span><br><span class="line">    client_header_buffer_size 4k;</span><br><span class="line">    large_client_header_buffers 4 32k;</span><br><span class="line">    client_max_body_size 10m;</span><br><span class="line"></span><br><span class="line">    client_body_buffer_size 512k;</span><br><span class="line">    client_body_timeout 600;</span><br><span class="line">    client_header_timeout 600;</span><br><span class="line">    send_timeout 600;</span><br><span class="line"></span><br><span class="line">    proxy_connect_timeout   1000ms;</span><br><span class="line">    proxy_send_timeout      2000000ms;</span><br><span class="line">    proxy_read_timeout      2000000ms;</span><br><span class="line">    proxy_buffers           64 8k;</span><br><span class="line">    proxy_busy_buffers_size    128k;</span><br><span class="line">    proxy_temp_file_write_size 64k;</span><br><span class="line">    proxy_redirect off;</span><br><span class="line">    #proxy_next_upstream off ;</span><br><span class="line"></span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line">    gzip_buffers 4 16k;</span><br><span class="line">    gzip_http_version 1.0;</span><br><span class="line">    gzip_comp_level 2;</span><br><span class="line">    gzip_types text/plain application/x-javascript text/css application/xml;</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    add_header X-Frame-Options "ALLOW-FROM  http://cloud.njsig.cn";</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Real-Port $remote_port;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">        '$status $body_bytes_sent "$http_referer" "$http_cookie" "$http_user_agent" '</span><br><span class="line">        '$request_time $remote_addr $server_addr $upstream_addr $host '</span><br><span class="line">        '"$http_x_forwarded_for" $upstream_response_time';</span><br><span class="line"></span><br><span class="line">    set_real_ip_from 10.0.0.0/8;</span><br><span class="line">    real_ip_header X-Real-IP;</span><br><span class="line"></span><br><span class="line">    #example</span><br><span class="line"><span class="meta">#</span><span class="bash">     server &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        listen 8000;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        server_name www;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        access_log logs/access.log  main;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        location / &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            proxy_pass http://127.0.0.1:8001;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        &#125;</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">      &#125;</span></span><br><span class="line">    include vhosts/*.conf;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####</span></span></span><br></pre><h5 id="nginx-conf-vhosts-opwf-conf-django项目简单配置"><a href="#nginx-conf-vhosts-opwf-conf-django项目简单配置" class="headerlink" title="nginx/conf/vhosts/opwf.conf django项目简单配置"></a>nginx/conf/vhosts/opwf.conf django项目简单配置</h5><pre class="highlight"><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name aaa.test.com bbb.test.com;</span><br><span class="line">        access_log  /home/work/nginx/logs/opwf_access.log main;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:8001;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre><h5 id="nginx-conf-vhosts-opwf-conf-django项目简单配置-1"><a href="#nginx-conf-vhosts-opwf-conf-django项目简单配置-1" class="headerlink" title="nginx/conf/vhosts/opwf.conf django项目简单配置"></a>nginx/conf/vhosts/opwf.conf django项目简单配置</h5><pre class="highlight"><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name ccc.test.com;</span><br><span class="line">        access_log  /home/work/nginx/logs/nj1_access.log main;</span><br><span class="line">        root /home/work/project/frontopwf/dist;</span><br><span class="line">        location / &#123;</span><br><span class="line">                try_files $uri $uri/ @router;</span><br><span class="line">        &#125;</span><br><span class="line">        location @router &#123;</span><br><span class="line">                rewrite ^.*$ /index.html last;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200302114623831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM
      
    
    </summary>
    
    
      <category term="nginx" scheme="https://github.com/vp1009/vp1009.github.io.git/categories/nginx/"/>
    
    
      <category term="python" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Docker 介绍，Linux简单安装</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/08/18/Docker%20%E4%BB%8B%E7%BB%8D%EF%BC%8CLinux%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/08/18/Docker%20%E4%BB%8B%E7%BB%8D%EF%BC%8CLinux%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85/</id>
    <published>2020-08-17T16:09:56.000Z</published>
    <updated>2020-09-13T11:53:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200301143418334.jpg#pic_center" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200301143418334.jpg#pic_center" class="lozad post-image"></p><p>什么是 Docker？</p><ul><li>一个简单的应用程序打包工具</li><li>使用最广泛的开源容器</li><li>一种操作系统级的虚拟化技术</li><li>依赖于Linux内核特性：Namespace 和 Cgroups</li></ul><ol><li>Docker 是应用最广泛的开源容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中</li><li>然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。</li><li>每个容器拥有一套和宿主机完全隔离的文件系统（共用linux内核），程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。</li></ol><h5 id="容器："><a href="#容器：" class="headerlink" title="容器："></a>容器：</h5><ol><li><p>容器是一个操作系统级别下的虚拟化技术，运行一个容器就行运行一个进程一样</p></li><li><p>容器依赖linux内核特性：Namespace（资源隔离）和Cgroups（资源限制）</p></li></ol><p>Docker的设计目标</p><ul><li><p>提供了简单的应用程序打包</p></li><li><p>开发人员和运维人员职责逻辑分离</p></li><li><p>多环境保持一致性</p></li></ul><p>Docker的思想</p><ol><li><p>Docker的思想源于集装箱，集装箱解决了什么问题呢？</p></li><li><p>在早期运输货物需要不同分类的船，例如运输水果的船，运输生活用品的船</p></li><li><p>有了集装箱后，在大船上，可以把货物分类到不同的集装箱中，水果一个集装箱，生活用品一个集装箱</p></li><li><p>它们之间互不影响，只要把货物封装好集装箱里，就可以把不同类的货物一起运走。</p></li><li><p>通过Docker logo也可以看出所以然来，Docker就像大船，集装箱就是容器。</p></li><li><p>一条鲸鱼拖着若干个集装箱的经典形象已经深入人心。</p></li></ol><p>Docker的基本组成</p><p><img src="https://img-blog.csdnimg.cn/20200301141951332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200301141951332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><table><thead><tr><th>DockerClient</th><th>客户端</th></tr></thead><tbody><tr><td>Docker Daemon</td><td>守护进程</td></tr><tr><td>Docker Images</td><td>镜像</td></tr><tr><td>Docker Container</td><td>容器</td></tr><tr><td>Docker Registry</td><td>镜像仓库</td></tr></tbody></table><p>虚拟机 和 容器</p><p><img src="https://img-blog.csdnimg.cn/20200301143040376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200301143040376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><p>VM</p><table><thead><tr><th>Infrastructure</th><th>代表他 可以是 台式 笔记本 服务器 云主机</th></tr></thead><tbody><tr><td>Hypervisor</td><td>运行在物理设备上 和 操作糸统之间的 中间软件管理层 ，也叫 宿主机</td></tr><tr><td>Guest OS</td><td>虚拟出的系统</td></tr><tr><td>Bins/Libx</td><td>二进制文件 / 库</td></tr><tr><td>App</td><td>部署的应用</td></tr></tbody></table><p>Container</p><table><thead><tr><th>Infrastructure</th><th>代表他 可以是 台式 笔记本 服务器 云主机</th></tr></thead><tbody><tr><td>Host OS</td><td>主机OS，这台机器的操作系统</td></tr><tr><td>Docker</td><td>系统级别的虚拟化技术，所以要基于已有的操作系统之上</td></tr><tr><td>Bins/Libx</td><td>二进制文件 / 库</td></tr><tr><td>App</td><td>部署的应用</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20200301150926289.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200301150926289.png" class="lozad post-image"><br><img src="https://img-blog.csdnimg.cn/20200301150947377.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200301150947377.png" class="lozad post-image"></p><p>由上图可看 容器呢 只包含了 二进制文件 和 库、应用程序，而虚拟机是 Guest OS 承载的 二进制文件 和 库、应用程序</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table><thead><tr><th></th><th>Container</th><th>VM</th></tr></thead><tbody><tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td>运动性能</td><td>接近原生</td><td>5%左右损失</td></tr><tr><td>磁盘占用</td><td>MB</td><td>GB</td></tr><tr><td>数量</td><td>成百上千</td><td>一般几十台</td></tr><tr><td>隔离性</td><td>进程级别</td><td>系统级（更彻底）</td></tr><tr><td>操作系统</td><td>只支持Linux</td><td>几乎所有</td></tr><tr><td>封装程度</td><td>只打包项目代码和依赖关系，共享宿主机内核</td><td>完整的操作系统</td></tr></tbody></table><h5 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h5><ol><li>docker设计小巧，部署迁移快速，运行高效，按照应用隔离，管理人员可以看到所有容器的内容。</li><li>虚拟化技术比较臃肿，需要先创建新的系统，按照系统隔离，管理员无法看到系统内部信息。</li></ol><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><ul><li><p>Docker就是手机中的各种APP，只需要一个系统就可以下载自己所需的应用</p></li><li><p>虚拟化技术相当于苹果手机安装一个庞大软件，这个软件上安装安卓系统、魅族系统等，每个系统上还要安装各类应用。</p></li></ul><p>Docker 的应用场景</p><ul><li>应用程序打包和发布</li><li>应用程序隔离</li><li>持续集成</li><li>部署微服务</li><li>快速搭建测试环境</li><li>提供Paas产品（平台即服务）</li></ul><h5 id="详解："><a href="#详解：" class="headerlink" title="详解："></a>详解：</h5><ul><li><p>节省项目环境部署时间</p><ul><li><strong>单项目打包</strong></li></ul><ol><li>每次部署项目到测试、生产等环境，都要部署一大堆依赖的软件、工具，时间久，出错概率大。</li><li>Docker主要理念就是环境打包部署，可在任意Docker Engine运行。</li><li>我们只需要将每个项目环境打包到镜像，push到镜像仓库，当有需要部署这个项目时，直接pull镜像启动容器，这个项目就可以访问了！一次构建多次部署，一劳永逸。</li></ol><ul><li><strong>整套项目打包</strong></li></ul><ol><li>比如有一个产品可以整套部署到客户那里，以往都是派一名实施工程师到客户那部署。</li><li>如果用了Docker，我们可以前期将这套项目封装打包起来，实现一键部署，分分钟钟搞定，就不需要再派人过去了。比如官方的Docker Compose编排工具。</li></ol><ul><li><strong>新开源技术试用</strong></li></ul><ol><li>有时，我们想调研一些开源项目，我们可以直接从公共镜像仓库pull项目官方做好镜像启动容器即可。</li></ol></li><li><p>环境一致性</p></li></ul><ol><li>项目在开发电脑本地运行没问题，到了测试或生产环境就运行不起来。</li><li>Docker将项目环境打包成镜像，可以在任何Docker Engine部署。</li></ol><ul><li>持续集成</li></ul><ol><li>一个项目版本快速迭代的测试场景，需要一个合理的CI（持续集成）/CD（持续部署）环境支撑。</li><li>CI/CD是一个周期性自动化项目测试流程，包括构建、部署、测试、发布等工作，很少需要人工干预。</li><li>Docker通过项目镜像构建和快速部署，打通测试环境与生产环境，高度保持多个环境之间一致性。</li></ol><ul><li>微服务</li></ul><ol><li><p>微服务指尽可能细粒度拆分业务程序架构，由多个独立服务组成业务系统。</p></li><li><p>Docker容器作为这些独立服务的部署单元，每个服务单独部署到一个docker容器中。</p></li></ol><p>Linux 上安装 Docker</p><h5 id="docker版本"><a href="#docker版本" class="headerlink" title="docker版本"></a>docker版本</h5><pre class="highlight"><span class="line">docker V1.13 版本的时候区分的 以下两个版本，大约是在17年初，我们用的是 最新版 V18.03</span><br></pre><ol><li>社区版（Community Edition, CE）</li><li>企业版（Enterprise Edition, EE）</li></ol><h4 id="docker安装参考官方文档"><a href="#docker安装参考官方文档" class="headerlink" title="docker安装参考官方文档"></a>docker安装参考官方文档</h4><ol><li>docker官方文档：<a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></li><li>centos安装docker：<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a><br><code>注：docker CE只支持 centos7 不支持centos6</code></li></ol><p><img src="https://img-blog.csdnimg.cn/20200301222519716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200301222519716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><pre class="highlight"><span class="line"><span class="comment"># 1.安装依赖包</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.添加Docker软件包源(否则doker安装的不是新版本)</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.安装Docker CE</span></span><br><span class="line">yum install -y docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.启动Docker服务并设置开机启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.测试docker是否安装成功（hello-world是官方提供的一个测试镜像）</span></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看docker基本信息</span></span><br><span class="line">docker info</span><br><span class="line">docker version</span><br></pre><h5 id="docker简单使用-创建Nginx容器"><a href="#docker简单使用-创建Nginx容器" class="headerlink" title="docker简单使用 创建Nginx容器"></a>docker简单使用 创建Nginx容器</h5><pre class="highlight"><span class="line"><span class="comment"># 1、创建一个nginx容器</span></span><br><span class="line">docker run -it nginx</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2、查看docker运行的容器(可以获取到这个容器的id)</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、访问这个容器</span></span><br><span class="line"><span class="comment"># 进入这个nginx容器（进入的文件系统和宿主机是完全隔离的，有自己独立的文件系统）</span></span><br><span class="line">docker <span class="keyword">exec</span> -it <span class="number">73877e65</span>c07d bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、查看当前容器的 IP</span></span><br><span class="line">docker inspect <span class="number">73877e65</span>c07d   <span class="comment"># 73877e65c07d是通过docekr ps查看到的容器ID</span></span><br><span class="line">curl <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span>               <span class="comment"># 测试这个nginx容器是否可以访问</span></span><br></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200301143418334.jpg#pic_center&quot; alt=&quot;在这里插入图片描述&quot; srcset=&quot;data:image/svg+xml,%3Csvg%20xmlns=&#39;http:/
      
    
    </summary>
    
    
      <category term="docker" scheme="https://github.com/vp1009/vp1009.github.io.git/categories/docker/"/>
    
    
      <category term="python" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python Django 支付宝 扫码支付</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/08/12/Python%20Django%20%E6%94%AF%E4%BB%98%E5%AE%9D%20%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/08/12/Python%20Django%20%E6%94%AF%E4%BB%98%E5%AE%9D%20%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98/</id>
    <published>2020-08-12T04:00:19.000Z</published>
    <updated>2020-09-13T11:49:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>*\</strong>*安装python-alipay-sdk**<em>**</em></p><pre class="highlight"><span class="line">pip install python-alipay-sdk --upgrade</span><br></pre><p><strong><em>\</em>原理介绍：**</strong></p><p>　　1.进行秘钥配置，因为传输的数据必须要进行签名加密，ubuntu内置命令openssl可以生成私钥，根据私钥生成公钥</p><pre class="highlight"><span class="line">　　openssl</span><br><span class="line">　　OpenSSL&gt; genrsa -out app_private_key.pem   2048  # 私钥 2048对应的是rsa加密时候的复杂程度，即rsa2</span><br><span class="line">　　OpenSSL&gt; rsa -in app_private_key.pem -pubout -out app_public_key.pem # 导出公钥</span><br><span class="line">　　OpenSSL&gt; exit</span><br></pre><p>　　2.cat app_publict_key.pem 查看公钥的内容</p><p>　　将—–BEGIN PUBLIC KEY—–和—–END PUBLIC KEY—–中间的内容保存在支付宝的用户配置中（沙箱或者正式）</p><p>​    <a href="https://openhome.alipay.com/platform/appDaily.htm?tab=info" target="_blank" rel="noopener">https://openhome.alipay.com/platform/appDaily.htm?tab=info</a></p><p>　　3.配置好公钥后，支付宝会生成公钥，将公钥的内容复制保存到一个文本文件中(alipay_pubilc_key.pem)，注意需要在文本的首尾添加标记位(—–BEGIN 　　PUBLIC KEY—–和—–END PUBLIC KEY—–) </p><p>　　4.将刚刚生成的私钥app_private_key.pem和支付宝公钥alipay_public_key.pem放到我们的项目目录中</p><p>　　5.使用支付宝 python包的初始化</p><p>　　6.调用支付接口</p><p>　　<a href="https://docs.open.alipay.com/270/alipay.trade.page.pay/" target="_blank" rel="noopener">https://docs.open.alipay.com/270/alipay.trade.page.pay/</a></p><p>　　7.获取支付结果接口</p><p>　　<a href="https://docs.open.alipay.com/api_1/alipay.trade.query" target="_blank" rel="noopener">https://docs.open.alipay.com/api_1/alipay.trade.query</a></p><p><strong><em>\</em>代码部分：**</strong></p><p>1.整个项目架构</p><p><img src="https://images2017.cnblogs.com/blog/1265917/201801/1265917-20180106213627440-1895798970.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://images2017.cnblogs.com/blog/1265917/201801/1265917-20180106213627440-1895798970.png" class="lozad post-image"></p><p>index.html代码</p><pre class="highlight"><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;static&#x2F;js&#x2F;jquery-1.4.2.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            $(&#39;#btn&#39;).click(function () &#123;</span><br><span class="line">                var order_id &#x3D; &quot;20180105002&quot;;</span><br><span class="line">                var req_data &#x3D; &#123;</span><br><span class="line">                    order_id: order_id,</span><br><span class="line">                    csrfmiddlewaretoken: &quot;&#123;&#123; csrf_token &#125;&#125;&quot;</span><br><span class="line">                &#125;;</span><br><span class="line">                $.post(&quot;&#x2F;pay&#x2F;&quot;, req_data, function (data) &#123;</span><br><span class="line">                    window.open(data.url)</span><br><span class="line">                &#125;);</span><br><span class="line">                $.get(&quot;&#x2F;check_pay&#x2F;?order_id&#x3D;&quot; + order_id, function (data) &#123;</span><br><span class="line">                    if (0 &#x3D;&#x3D; data.code) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 支付成功</span><br><span class="line">                        alert(&quot;支付成功&quot;);</span><br><span class="line">                        location.reload();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        alert(data.message)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btn&quot; value&#x3D;&quot;支付&quot;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre><p>2.AppTest.views.py代码</p><pre class="highlight"><span class="line">#coding:utf-8</span><br><span class="line">from django.shortcuts import render</span><br><span class="line"></span><br><span class="line">from django.shortcuts import render</span><br><span class="line">from django.http import JsonResponse</span><br><span class="line">from alipay import AliPay</span><br><span class="line">import os</span><br><span class="line">from django.conf import settings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    return render(request, &quot;index.html&quot;,locals())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pay(request):</span><br><span class="line">    order_id &#x3D; request.POST.get(&quot;order_id&quot;)</span><br><span class="line">    # 创建用于进行支付宝支付的工具对象</span><br><span class="line">    alipay &#x3D; AliPay(</span><br><span class="line">        appid&#x3D;settings.ALIPAY_APPID,</span><br><span class="line">        app_notify_url&#x3D;None,  # 默认回调url</span><br><span class="line">        app_private_key_path&#x3D;os.path.join(settings.BASE_DIR, &quot;AppTest&#x2F;app_private_key.pem&quot;),</span><br><span class="line">        alipay_public_key_path&#x3D;os.path.join(settings.BASE_DIR, &quot;AppTest&#x2F;alipay_public_key.pem&quot;),</span><br><span class="line">        # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,</span><br><span class="line">        sign_type&#x3D;&quot;RSA2&quot;,  # RSA 或者 RSA2</span><br><span class="line">        debug&#x3D;True  # 默认False  配合沙箱模式使用</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # 电脑网站支付，需要跳转到https:&#x2F;&#x2F;openapi.alipay.com&#x2F;gateway.do? + order_string</span><br><span class="line">    order_string &#x3D; alipay.api_alipay_trade_page_pay(</span><br><span class="line">        out_trade_no&#x3D;order_id,</span><br><span class="line">        total_amount&#x3D;str(0.01),  # 将Decimal类型转换为字符串交给支付宝</span><br><span class="line">        subject&#x3D;&quot;测试订单&quot;,</span><br><span class="line">        return_url&#x3D;&quot;https:&#x2F;&#x2F;example.com&quot;,</span><br><span class="line">        notify_url&#x3D;&quot;https:&#x2F;&#x2F;example.com&#x2F;notify&quot;  # 可选, 不填则使用默认notify url</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # 让用户进行支付的支付宝页面网址</span><br><span class="line">    url &#x3D; settings.ALIPAY_URL + &quot;?&quot; + order_string</span><br><span class="line"></span><br><span class="line">    return JsonResponse(&#123;&quot;code&quot;: 0, &quot;message&quot;: &quot;请求支付成功&quot;, &quot;url&quot;: url&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def check_pay(request):</span><br><span class="line">    # 创建用于进行支付宝支付的工具对象</span><br><span class="line">    order_id &#x3D; request.GET.get(&quot;order_id&quot;)</span><br><span class="line">    alipay &#x3D; AliPay(</span><br><span class="line">        appid&#x3D;settings.ALIPAY_APPID,</span><br><span class="line">        app_notify_url&#x3D;None,  # 默认回调url</span><br><span class="line">        app_private_key_path&#x3D;os.path.join(settings.BASE_DIR, &quot;AppTest&#x2F;app_private_key.pem&quot;),</span><br><span class="line">        alipay_public_key_path&#x3D;os.path.join(settings.BASE_DIR, &quot;AppTest&#x2F;alipay_public_key.pem&quot;),</span><br><span class="line">        # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,</span><br><span class="line">        sign_type&#x3D;&quot;RSA2&quot;,  # RSA2,官方推荐，配置公钥的时候能看到</span><br><span class="line">        debug&#x3D;True  # 默认False  配合沙箱模式使用</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        # 调用alipay工具查询支付结果</span><br><span class="line">        response &#x3D; alipay.api_alipay_trade_query(order_id)  # response是一个字典</span><br><span class="line">        # 判断支付结果</span><br><span class="line">        code &#x3D; response.get(&quot;code&quot;)  # 支付宝接口调用成功或者错误的标志</span><br><span class="line">        trade_status &#x3D; response.get(&quot;trade_status&quot;)  # 用户支付的情况</span><br><span class="line"></span><br><span class="line">        if code &#x3D;&#x3D; &quot;10000&quot; and trade_status &#x3D;&#x3D; &quot;TRADE_SUCCESS&quot;:</span><br><span class="line">            # 表示用户支付成功</span><br><span class="line">            # 返回前端json，通知支付成功</span><br><span class="line">            return JsonResponse(&#123;&quot;code&quot;: 0, &quot;message&quot;: &quot;支付成功&quot;&#125;)</span><br><span class="line"></span><br><span class="line">        elif code &#x3D;&#x3D; &quot;40004&quot; or (code &#x3D;&#x3D; &quot;10000&quot; and trade_status &#x3D;&#x3D; &quot;WAIT_BUYER_PAY&quot;):</span><br><span class="line">            # 表示支付宝接口调用暂时失败，（支付宝的支付订单还未生成） 后者 等待用户支付</span><br><span class="line">            # 继续查询</span><br><span class="line">            print(code)</span><br><span class="line">            print(trade_status)</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">            # 支付失败</span><br><span class="line">            # 返回支付失败的通知</span><br><span class="line">            return JsonResponse(&#123;&quot;code&quot;: 1, &quot;message&quot;: &quot;支付失败&quot;&#125;)</span><br><span class="line"># Create your views here.</span><br></pre><p>3.主urls.py</p><pre class="highlight"><span class="line">from django.conf.urls import include, url</span><br><span class="line">from django.contrib import admin</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^admin&#x2F;&#39;, include(admin.site.urls)),</span><br><span class="line">    url(r&#39;^&#39;, include(&#39;AppTest.urls&#39;)),</span><br><span class="line">]</span><br></pre><p>4.AppTest urls.py</p><pre class="highlight"><span class="line">from django.conf.urls import include, url</span><br><span class="line">from views import *</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&quot;^$&quot;, index),</span><br><span class="line">    url(r&quot;^pay&#x2F;$&quot;, pay),</span><br><span class="line">    url(r&quot;^check_pay&#x2F;$&quot;, check_pay),</span><br><span class="line">]</span><br></pre><p>5.setttings.py中设置</p><p>修改templates部分</p><pre class="highlight"><span class="line">TEMPLATES &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,</span><br><span class="line">        &#39;DIRS&#39;: [</span><br><span class="line">            os.path.join(BASE_DIR,&quot;template&quot;).replace(&quot;\\&quot;,&quot;&#x2F;&quot;)</span><br><span class="line">        ],</span><br><span class="line">        &#39;APP_DIRS&#39;: True,</span><br><span class="line">        &#39;OPTIONS&#39;: &#123;</span><br><span class="line">            &#39;context_processors&#39;: [</span><br><span class="line">                &#39;django.template.context_processors.debug&#39;,</span><br><span class="line">                &#39;django.template.context_processors.request&#39;,</span><br><span class="line">                &#39;django.contrib.auth.context_processors.auth&#39;,</span><br><span class="line">                &#39;django.contrib.messages.context_processors.messages&#39;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre><p>末尾加入</p><pre class="highlight"><span class="line">STATIC_URL &#x3D; &#39;&#x2F;static&#x2F;&#39;</span><br><span class="line">STATICFILES_DIRS &#x3D; [os.path.join(BASE_DIR, &quot;static&quot;)]</span><br><span class="line"></span><br><span class="line"># 支付宝配置参数</span><br><span class="line">ALIPAY_APPID &#x3D; &quot;2017072407880788&quot;</span><br><span class="line">ALIPAY_URL &#x3D; &quot;https:&#x2F;&#x2F;openapi.alipay.com&#x2F;gateway.do&quot;</span><br></pre><p><strong>测试效果：</strong></p><p><strong><img src="https://images2017.cnblogs.com/blog/1265917/201801/1265917-20180106214211659-814207984.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://images2017.cnblogs.com/blog/1265917/201801/1265917-20180106214211659-814207984.png" class="lozad post-image"></strong></p><p><strong><img src="https://images2017.cnblogs.com/blog/1265917/201801/1265917-20180106214152831-470859591.png" alt="img" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://images2017.cnblogs.com/blog/1265917/201801/1265917-20180106214152831-470859591.png" class="lozad post-image"></strong></p><p>返回结果</p><p><a href="https://example.com/?total_amount=0.01&amp;timestamp=2018-01-06+21%3A28%3A38&amp;sign=fg19hD85DPPuN1aaI%2B%2BskuomKUxaDGE%2FdvyttEyV3vubVkVvBDXVziZaGybXqZs5o4bXYojx587qNBb8e%2FjAJOBCwKwYZxd7qR3AKlVabkPDzEOlzvEaSW7HTQpsWsVeX6BW%2ByEO8pWQ8c%2BS8B8tS8a8AFtQxeW92as4hdNjQU2YBZ2SVxtKSohWbFWpny1gDWXinQ3y2HNo4t5lmA8fRknB0MaUPwR1SzWa0k%2BylYjpWEnzC6OihP0Er21Ad8fiUwtSxZqH4xIAhnbofAy%2BHYZZVsv5lYg%2Brb87eM6Yz7xwUe5v5dDEoz%2FOLjsuB0GDRTdvhHqs39cGIoMXFfEpbw%3D%3D&amp;trade_no=2018010621001004260217512776&amp;sign_type=RSA2&amp;auth_app_id=2017072407880788&amp;charset=utf-8&amp;seller_id=2088221936946848&amp;method=alipay.trade.page.pay.return&amp;app_id=2017072407880788&amp;out_trade_no=20180105002&amp;version=1.0" target="_blank" rel="noopener">https://example.com/?total_amount=0.01&amp;timestamp=2018-01-06+21%3A28%3A38&amp;sign=fg19hD85DPPuN1aaI%2B%2BskuomKUxaDGE%2FdvyttEyV3vubVkVvBDXVziZaGybXqZs5o4bXYojx587qNBb8e%2FjAJOBCwKwYZxd7qR3AKlVabkPDzEOlzvEaSW7HTQpsWsVeX6BW%2ByEO8pWQ8c%2BS8B8tS8a8AFtQxeW92as4hdNjQU2YBZ2SVxtKSohWbFWpny1gDWXinQ3y2HNo4t5lmA8fRknB0MaUPwR1SzWa0k%2BylYjpWEnzC6OihP0Er21Ad8fiUwtSxZqH4xIAhnbofAy%2BHYZZVsv5lYg%2Brb87eM6Yz7xwUe5v5dDEoz%2FOLjsuB0GDRTdvhHqs39cGIoMXFfEpbw%3D%3D&amp;trade_no=2018010621001004260217512776&amp;sign_type=RSA2&amp;auth_app_id=2017072407880788&amp;charset=utf-8&amp;seller_id=2088221936946848&amp;method=alipay.trade.page.pay.return&amp;app_id=2017072407880788&amp;out_trade_no=20180105002&amp;version=1.0</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;*\&lt;/strong&gt;*安装python-alipay-sdk**&lt;em&gt;**&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;span class=&quot;line&quot;&gt;pip install python-alipay-sdk --upgrad
      
    
    </summary>
    
    
      <category term="支付宝扫码" scheme="https://github.com/vp1009/vp1009.github.io.git/categories/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%AB%E7%A0%81/"/>
    
    
      <category term="python" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch 索引、类型、文档。接口的方式 CURD</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/08/05/ElasticSearch%20%E7%B4%A2%E5%BC%95%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E6%96%87%E6%A1%A3%E3%80%82%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E5%BC%8F%20CURD/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/08/05/ElasticSearch%20%E7%B4%A2%E5%BC%95%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E6%96%87%E6%A1%A3%E3%80%82%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E5%BC%8F%20CURD/</id>
    <published>2020-08-05T07:01:55.000Z</published>
    <updated>2020-09-13T09:44:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/gwd1154978352/article/details/82740424" target="_blank" rel="noopener">参考文档：https://blog.csdn.net/gwd1154978352/article/details/82740424</a></p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>索引是ElasticSearch存放数据的地方，可以理解为Mysql中的一个数据库。<br><code>你可以这么理解，你不能就说他是</code></p><p>我们的数据被 <strong>存储和索引在分片(shards)中</strong>，索引只是一个 把一个或多个分片分组在一起的逻辑空间。（就好像说）<code>这是一些内部细节我们不用关心分片。</code></p><p>对于我们的程序而言，文档存储在索引(index)中。剩下的细节由Elasticsearch关心既可。（索引的名字必须是全部小写，不能以下划线开头，不能包含逗号）</p><p><img src="https://img-blog.csdnimg.cn/20200612235843673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200612235843673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>类型用于区分同一个索引下不同的数据类型，相当于MySQL中的表。在Elasticsearch中，我们使用相同类型(type)的文档表示相同的“事物”，因为他们的数据结构也是相同的。每个类型(type)都有自己的映射(mapping)或者结构定义，就像传统数据库表中的列一样。所有类型下的文档被存储在同一个索引下，但是类型的映射(mapping)会告诉Elasticsearch不同的文档如何被索引。</p><p><img src="https://img-blog.csdnimg.cn/20200613000326776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200613000326776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br>这个还是比较好理解的</p><h5 id="注：5-0版本之前，一个索引可以对应多个类型。5-0版本之后，一个索引只能对应一个类型"><a href="#注：5-0版本之前，一个索引可以对应多个类型。5-0版本之后，一个索引只能对应一个类型" class="headerlink" title="注：5.0版本之前，一个索引可以对应多个类型。5.0版本之后，一个索引只能对应一个类型"></a><code>注：5.0版本之前，一个索引可以对应多个类型。5.0版本之后，一个索引只能对应一个类型</code></h5><p><img src="https://img-blog.csdnimg.cn/20200613000611305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200613000611305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>文档是ElasticSearch中存储的实体，类比MySQL，每个文档相当于数据库表中的一行数据。 在Elasticsearch中，文档 <strong>(document)</strong> 这个术语有着特殊含义。它特指最顶层结构或者根对象(root object)序列化成的JSON数据（以唯一ID标识并存储于Elasticsearch中）。<br>文档由字段组成，相当于关系数据库中列的属性，不同的是ES的不同文档可以具有不同的字段集合。<br>对比关系型数据库：</p><pre class="highlight"><span class="line">Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns</span><br><span class="line">Elasticsearch -&gt; Indices   -&gt; Types  -&gt; Documents -&gt; Fields</span><br><span class="line"><span class="number">12</span></span><br></pre><h4 id="文档元数据"><a href="#文档元数据" class="headerlink" title="文档元数据"></a>文档元数据</h4><p>一个文档不只有数据。它还包含了元数据(metadata)——关于文档的信息。三个必须的元数据节点是：</p><table><thead><tr><th>节点</th><th>说明</th></tr></thead><tbody><tr><td>_index</td><td>文档存储的地方</td></tr><tr><td>_type</td><td>文档代表的对象的类</td></tr><tr><td>_id</td><td>文档的唯一标识</td></tr></tbody></table><ul><li>_index：索引</li><li>_type：类型</li><li>_id：id仅仅是一个字符串，它与_index和_type组合时，就可以在Elasticsearch中唯一标识一个文档。当创建一个文档，<code>你可以自定义_id，也可以让Elasticsearch帮你自动生成。</code></li></ul><p>说的也就是这个 ↓<br><img src="https://img-blog.csdnimg.cn/20200613001612214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200613001612214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><h4 id="索引创建的规则"><a href="#索引创建的规则" class="headerlink" title="索引创建的规则"></a>索引创建的规则</h4><ul><li>类似的数据放在一个索引，非类似的数据放不同索引</li><li>index中包含了很多类似的document</li><li>索引名称必须是小写的，不能用下划线开头，不能包含逗号：product，website，blog</li></ul><h4 id="创建索引、类型、文档（接口的方式）"><a href="#创建索引、类型、文档（接口的方式）" class="headerlink" title="创建索引、类型、文档（接口的方式）"></a>创建索引、类型、文档（接口的方式）</h4><p>刚才大家也看到了我的截图是在 Kibana上操作的，但现在书写的是以 接口的方式创建，Kibana 会在后续更新出来。</p><p>就随便写写</p><pre class="highlight"><span class="line">curl -H <span class="string">'Content-Type:application/json'</span> -XPUT http://localhost:<span class="number">9200</span>/Only_for_you/testing_data/<span class="number">1</span> -d <span class="string">"</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">      "</span>private_id<span class="string">": "</span><span class="number">1</span><span class="string">",</span></span><br><span class="line"><span class="string">      "</span>title<span class="string">": "</span>This <span class="keyword">is</span> an interesting piece of data<span class="string">",</span></span><br><span class="line"><span class="string">      "</span>content<span class="string">": "</span>I Really Really, really like yo<span class="string">u",</span></span><br><span class="line"><span class="string">      "</span>tags<span class="string">": ["</span>elasticsearch<span class="string">", "</span>Love Lette<span class="string">r"]</span></span><br><span class="line"><span class="string">&#125;"</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre><p>执行后 就会OK了，大家看到我在 类型的后面写了个 1，这个1 就代表了ID。如果不写的话 系统会自动生成的id，长度为20个字符，URL安全，base64编码，GUID，分布式系统并行生成时不可能会发生冲突。</p><p>就比如这条数据，我们更新他 <code>更新就不要用 put了，会error</code></p><pre class="highlight"><span class="line">curl -H <span class="string">'Content-Type:application/json'</span> -XPOST http://localhost:<span class="number">9200</span>/Only_for_you/testing_data/ -d <span class="string">"</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">      "</span>private_id<span class="string">": "</span><span class="number">1</span><span class="string">",</span></span><br><span class="line"><span class="string">      "</span>title<span class="string">": "</span>This <span class="keyword">is</span> an interesting piece of data<span class="string">",</span></span><br><span class="line"><span class="string">      "</span>content<span class="string">": "</span>I Really Really, really like yo<span class="string">u",</span></span><br><span class="line"><span class="string">      "</span>tags<span class="string">": ["</span>elasticsearch<span class="string">", "</span>Love Lette<span class="string">r"]</span></span><br><span class="line"><span class="string">&#125;"</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre><p>返回结果</p><pre class="highlight"><span class="line">&#123;</span><br><span class="line">  <span class="string">"_index"</span> : <span class="string">"Only_for_you"</span>,</span><br><span class="line">  <span class="string">"_type"</span> : <span class="string">"testing_data"</span>,</span><br><span class="line">  <span class="string">"_id"</span> : <span class="string">"oJVnqXIBlXk7LCfggxrl"</span>,</span><br><span class="line">  <span class="string">"_version"</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="string">"result"</span> : <span class="string">"updated"</span>,</span><br><span class="line">  <span class="string">"_shards"</span> : &#123;</span><br><span class="line">    <span class="string">"total"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">"successful"</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="string">"failed"</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"_seq_no"</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="string">"_primary_term"</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br><span class="line">这里简单的概述下：POST 和 PUT 上的区别</span><br></pre><ul><li>POST不用加具体的id，它是作用在一个集合资源之上的（/uri）</li><li>PUT操作是作用在一个具体资源之上的（/uri/xxx），所以要指定ID</li></ul><h4 id="查看文档"><a href="#查看文档" class="headerlink" title="查看文档"></a>查看文档</h4><p>查看的话，方法很多种。</p><ul><li><p>浏览器直接 拼地址</p><p><img src="https://img-blog.csdnimg.cn/20200613005052905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200613005052905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p></li><li><p>使用ES浏览器插件</p><p><img src="https://img-blog.csdnimg.cn/20200613005208881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200613005208881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"><br><a href="https://download.csdn.net/download/weixin_44685869/12518847" target="_blank" rel="noopener">插件地址：https://download.csdn.net/download/weixin_44685869/12518847</a><br>我已经上传到我的 CSDN上传里了，你们可以在那里面找</p></li><li><p>在Linux中使用如下脚本：</p></li></ul><pre class="highlight"><span class="line">curl -H 'Content-Type:application/json' -XGET http://localhost:9200/Only_for_you/testing_data/1?pretty</span><br><span class="line"><span class="number">1</span></span><br></pre><h5 id="美化返回结果"><a href="#美化返回结果" class="headerlink" title="美化返回结果"></a>美化返回结果</h5><p>返回的响应包含了现在熟悉的元数据节点，增加了<code>_source</code>字段，它包含了在创建索引时我们发送给Elasticsearch的原始文档。</p><ul><li>pretty：在任意的查询字符串中增加pretty参数，类似于上面的例子。会让Elasticsearch美化输出(pretty-print)JSON响应以便更加容易阅读。</li><li>_source字段不会被美化，它的样子与我们输入的一致，现在只包含我们请求的字段，而且过滤了date字段。</li></ul><p>如果你只想得到_source字段而不要其他的元数据，你可以这样请求：</p><pre class="highlight"><span class="line">curl -H <span class="string">'Content-Type:application/json'</span> -XGET http://localhost:<span class="number">9200</span>/Only_for_you/testing_data/<span class="number">1</span>/_source</span><br><span class="line"><span class="number">1</span></span><br></pre><h5 id="返回响应头消息"><a href="#返回响应头消息" class="headerlink" title="返回响应头消息"></a>返回响应头消息</h5><p>请求返回的响应内容包括 {“found”: true}。这意味着文档已经找到。如果我们请求一个不存在的文档，依旧会得到一个JSON，不过found值变成了false。此外，HTTP响应状态码也会变成’404 Not Found’代替’200 OK’。我们可以在curl后加-i参数得到响应头：</p><pre class="highlight"><span class="line">curl -H 'Content-Type:application/json' -i -XGET http://localhost:9200/Only_for_you/testing_data/1?pretty</span><br><span class="line"><span class="number">1</span></span><br></pre><p>返回结果：</p><pre class="highlight"><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">content-type: application/json; charset=UTF<span class="number">-8</span></span><br><span class="line">content-length: <span class="number">337</span></span><br><span class="line"></span><br><span class="line">*********** 以下数据省略 ************</span><br><span class="line"><span class="number">123456</span></span><br></pre><h4 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h4><pre class="highlight"><span class="line">curl -H <span class="string">'Content-Type:application/json'</span> -XPOST http://localhost:<span class="number">9200</span>/Only_for_you/testing_data/<span class="number">1</span>/_update -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">  "script": "ctx._source.content = \"new content\""</span></span><br><span class="line"><span class="string">123</span></span><br></pre><h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><pre class="highlight"><span class="line">curl -XDELETE http://localhost:<span class="number">9200</span>/blog/article/<span class="number">1</span> </span><br><span class="line"><span class="number">1</span></span><br></pre><h4 id="增删改查-简单的概述下"><a href="#增删改查-简单的概述下" class="headerlink" title="增删改查 简单的概述下"></a>增删改查 简单的概述下</h4><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>POST</td><td>/uri 创建</td></tr><tr><td>DELETE</td><td>/uri/xxx 删除</td></tr><tr><td>PUT</td><td>/uri/xxx 更新或创建</td></tr><tr><td>GET</td><td>/uri/xxx 查看</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/gwd1154978352/article/details/82740424&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文档：https://blog.csdn.net/gwd11549
      
    
    </summary>
    
    
      <category term="ES检索" scheme="https://github.com/vp1009/vp1009.github.io.git/categories/ES%E6%A3%80%E7%B4%A2/"/>
    
    
      <category term="python" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch 介绍</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/08/01/ElasticSearch%20%E4%BB%8B%E7%BB%8D/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/08/01/ElasticSearch%20%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-08-01T04:09:00.000Z</published>
    <updated>2020-09-17T06:18:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200611210137425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200611210137425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><h4 id="什么是ElasticSearch？"><a href="#什么是ElasticSearch？" class="headerlink" title="什么是ElasticSearch？"></a>什么是ElasticSearch？</h4><p>Elasticsearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene基础之上。 Lucene 可以说是当下最先进、高性能、全功能的搜索引擎库—无论是开源还是私有。</p><p>Lucece 这个 可是个很牛逼的东西，整理好资料我会在接下来的博客中 发布。</p><p><strong>优点</strong>：</p><ul><li>一个分布式的实时文档存储，每个字段 可以被索引与搜索</li><li>一个分布式实时分析搜索引擎</li><li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</li></ul><p>Elasticsearch 可以横向扩展至数百（甚至数千）的服务器节点，同时可以处理PB级数据。Elasticsearch 天生就是分布式的，并且在设计时屏蔽了分布式的复杂性。</p><h4 id="用它来干什么"><a href="#用它来干什么" class="headerlink" title="用它来干什么?"></a>用它来干什么?</h4><p>Elasticsearch 是将所有的功能打包成一个单独的服务，这样你可以通过程序与它提供的简单的 RESTful API 进行通信， 可以使用自己喜欢的编程语言充当 web 客户端 和 命令行 去充当这个客户端。</p><p>Elasticsearch 在速度和可扩展性方面都表现出色，而且还能够索引多种类型的内容，这意味着其可用于多种用例：</p><ul><li>应用程序搜索</li><li>网站搜索</li><li>企业搜索</li><li>日志处理和分析</li><li>基础设施指标和容器监测</li><li>应用程序性能监测</li><li>地理空间数据分析和可视化</li><li>安全分析</li><li>业务分析</li></ul><h4 id="为何使用-Elasticsearch？"><a href="#为何使用-Elasticsearch？" class="headerlink" title="为何使用 Elasticsearch？"></a>为何使用 Elasticsearch？</h4><p>Elasticsearch 快，真男人的那种快。 由于 Elasticsearch 是在 Lucene 基础上构建而成的，所以在全文本搜索方面表现十分牛逼。Elasticsearch 同时还是一个近实时的搜索平台，这意味着从文档索引操作到文档变为可搜索状态之间的延时很短，一般只有一秒。因此，Elasticsearch 非常适用于对时间有严苛要求的用例，例如安全分析和基础设施监测。</p><p>Elasticsearch 具有<code>分布式</code>的本质特征。 Elasticsearch 中<code>存储的文档分布在不同的容器中</code>，这些容器称为分片，可以进行复制以提供数据冗余副本，以防发生硬件故障。Elasticsearch 的分布式特性使得它可以扩展至数百台（甚至数千台）服务器，并处理 PB 量级的数据。</p><p>Elasticsearch 包含一系列广泛的功能。 除了速度、可扩展性和弹性等优势以外，Elasticsearch 还有大量强大的内置功能（例如数据汇总和索引生命周期管理），可以方便用户更加高效地存储和搜索数据。</p><p>Elastic Stack 简化了数据采集、可视化和报告过程。 通过与 Beats 和 Logstash 进行集成，用户能够在向 Elasticsearch 中索引数据之前轻松地处理数据。同时，Kibana 不仅可针对 Elasticsearch 数据提供实时可视化，同时还提供 UI 以便用户快速访问应用程序性能监测 (APM)、日志和基础设施指标等数据。</p><h4 id="elastic-search-在项目中的位置"><a href="#elastic-search-在项目中的位置" class="headerlink" title="elastic search 在项目中的位置"></a>elastic search 在项目中的位置</h4><p><img src="https://img-blog.csdnimg.cn/20200612114228107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200612114228107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><h4 id="Elasticsearch-的工作原理是什么？"><a href="#Elasticsearch-的工作原理是什么？" class="headerlink" title="Elasticsearch 的工作原理是什么？"></a>Elasticsearch 的工作原理是什么？</h4><p>原始数据会从多个来源（包括日志、系统指标和网络应用程序）输入到 Elasticsearch 中。数据采集指在 Elasticsearch 中进行索引之前解析、标准化并充实这些原始数据的过程。这些数据在 Elasticsearch 中索引完成之后，用户便可针对他们的数据运行复杂的查询，并使用聚合来检索自身数据的复杂汇总。在 Kibana 中，用户可以基于自己的数据创建强大的可视化，分享仪表板，并对 Elastic Stack 进行管理。</p><h4 id="Elasticsearch-索引是什么？"><a href="#Elasticsearch-索引是什么？" class="headerlink" title="Elasticsearch 索引是什么？"></a>Elasticsearch 索引是什么？</h4><p>Elasticsearch 索引指相互关联的文档集合。Elasticsearch 会以 JSON 文档的形式存储数据。每个文档都会在一组键（字段或属性的名称）和它们对应的值（字符串、数字、布尔值、日期、数值组、地理位置或其他类型的数据）之间建立联系。</p><p>Elasticsearch 使用的是一种名为 <strong>倒排索引</strong> 的数据结构，这一结构的设计可以允许十分快速地进行全文本搜索。倒排索引会列出在所有文档中出现的每个特有词汇，并且可以找到包含每个词汇的全部文档。</p><p>在索引过程中，Elasticsearch 会存储文档并构建倒排索引，这样用户便可以近实时地对文档数据进行搜索。索引过程是在索引 API 中启动的，通过此 API 您既可向特定索引中添加 JSON 文档，也可更改特定索引中的 JSON 文档。</p><pre class="highlight"><span class="line">ELK &#x3D; Elasticsearch, Logstash, Kibana 是一套实时数据收集，存储，索引，检索，统计分析及可视化的解决方案。最新版本已经改名为Elastic Stack，并新增了Beats项目。</span><br></pre><h4 id="Logstash-的用途是什么？"><a href="#Logstash-的用途是什么？" class="headerlink" title="Logstash 的用途是什么？"></a>Logstash 的用途是什么？</h4><p>Logstash 是 Elastic Stack 的核心产品之一，可用来对数据进行聚合和处理，并将数据发送到 Elasticsearch。Logstash 是一个开源的服务器端数据处理管道，允许您在将数据索引到 Elasticsearch 之前同时从多个来源采集数据，并对数据进行充实和转换。</p><h4 id="Kibana-的用途是什么？"><a href="#Kibana-的用途是什么？" class="headerlink" title="Kibana 的用途是什么？"></a>Kibana 的用途是什么？</h4><p>Kibana 是用于 Elasticsearch 的数据可视化和管理工具，实时的提供直方图、线形图、饼状图和地图。Kibana 同时还包括诸如 Canvas 和 Elastic Maps 等高级应用程序；Canvas 允许用户基于自身数据创建定制的动态信息图表，而 Elastic Maps 则可用来对地理空间数据进行可视化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200611210137425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM
      
    
    </summary>
    
    
      <category term="ES检索" scheme="https://github.com/vp1009/vp1009.github.io.git/categories/ES%E6%A3%80%E7%B4%A2/"/>
    
    
      <category term="python" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>面向对象五大原则SOLID</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/07/29/s_i/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/07/29/s_i/</id>
    <published>2020-07-29T15:40:20.000Z</published>
    <updated>2020-07-29T23:47:43.397Z</updated>
    
    <content type="html"><![CDATA[<h4 id="浅谈面向对象五大原则-S-O-L-I-D"><a href="#浅谈面向对象五大原则-S-O-L-I-D" class="headerlink" title="浅谈面向对象五大原则 S.O.L.I.D"></a>浅谈面向对象五大原则 S.O.L.I.D</h4><p>设计模式中的SOLID原则，分别是单一原则、开闭原则、里氏替换原则、接口隔离原则、依赖倒置原则。前辈们总结出来的，遵循五大原则可以使程序解决紧耦合，更加健壮。<br>s<br>SRP    单一责任原则<br>OCP    开放封闭原则<br>LSP    里氏替换原则<br>ISP    接口隔离原则<br>DIP    依赖倒置原则</p><h4 id="单一责任原则"><a href="#单一责任原则" class="headerlink" title="单一责任原则"></a>单一责任原则</h4><p>指的是一个类或者一个方法只做一件事。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化就可能抑制或者削弱这个类完成其他职责的能力。例如餐厅服务员负责把订单给厨师去做，而不是服务员又要订单又要炒菜。</p><h4 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h4><p>对扩展开放，对修改关闭。意为一个类独立之后就不应该去修改它，而是以扩展的方式适应新需求。例如一开始做了普通计算器程序，突然添加新需求，要再做一个程序员计算器，这时不应该修改普通计算器内部，应该使用面向接口编程，组合实现扩展</p><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><p>所有基类出现的地方都可以用派生类替换而不会程序产生错误。子类可以扩展父类的功能，但不能改变父类原有的功能。例如机动车必须有轮胎和发动机，子类宝马和奔驰不应该改写没轮胎或者没发动机。</p><h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p>指的是高级模块不应该依赖低级模块，而是依赖抽象。抽象不能依赖细节，细节要依赖抽象。比如类A内有类B对象，称为类A依赖类B，但是不应该这样做，而是选择类A去依赖抽象。例如垃圾收集器不管垃圾是什么类型，要是垃圾就行。</p><h4 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h4><p>没人写一款程序能完全遵守SOLID原则，甚至有些设计模式是违反SOLID原则。如何权衡就要看利是否大于弊。不足之处望指教。s</p><p>转载于：<a><a href="https://www.cnblogs.com/suli0827/p/9515842.html" target="_blank" rel="noopener">https://www.cnblogs.com/suli0827/p/9515842.html</a></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;浅谈面向对象五大原则-S-O-L-I-D&quot;&gt;&lt;a href=&quot;#浅谈面向对象五大原则-S-O-L-I-D&quot; class=&quot;headerlink&quot; title=&quot;浅谈面向对象五大原则 S.O.L.I.D&quot;&gt;&lt;/a&gt;浅谈面向对象五大原则 S.O.L.I.D&lt;/h4&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="python" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>微服务</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/07/29/v_w/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/07/29/v_w/</id>
    <published>2020-07-29T15:24:30.000Z</published>
    <updated>2020-07-29T23:40:12.076Z</updated>
    
    <content type="html"><![CDATA[<p>微服务（Microservice）这个概念是2012年出现的，作为加快Web和移动应用程序开发进程的一种方法，2014年开始受到各方的关注，而2015年，可以说是微服务的元年；</p><p>越来越多的论坛、社区、blog以及互联网行业巨头开始对微服务进行讨论、实践，可以说这样更近一步推动了微服务的发展和创新。而微服务的流行，Martin Fowler功不可没。</p><p>1 互联网的快速发展</p><p>2 敏捷开发 精益方法的深入人心</p><p>3 容器技术的成熟</p><h4 id="传统的项目架构？"><a href="#传统的项目架构？" class="headerlink" title="传统的项目架构？"></a>传统的项目架构？</h4><p><strong>优点：</strong></p><p>①开发简单，集中式管理</p><p>②基本不会重复开发</p><p>③功能都在本地，没有分布式的管理和调用消耗</p><p><strong>缺点：</strong></p><p>1、效率低：开发都在同一个项目改代码，相互等待，冲突不断</p><p>2、维护难：代码功功能耦合在一起，新人不知道何从下手</p><p>3、不灵活：构建时间长，任何小修改都要重构整个项目，耗时</p><p>4、稳定性差：一个微小的问题，都可能导致整个应用挂掉</p><p>5、扩展性不够：无法满足高并发下的业务需求</p><p><strong>常见的系统架构遵循的三个标准和业务驱动力：</strong></p><p>1、提高敏捷性：及时响应业务需求，促进企业发展</p><p>2、提升用户体验：提升用户体验，减少用户流失</p><p>3、降低成本：降低增加产品、客户或业务方案的成本</p><h4 id="现在我们来看一下微服务必须需要的原则？"><a href="#现在我们来看一下微服务必须需要的原则？" class="headerlink" title="现在我们来看一下微服务必须需要的原则？"></a>现在我们来看一下微服务必须需要的原则？</h4><p>1，单一功能职责</p><p>   单一功能职责是SOLID设计模式之一，它意味着一个单元，无论是类、函数还是微服务，都应该有且只有一个职责。在任何时候，一个微服务都不应该有一个以上的职责。</p><p>2，围绕着业务功能设计</p><p>   微服务应该专注于特定的业务功能，并确保它有助于完成任务。微服务绝不应限制自己采用最适合解决业务目的的适当技术栈或后端数据库存储。当我们设计单个应用程序时，这常常是一个约束，我们试图在某些领域中使用一些折中来解决多个业务解决方案。微服务使您能够选择最适合当前问题的解决方案。（某个微服务不仅仅只为一个微服务来服务，他要为其他的微服务提供支持，也就是全局的架构）</p><p>3，你建造它，你拥有它。</p><p>这种设计的另一个重要方面与开发前后的职责有关。在大型组织中，通常由一个团队开发app location(应用)，经过一些知识转移会议后，将项目移交给维护团队。在微服务中，构建服务的团队拥有它，并负责在将来维护它。这使开发人员能够接触到他们的软件的日常操作，并且他们能够更好地理解他们构建的产品在现实世界中是如何被客户使用的。</p><p>4，基础设施自动化</p><p>准备和构建微服务的基础设施是另一个非常重要的需求，服务应该是可独立部署的，并且应该捆绑所有依赖项，包括库依赖项，甚至是执行环境，如抽象物理资源（web服务器和容器或虚拟机）。</p><p>微服务和SOA之间的一个主要区别在于它们的自治级别。虽然大多数SOA实现提供了服务级抽象，但是微服务更进一步抽象了实现和执行环境。</p><p>在传统的应用程序开发中，我们构建一个WAR或EAR，然后将其部署到JEE应用程序服务器中，例如使用JBoss、WebLogic、WebSphere等等。我们可以将多个应用程序部署到同一个JEE容器中。在理想的场景中，在微服务方法中，每个微服务将构建为一个胖Jar，嵌入所有依赖项，并作为独立的Java进程运行。</p><p>5，容错设计</p><p>微服务的设计应考虑到故障情况。如果服务失败，或者宕机一段时间，该怎么办?这些都是非常重要的问题，必须在实际编码开始之前解决——以便清楚地估计服务故障将如何影响用户体验。</p><p>快速故障是另一个用于构建容错、弹性系统的概念。这种哲学提倡预期失败的系统，而不是构建永远不会失败的系统。由于服务在任何时候都可能失败，因此能够快速检测故障并在可能的情况下自动恢复服务非常重要。</p><p>微服务应用程序非常重视应用程序的实时监控，检查体系结构元素(数据库每秒接收多少请求)和业务相关指标(例如每分钟接收多少订单)。语义监视可以提供出错的早期预警系统，从而触发开发团队进行跟踪和调查。</p><h4 id="微服务的目的？"><a href="#微服务的目的？" class="headerlink" title="微服务的目的？"></a>微服务的目的？</h4><p><strong>目的：</strong>有效的拆分应用，实现敏捷开发和部署</p><h4 id="微服务的优点-？"><a href="#微服务的优点-？" class="headerlink" title="微服务的优点 ？"></a>微服务的优点 ？</h4><p>微服务有许多优点相比传统的多层架构（单体庞大应用），微服务的优点如下：</p><p>1，使用微服务，架构师和开发人员可以为每个微服务选择适合于特定用途的架构和技术(通晓多种语言对应的熟悉语言的架构)。这为以更经济有效的方式设计更适合的解决方案提供了灵活性。</p><p>2，由于服务相当简单，而且规模更小，企业可以试验新的流程、算法、业务逻辑等等。它通过提供快速试验和失败的能力，使企业能够进行颠覆性创新。</p><p>3，微服务能够实现选择性的可伸缩性，即每个服务都可以独立地伸缩，而且伸缩的成本相对于单体应用方面要低。</p><p>4，微服务是自包含的、独立的部署模块，当第二个微服务没有按照我们的需要执行时，可以使用另一个类似的微服务替换一个微服务。它有助于做出正确的“购买构建”决策，而这通常是许多企业面临的挑战。</p><p>5，微服务帮助我们构建本质上是有机的系统(有机的系统是通过添加越来越多的功能在一段时间内横向增长的系统)。因为微服务都是关于独立可管理的服务——它允许在需要时添加越来越多的服务，而对现有服务的影响最小。</p><p>6，技术变化是软件开发中的障碍之一。使用微服务，可以单独更改或升级每个服务的技术，而不是升级整个应用程序。</p><p>7，由于microservices将服务运行时环境和服务本身打包在一起，因此允许在同一环境中共存多个版本的服务。</p><p>8，最后，微服务还支持更小、更专注的敏捷开发团队。团队将根据微服务的边界进行组织。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;微服务（Microservice）这个概念是2012年出现的，作为加快Web和移动应用程序开发进程的一种方法，2014年开始受到各方的关注，而2015年，可以说是微服务的元年；&lt;/p&gt;
&lt;p&gt;越来越多的论坛、社区、blog以及互联网行业巨头开始对微服务进行讨论、实践，可以说
      
    
    </summary>
    
    
    
      <category term="python" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django工程搭建</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/07/23/d_g/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/07/23/d_g/</id>
    <published>2020-07-22T17:20:23.000Z</published>
    <updated>2020-09-02T10:55:52.656Z</updated>
    
    <content type="html"><![CDATA[<h3 id="后端django工程"><a href="#后端django工程" class="headerlink" title="后端django工程"></a>后端django工程</h3><ol><li><p>框架</p><ul><li>django</li></ul></li><li><p>用户模型</p><ul><li>django内置的user模型<ul><li>添加导包路径 apps 目录添加到 sys.path里</li><li>配置pycharm的包搜索路径</li></ul></li><li>扩展用户模型: 增加手机号,昵称,头像,地址,…..</li></ul></li><li><p>认证模型</p><ul><li>前后端不分离: session认证(基于cookie, 服务端存储session信息)</li><li>前后端分离: jwt认证(不受限于跨域, 服务端不存储信息)</li></ul></li><li><p>基础结构及配置</p><ul><li>基础目录配置</li><li>cors配置</li></ul></li><li><p>drf初始化</p><ul><li><p>安装: pip install djangorestframework, django-filter</p></li><li><p>注册应用: INSTALLED_APPS 中 […’rest_framework’, ‘django_filters’]</p></li><li><p>添加配置:</p><pre class="highlight"><span class="line"><span class="comment"># 过滤器</span></span><br><span class="line"><span class="comment"># 1,安装 django-filter</span></span><br><span class="line"><span class="comment"># 2,注册应用</span></span><br><span class="line"><span class="comment"># 3,配置settings, 在view里配置可过滤的字段</span></span><br><span class="line"><span class="comment"># 4,使用 查询字符串携带过滤信息</span></span><br><span class="line"></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># 文档报错： AttributeError: ‘AutoSchema’ object has no attribute ‘get_link’</span></span><br><span class="line">    <span class="comment"># 用下面的设置可以解决</span></span><br><span class="line">    <span class="string">'DEFAULT_SCHEMA_CLASS'</span>: <span class="string">'rest_framework.schemas.AutoSchema'</span>,</span><br><span class="line">    <span class="comment"># 默认设置是:</span></span><br><span class="line">    <span class="comment"># 'DEFAULT_SCHEMA_CLASS': 'rest_framework.schemas.openapi.AutoSchema',</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 异常处理器</span></span><br><span class="line">    <span class="comment"># 'EXCEPTION_HANDLER': 'user.utils.exception_handler',</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Base API policies</span></span><br><span class="line">    <span class="string">'DEFAULT_RENDERER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.renderers.JSONRenderer'</span>,</span><br><span class="line">        <span class="string">'rest_framework.renderers.BrowsableAPIRenderer'</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'DEFAULT_PARSER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.parsers.JSONParser'</span>,</span><br><span class="line">        <span class="string">'rest_framework.parsers.FormParser'</span>,</span><br><span class="line">        <span class="string">'rest_framework.parsers.MultiPartParser'</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'DEFAULT_AUTHENTICATION_CLASSES'</span>: [  <span class="comment"># 认证器</span></span><br><span class="line">        <span class="string">'rest_framework.authentication.SessionAuthentication'</span>,  <span class="comment"># 使用session时的认证器</span></span><br><span class="line">        <span class="string">'rest_framework.authentication.BasicAuthentication'</span>  <span class="comment"># 提交表单时的认证器</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'DEFAULT_PERMISSION_CLASSES'</span>: [  <span class="comment"># 权限配置, 顺序靠上的严格</span></span><br><span class="line">        <span class="string">'rest_framework.permissions.IsAdminUser'</span>,  <span class="comment"># 管理员可以访问</span></span><br><span class="line">        <span class="string">'rest_framework.permissions.IsAuthenticated'</span>,  <span class="comment"># 认证用户可以访问</span></span><br><span class="line">        <span class="string">'rest_framework.permissions.IsAuthenticatedOrReadOnly'</span>,  <span class="comment"># 认证用户可以访问, 否则只能读取</span></span><br><span class="line">        <span class="string">'rest_framework.permissions.AllowAny'</span>,  <span class="comment"># 所有用户都可以访问</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment"># 限流</span></span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.throttling.AnonRateThrottle'</span>,</span><br><span class="line">        <span class="string">'rest_framework.throttling.UserRateThrottle'</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment"># 限流策略</span></span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_RATES'</span>: &#123;</span><br><span class="line">        <span class="string">'user'</span>: <span class="string">'10/hour'</span>,</span><br><span class="line">        <span class="string">'anon'</span>: <span class="string">'3/day'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">'DEFAULT_CONTENT_NEGOTIATION_CLASS'</span>: <span class="string">'rest_framework.negotiation.DefaultContentNegotiation'</span>,</span><br><span class="line">    <span class="string">'DEFAULT_METADATA_CLASS'</span>: <span class="string">'rest_framework.metadata.SimpleMetadata'</span>,</span><br><span class="line">    <span class="string">'DEFAULT_VERSIONING_CLASS'</span>: <span class="literal">None</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全局分页器, 例如 省市区的数据自定义分页器, 不需要分页</span></span><br><span class="line">    <span class="string">'DEFAULT_PAGINATION_CLASS'</span>: <span class="string">'rest_framework.pagination.PageNumberPagination'</span>,</span><br><span class="line">    <span class="comment"># 每页返回数量</span></span><br><span class="line">    <span class="string">'PAGE_SIZE'</span>: <span class="number">10</span>,  <span class="comment"># 默认 None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 过滤器后端</span></span><br><span class="line">    <span class="string">'DEFAULT_FILTER_BACKENDS'</span>: [</span><br><span class="line">        <span class="string">'django_filters.rest_framework.DjangoFilterBackend'</span>,</span><br><span class="line">        <span class="comment"># 'django_filters.rest_framework.backends.DjangoFilterBackend', 包路径有变化</span></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Filtering 过滤排序</span></span><br><span class="line">    <span class="string">'SEARCH_PARAM'</span>: <span class="string">'search'</span>,</span><br><span class="line">    <span class="string">'ORDERING_PARAM'</span>: <span class="string">'ordering'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">'NUM_PROXIES'</span>: <span class="literal">None</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Versioning  接口版本控制</span></span><br><span class="line">    <span class="string">'DEFAULT_VERSION'</span>: <span class="literal">None</span>,</span><br><span class="line">    <span class="string">'ALLOWED_VERSIONS'</span>: <span class="literal">None</span>,</span><br><span class="line">    <span class="string">'VERSION_PARAM'</span>: <span class="string">'version'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Authentication  认证</span></span><br><span class="line">    <span class="comment"># 未认证用户使用的用户类型</span></span><br><span class="line">    <span class="string">'UNAUTHENTICATED_USER'</span>: <span class="string">'django.contrib.auth.models.AnonymousUser'</span>,</span><br><span class="line">    <span class="comment"># 未认证用户使用的Token值</span></span><br><span class="line">    <span class="string">'UNAUTHENTICATED_TOKEN'</span>: <span class="literal">None</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># View configuration</span></span><br><span class="line">    <span class="string">'VIEW_NAME_FUNCTION'</span>: <span class="string">'rest_framework.views.get_view_name'</span>,</span><br><span class="line">    <span class="string">'VIEW_DESCRIPTION_FUNCTION'</span>: <span class="string">'rest_framework.views.get_view_description'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">'NON_FIELD_ERRORS_KEY'</span>: <span class="string">'non_field_errors'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Testing</span></span><br><span class="line">    <span class="string">'TEST_REQUEST_RENDERER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.renderers.MultiPartRenderer'</span>,</span><br><span class="line">        <span class="string">'rest_framework.renderers.JSONRenderer'</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'TEST_REQUEST_DEFAULT_FORMAT'</span>: <span class="string">'multipart'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Hyperlink settings</span></span><br><span class="line">    <span class="string">'URL_FORMAT_OVERRIDE'</span>: <span class="string">'format'</span>,</span><br><span class="line">    <span class="string">'FORMAT_SUFFIX_KWARG'</span>: <span class="string">'format'</span>,</span><br><span class="line">    <span class="string">'URL_FIELD_NAME'</span>: <span class="string">'url'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Input and output formats</span></span><br><span class="line">    <span class="string">'DATE_FORMAT'</span>: ISO_8601,</span><br><span class="line">    <span class="string">'DATE_INPUT_FORMATS'</span>: [ISO_8601],</span><br><span class="line"></span><br><span class="line">    <span class="string">'DATETIME_FORMAT'</span>: ISO_8601,</span><br><span class="line">    <span class="string">'DATETIME_INPUT_FORMATS'</span>: [ISO_8601],</span><br><span class="line"></span><br><span class="line">    <span class="string">'TIME_FORMAT'</span>: ISO_8601,</span><br><span class="line">    <span class="string">'TIME_INPUT_FORMATS'</span>: [ISO_8601],</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Encoding</span></span><br><span class="line">    <span class="string">'UNICODE_JSON'</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">'COMPACT_JSON'</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">'STRICT_JSON'</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">'COERCE_DECIMAL_TO_STRING'</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">'UPLOADED_FILES_USE_URL'</span>: <span class="literal">True</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Browseable API</span></span><br><span class="line">    <span class="string">'HTML_SELECT_CUTOFF'</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="string">'HTML_SELECT_CUTOFF_TEXT'</span>: <span class="string">"More than &#123;count&#125; items..."</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Schemas</span></span><br><span class="line">    <span class="string">'SCHEMA_COERCE_PATH_PK'</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">'SCHEMA_COERCE_METHOD_NAMES'</span>: &#123;</span><br><span class="line">        <span class="string">'retrieve'</span>: <span class="string">'read'</span>,</span><br><span class="line">        <span class="string">'destroy'</span>: <span class="string">'delete'</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;后端django工程&quot;&gt;&lt;a href=&quot;#后端django工程&quot; class=&quot;headerlink&quot; title=&quot;后端django工程&quot;&gt;&lt;/a&gt;后端django工程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;框架&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;django&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="Django" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django Admin上传图片</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/07/22/Django%20Admin%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/07/22/Django%20Admin%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</id>
    <published>2020-07-22T03:11:23.000Z</published>
    <updated>2020-09-13T09:11:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h3><p>Django有提供文件系统支持，在Admin站点中可以轻松上传图片。</p><p>使用Admin站点保存图片，需要安装Python的图片操作包</p><pre class="highlight"><span class="line">pip install Pillow</span><br><span class="line"><span class="number">1</span></span><br></pre><h4 id="1-配置"><a href="#1-配置" class="headerlink" title="1 配置"></a>1 配置</h4><p>默认情况下，Django会将上传的图片保存在本地服务器上，需要配置保存的路径。</p><p>我们可以将上传的文件保存在静态文件目录中，如我们之前设置的static目录中在settings.py 文件中添加如下上传保存目录信息</p><pre class="highlight"><span class="line">MEDIA_ROOT=os.path.join(BASE_DIR,<span class="string">"static/media"</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre><p><img src="https://img-blog.csdnimg.cn/20200425223259996.png" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425223259996.png" class="lozad post-image"></p><h4 id="2-为模型类添加ImageField字段"><a href="#2-为模型类添加ImageField字段" class="headerlink" title="2 为模型类添加ImageField字段"></a>2 为模型类添加ImageField字段</h4><p>我们为之前的BookInfo模型类添加一个ImageFiled</p><pre class="highlight"><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    image = models.ImageField(upload_to=<span class="string">'book'</span>, verbose_name=<span class="string">'图片'</span>, null=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    upload_to 选项指明该字段的图片保存在MEDIA_ROOT目录中的哪个子目录</span><br><span class="line"><span class="number">123456</span></span><br></pre><ul><li>进行数据库迁移操作</li></ul><pre class="highlight"><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br><span class="line"><span class="number">12</span></span><br></pre><h4 id="3-使用Admin站点上传图片"><a href="#3-使用Admin站点上传图片" class="headerlink" title="3 使用Admin站点上传图片"></a>3 使用Admin站点上传图片</h4><p>进入Admin站点的图书管理页面，选择一个图书，能发现多出来一个上传图片的字段</p><p><img src="https://img-blog.csdnimg.cn/20200425223441314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425223441314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><p>选择一张图片并保存后，图片会被保存在<code>static/media/book/</code>目录下。</p><p>在数据库中，我们能看到image字段被设置为图片的路径</p><p><img src="https://img-blog.csdnimg.cn/20200425223503320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425223503320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;上传图片&quot;&gt;&lt;a href=&quot;#上传图片&quot; class=&quot;headerlink&quot; title=&quot;上传图片&quot;&gt;&lt;/a&gt;上传图片&lt;/h3&gt;&lt;p&gt;Django有提供文件系统支持，在Admin站点中可以轻松上传图片。&lt;/p&gt;
&lt;p&gt;使用Admin站点保存图片，需要安装Py
      
    
    </summary>
    
    
      <category term="djangobook" scheme="https://github.com/vp1009/vp1009.github.io.git/categories/djangobook/"/>
    
    
      <category term="python" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>集群or分布式</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/07/20/r_d/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/07/20/r_d/</id>
    <published>2020-07-19T19:09:23.000Z</published>
    <updated>2020-09-02T10:56:48.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集群-or-分布式"><a href="#集群-or-分布式" class="headerlink" title="集群 or 分布式"></a>集群 or 分布式</h3><p>一开始, 一个人干</p><p>能力不足了,  为了提高性能</p><p>一群人一起干,   干同样的事情,   集群( 一个地点)</p><p>分布式(分步式),  炒菜</p><p>每个人擅长的部分不一样, </p><p>买菜,  一个人</p><p>洗菜,  一个人</p><p>切菜, 两个人(集群)</p><p>炒菜, 五个人(集群)</p><p>分布式 (很多业务, 每个业务又是一个集群)</p><p>结论:  </p><p>​    集群: (很多机器, 合作起来提供一个服务)</p><p>​    分布式: 分步骤, 合作完成一个功能 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;集群-or-分布式&quot;&gt;&lt;a href=&quot;#集群-or-分布式&quot; class=&quot;headerlink&quot; title=&quot;集群 or 分布式&quot;&gt;&lt;/a&gt;集群 or 分布式&lt;/h3&gt;&lt;p&gt;一开始, 一个人干&lt;/p&gt;
&lt;p&gt;能力不足了,  为了提高性能&lt;/p&gt;
&lt;p&gt;一群人
      
    
    </summary>
    
    
    
      <category term="Django" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Celery+Redis</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/07/17/c_y/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/07/17/c_y/</id>
    <published>2020-07-17T05:53:00.000Z</published>
    <updated>2020-07-23T04:05:08.444Z</updated>
    
    <content type="html"><![CDATA[<p>1、任务（tasks）–用户定义的函数，用于实现用户的功能，比如执行一个耗时很长的任务</p><p>2、中间介（Broker）–用于存放tasks的地方，但是这个中间介需要解决一个问题，就是可能需要存放非常非常多的tasks，而且要保证Worker能够从这里拿取</p><p>3、执行者（Worker）–用于执行tasks，也就是真正调用我们在tasks中定义的函数</p><p>4、存储（Backend）–把执行tasks返回的结果进行存储，以供用户查看或调用</p><h2 id="1、各模块功能"><a href="#1、各模块功能" class="headerlink" title="1、各模块功能"></a>1、各模块功能</h2><p>Celery中，以上组件具体功能如下：</p><p><strong>任务模块 Task</strong></p><p>包含异步任务和定时任务。其中，异步任务通常在业务逻辑中被触发并发往任务队列，而定时任务由 Celery Beat 进程周期性地将任务发往任务队列。</p><p><strong>消息中间件 Broker</strong></p><p>Broker，即为任务调度队列，接收任务生产者发来的消息（即任务），将任务存入队列。Celery 本身不提供队列服务，官方推荐使用 RabbitMQ 和 Redis 等。</p><p><strong>任务执行单元 Worker</strong></p><p>Worker 是执行任务的处理单元，它实时监控消息队列，获取队列中调度的任务，并执行它。</p><p><strong>任务结果存储 Backend</strong></p><p>Backend 用于存储任务的执行结果，以供查询。同消息中间件一样，存储也可使用 RabbitMQ, Redis 和 MongoDB 等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、任务（tasks）–用户定义的函数，用于实现用户的功能，比如执行一个耗时很长的任务&lt;/p&gt;
&lt;p&gt;2、中间介（Broker）–用于存放tasks的地方，但是这个中间介需要解决一个问题，就是可能需要存放非常非常多的tasks，而且要保证Worker能够从这里拿取&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="Redis" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Django Admin 调整站点信息（更改 Admin站点的名称信息）</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/07/16/Django%20Admin%20%E8%B0%83%E6%95%B4%E7%AB%99%E7%82%B9%E4%BF%A1%E6%81%AF%EF%BC%88%E6%9B%B4%E6%94%B9%20Admin%E7%AB%99%E7%82%B9%E7%9A%84%E5%90%8D%E7%A7%B0%E4%BF%A1%E6%81%AF%EF%BC%89/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/07/16/Django%20Admin%20%E8%B0%83%E6%95%B4%E7%AB%99%E7%82%B9%E4%BF%A1%E6%81%AF%EF%BC%88%E6%9B%B4%E6%94%B9%20Admin%E7%AB%99%E7%82%B9%E7%9A%84%E5%90%8D%E7%A7%B0%E4%BF%A1%E6%81%AF%EF%BC%89/</id>
    <published>2020-07-15T16:22:09.000Z</published>
    <updated>2020-09-13T09:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="调整站点信息"><a href="#调整站点信息" class="headerlink" title="调整站点信息"></a>调整站点信息</h3><p>Admin站点的名称信息也是可以自定义的。</p><p>未调整前如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200425222752410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425222752410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><ul><li><code>admin.site.site_header</code> 设置网站页头</li><li><code>admin.site.site_title</code> 设置页面标题</li><li><code>admin.site.index_title</code> 设置首页标语</li></ul><p>在 <code>admin.py</code> 文件中添加一下信息</p><pre class="highlight"><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line">admin.site.site_header = <span class="string">'传智书城'</span></span><br><span class="line">admin.site.site_title = <span class="string">'传智书城MIS'</span></span><br><span class="line">admin.site.index_title = <span class="string">'欢迎使用传智书城MIS'</span></span><br><span class="line"><span class="number">12345</span></span><br></pre><p>刷新网站，效果如下</p><p><img src="https://img-blog.csdnimg.cn/20200425223005559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200425223005559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;调整站点信息&quot;&gt;&lt;a href=&quot;#调整站点信息&quot; class=&quot;headerlink&quot; title=&quot;调整站点信息&quot;&gt;&lt;/a&gt;调整站点信息&lt;/h3&gt;&lt;p&gt;Admin站点的名称信息也是可以自定义的。&lt;/p&gt;
&lt;p&gt;未调整前如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=
      
    
    </summary>
    
    
      <category term="djangobook" scheme="https://github.com/vp1009/vp1009.github.io.git/categories/djangobook/"/>
    
    
      <category term="python" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>django之redis和django-redis的使用</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/07/15/r_z/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/07/15/r_z/</id>
    <published>2020-07-15T13:10:20.000Z</published>
    <updated>2020-07-15T13:39:33.973Z</updated>
    
    <content type="html"><![CDATA[<p>-redis</p><p>　　-非关系型内存数据（nosql:mongodb,redis），key-value的存储<br>　　-单线程单进程，qps:10w<br>　　-Memcached：多线程，支持的数据类型少：只支持字符串类型，不支持持久化<br>　　-redis：5大数据类型<br>　　　　k1:‘123‘, 字符串<br>　　　　k2:[1,2,3,4], 列表/数组<br>　　　　k3:{1,2,3,4} 集合：去重，爬虫去重<br>　　　　k4:{name:lqz,age:12} 字典/哈希表<br>　　　　k5:{(‘lqz‘,18),(‘egon‘,33)} 有序集合：游戏排行榜<br>　　-redis支持持久化：两种持久化的方案</p><p>-python操作redis<br>　　from redis import Redis<br>　　conn=Redis()</p><p>-redis连接池<br>　　#pool需要做成单例<br>　　pool=ConnectionPool(host=‘127.0.0.1‘,port=6379,max_connections=100)<br>　　conn=Redis(connection_pool=pool)</p><p>-redis之字符串操作<br>　　-set<br>　　-get<br>　　-mset<br>　　-mget<br>　　-incr<br>　　-decr<br>　　-append</p><p>-redis之hash操作<br>　　-hset<br>　　-hmset<br>　　-hget<br>　　-hmget<br>　　-hgetall<br>　　-hlen<br>　　-hdel<br>　　-hincrby<br>　　-hscan<br>　　-hscan_iter</p><p>-redis之列表操作<br>　　-lpush<br>　　-llen<br>　　-linsert<br>　　-lpop<br>　　-blpop</p><p>　　-自定义增量迭代</p><p>只支持一层的5大数据类型：也就是说字典的value值只能是字符串，列表的value值只能是字符串</p><p>-redis的其他操作<br>　　-delete<br>　　-exisit<br>　　-rename<br>　　-keys 模糊匹配key值<br>　　-expire<br>　　-type</p><p>-事务（重点）<br>　　conn=Redis()<br>　　pipe = conn.pipeline(transaction=True)<br>　　pipe.multi()<br>　　pipe.set(‘name‘, ‘alex‘)<br>　　pipe.set(‘role‘, ‘sb‘)<br>　　pipe.execute()</p><p>-在django中使用redis<br>　　-所有框架都能用的方式：<br>　　　　-先新建一个py文件，生成一个redis连接池<br>　　　　-在哪用，导过来，<br>　　　　　　conn=Redis(connection_pool=POOL)<br>　　　　　　conn.set(‘xxx‘,‘yyyy‘)<br>　　-django中使用：django-redis模块<br>　　　　-在setting中配置：<br>　　　　　　CACHES = {<br>　　　　　　　　“default”: {<br>　　　　　　　　　　“BACKEND”: “django_redis.cache.RedisCache”,<br>　　　　　　　　　　“LOCATION”: “redis://127.0.0.1:6379”,<br>　　　　　　　　　　“OPTIONS”: {<br>　　　　　　　　　　　　“CLIENT_CLASS”: “django_redis.client.DefaultClient”,<br>　　　　　　　　　　　　“CONNECTION_POOL_KWARGS”: {“max_connections”: 100}}}}<br>　　　　-使用<br>　　　　　　在使用的位置：<br>　　　　　　from django_redis import get_redis_connection<br>　　　　　　conn=get_redis_connection()<br>　　　　　　conn.set</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;-redis&lt;/p&gt;
&lt;p&gt;　　-非关系型内存数据（nosql:mongodb,redis），key-value的存储&lt;br&gt;　　-单线程单进程，qps:10w&lt;br&gt;　　-Memcached：多线程，支持的数据类型少：只支持字符串类型，不支持持久化&lt;br&gt;　　-redis
      
    
    </summary>
    
    
    
      <category term="Redis" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件操作</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/07/14/l_n/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/07/14/l_n/</id>
    <published>2020-07-14T01:02:20.000Z</published>
    <updated>2020-07-14T14:18:11.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux文件操作（看大小，tail-f-n-grep-head-cut-wc-sort）"><a href="#Linux文件操作（看大小，tail-f-n-grep-head-cut-wc-sort）" class="headerlink" title="Linux文件操作（看大小，tail -f -n grep head cut wc sort）"></a>Linux文件操作（看大小，tail -f -n grep head cut wc sort）</h2><p>命令head默认是查看文件的前10行，通过命令head /etc/passwd查看文件的前10行，也可以增加参数-n 15查看前15行，参数n在这里是指定行数的意思。我们可以通过命令man head查看更多的参数使用方法。</p><p>命令tail默认是查看文件的最后10行，通过命令tail /etc/passwd查看文件的最后10行，也可以增加参数-n 5查看最后5行，参数n在这里是指定行数的意思。我们可以通过man tail查看更多的参数使用方法。命令tail经常被用来查看最新的日志信息。可以用tailf命令或者tail –f来实时查看日志信息。</p><p>命令grep用来过滤信息，通过命令cat /etc/passwd | grep thomas从passwd文件中快速找到还有thomas信息的内容。通过命令cat /etc/passwd | grep –n tcpdump从passwd文件中快速找到tcpdump信息的内容并显示出行号，参数-v是取反，如上面2个例子找的信息里面不包括thomas和tcpdump的信息，我们通过man grep可以学习更多的参数使用方法。</p><p>命令cut可以只显示某一列的内容，如果我们只想看某个文件的第一列的话可以用cut –d: -f1 /etc/passwd,参数f1在这里的意思是第一列，我们可以通过man cut来查看更多的参数使用方法。</p><p>命令wc是用来统计字符数的，为文件信息的搜集提供帮助，如我们想知道根目录下有多少个目录，直接可以用ls / | wc –l直接计算出根目录下有多少行数，在目录和文件数特别多的时候非常好用。如我们用ls –R /etc | wc –l来查看/etc目录和文件数行数是多少，其中参数R是递归查找，意思是可以查到目录下面的文件。通过man wc查看更多的参数使用方法。</p><p>命令sort是用来排序的，我们用命令sort –n 参数n是以数字排列顺序，参数t是以什么为分隔符，参数k是选择第几列，通过命令sort –n –t: -k3 /etc/passwd来对/etc/目录下passwd文件已冒号为分界符第3列用数字排序。我们通过man sort可以查看更多的参数使用方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux文件操作（看大小，tail-f-n-grep-head-cut-wc-sort）&quot;&gt;&lt;a href=&quot;#Linux文件操作（看大小，tail-f-n-grep-head-cut-wc-sort）&quot; class=&quot;headerlink&quot; title=&quot;Li
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>关于mysql优化</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/07/14/m_s/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/07/14/m_s/</id>
    <published>2020-07-14T01:02:20.000Z</published>
    <updated>2020-07-21T16:01:22.708Z</updated>
    
    <content type="html"><![CDATA[<h4 id="优化数据的访问"><a href="#优化数据的访问" class="headerlink" title="优化数据的访问"></a>优化数据的访问</h4><ol><li><p>确认应用程序是否检索了大量超过需要的数据。通常以为访问太多的行，或者访问太多的列</p></li><li><p>确认mysql服务器层是否存在分析大量超过需要的数据行</p></li><li><p>当访问量过大时，考虑数据库读写分离原则，当我们使用分离，数据库的压力还是很大的时候，这就需要使用数据拆分了。数据库的拆分原则：就是通过某种特定的条件，按照某个维度，将我们存放同一个数据库中的数据分散存到多个数据库（主机）上面已达到分散单裤（主机）负载的效果。</p><ul><li><p>首选是垂直拆分：一个数据库是由多个表组成，每个表对应着不同的业务，垂直切分指按照业务进行分类，分布到不同的数据库上面，这样也就将压力分布到不同的数据库上。 <strong>优点</strong> ：1 拆分后业务清晰，拆分规则明确 2 系统之间整合或扩展容易 3 数据维护简单 <strong>缺点</strong> ：1 部分代码无法join，只能通过接口方式解决，提高了系统复杂度 2 事物处理复杂</p></li><li><p>水平拆分：相似与垂直拆分，水平拆分不是将表的数据做分类，而是按照某个字段的某种规则分散到多个库之中，每个表包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行进行切分，就是讲表中的某些行切分到一个数据库，而另外的某些行又切分到其他的数据库中。</p></li><li><p><strong>总</strong> ： 如果分库后仍然查的满的话，按照分库的思想做分表的工作数据库采用分布式数据库（所有的节点加起来才是整体数据），服务器满足不了大型系统增长的业务需求，数据库读写分离随着业务的发展，最终也无法满足，需要分布式数据库及分布式文件系统来支撑。</p><p>优先考虑缓存讲题对数据库的操作</p><p>在考录读写分离，降低数据库写操作</p><p>首先垂直拆分在水平拆分</p><p>先分库在分表</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;优化数据的访问&quot;&gt;&lt;a href=&quot;#优化数据的访问&quot; class=&quot;headerlink&quot; title=&quot;优化数据的访问&quot;&gt;&lt;/a&gt;优化数据的访问&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;确认应用程序是否检索了大量超过需要的数据。通常以为访问太多的行，或者访问太多的列&lt;
      
    
    </summary>
    
    
    
      <category term="Mysql" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>验证码的时效性</title>
    <link href="https://github.com/vp1009/vp1009.github.io.git/2020/07/14/r_s/"/>
    <id>https://github.com/vp1009/vp1009.github.io.git/2020/07/14/r_s/</id>
    <published>2020-07-14T01:02:20.000Z</published>
    <updated>2020-07-22T12:00:29.936Z</updated>
    
    <content type="html"><![CDATA[<p>redis场景，服务器内存不够了，怎么办（或者说被人干蹦了），我们的redis信息是不是就没了，redis服务hi不是挂了，如何优化？容灾方式？分配redis多大内存，是否满足我们的生产的需求，一般我们会缓存到多大的一个数据量，峰值是多少？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>Redis场景，服务器内存不够了：</p><p>一，增加内存</p><p>redis存储在内存中，数据太多，占用大多内存，那么增加内存就是直接的方法，但是这个方法一般不采用，因为内存满了就加内存，满了就加，那代价太大，相当于用钱解决的问题，不首先考虑，一般有方面都做到最优化，才考虑此方法。</p><p>二，搭建Redis集群</p><ol><li>所有的redis节点批次互联（PING-PONG机制),内部使用二进制协议优化传输速度和宽带。</li><li>节点的fail是通过集群中超过半数的节点检测时效时才生效。</li><li>客户端与redis节点智联，不需要中间proxy层，客户端不需要连接集群所有的节点，连接集群中任何一个可用的节点即可。</li><li>redis-cluster把所有的物理节点映射到[0-16383]slot上，cluster负责维护node&lt;-&gt;slot&lt;-&gt;value</li></ol><p>Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点，最多16384个节点。</p><p>节点间相互通信，一半以上节点ping不同一个节点，则说明此节点挂掉，从节点顶上</p><p>(1)集群中所有master参与投票,如果半数以上master节点与其中一个master节点通信超过(cluster-node-timeout),认为该master节点挂掉.</p><p>(2):什么时候整个集群不可用(cluster_state:fail)? </p><ul><li>如果集群任意master挂掉,且当前master没有slave，则集群进入fail状态。也可以理解成集群的[0-16383]slot映射不完全时进入fail状态。</li><li>如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态。</li></ul><h4 id="Redis服务器因某种原因崩掉了，redis的信息是不是就没了-（容灾方式）"><a href="#Redis服务器因某种原因崩掉了，redis的信息是不是就没了-（容灾方式）" class="headerlink" title="Redis服务器因某种原因崩掉了，redis的信息是不是就没了 （容灾方式）"></a>Redis服务器因某种原因崩掉了，redis的信息是不是就没了 （容灾方式）</h4><p>redis 持久化策略：</p><p>　　RDB：对redis中的数据周期性的持久化</p><h4 id="优点"><a href="#优点" class="headerlink" title="　　　优点"></a>　　　优点</h4><p>​              1、会生成多个数据文件，每个数据文件都代表了某一个时间的全部数据。非常适合做冷备。可以将数据上传到云服务备份。</p><p>　　　　2、RDB对redis对外提供的服务影响小，可以让redis保持高性能。</p><p>　　　　3、相比较来说，基于RDB文件重启恢复redis更快</p><p>　　AOF：对每条写入命令作为日志。以append-only模式写入日志。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="　　　优点"></a>　　　优点</h4><p>​              1、可以更好的保护数据不丢失，一般AOF每隔1秒，通过后台线程执行一次fsync操作。最多丢失1s数据</p><p>　　　　2、文件以append-only模式写入，没有io开销。文件不容易损坏。损坏也很容易恢复。</p><p>　　　　3、AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在rewrite log的时候，会对其中的指导进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的merge后的日志文件ready的时候，再交换新老日志文件即可。</p><p>　　　　4、日志文件可读性强。适合做灾难性的误删除的紧急恢复。</p><p>一般线上环境我们会将2中机制都开启。具体的RDB策略和AOF策略都可以在redis.conf里面配置</p><p>RDB： save 60 1000 : 表示每60s有超过1000条数据更新就备份。</p><p>AOF： append-only : true 开启aof策略</p><p>　　　　everysec: 每秒备份</p><p>　　　　auto-aof-rewrite-percentage 100 : 当aof大小膨胀到上次2倍就备份</p><p>　　　　auto-aof-rewrite-min-size 64mb ： 和上面是 且 关系。 aof文件必须超过64m才会备份</p><h4 id="通过RDB恢复数据的步骤："><a href="#通过RDB恢复数据的步骤：" class="headerlink" title="通过RDB恢复数据的步骤："></a>通过RDB恢复数据的步骤：</h4><p>先将云服务的RDB备份数据copy到redis配置的备份目录。然后将aof关闭（一定要关闭，否则优先从aof日志文件本分，但是如果没有的话就创建空的。所以redis是无法加载rdb备份文件的）。然后重启redis，此时我们redis-cli 进入redis发现redis已经自动加载备份的rdb文件数据了。这时候手动命令启动aof。这时候redis就会备份aof日志。这启动aof是暂时的。我们停掉redis，在配置文件中修改将aof开启，然后再开启，现在redis已经恢复数据，且AOF已经开启了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;redis场景，服务器内存不够了，怎么办（或者说被人干蹦了），我们的redis信息是不是就没了，redis服务hi不是挂了，如何优化？容灾方式？分配redis多大内存，是否满足我们的生产的需求，一般我们会缓存到多大的一个数据量，峰值是多少？&lt;/p&gt;
&lt;h3 id=&quot;思路&quot;&gt;
      
    
    </summary>
    
    
    
      <category term="Redis" scheme="https://github.com/vp1009/vp1009.github.io.git/tags/Redis/"/>
    
  </entry>
  
</feed>
